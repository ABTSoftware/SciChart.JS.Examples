(() => {
  var e = {
      71993: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.buildAnnotations = void 0);
        const i = r(40301),
          o = r(11396),
          a = r(29371),
          s = r(89171),
          n = r(48882),
          l = r(25107),
          d = r(96696),
          h = r(23272),
          u = r(84736),
          c = r(28677),
          p = r(40734),
          g = r(74370),
          y = r(26977),
          f = r(49617),
          v = r(98409),
          m = r(11043),
          S = r(58996),
          P = r(45921);
        (0, P.registerType)(
          m.EBaseType.Annotation,
          u.EAnnotationType.RenderContextAxisMarkerAnnotation,
          (e) => new a.AxisMarkerAnnotation(e),
          !0
        ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextBoxAnnotation,
            (e) => new s.BoxAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextHorizontalLineAnnotation,
            (e) => new d.HorizontalLineAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextLineAnnotation,
            (e) => new c.LineAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextVerticalLineAnnotation,
            (e) => new v.VerticalLineAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.SVGTextAnnotation,
            (e) => new f.TextAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.SVGCustomAnnotation,
            (e) => new n.CustomAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.SVGPolarPointerAnnotation,
            (e) => new y.PolarPointerAnnotation(e)
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.HtmlTextAnnotation,
            (e) => new h.HtmlTextAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextNativeTextAnnotation,
            (e) => new g.NativeTextAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextArcAnnotation,
            (e) => new i.ArcAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.HtmlCustomAnnotation,
            (e) => new l.CustomHtmlAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextLineArrowAnnotation,
            (e) => new p.LineArrowAnnotation(e),
            !0
          ),
          (0, P.registerType)(
            m.EBaseType.Annotation,
            u.EAnnotationType.RenderContextPolarArcAnnotation,
            (e) => new o.PolarArcAnnotation(e),
            !0
          ),
          (t.buildAnnotations = (e) => {
            "string" == typeof e && (e = JSON.parse(e, S.chartReviver));
            const t = [];
            if (Array.isArray(e))
              for (const r of e)
                t.push(
                  (0, P.createType)(
                    m.EBaseType.Annotation,
                    r.type,
                    null,
                    r.options
                  )
                );
            else
              t.push(
                (0, P.createType)(
                  m.EBaseType.Annotation,
                  e.type,
                  null,
                  e.options
                )
              );
            return t;
          });
      },
      25924: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.buildAxis3D = t.buildAxes = void 0);
        const i = r(59516),
          o = r(2296),
          a = r(78471),
          s = r(48767),
          n = r(39920),
          l = r(92596),
          d = r(68695),
          h = r(18184),
          u = r(51392),
          c = r(54948),
          p = r(1370),
          g = r(63922),
          y = r(48936),
          f = r(2192),
          v = r(11043),
          m = r(40359),
          S = r(58996),
          P = r(45921);
        (0, P.registerType)(
          v.EBaseType.LabelProvider,
          m.ELabelProviderType.Numeric,
          (e) => new n.NumericLabelProvider(e),
          !0
        ),
          (0, P.registerType)(
            v.EBaseType.LabelProvider,
            m.ELabelProviderType.Date,
            (e) => new a.DateLabelProvider(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.LabelProvider,
            m.ELabelProviderType.Logarithmic,
            (e) => new s.LogarithmicLabelProvider(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.LabelProvider,
            m.ELabelProviderType.SmartDate,
            (e) => new d.SmartDateLabelProvider(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.LabelProvider,
            m.ELabelProviderType.Text,
            (e) => new h.TextLabelProvider(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.LabelProvider,
            m.ELabelProviderType.Pie,
            (e) => new l.PieLabelProvider(e),
            !0
          ),
          (t.buildAxes = (e, t) => {
            "string" == typeof t && (t = JSON.parse(t, S.chartReviver));
            const r = [];
            if (Array.isArray(t)) for (const i of t) r.push(C(e, i));
            else r.push(C(e, t));
            return r;
          });
        const C = (e, t) => {
          let r;
          switch (t.type) {
            case f.EAxisType.CategoryAxis:
              r = new i.CategoryAxis(e, t.options);
              break;
            case f.EAxisType.NumericAxis:
              r = new c.NumericAxis(e, t.options);
              break;
            case f.EAxisType.LogarithmicAxis:
              r = new u.LogarithmicAxis(e, t.options);
              break;
            case f.EAxisType.DateTimeNumericAxis:
              r = new o.DateTimeNumericAxis(e, t.options);
              break;
            case f.EAxisType.PolarNumericAxis:
              r = new g.PolarNumericAxis(e, t.options);
              break;
            case f.EAxisType.PolarCategoryAxis:
              r = new p.PolarCategoryAxis(e, t.options);
              break;
            default:
              r = new c.NumericAxis(e, {});
          }
          return r;
        };
        t.buildAxis3D = (e, t) => {
          let r;
          return (
            (r =
              t.type === f.EAxisType.NumericAxis3D
                ? new y.NumericAxis3D(e, t.options)
                : new y.NumericAxis3D(e, {})),
            r
          );
        };
      },
      44544: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.buildDataSeries3D = t.buildDataSeries = void 0);
        const i = r(57835),
          o = r(58465),
          a = r(73165),
          s = r(26974),
          n = r(95632),
          l = r(55007),
          d = r(39892),
          h = r(91154),
          u = r(92475),
          c = r(22382),
          p = r(51885),
          g = r(43427),
          y = r(35471),
          f = r(15799),
          v = r(9682),
          m = r(38446),
          S = r(29803),
          P = r(73016),
          C = r(19663),
          b = r(75650),
          x = r(35508),
          A = r(23291),
          T = r(75869),
          E = r(98102),
          R = r(51097),
          D = r(58996);
        t.buildDataSeries = (e, t, r, i) => {
          if (!t) return;
          let o, a;
          if (
            ("string" == typeof t && (t = JSON.parse(t, D.chartReviver)),
            "string" == typeof r && (r = JSON.parse(r, D.chartReviver)),
            (o = M(e, t, r)),
            "filter" in t.options && (a = t.options.filter),
            a &&
              t.type !== p.EDataSeriesType.HeatmapUniform &&
              t.type !== p.EDataSeriesType.HeatmapNonUniform &&
              o)
          ) {
            const e = w(null != i ? i : o, a);
            e && (o = e);
          }
          return o;
        };
        const w = (e, t) => {
            if (t.type === R.EDataFilterType.HlcScaleOffset)
              return new o.HlcScaleOffsetFilter(e, t.options);
            if (t.type === R.EDataFilterType.OhlcScaleOffset)
              return new a.OhlcScaleOffsetFilter(e, t.options);
            if (t.type === R.EDataFilterType.XyLinearTrend)
              return new s.XyLinearTrendFilter(e, t.options);
            if (t.type === R.EDataFilterType.XyMovingAverage)
              return new n.XyMovingAverageFilter(e, t.options);
            if (t.type === R.EDataFilterType.XyRatio) {
              const r = t.options;
              if (Array.isArray(r.divisorSeries)) {
                const i = new Array(e.count()).fill(0);
                t.options.divisorSeries = new v.XyDataSeries(
                  e.webAssemblyContext,
                  { xValues: i, yValues: r.divisorSeries }
                );
              }
              return new l.XyRatioFilter(e, t.options);
            }
            return t.type === R.EDataFilterType.XyScaleOffset
              ? new d.XyScaleOffsetFilter(e, t.options)
              : t.type === R.EDataFilterType.XyyScaleOffset
              ? new h.XyyScaleOffsetFilter(e, t.options)
              : t.type === R.EDataFilterType.XyzScaleOffset
              ? new u.XyzScaleOffsetFilter(e, t.options)
              : void 0;
          },
          M = (e, t, r) => {
            const o = Object.assign({}, t.options);
            switch (t.type) {
              case p.EDataSeriesType.Xy: {
                const t = o;
                return (
                  (t.arrayCount = 1),
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]), (t.yValues = r[t.yDataId])),
                  new v.XyDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.Xyy: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.yValues = r[t.yDataId]),
                    (t.y1Values = r[t.y1DataId])),
                  new b.XyyDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.Xyz: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.yValues = r[t.yDataId]),
                    (t.zValues = r[t.zDataId])),
                  new x.XyzDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.Xyxy: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.yValues = r[t.yDataId]),
                    (t.x1Values = r[t.x1DataId]),
                    (t.y1Values = r[t.y1DataId])),
                  new C.XyxyDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.XyN: {
                const t = o;
                return r && t.xDataId, new m.XyNDataSeries(e, t);
              }
              case p.EDataSeriesType.XyText: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]), (t.yValues = r[t.yDataId])),
                  new S.XyTextDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.Hlc: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.highValues = r[t.highDataId]),
                    (t.lowValues = r[t.lowDataId]),
                    (t.yValues = r[t.closeDataId])),
                  new c.HlcDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.Ohlc: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.openValues = r[t.openDataId]),
                    (t.highValues = r[t.highDataId]),
                    (t.lowValues = r[t.lowDataId]),
                    (t.closeValues = r[t.closeDataId])),
                  new y.OhlcDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.HeatmapUniform: {
                const t = o;
                return new f.UniformHeatmapDataSeries(e, t);
              }
              case p.EDataSeriesType.HeatmapNonUniform: {
                const t = o;
                return new g.NonUniformHeatmapDataSeries(e, t);
              }
              case p.EDataSeriesType.XyN:
                throw new Error("XyN data series is not supported yet!");
              case p.EDataSeriesType.Xyx: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.yValues = r[t.yDataId]),
                    (t.x1Values = r[t.x1DataId])),
                  new P.XyxDataSeries(e, t)
                );
              }
              case p.EDataSeriesType.X:
                throw new Error("X data series is not supported yet!");
              case p.EDataSeriesType.BoxPlot: {
                const t = o;
                return (
                  r &&
                    t.xDataId &&
                    ((t.xValues = r[t.xDataId]),
                    (t.lowerQuartileValues = r[t.lowerDataId]),
                    (t.upperQuartileValues = r[t.upperDataId]),
                    (t.maximumValues = r[t.maxDataId]),
                    (t.minimumValues = r[t.minDataId]),
                    (t.yValues = r[t.medianDataId]),
                    (t.medianValues = r[t.medianDataId])),
                  new i.BoxPlotDataSeries(e, t)
                );
              }
              default:
                return ((e) => {
                  throw new Error(`Invalid Data Series Type value: "${e}"!`);
                })(t.type);
            }
          };
        t.buildDataSeries3D = (e, t, r) => {
          if (t)
            return (
              "string" == typeof t && (t = JSON.parse(t, D.chartReviver)),
              "string" == typeof r && (r = JSON.parse(r, D.chartReviver)),
              L(e, t, r)
            );
        };
        const L = (e, t, r) => {
          const i = Object.assign({}, t.options);
          switch (t.type) {
            case A.EDataSeriesType3D.Xyz3D: {
              const t = i;
              return (
                r &&
                  t.xDataId &&
                  ((t.xValues = r[t.xDataId]),
                  (t.yValues = r[t.yDataId]),
                  (t.zValues = r[t.zDataId])),
                new E.XyzDataSeries3D(e, t)
              );
            }
            case A.EDataSeriesType3D.UniformGrid3D: {
              const t = i;
              return new T.UniformGridDataSeries3D(e, t);
            }
            case A.EDataSeriesType3D.NonUniformGrid3D:
              throw new Error(
                "NonUniformGrid3D data series is not supported yet!"
              );
            default:
              return ((e) => {
                throw new Error(`Invalid Data Series Type value: "${e}"!`);
              })(t.type);
          }
        };
      },
      96841: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.buildModifiers3D = t.buildModifiers = void 0);
        const i = r(62773),
          o = r(71575),
          a = r(9656),
          s = r(56985),
          n = r(55526),
          l = r(21562),
          d = r(63903),
          h = r(96408),
          u = r(18809),
          c = r(32545),
          p = r(9809),
          g = r(3397),
          y = r(63407),
          f = r(64171),
          v = r(11043),
          m = r(89955),
          S = r(58996),
          P = r(45921),
          C = r(49975),
          b = r(95648),
          x = r(94118),
          A = r(37221),
          T = r(99389),
          E = r(30580),
          R = r(36463),
          D = r(27524),
          w = r(47737),
          M = r(73792),
          L = r(17707),
          O = r(66477),
          I = r(68491);
        (0, P.registerType)(
          v.EBaseType.Chart2DModifier,
          m.EChart2DModifierType.Cursor,
          (e) => new i.CursorModifier(e),
          !0
        ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarCursor,
            (e) => new x.PolarCursorModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.DataPointSelection,
            (e) => new o.DataPointSelectionModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarDataPointSelection,
            (e) => new A.PolarDataPointSelectionModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.MouseWheelZoom,
            (e) => new s.MouseWheelZoomModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarMouseWheelZoom,
            (e) => new E.PolarMouseWheelZoomModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PinchZoom,
            (e) => new l.PinchZoomModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.Rollover,
            (e) => new d.RolloverModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.VerticalSlice,
            (e) => new h.VerticalSliceModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.RubberBandXYZoom,
            (e) => new u.RubberBandXyZoomModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarArcZoom,
            (e) => new b.PolarArcZoomModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.SeriesSelection,
            (e) => new c.SeriesSelectionModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.AnnotationHover,
            (e) => new C.AnnotationHoverModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.XAxisDrag,
            (e) => new p.XAxisDragModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.YAxisDrag,
            (e) => new g.YAxisDragModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.ZoomExtents,
            (e) => new y.ZoomExtentsModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarZoomExtents,
            (e) => new R.PolarZoomExtentsModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.ZoomPan,
            (e) => new f.ZoomPanModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarPan,
            (e) => new D.PolarPanModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.OverviewRangeSelection,
            (e) => new n.OverviewRangeSelectionModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.Legend,
            (e) => new a.LegendModifier(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart2DModifier,
            m.EChart2DModifierType.PolarLegend,
            (e) => new T.PolarLegendModifier(e),
            !0
          ),
          (t.buildModifiers = (e) => {
            "string" == typeof e && (e = JSON.parse(e, S.chartReviver));
            const t = [];
            if (Array.isArray(e)) for (const r of e) t.push(k(r));
            else t.push(k(e));
            return t;
          });
        const k = (e) =>
          e.type === m.EChart2DModifierType.Custom
            ? (0, P.createType)(
                v.EBaseType.Chart2DModifier,
                e.customType,
                null,
                e.options
              )
            : (0, P.createType)(
                v.EBaseType.Chart2DModifier,
                e.type,
                null,
                e.options
              );
        (0, P.registerType)(
          v.EBaseType.Chart3DModifier,
          m.EChart3DModifierType.MouseWheelZoom,
          (e) => new w.MouseWheelZoomModifier3D(e),
          !0
        ),
          (0, P.registerType)(
            v.EBaseType.Chart3DModifier,
            m.EChart3DModifierType.Orbit,
            (e) => new L.OrbitModifier3D(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart3DModifier,
            m.EChart3DModifierType.PinchZoom,
            (e) => new M.PinchZoomModifier3D(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart3DModifier,
            m.EChart3DModifierType.Tooltip,
            (e) => new O.TooltipModifier3D(e),
            !0
          ),
          (0, P.registerType)(
            v.EBaseType.Chart3DModifier,
            m.EChart3DModifierType.ZoomExtents,
            (e) => new I.ResetCamera3DModifier(e),
            !0
          ),
          (t.buildModifiers3D = (e) => {
            "string" == typeof e && (e = JSON.parse(e, S.chartReviver));
            const t = [];
            if (Array.isArray(e)) for (const r of e) t.push(_(r));
            else t.push(_(e));
            return t;
          });
        const _ = (e) =>
          e.type === m.EChart3DModifierType.Custom
            ? (0, P.createType)(
                v.EBaseType.Chart3DModifier,
                e.customType,
                null,
                e.options
              )
            : (0, P.createType)(
                v.EBaseType.Chart3DModifier,
                e.type,
                null,
                e.options
              );
      },
      12193: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.buildSeries3D = t.buildSeries = void 0);
        const i = r(75619),
          o = r(51885),
          a = r(33906),
          s = r(52881),
          n = r(22745),
          l = r(10749),
          d = r(21033),
          h = r(77057),
          u = r(58229),
          c = r(61704),
          p = r(62314),
          g = r(56705),
          y = r(592),
          f = r(56498),
          v = r(81856),
          m = r(15273),
          S = r(1367),
          P = r(9488),
          C = r(96852),
          b = r(75933),
          x = r(33802),
          A = r(31544),
          T = r(1126),
          E = r(98550),
          R = r(11555),
          D = r(12641),
          w = r(20667),
          M = r(43852),
          L = r(93522),
          O = r(65297),
          I = r(72362),
          k = r(95179),
          _ = r(89078),
          V = r(21037),
          N = r(50085),
          B = r(68264),
          F = r(78146),
          H = r(32471),
          Y = r(86109),
          z = r(56664),
          j = r(1406),
          X = r(83262),
          G = r(71719),
          W = r(1391),
          U = r(88189),
          $ = r(70033),
          Z = r(52954),
          q = r(10763),
          K = r(11043),
          J = r(2963),
          Q = r(28436),
          ee = r(30323),
          te = r(5337),
          re = r(75323),
          ie = r(44544),
          oe = r(58996),
          ae = r(45921),
          se = r(55303),
          ne = r(16098),
          le = r(4455),
          de = r(83187),
          he = r(38831),
          ue = r(88409),
          ce = r(38595),
          pe = r(33236),
          ge = r(51852),
          ye = r(69773),
          fe = r(19963),
          ve = r(15518),
          me = r(68584),
          Se = r(2928),
          Pe = r(2270),
          Ce = r(10947),
          be = r(45265),
          xe = r(56675),
          Ae = r(39927),
          Te = r(72954),
          Ee = r(10435),
          Re = r(23291),
          De = r(56356),
          we = r(37622),
          Me = r(70027),
          Le = r(28009),
          Oe = r(25889);
        function Ie(e, t) {
          return e.hasOwnProperty(t);
        }
        (0, ae.registerWasmType)(
          K.EBaseType.PointMarker,
          ee.EPointMarkerType.Cross,
          (e, t) => new n.CrossPointMarker(e, t),
          !0
        ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker,
            ee.EPointMarkerType.Ellipse,
            (e, t) => new l.EllipsePointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker,
            ee.EPointMarkerType.Sprite,
            (e, t) => new d.SpritePointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker,
            ee.EPointMarkerType.Square,
            (e, t) => new h.SquarePointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker,
            ee.EPointMarkerType.Triangle,
            (e, t) => new u.TrianglePointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker,
            ee.EPointMarkerType.X,
            (e, t) => new c.XPointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.ShaderEffect,
            re.EShaderEffectType.Glow,
            (e, t) => new V.GlowEffect(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.ShaderEffect,
            re.EShaderEffectType.Shadow,
            (e, t) => new B.ShadowEffect(e, t),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.Animation,
            q.EAnimationType.Fade,
            (e) => new p.FadeAnimation(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.Animation,
            q.EAnimationType.Scale,
            (e) => new g.ScaleAnimation(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.Animation,
            q.EAnimationType.Sweep,
            (e) => new y.SweepAnimation(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.Animation,
            q.EAnimationType.Wave,
            (e) => new f.WaveAnimation(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Default,
            (e) => new C.DataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Line,
            (e) => new x.LineSeriesDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Column,
            (e) => new S.ColumnSeriesDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Rectangle,
            (e) => new Me.RectangleSeriesDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Text,
            (e) => new T.TextDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Heatmap,
            (e) => new b.HeatMapDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.NonUniformHeatmap,
            (e) => new A.NonUniformHeatMapDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Bubble,
            (e) => new m.BubbleSeriesDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Band,
            (e) => new v.BandSeriesDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.Contours,
            (e) => new P.ContoursDataLabelProvider(e),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.PolarDefault,
            (e) => new fe.PolarDataLabelProvider(e)
          ),
          (0, ae.registerType)(
            K.EBaseType.DataLabelProvider,
            J.EDataLabelProviderType.PolarColumn,
            (e) => new ve.PolarColumnSeriesDataLabelProvider(e)
          ),
          (0, ae.registerType)(
            K.EBaseType.MetadataGenerator,
            "Template",
            (e) => new a.TemplateMetadataGenerator(e),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PaletteProvider,
            Q.EPaletteProviderType.Gradient,
            (e, t) => s.PaletteFactory.createGradient(e, t),
            !0
          ),
          (0, ae.registerType)(
            K.EBaseType.PaletteProvider,
            Q.EPaletteProviderType.DataPointSelection,
            (e) => new i.DataPointSelectionPaletteProvider(e),
            !0
          ),
          (t.buildSeries = (e, r, i) => {
            "string" == typeof r && (r = JSON.parse(r, oe.chartReviver)),
              "string" == typeof i && (i = JSON.parse(i, oe.chartReviver));
            const o = [];
            Array.isArray(r) || (r = [r]);
            for (const a of r) {
              let r;
              if (a.type === te.ESeriesType.BandSeries)
                r = new E.FastBandRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.BubbleSeries)
                r = new R.FastBubbleRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.CandlestickSeries)
                r = new D.FastCandlestickRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.ColumnSeries)
                r = new w.FastColumnRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.ImpulseSeries)
                r = new L.FastImpulseRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.LineSeries)
                r = new O.FastLineRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.LineSegmentSeries)
                r = new se.LineSegmentRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.MountainSeries)
                r = new I.FastMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.ErrorBarsSeries)
                r = new M.FastErrorBarsRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.BoxPlotSeries)
                r = new pe.FastBoxPlotRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.TriangleSeries)
                r = new ge.TriangleRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.RectangleSeries)
                r = new ne.FastRectangleRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.OhlcSeries)
                r = new k.FastOhlcRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.ScatterSeries)
                r = new Z.XyScatterRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.SplineBandSeries)
                r = new F.SplineBandRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.SplineLineSeries)
                r = new H.SplineLineRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.SplineMountainSeries)
                r = new Y.SplineMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.UniformHeatmapSeries)
                r = new $.UniformHeatmapRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.NonUniformHeatmapSeries)
                r = new N.NonUniformHeatmapRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.UniformContoursSeries)
                r = new U.UniformContoursRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.TextSeries)
                r = new _.FastTextRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.StackedColumnSeries)
                r = new X.StackedColumnRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.StackedMountainSeries)
                r = new W.StackedMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.SmoothStackedMountainSeries)
                r = new z.SmoothStackedMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.StackedColumnCollection) {
                const o = new j.StackedColumnCollection(e, a.options);
                o.add(...(0, t.buildSeries)(e, a.series, i)), (r = o);
              } else if (a.type === te.ESeriesType.StackedMountainCollection) {
                const o = new G.StackedMountainCollection(e, a.options);
                o.add(...(0, t.buildSeries)(e, a.series, i)), (r = o);
              } else if (a.type === te.ESeriesType.PolarLineSeries)
                r = new le.PolarLineRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarScatterSeries)
                r = new ye.PolarXyScatterRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarBandSeries)
                r = new de.PolarBandRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarColumnSeries)
                r = new he.PolarColumnRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarMountainSeries)
                r = new ue.PolarMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarUniformHeatmapSeries)
                r = new Ce.PolarUniformHeatmapRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarStackedMountainSeries)
                r = new ce.PolarStackedMountainRenderableSeries(e, a.options);
              else if (a.type === te.ESeriesType.PolarStackedColumnSeries)
                r = new Pe.PolarStackedColumnRenderableSeries(e, a.options);
              else if (
                a.type === te.ESeriesType.PolarStackedMountainCollection
              ) {
                const o = new me.PolarStackedMountainCollection(e, a.options);
                o.add(...(0, t.buildSeries)(e, a.series, i)), (r = o);
              } else if (
                a.type === te.ESeriesType.PolarStackedColumnCollection
              ) {
                const o = new Se.PolarStackedColumnCollection(e, a.options);
                o.add(...(0, t.buildSeries)(e, a.series, i)), (r = o);
              }
              if (r) {
                const t = ke(e, a, i);
                t && (r.dataSeries = t);
              }
              r && o.push(r);
            }
            return o;
          });
        const ke = (e, t, r) => {
          const i = Ie((a = t), "xyData")
            ? { type: o.EDataSeriesType.Xy, options: a.xyData }
            : Ie(a, "xyyData")
            ? { type: o.EDataSeriesType.Xyy, options: a.xyyData }
            : Ie(a, "xyzData")
            ? { type: o.EDataSeriesType.Xyz, options: a.xyzData }
            : Ie(a, "xyxyData")
            ? { type: o.EDataSeriesType.Xyxy, options: a.xyxyData }
            : Ie(a, "xyxData")
            ? { type: o.EDataSeriesType.Xyx, options: a.xyxData }
            : Ie(a, "xynData")
            ? { type: o.EDataSeriesType.XyN, options: a.xynData }
            : Ie(a, "xyTextData")
            ? { type: o.EDataSeriesType.XyText, options: a.xyTextData }
            : Ie(a, "hlcData")
            ? { type: o.EDataSeriesType.Hlc, options: a.hlcData }
            : Ie(a, "ohlcData")
            ? { type: o.EDataSeriesType.Ohlc, options: a.ohlcData }
            : Ie(a, "boxPlotData")
            ? { type: o.EDataSeriesType.BoxPlot, options: a.boxPlotData }
            : Ie(a, "triangleData")
            ? { type: o.EDataSeriesType.Xy, options: a.triangleData }
            : !Ie(a, "heatmapData") ||
              (a.type !== te.ESeriesType.UniformHeatmapSeries &&
                a.type !== te.ESeriesType.UniformContoursSeries &&
                a.type !== te.ESeriesType.PolarUniformHeatmapSeries)
            ? Ie(a, "heatmapData") &&
              a.type === te.ESeriesType.NonUniformHeatmapSeries
              ? {
                  type: o.EDataSeriesType.HeatmapNonUniform,
                  options: a.heatmapData,
                }
              : void 0
            : {
                type: o.EDataSeriesType.HeatmapUniform,
                options: a.heatmapData,
              };
          var a;
          if (i)
            return t.options &&
              "dataSeries" in t.options &&
              t.options.dataSeries &&
              i.options &&
              "filter" in i.options &&
              i.options.filter
              ? (0, ie.buildDataSeries)(e, i, r, t.options.dataSeries)
              : (0, ie.buildDataSeries)(e, i, r);
        };
        (0, ae.registerWasmType)(
          K.EBaseType.PointMarker3D,
          De.EPointMarker3DType.Sphere,
          (e, t) => new we.SpherePointMarker3D(e, t),
          !0
        ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Cube,
            (e, t) => new we.CubePointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Pyramid,
            (e, t) => new we.PyramidPointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Cylinder,
            (e, t) => new we.CylinderPointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Ellipse,
            (e, t) => new we.EllipsePointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Pixel,
            (e, t) => new we.PixelPointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Quad,
            (e, t) => new we.QuadPointMarker(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PointMarker3D,
            De.EPointMarker3DType.Triangle,
            (e, t) => new we.TrianglePointMarker3D(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PaletteProvider,
            Q.EPaletteProviderType.Gradient3D,
            (e, t) => new Le.GradientColorPalette(e, t),
            !0
          ),
          (0, ae.registerWasmType)(
            K.EBaseType.PaletteProvider,
            Q.EPaletteProviderType.Solid3D,
            (e, t) => new Oe.SolidColorBrushPalette(e, t),
            !0
          ),
          (t.buildSeries3D = (e, t, r) => {
            "string" == typeof t && (t = JSON.parse(t, oe.chartReviver)),
              "string" == typeof r && (r = JSON.parse(r, oe.chartReviver));
            const i = [];
            Array.isArray(t) || (t = [t]);
            for (const o of t) {
              let t;
              switch (o.type) {
                case be.ESeriesType3D.ColumnRenderableSeries3D:
                  t = new xe.ColumnRenderableSeries3D(e, o.options);
                  break;
                case be.ESeriesType3D.PointLineRenderableSeries3D:
                  t = new Ae.PointLineRenderableSeries3D(e, o.options);
                  break;
                case be.ESeriesType3D.ScatterRenderableSeries3D:
                  t = new Te.ScatterRenderableSeries3D(e, o.options);
                  break;
                case be.ESeriesType3D.SurfaceMeshRenderableSeries3D:
                  t = new Ee.SurfaceMeshRenderableSeries3D(e, o.options);
              }
              if (t) {
                const i = _e(e, o, r);
                i && (t.dataSeries = i);
              }
              t && i.push(t);
            }
            return i;
          });
        const _e = (e, t, r) => {
            const i = Ve(t);
            if (i) return (0, ie.buildDataSeries3D)(e, i, r);
          },
          Ve = (e) =>
            Ie(e, "xyzData")
              ? { type: Re.EDataSeriesType3D.Xyz3D, options: e.xyzData }
              : Ie(e, "uniformGridData")
              ? {
                  type: Re.EDataSeriesType3D.UniformGrid3D,
                  options: e.uniformGridData,
                }
              : void 0;
      },
      64931: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.configure3DSurface =
            t.configure2DSurface =
            t.buildSubCharts =
            t.build3DChart =
            t.buildPieChart =
            t.build2DPolarChart =
            t.build2DChart =
              void 0);
        const o = r(60872),
          a = r(53521),
          s = r(57384),
          n = r(70397),
          l = r(45481),
          d = r(83638),
          h = r(6153),
          u = r(55173),
          c = r(24478),
          p = r(27282),
          g = r(12119),
          y = r(27194),
          f = r(73145),
          v = r(55696),
          m = r(66010),
          S = r(99016),
          P = r(2705),
          C = r(60819),
          b = r(54948),
          x = r(66570),
          A = r(57419),
          T = r(79548),
          E = r(84626),
          R = r(11043),
          D = r(883),
          w = r(73785),
          M = r(71993),
          L = r(25924),
          O = r(96841),
          I = r(12193),
          k = r(58996),
          _ = r(45921),
          V = r(62916),
          N = r(16602),
          B = r(25610),
          F = r(91465),
          H = r(8320),
          Y = r(94416),
          z = r(24696),
          j = r(63922),
          X = r(16989),
          G = r(38215),
          W = r(52361),
          U = r(48936);
        function $(e, t) {
          var r;
          const i = t.webAssemblyContext2D,
            o = Array.isArray(e) ? e : [e],
            a = [];
          for (const e of o)
            if (
              (null === (r = null == e ? void 0 : e.surface) || void 0 === r
                ? void 0
                : r.surfaceType) === F.ESciChartSurfaceType.Polar2D
            ) {
              const r = H.SciChartPolarSubSurface.createSubSurface(
                t,
                e.surface
              );
              Z(e, r, i), a.push(r);
            } else {
              const r = B.SciChartSubSurface.createSubSurface(t, e.surface);
              Z(e, r, i), a.push(r);
            }
          return a;
        }
        function Z(e, t, r) {
          e.xAxes && t.xAxes.add(...(0, L.buildAxes)(r, e.xAxes)),
            e.yAxes && t.yAxes.add(...(0, L.buildAxes)(r, e.yAxes)),
            t.isPolar
              ? (0 !== t.xAxes.size() ||
                  e.subCharts ||
                  t.xAxes.add(
                    new j.PolarNumericAxis(r, {
                      polarAxisMode: X.EPolarAxisMode.Angular,
                      axisAlignment: G.EAxisAlignment.Top,
                    })
                  ),
                0 !== t.yAxes.size() ||
                  e.subCharts ||
                  t.yAxes.add(
                    new j.PolarNumericAxis(r, {
                      polarAxisMode: X.EPolarAxisMode.Radial,
                      axisAlignment: G.EAxisAlignment.Right,
                    })
                  ))
              : (0 !== t.xAxes.size() ||
                  e.subCharts ||
                  t.xAxes.add(new b.NumericAxis(r)),
                0 !== t.yAxes.size() ||
                  e.subCharts ||
                  t.yAxes.add(new b.NumericAxis(r))),
            e.series &&
              t.renderableSeries.add(
                ...(0, I.buildSeries)(r, e.series, e.sharedData)
              ),
            e.modifiers &&
              t.chartModifiers.add(...(0, O.buildModifiers)(e.modifiers)),
            e.annotations &&
              t.annotations.add(...(0, M.buildAnnotations)(e.annotations)),
            e.subCharts && !t.isSubSurface && $(e.subCharts, t);
        }
        function q(e, t, r) {
          e.xAxis
            ? (t.xAxis = (0, L.buildAxis3D)(r, e.xAxis))
            : (t.xAxis = new U.NumericAxis3D(r)),
            e.yAxis
              ? (t.yAxis = (0, L.buildAxis3D)(r, e.yAxis))
              : (t.yAxis = new U.NumericAxis3D(r)),
            e.zAxis
              ? (t.zAxis = (0, L.buildAxis3D)(r, e.zAxis))
              : (t.zAxis = new U.NumericAxis3D(r)),
            e.series &&
              t.renderableSeries.add(
                ...(0, I.buildSeries3D)(r, e.series, e.sharedData)
              ),
            e.modifiers &&
              t.chartModifiers.add(...(0, O.buildModifiers3D)(e.modifiers));
        }
        (0, _.registerType)(
          R.EBaseType.ThemeProvider,
          V.EThemeProviderType.Light,
          () => new C.SciChartJSLightTheme(),
          !0
        ),
          (0, _.registerType)(
            R.EBaseType.ThemeProvider,
            V.EThemeProviderType.DarkV2,
            () => new P.SciChartJSDarkv2Theme(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.ThemeProvider,
            V.EThemeProviderType.Dark,
            () => new S.SciChartJSDarkTheme(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.ThemeProvider,
            V.EThemeProviderType.Navy,
            () => new m.SciChartJsNavyTheme(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutManager,
            D.ELayoutManagerType.Default,
            (e) => new l.LayoutManager(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutManager,
            D.ELayoutManagerType.Polar,
            (e) => new z.PolarLayoutManager(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutManager,
            D.ELayoutManagerType.CentralAxes,
            (e) => new n.CentralAxesLayoutManager(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.BottomInner,
            (e) => new o.BottomAlignedInnerAxisLayoutStrategy(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.BottomOuter,
            (e) => new a.BottomAlignedOuterAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.BottomStacked,
            (e) =>
              new s.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.LeftInner,
            (e) => new d.LeftAlignedInnerAxisLayoutStrategy(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.LeftOuter,
            (e) => new h.LeftAlignedOuterAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.LeftStacked,
            (e) => new u.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.RightInner,
            (e) => new c.RightAlignedInnerAxisLayoutStrategy(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.RightOuter,
            (e) => new p.RightAlignedOuterAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.RightStacked,
            (e) => new g.RightAlignedOuterVerticallyStackedAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.TopInner,
            (e) => new y.TopAlignedInnerAxisLayoutStrategy(e),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.TopOuter,
            (e) => new f.TopAlignedOuterAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.LayoutStrategy,
            w.ELayoutStrategyType.TopStacked,
            (e) => new v.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy(),
            !0
          ),
          (0, _.registerType)(
            R.EBaseType.Loader,
            "Default",
            () => new x.DefaultSciChartLoader(),
            !0
          ),
          (t.build2DChart = (e, t) =>
            i(void 0, void 0, void 0, function* () {
              var r;
              let i;
              "string" == typeof t && (t = JSON.parse(t, k.chartReviver)),
                (i = (null == t ? void 0 : t.createSingle)
                  ? yield E.SciChartSurface.createSingle(
                      e,
                      null == t ? void 0 : t.surface
                    )
                  : yield E.SciChartSurface.create(
                      e,
                      null == t ? void 0 : t.surface
                    ));
              let { wasmContext: o, sciChartSurface: a } = i;
              const s = N.PerformanceDebugHelper.mark(
                N.EPerformanceMarkType.SetupStart,
                { contextId: a.id }
              );
              return (
                Z(t, a, o),
                t.onCreated &&
                  ("string" == typeof t.onCreated &&
                    ((a.onCreatedName = t.onCreated),
                    (t.onCreated = (0, _.getFunction)(
                      R.EBaseType.OnCreateFunction,
                      t.onCreated
                    ))),
                  yield t.onCreated(a)),
                N.PerformanceDebugHelper.mark(N.EPerformanceMarkType.SetupEnd, {
                  contextId: a.id,
                  relatedId:
                    null === (r = null == s ? void 0 : s.detail) || void 0 === r
                      ? void 0
                      : r.relatedId,
                }),
                { wasmContext: o, sciChartSurface: a }
              );
            })),
          (t.build2DPolarChart = (e, t) =>
            i(void 0, void 0, void 0, function* () {
              var r;
              let i;
              "string" == typeof t && (t = JSON.parse(t, k.chartReviver)),
                (i = (null == t ? void 0 : t.createSingle)
                  ? yield Y.SciChartPolarSurface.createSingle(
                      e,
                      null == t ? void 0 : t.surface
                    )
                  : yield Y.SciChartPolarSurface.create(
                      e,
                      null == t ? void 0 : t.surface
                    ));
              let { wasmContext: o, sciChartSurface: a } = i;
              const s = N.PerformanceDebugHelper.mark(
                N.EPerformanceMarkType.SetupStart,
                { contextId: a.id }
              );
              return (
                Z(t, a, o),
                t.onCreated &&
                  ("string" == typeof t.onCreated &&
                    ((a.onCreatedName = t.onCreated),
                    (t.onCreated = (0, _.getFunction)(
                      R.EBaseType.OnCreateFunction,
                      t.onCreated
                    ))),
                  yield t.onCreated(a)),
                N.PerformanceDebugHelper.mark(N.EPerformanceMarkType.SetupEnd, {
                  contextId: a.id,
                  relatedId:
                    null === (r = null == s ? void 0 : s.detail) || void 0 === r
                      ? void 0
                      : r.relatedId,
                }),
                { wasmContext: o, sciChartSurface: a }
              );
            })),
          (t.buildPieChart = (e, t) =>
            i(void 0, void 0, void 0, function* () {
              "string" == typeof t && (t = JSON.parse(t, k.chartReviver));
              const r = yield T.SciChartPieSurface.create(
                e,
                null == t ? void 0 : t.surface
              );
              if (null == t ? void 0 : t.segments)
                for (const e of null == t ? void 0 : t.segments) {
                  const t = new A.PieSegment(e);
                  r.pieSegments.add(t);
                }
              return (
                t.onCreated &&
                  ("string" == typeof t.onCreated &&
                    ((r.onCreatedName = t.onCreated),
                    (t.onCreated = (0, _.getFunction)(
                      R.EBaseType.OnCreateFunction,
                      t.onCreated
                    ))),
                  t.onCreated(r)),
                r
              );
            })),
          (t.build3DChart = (e, t) =>
            i(void 0, void 0, void 0, function* () {
              var r, i;
              let o;
              if (
                ("string" == typeof t && (t = JSON.parse(t, k.chartReviver)),
                (o = (null == t ? void 0 : t.createSingle)
                  ? yield W.SciChart3DSurface.createSingle(
                      e,
                      Object.assign({}, null == t ? void 0 : t.surface)
                    )
                  : yield W.SciChart3DSurface.create(
                      e,
                      Object.assign({}, null == t ? void 0 : t.surface)
                    )),
                null === (r = null == t ? void 0 : t.surface) || void 0 === r
                  ? void 0
                  : r.theme)
              )
                if ("type" in t.surface.theme) {
                  const e = (0, _.getFunction)(
                    R.EBaseType.ThemeProvider,
                    t.surface.theme.type
                  ).call(null);
                  e && o.sciChart3DSurface.applyTheme(e);
                } else o.sciChart3DSurface.applyTheme(t.surface.theme);
              let { wasmContext: a, sciChart3DSurface: s } = o;
              const n = N.PerformanceDebugHelper.mark(
                N.EPerformanceMarkType.SetupStart,
                { contextId: s.id }
              );
              return (
                q(t, s, a),
                t.onCreated &&
                  ("string" == typeof t.onCreated &&
                    ((s.onCreatedName = t.onCreated),
                    (t.onCreated = (0, _.getFunction)(
                      R.EBaseType.OnCreateFunction,
                      t.onCreated
                    ))),
                  yield t.onCreated(s)),
                N.PerformanceDebugHelper.mark(N.EPerformanceMarkType.SetupEnd, {
                  contextId: s.id,
                  relatedId:
                    null === (i = null == n ? void 0 : n.detail) || void 0 === i
                      ? void 0
                      : i.relatedId,
                }),
                { wasmContext: a, sciChart3DSurface: s }
              );
            })),
          (t.buildSubCharts = $),
          (t.configure2DSurface = Z),
          (t.configure3DSurface = q);
      },
      58996: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.chartBuilder =
            t.ensureRegistrations =
            t.configureChart =
            t.buildChart =
            t.chartReviver =
              void 0);
        const i = r(98140),
          o = r(87108),
          a = r(91465),
          s = r(71993),
          n = r(25924),
          l = r(44544),
          d = r(96841),
          h = r(12193),
          u = r(64931),
          c = r(45921);
        function p(e, t) {
          switch (e) {
            case "visibleRange":
            case "visibleRangeLimit":
            case "visibleRangeSizeLimit":
            case "growBy":
              return new i.NumberRange(t.min, t.max);
            case "padding":
              const e = t;
              return new o.Thickness(e.top, e.right, e.bottom, e.left);
            default:
              return null === t ? NaN : t;
          }
        }
        t.chartReviver = p;
        const g = (e) => ("options" in e ? e.options : e);
        function y(e, t) {
          var r;
          "string" == typeof t && (t = JSON.parse(t, p)), t || (t = {});
          const i =
              null !== (r = null == t ? void 0 : t.type) && void 0 !== r
                ? r
                : a.ESciChartSurfaceType.Default2D,
            o = g(t);
          if (i === a.ESciChartSurfaceType.Default2D)
            return (0, u.build2DChart)(e, o);
          if (i === a.ESciChartSurfaceType.Polar2D)
            return (0, u.build2DPolarChart)(e, o);
          if (i === a.ESciChartSurfaceType.Pie2D)
            return (0, u.buildPieChart)(e, o);
          if (i === a.ESciChartSurfaceType.Default3D)
            return (0, u.build3DChart)(e, o);
          throw new Error(
            `Surface type: ${i} does not exist. See ESciChartSurfaceType for all available types.`
          );
        }
        (t.buildChart = y),
          (t.configureChart = (e, t, r) => {
            var i;
            "string" == typeof r && (r = JSON.parse(r, p)), r || (r = {});
            const o =
                null !== (i = null == r ? void 0 : r.type) && void 0 !== i
                  ? i
                  : a.ESciChartSurfaceType.Default2D,
              s = g(r);
            if (o === a.ESciChartSurfaceType.Default2D)
              (0, u.configure2DSurface)(s, e, t);
            else if (o !== a.ESciChartSurfaceType.Pie2D)
              throw new Error(
                `Surface type: ${o} is not yet supported by the builder api`
              );
          }),
          (t.ensureRegistrations = () => {}),
          (t.chartBuilder = {
            buildChart: y,
            chartReviver: p,
            build2DChart: u.build2DChart,
            build2DPolarChart: u.build2DPolarChart,
            buildPieChart: u.buildPieChart,
            configureChart: t.configureChart,
            buildSeries: h.buildSeries,
            buildDataSeries: l.buildDataSeries,
            buildModifiers: d.buildModifiers,
            buildAxes: n.buildAxes,
            buildAnnotations: s.buildAnnotations,
            registerType: c.registerType,
            registerWasmType: c.registerWasmType,
            registerFunction: c.registerFunction,
            build3DChart: u.build3DChart,
            buildAxis3D: n.buildAxis3D,
            buildModifiers3D: d.buildModifiers3D,
            buildSeries3D: h.buildSeries3D,
            buildDataSeries3D: l.buildDataSeries3D,
          });
      },
      45921: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getSubTypes =
            t.createType =
            t.getFunction =
            t.registerFunction =
            t.registerWasmType =
            t.registerType =
              void 0);
        const r = new Map();
        (t.registerType = (e, t, i, o = !1) => {
          const a = e + ":" + t;
          if (r.has(a) && !o)
            throw new Error(
              "Type " +
                a +
                " is already registered.  Call with overWrite: true if you intended to replace it."
            );
          r.set(a, { func: i });
        }),
          (t.registerWasmType = (e, t, i, o = !1) => {
            const a = e + ":" + t;
            if (r.has(a) && !o)
              throw new Error(
                "Type " +
                  a +
                  " is already registered.  Call with overWrite: true if you intended to replace it."
              );
            r.set(a, { wasm: !0, func: i });
          }),
          (t.registerFunction = (e, t, i, o = !1) => {
            const a = e + ":" + t;
            if (r.has(a) && !o)
              throw new Error(
                "Function " +
                  a +
                  " is already registered.  Call with overWrite: true if you intended to replace it."
              );
            r.set(a, { func: i });
          }),
          (t.getFunction = (e, t) => {
            const i = e + ":" + t,
              o = r.get(i);
            if (o) return o.func;
            throw new Error("Nothing registered for " + i);
          }),
          (t.createType = (e, t, i, o) => {
            const a = e + ":" + t,
              s = r.get(a);
            if (s) {
              const { wasm: e, func: t } = s;
              return e ? t(i, o) : t(o);
            }
            throw new Error("Nothing registered for " + a);
          }),
          (t.getSubTypes = (e) =>
            Array.from(r.keys())
              .map((e) => e.split(":"))
              .filter((t) => t[0] === e)
              .map((e) => e[1]));
      },
      3810: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CameraController = t.ECameraProjectionMode = void 0);
        const i = r(3214),
          o = r(23866),
          a = r(50605),
          s = r(16110),
          n = r(17542);
        var l;
        !(function (e) {
          (e.Perspective = "Perspective"), (e.Orthogonal = "Orthogonal");
        })((l = t.ECameraProjectionMode || (t.ECameraProjectionMode = {}))),
          (t.CameraController = class {
            constructor(e, t) {
              var r, o, a, n, d, h, u, c, p;
              (this.aspectRatioProperty = 1.5),
                (this.idProperty = "Default"),
                (this.farClipProperty = 4e3),
                (this.fieldOfViewProperty = 60),
                (this.isAttachedProperty = !1),
                (this.nearClipProperty = 1),
                (this.orbitalPitchProperty = 0),
                (this.orbitalYawProperty = 0),
                (this.orthoHeightProperty = 400),
                (this.orthoWidthProperty = 600),
                (this.positionProperty = s.Vector3.zero),
                (this.projectionModeProperty = l.Perspective),
                (this.targetProperty = s.Vector3.zero),
                (this.webAssemblyContext = e),
                (this.propertyChanged = new i.EventHandler()),
                this.resetToDefaults(),
                (this.id =
                  null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                    ? r
                    : this.id),
                (this.farClipProperty =
                  null !== (o = null == t ? void 0 : t.farClip) && void 0 !== o
                    ? o
                    : this.farClip),
                (this.fieldOfViewProperty =
                  null !== (a = null == t ? void 0 : t.fieldOfView) &&
                  void 0 !== a
                    ? a
                    : this.fieldOfView),
                (this.nearClipProperty =
                  null !== (n = null == t ? void 0 : t.nearClip) && void 0 !== n
                    ? n
                    : this.nearClip),
                (this.orthoHeightProperty =
                  null !== (d = null == t ? void 0 : t.orthoHeight) &&
                  void 0 !== d
                    ? d
                    : this.orthoHeight),
                (this.orthoWidthProperty =
                  null !== (h = null == t ? void 0 : t.orthoWidth) &&
                  void 0 !== h
                    ? h
                    : this.orthoWidth),
                (this.projectionModeProperty =
                  null !== (u = null == t ? void 0 : t.projectionMode) &&
                  void 0 !== u
                    ? u
                    : this.projectionMode),
                (this.position = (null == t ? void 0 : t.position)
                  ? s.Vector3.hydrate(null == t ? void 0 : t.position)
                  : this.position),
                (this.target = (null == t ? void 0 : t.target)
                  ? s.Vector3.hydrate(null == t ? void 0 : t.target)
                  : this.target),
                (this.id =
                  null !== (c = null == t ? void 0 : t.id) && void 0 !== c
                    ? c
                    : this.id),
                (this.debugPositionsProperty =
                  null !== (p = null == t ? void 0 : t.debugPositions) &&
                  void 0 !== p &&
                  p);
            }
            get id() {
              return this.idProperty;
            }
            set id(e) {
              (this.idProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_ID);
            }
            get orthoHeight() {
              return this.orthoHeightProperty;
            }
            set orthoHeight(e) {
              this.orthoHeightProperty !== e &&
                ((this.orthoHeightProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_ORTHOHEIGHT));
            }
            get orthoWidth() {
              return this.orthoWidthProperty;
            }
            set orthoWidth(e) {
              this.orthoWidthProperty !== e &&
                ((this.orthoWidthProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_ORTHOWIDTH));
            }
            get projectionMode() {
              return this.projectionModeProperty;
            }
            set projectionMode(e) {
              this.projectionModeProperty !== e &&
                ((this.projectionModeProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_PROJECTIONMODE));
            }
            get aspectRatio() {
              return this.aspectRatioProperty;
            }
            set aspectRatio(e) {
              this.aspectRatioProperty !== e &&
                ((this.aspectRatioProperty = e),
                (this.orthoWidth = this.orthoHeight * this.aspectRatioProperty),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_ASPECTRATIO));
            }
            get isAttached() {
              return this.isAttachedProperty;
            }
            set isAttached(e) {
              (this.isAttachedProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_ISATTACHED);
            }
            get radius() {
              return this.target.subtract(this.position).length;
            }
            set radius(e) {
              e <= 1 && (e = 1),
                this.radius !== e &&
                  ((this.position = this.target.subtract(
                    this.forward.scalarMultiply(e)
                  )),
                  this.notifyPropertyChanged(n.PROPERTY.CAMERA_RADIUS));
            }
            get orbitalPitch() {
              return this.orbitalPitchProperty;
            }
            set orbitalPitch(e) {
              if (this.orbitalPitchProperty === e) return;
              this.orbitalPitchProperty = e > 90 ? 89.9 : e < -90 ? -89.9 : e;
              const t = this.webAssemblyContext.Math3D.PitchAndYawToDirection(
                this.orbitalPitchProperty,
                this.orbitalYawProperty
              );
              try {
                let e = new s.Vector3(t.x, t.y, t.z);
                (e = e.scalarMultiply(this.radius)),
                  (this.position = this.target.subtract(e)),
                  this.notifyPropertyChanged(n.PROPERTY.CAMERA_ORBITALPITCH);
              } finally {
                null == t || t.delete();
              }
            }
            get orbitalYaw() {
              return this.orbitalYawProperty;
            }
            set orbitalYaw(e) {
              if (this.orbitalYawProperty === e) return;
              this.orbitalYawProperty = e;
              const t = this.webAssemblyContext.Math3D.PitchAndYawToDirection(
                this.orbitalPitchProperty,
                this.orbitalYawProperty
              );
              try {
                let e = new s.Vector3(t.x, t.y, t.z);
                (e = e.scalarMultiply(this.radius)),
                  (this.position = this.target.subtract(e)),
                  this.notifyPropertyChanged(n.PROPERTY.CAMERA_ORBITALYAW);
              } finally {
                null == t || t.delete();
              }
            }
            get farClip() {
              return this.farClipProperty;
            }
            set farClip(e) {
              (this.farClipProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_FARCLIP);
            }
            get nearClip() {
              return this.nearClipProperty;
            }
            set nearClip(e) {
              (this.nearClipProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_NEARCLIP);
            }
            get fieldOfView() {
              return this.fieldOfViewProperty;
            }
            set fieldOfView(e) {
              (this.fieldOfViewProperty = e),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_FIELDOFVIEW);
            }
            get upGlobal() {
              return new s.Vector3(0, 1, 0);
            }
            get side() {
              const e = this.forward,
                t = e
                  .crossProduct(this.upGlobal)
                  .crossProduct(e)
                  .crossProduct(e);
              return t.normalize(), t;
            }
            get forward() {
              const e = this.target.subtract(this.position);
              return e.normalize(), e;
            }
            get up() {
              const e = this.forward,
                t = e.crossProduct(this.upGlobal).crossProduct(e);
              return t.normalize(), t;
            }
            get target() {
              return this.targetProperty;
            }
            set target(e) {
              if (this.targetProperty === e) return;
              let t, r;
              this.targetProperty = e;
              try {
                (t = this.forward.toTsrVector3(this.webAssemblyContext)),
                  (r =
                    this.webAssemblyContext.Math3D.DirectionToPitchAndYaw(t)),
                  (this.orbitalPitchProperty = r.pitch),
                  (this.orbitalYawProperty = r.yaw),
                  this.notifyPropertyChanged(n.PROPERTY.CAMERA_TARGET);
              } finally {
                null == t || t.delete(), null == r || r.delete();
              }
            }
            get position() {
              return this.positionProperty;
            }
            set position(e) {
              if (this.positionProperty === e) return;
              let t, r;
              this.positionProperty = e;
              try {
                (t = this.forward.toTsrVector3(this.webAssemblyContext)),
                  (r =
                    this.webAssemblyContext.Math3D.DirectionToPitchAndYaw(t)),
                  (this.orbitalPitchProperty = r.pitch),
                  (this.orbitalYawProperty = r.yaw),
                  this.notifyPropertyChanged(n.PROPERTY.CAMERA_POSITION);
              } finally {
                null == t || t.delete(), null == r || r.delete();
              }
            }
            toOrthogonal() {
              this.projectionModeProperty !== l.Orthogonal &&
                ((this.projectionModeProperty = l.Orthogonal),
                (this.orthoWidthProperty = this.radius),
                (this.orthoHeightProperty = this.orthoWidth / this.aspectRatio),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_PROJECTIONMODE));
            }
            toPerspective() {
              this.projectionModeProperty !== l.Perspective &&
                ((this.projectionModeProperty = l.Perspective),
                (this.radius = this.orthoWidth),
                this.notifyPropertyChanged(n.PROPERTY.CAMERA_PROJECTIONMODE));
            }
            resetToDefaults() {
              let e, t;
              (this.positionProperty = new s.Vector3(-1e3, 1e3, -1e3)),
                (this.targetProperty = new s.Vector3(0, 0, 0)),
                (this.fieldOfViewProperty = 60),
                (this.nearClipProperty = 1),
                (this.farClipProperty = 4e3),
                (this.projectionModeProperty = l.Perspective),
                (this.aspectRatioProperty = 1.5),
                (this.orthoWidthProperty = 600),
                (this.orthoHeightProperty = 400);
              try {
                (e = this.forward.toTsrVector3(this.webAssemblyContext)),
                  (t =
                    this.webAssemblyContext.Math3D.DirectionToPitchAndYaw(e)),
                  (this.orbitalPitch = t.pitch),
                  (this.orbitalYaw = t.yaw);
              } finally {
                null == t || t.delete(), null == e || e.delete();
              }
            }
            updateEngineCamera(e) {
              let t, r, i;
              o.Guard.notNull(e, "tsrCamera");
              try {
                (t = this.position.toTsrVector3(this.webAssemblyContext)),
                  (r = this.target.toTsrVector3(this.webAssemblyContext)),
                  (i = this.up.toTsrVector3(this.webAssemblyContext)),
                  e.SetLoc(t),
                  e.SetAt(r),
                  e.SetFarClip(this.farClip),
                  e.SetNearClip(this.nearClip),
                  e.SetFovAngle(
                    this.webAssemblyContext.Math3D.DegToRad(this.fieldOfView)
                  ),
                  e.SetProjectionMode(
                    this.projectionMode === l.Perspective
                      ? this.webAssemblyContext.eTSRCameraProjectionMode
                          .CAMERA_PROJECTIONMODE_PERSPECTIVE
                      : this.webAssemblyContext.eTSRCameraProjectionMode
                          .CAMERA_PROJECTIONMODE_ORTHOGONAL
                  ),
                  e.SetOrthoWidth(this.orthoWidth),
                  e.SetOrthoHeight(this.orthoHeight),
                  e.SetAspectRatio(this.aspectRatio),
                  e.SetYaw(
                    this.webAssemblyContext.Math3D.DegToRad(this.orbitalYaw)
                  ),
                  e.SetPitch(
                    this.webAssemblyContext.Math3D.DegToRad(this.orbitalPitch)
                  ),
                  e.SetUp(i);
              } finally {
                null == t || t.delete(),
                  null == r || r.delete(),
                  null == i || i.delete();
              }
            }
            notifyPropertyChanged(e) {
              var t;
              !this.debugPositionsProperty ||
                (e !== n.PROPERTY.CAMERA_POSITION &&
                  e !== n.PROPERTY.CAMERA_TARGET) ||
                console.log(
                  `SciChart.js Camera P=${this.position.toString()}, T=${this.target.toString()}`
                ),
                null === (t = this.propertyChanged) ||
                  void 0 === t ||
                  t.raiseEvent(new a.PropertyChangedEventArgs(e));
            }
            debugOutput() {
              const e = [
                `Camera id='${this.id}': `,
                `  position: ${this.position.toString()}`,
                `  target: ${this.target.toString()}`,
                `  pitch: ${this.orbitalPitch.toFixed(2)} degrees`,
                `  yaw: ${this.orbitalYaw.toFixed(2)} degrees`,
                `  up Vector: ${this.up.toString()}`,
                `  forward Vector: ${this.forward.toString()}`,
                `  projectionMode: ${this.projectionMode}`,
              ];
              return (
                this.projectionMode === l.Orthogonal
                  ? (e.push(`  orthoWidth: ${this.orthoWidth.toFixed(2)}`),
                    e.push(`  orthoHeight: ${this.orthoHeight.toFixed(2)}`))
                  : (e.push(`  radius: ${this.radius.toFixed(2)}`),
                    e.push(
                      `  fieldOfView: ${this.fieldOfView.toFixed(2)} degrees`
                    )),
                e.forEach((e) => console.log(e)),
                e
              );
            }
            toJSON() {
              return {
                id: this.id,
                position: this.position,
                target: this.target,
                fieldOfView: this.fieldOfView,
                nearClip: this.nearClip,
                farClip: this.farClip,
                projectionMode: this.projectionMode,
                orthoWidth: this.orthoWidth,
                orthoHeight: this.orthoHeight,
              };
            }
          });
      },
      63220: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChartModifierBase3D = void 0);
        const i = r(13063),
          o = r(66405);
        class a extends i.ChartModifierBase {
          constructor(e) {
            super(e), (this.typeMap = new Map());
          }
          get modifierType() {
            return o.EModifierType.Chart3DModifier;
          }
          toJSON() {
            const e = { id: this.id, executeCondition: this.executeCondition };
            return { type: this.type, options: e };
          }
        }
        t.ChartModifierBase3D = a;
      },
      89577: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomChartModifier3D = void 0);
        const i = r(89955),
          o = r(63220);
        class a extends o.ChartModifierBase3D {
          constructor(e) {
            super(e), (this.type = i.EChart3DModifierType.Custom);
          }
        }
        t.CustomChartModifier3D = a;
      },
      47737: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MouseWheelZoomModifier3D = void 0);
        const i = r(89955),
          o = r(3810),
          a = r(63220);
        class s extends a.ChartModifierBase3D {
          constructor(e) {
            super(e),
              (this.type = i.EChart3DModifierType.MouseWheelZoom),
              (this.mouseWheelSensitivity =
                (null == e ? void 0 : e.mouseWheelSensitivity) || 0.1);
          }
          modifierMouseWheel(e) {
            super.modifierMouseWheel(e);
            const t = this.parentSurface;
            if (!t) return;
            const r = t.camera;
            if (!r) return;
            const i = e.mouseWheelDelta,
              a = r.radius,
              s = (a + i * this.mouseWheelSensitivity) / a;
            r.projectionMode === o.ECameraProjectionMode.Perspective
              ? (r.radius *= s)
              : ((r.orthoWidth *= s), (r.orthoHeight *= s)),
              (e.handled = !0);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { mouseWheelSensitivity: this.mouseWheelSensitivity };
            return Object.assign(e.options, t), e;
          }
        }
        t.MouseWheelZoomModifier3D = s;
      },
      17707: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OrbitModifier3D = void 0);
        const i = r(6859),
          o = r(89955),
          a = r(73792);
        class s extends a.PinchZoomModifier3D {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = o.EChart3DModifierType.Orbit),
              (this.enableZoom = !0),
              (this.enableZoom =
                null !== (t = null == e ? void 0 : e.enableZoom) && void 0 !== t
                  ? t
                  : this.enableZoom),
              (this.executeCondition =
                null !== (r = null == e ? void 0 : e.executeCondition) &&
                void 0 !== r
                  ? r
                  : { button: i.EExecuteOn.MouseLeftButton });
          }
          modifierMouseDown(e) {
            if (!this.isAttached)
              throw new Error(
                "Should not call OrbitModifier3D.modifierMouseDown if not attached"
              );
            this.checkExecuteConditions(e).isPrimary &&
              (super.modifierMouseDown(e),
              this.activePointerEvents.set(e.pointerId, e));
          }
          modifierMouseMove(e) {
            this.updatePointerInfo(e),
              this.previousPoint &&
                (this.enableZoom &&
                  super.getIsActionAllowed(e) &&
                  super.performModifierAction(e),
                this.getIsActionAllowed(e) && this.performModifierAction(e));
          }
          modifierMouseUp(e) {
            if ((super.modifierMouseUp(e), this.activePointerEvents.size > 0)) {
              const t = this.activePointerEvents.values().next().value;
              e.target.setPointerCapture(t.pointerId);
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = { enableZoom: this.enableZoom };
            return Object.assign(e.options, t), e;
          }
          performModifierAction(e) {
            const t = this.parentSurface.camera;
            if (!t) return;
            const r = e.mousePoint,
              i = 0.2 * (this.previousPoint.x - r.x),
              o = 0.2 * (this.previousPoint.y - r.y);
            (t.orbitalYaw += i), (t.orbitalPitch -= o);
          }
          getIsActionAllowed(e) {
            return !(
              this.activePointerEvents.values().next().value.pointerId !==
                e.pointerId || this.activePointerEvents.size > 1
            );
          }
        }
        t.OrbitModifier3D = s;
      },
      73792: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PinchZoomModifier3D = void 0);
        const i = r(89955),
          o = r(3810),
          a = r(63220);
        class s extends a.ChartModifierBase3D {
          constructor(e) {
            var t;
            super(e),
              (this.growFactor = 0.5),
              (this.type = i.EChart3DModifierType.PinchZoom),
              (this.growFactor =
                null !== (t = null == e ? void 0 : e.growFactor) && void 0 !== t
                  ? t
                  : this.growFactor);
          }
          modifierMouseDown(e) {
            if ((super.modifierMouseDown(e), !this.isAttached))
              throw new Error(
                "Should not call PinchZoomModifier3D.modifierMouseDown if not attached"
              );
            ("touch" === e.pointerType || "pen" === e.pointerType) &&
              this.activePointerEvents.set(e.pointerId, e);
          }
          modifierMouseMove(e) {
            var t;
            super.modifierMouseMove(e),
              null === (t = this.activePointerEvents.get(e.pointerId)) ||
                void 0 === t ||
                t.mousePoint,
              this.activePointerEvents.has(e.pointerId) &&
                this.activePointerEvents.set(e.pointerId, e),
              this.getIsActionAllowed(e) && this.performModifierAction(e);
          }
          modifierMouseUp(e) {
            super.modifierMouseUp(e), this.removeFromActiveTouchEvents(e);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { growFactor: this.growFactor };
            return Object.assign(e.options, t), e;
          }
          performZoom(e, t, r) {
            const i = this.parentSurface;
            if (!i) return;
            const a = i.camera;
            if (!a) return;
            const s = Math.sqrt(Math.pow(t, 2) + Math.pow(r, 2)),
              n = Math.sqrt(
                Math.pow(this.previousHorizontalTouchPointsDistance, 2) +
                  Math.pow(this.previousVerticalTouchPointsDistance, 2)
              ),
              l = a.radius,
              d = (l + (n - s) * this.growFactor) / l;
            a.projectionMode === o.ECameraProjectionMode.Perspective
              ? (a.radius *= d)
              : ((a.orthoWidth *= d), (a.orthoHeight *= d));
          }
          removeFromActiveTouchEvents(e) {
            this.activePointerEvents.delete(e.pointerId),
              this.activePointerEvents.size < 2 &&
                ((this.previousHorizontalTouchPointsDistance = void 0),
                (this.previousVerticalTouchPointsDistance = void 0));
          }
          performModifierAction(e) {
            const [{ mousePoint: t }, { mousePoint: r }] = Array.from(
                this.activePointerEvents.values()
              ),
              i = Math.abs(t.x - r.x),
              o = Math.abs(t.y - r.y);
            void 0 !== this.previousHorizontalTouchPointsDistance &&
              void 0 !== this.previousVerticalTouchPointsDistance &&
              this.performZoom(e.mousePoint, i, o),
              (this.previousHorizontalTouchPointsDistance = i),
              (this.previousVerticalTouchPointsDistance = o);
          }
          getIsActionAllowed(e) {
            return (
              ("touch" === e.pointerType || "pen" === e.pointerType) &&
              this.activePointerEvents.size >= 2
            );
          }
        }
        t.PinchZoomModifier3D = s;
      },
      68491: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ResetCamera3DModifier = void 0);
        const i = r(33485),
          o = r(10276),
          a = r(70162),
          s = r(89955),
          n = r(3810),
          l = r(63220);
        class d extends l.ChartModifierBase3D {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type = s.EChart3DModifierType.ZoomExtents),
              (this.isAnimated = !0),
              (this.animationDuration = 400),
              (this.easingFunction = o.easing.outExpo),
              (this.isAnimated =
                null === (t = null == e ? void 0 : e.isAnimated) ||
                void 0 === t ||
                t),
              (this.animationDuration =
                null !== (r = null == e ? void 0 : e.animationDuration) &&
                void 0 !== r
                  ? r
                  : 400),
              (null == e ? void 0 : e.easingFunction) &&
                "string" == typeof e.easingFunction &&
                (e.easingFunction = o.easing[e.easingFunction]),
              (this.easingFunction =
                null !== (i = null == e ? void 0 : e.easingFunction) &&
                void 0 !== i
                  ? i
                  : o.easing.outExpo),
              (this.destination = null == e ? void 0 : e.destination);
          }
          onAttach() {
            if (!this.destination) {
              const e = this.parentSurface;
              if (!e) return;
              const t = e.camera;
              if (!t) return;
              this.destination = {
                radius: t.radius,
                pitch: t.orbitalPitch,
                yaw: t.orbitalYaw,
                width: t.orthoWidth,
                height: t.orthoHeight,
              };
            }
          }
          modifierDoubleClick(e) {
            var t, r;
            const o = this.parentSurface;
            if (!o) return;
            const s = o.camera;
            if (s) {
              if (s.projectionMode === n.ECameraProjectionMode.Perspective) {
                const e = new a.GenericAnimation({
                  from: {
                    radius: s.radius,
                    pitch: s.orbitalPitch,
                    yaw: s.orbitalYaw,
                  },
                  to:
                    null !== (t = this.destination) && void 0 !== t
                      ? t
                      : { radius: 1, pitch: 0, yaw: 0 },
                  onAnimate: (e, t, r) => {
                    (s.radius = i.DoubleAnimator.interpolate(
                      e.radius,
                      t.radius,
                      r
                    )),
                      (s.orbitalPitch = i.DoubleAnimator.interpolate(
                        e.pitch,
                        t.pitch,
                        r
                      )),
                      (s.orbitalYaw = i.DoubleAnimator.interpolate(
                        e.yaw,
                        t.yaw,
                        r
                      ));
                  },
                  duration: this.isAnimated ? this.animationDuration : 0,
                  ease: this.easingFunction,
                });
                o.addAnimation(e);
              } else {
                const e = new a.GenericAnimation({
                  from: { width: s.orthoWidth, height: s.orthoHeight },
                  to:
                    null !== (r = this.destination) && void 0 !== r
                      ? r
                      : { width: 1, height: 1 },
                  onAnimate: (e, t, r) => {
                    (s.orthoWidth = i.DoubleAnimator.interpolate(
                      e.width,
                      t.width,
                      r
                    )),
                      (s.orthoHeight = i.DoubleAnimator.interpolate(
                        e.height,
                        t.height,
                        r
                      ));
                  },
                  duration: this.isAnimated ? this.animationDuration : 0,
                  ease: this.easingFunction,
                });
                o.addAnimation(e);
              }
              e.handled = !0;
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                animationDuration: this.animationDuration,
                easingFunction: this.easingFunction.name,
                isAnimated: this.isAnimated,
                destination: this.destination,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.ResetCamera3DModifier = d;
      },
      66477: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.adjustTooltipPosition3D = t.TooltipModifier3D = void 0);
        const i = r(62773),
          o = r(31306),
          a = r(56744),
          s = r(89955),
          n = r(32873),
          l = r(23291),
          d = r(58042),
          h = r(26079),
          u = r(63220);
        class c extends u.ChartModifierBase3D {
          constructor(e) {
            var t, r, i, o, a, n, l, d, h, u, c, y;
            super(e),
              (this.type = s.EChart3DModifierType.Tooltip),
              (this.showTooltip = !0),
              (this.includedSeriesMap = new Map()),
              (this.tooltipSvgTemplateProperty = g),
              (this.tooltipContainerBackgroundProperty = "#228B22"),
              (this.tooltipTextStrokeProperty = "#fff"),
              (this.tooltipDataTemplateProperty = p),
              (this.crosshairStrokeProperty =
                null !== (t = null == e ? void 0 : e.crosshairStroke) &&
                void 0 !== t
                  ? t
                  : "#FF6600"),
              (this.crosshairStrokeThicknessProperty =
                null !==
                  (r = null == e ? void 0 : e.crosshairStrokeThickness) &&
                void 0 !== r
                  ? r
                  : 2),
              (this.isCrosshairVisibleProperty =
                null === (i = null == e ? void 0 : e.isCrosshairVisible) ||
                void 0 === i ||
                i),
              (null == e ? void 0 : e.tooltipSvgTemplate) &&
                "string" == typeof e.tooltipSvgTemplate &&
                (this.typeMap.set("tooltipSvgTemplate", e.tooltipSvgTemplate),
                (e.tooltipSvgTemplate = getFunction(
                  EBaseType.OptionFunction,
                  e.tooltipSvgTemplate
                ))),
              (this.tooltipSvgTemplateProperty =
                null !== (o = null == e ? void 0 : e.tooltipSvgTemplate) &&
                void 0 !== o
                  ? o
                  : this.tooltipSvgTemplateProperty),
              (this.tooltipContainerBackgroundProperty =
                null !==
                  (a = null == e ? void 0 : e.tooltipContainerBackground) &&
                void 0 !== a
                  ? a
                  : this.tooltipContainerBackgroundProperty),
              (this.tooltipTextStrokeProperty =
                null !== (n = null == e ? void 0 : e.tooltipTextStroke) &&
                void 0 !== n
                  ? n
                  : this.tooltipTextStrokeProperty),
              (this.showTooltip =
                null !== (l = null == e ? void 0 : e.showTooltip) &&
                void 0 !== l
                  ? l
                  : this.showTooltip),
              (this.placementDivIdProperty =
                null !== (d = null == e ? void 0 : e.placementDivId) &&
                void 0 !== d
                  ? d
                  : this.placementDivIdProperty),
              (null == e ? void 0 : e.tooltipLegendTemplate) &&
                "string" == typeof e.tooltipLegendTemplate &&
                (this.typeMap.set(
                  "tooltipLegendTemplate",
                  e.tooltipLegendTemplate
                ),
                (e.tooltipLegendTemplate = getFunction(
                  EBaseType.OptionFunction,
                  e.tooltipLegendTemplate
                ))),
              (this.tooltipLegendTemplateProperty =
                null !== (h = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== h
                  ? h
                  : this.tooltipLegendTemplateProperty),
              (this.tooltipLegendOffsetXProperty =
                null !== (u = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== u
                  ? u
                  : this.tooltipLegendOffsetX),
              (this.tooltipLegendOffsetYProperty =
                null !== (c = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== c
                  ? c
                  : this.tooltipLegendOffsetY),
              (null == e ? void 0 : e.tooltipDataTemplate) &&
                "string" == typeof e.tooltipDataTemplate &&
                (this.typeMap.set("tooltipDataTemplate", e.tooltipDataTemplate),
                (e.tooltipDataTemplate = getFunction(
                  EBaseType.OptionFunction,
                  e.tooltipDataTemplate
                ))),
              (this.tooltipDataTemplateProperty =
                null !== (y = null == e ? void 0 : e.tooltipDataTemplate) &&
                void 0 !== y
                  ? y
                  : this.tooltipDataTemplateProperty);
          }
          includeSeries(e, t) {
            this.includedSeriesMap.set(e, t);
          }
          getIncludedSeries() {
            return this.parentSurface.renderableSeries
              .asArray()
              .filter(
                (e) => e.isVisible && !1 !== this.includedSeriesMap.get(e)
              );
          }
          get isCrosshairVisible() {
            return this.isCrosshairVisibleProperty;
          }
          set isCrosshairVisible(e) {
            var t;
            (this.isCrosshairVisibleProperty = e),
              null === (t = this.parentSurface) ||
                void 0 === t ||
                t.invalidateElement();
          }
          get crosshairStroke() {
            return this.crosshairStrokeProperty;
          }
          set crosshairStroke(e) {
            var t;
            (this.crosshairStrokeProperty = e),
              null === (t = this.parentSurface) ||
                void 0 === t ||
                t.invalidateElement();
          }
          get crosshairStrokeThickness() {
            return this.crosshairStrokeThicknessProperty;
          }
          set crosshairStrokeThickness(e) {
            var t;
            (this.crosshairStrokeThicknessProperty = e),
              null === (t = this.parentSurface) ||
                void 0 === t ||
                t.invalidateElement();
          }
          get tooltipSvgTemplate() {
            return this.tooltipSvgTemplateProperty;
          }
          set tooltipSvgTemplate(e) {
            (this.tooltipSvgTemplateProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.tooltipSvgTemplate = e);
          }
          get tooltipLegendTemplate() {
            return this.tooltipLegendTemplateProperty;
          }
          set tooltipLegendTemplate(e) {
            (this.tooltipLegendTemplateProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.tooltipLegendTemplate = e);
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.tooltipDataTemplate = e);
          }
          get tooltipContainerBackground() {
            return this.tooltipContainerBackgroundProperty;
          }
          set tooltipContainerBackground(e) {
            this.tooltipContainerBackgroundProperty !== e &&
              ((this.tooltipContainerBackgroundProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.containerBackground = e));
          }
          get tooltipLegendOffsetX() {
            return this.tooltipLegendOffsetXProperty;
          }
          set tooltipLegendOffsetX(e) {
            this.tooltipLegendOffsetXProperty !== e &&
              ((this.tooltipLegendOffsetXProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.tooltipLegendOffsetX = e));
          }
          get tooltipLegendOffsetY() {
            return this.tooltipLegendOffsetYProperty;
          }
          set tooltipLegendOffsetY(e) {
            this.tooltipLegendOffsetYProperty !== e &&
              ((this.tooltipLegendOffsetYProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.tooltipLegendOffsetY = e));
          }
          get tooltipTextStroke() {
            return this.tooltipTextStrokeProperty;
          }
          set tooltipTextStroke(e) {
            this.tooltipTextStrokeProperty !== e &&
              ((this.tooltipTextStrokeProperty = e),
              this.tooltipAnnotation &&
                (this.tooltipAnnotation.textStroke = e));
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              this.notifyPropertyChanged("PLACEMENT_DIV_ID"));
          }
          onAttach() {
            super.onAttach(),
              this.parentSurface &&
                ((this.parentSurface.isHitTestEnabled = !0),
                (this.crosshairEntity = (0, a.deleteSafe)(
                  this.crosshairEntity
                )),
                (this.crosshairEntity = new h.CrosshairLinesSceneEntity(
                  this.parentSurface.webAssemblyContext3D
                )),
                this.parentSurface.rootEntity.children.add(
                  this.crosshairEntity
                ),
                (this.tooltipAnnotation = new d.TooltipSvgAnnotation3D({
                  xCoordinateMode: o.ECoordinateMode.Pixel,
                  yCoordinateMode: o.ECoordinateMode.Pixel,
                  tooltipSvgTemplate: this.tooltipSvgTemplate,
                  containerBackground: this.tooltipContainerBackground,
                  textStroke: this.tooltipTextStroke,
                  tooltipLegendTemplate: this.tooltipLegendTemplate,
                  tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                  tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                  placementDivId: this.placementDivId,
                  tooltipDataTemplate: this.tooltipDataTemplate,
                })),
                this.parentSurface.modifierAnnotations.add(
                  this.tooltipAnnotation
                ));
          }
          onDetach() {
            super.onDetach(),
              this.parentSurface &&
                (this.parentSurface.rootEntity.children.remove(
                  this.crosshairEntity
                ),
                this.parentSurface.modifierAnnotations.remove(
                  this.tooltipAnnotation
                ),
                (this.tooltipAnnotation = void 0)),
              (this.crosshairEntity = (0, a.deleteSafe)(this.crosshairEntity));
          }
          modifierMouseMove(e) {
            this.activePointerEvents.set(e.pointerId, e),
              super.modifierMouseMove(e),
              this.getIsActionAllowed(e) && this.update();
          }
          onParentSurfaceRendered() {
            this.update();
          }
          update() {
            var e, t, r, i, o;
            if (!this.mousePoint) return;
            const { x: a, y: s } = this.mousePoint,
              l = this.getIncludedSeries()
                .map((e) => e.hitTest(this.mousePoint))
                .find((e) => e.isHit);
            if (null == l ? void 0 : l.isHit) {
              if (
                (this.crosshairEntity &&
                  this.isCrosshairVisible &&
                  ((this.crosshairEntity.worldDimensions =
                    null === (e = this.parentSurface) || void 0 === e
                      ? void 0
                      : e.worldDimensions),
                  (this.crosshairEntity.cameraPosition =
                    null ===
                      (r =
                        null === (t = this.parentSurface) || void 0 === t
                          ? void 0
                          : t.camera) || void 0 === r
                      ? void 0
                      : r.position),
                  (this.crosshairEntity.stroke = this.crosshairStroke),
                  (this.crosshairEntity.strokeThickness =
                    this.crosshairStrokeThickness),
                  (this.crosshairEntity.location = l.hitWorldCoords),
                  (this.crosshairEntity.isVisible = this.isCrosshairVisible),
                  null === (i = this.parentSurface) ||
                    void 0 === i ||
                    i.invalidateElement()),
                (this.tooltipAnnotation.isHidden = !this.showTooltip),
                this.showTooltip)
              ) {
                const e = (0, n.translateToNotScaled)(a),
                  t = (0, n.translateToNotScaled)(s);
                (this.tooltipAnnotation.x1 = e),
                  (this.tooltipAnnotation.y1 = t);
              }
              (this.showTooltip || this.tooltipLegendTemplate) &&
                (this.tooltipAnnotation.seriesInfo = l);
            } else
              (this.tooltipAnnotation.seriesInfo = void 0),
                (this.crosshairEntity.isVisible = !1),
                (this.tooltipAnnotation.isHidden = !0),
                null === (o = this.parentSurface) ||
                  void 0 === o ||
                  o.invalidateElement();
          }
        }
        t.TooltipModifier3D = c;
        const p = (e, t) => {
            const r = [];
            return (
              t.title && r.push(t.title),
              e &&
                e.isHit &&
                (e.dataSeriesName && r.push(e.dataSeriesName),
                (e.dataSeriesType === l.EDataSeriesType3D.Xyz3D ||
                  e.dataSeriesType === l.EDataSeriesType3D.UniformGrid3D) &&
                  (r.push(`X: ${e.xValue}`),
                  r.push(`Y: ${e.yValue}`),
                  r.push(`Z: ${e.zValue}`))),
              r
            );
          },
          g = (e, r) => {
            var o;
            const a = `id_${Date.now()}`,
              s = (
                null !== (o = r.tooltipDataTemplate) && void 0 !== o ? o : p
              )(e, r);
            if (0 === s.length) return "<svg></svg>";
            const { width: n, height: l } = (0, i.calcTooltipSize)(s);
            (0, t.adjustTooltipPosition3D)(n, l, r);
            let d = "";
            return (
              s.forEach((e, t) => {
                d += `<tspan x="8" dy="1.2em">${e}</tspan>`;
              }),
              `<svg class="scichart__cursor-tooltip" width="${n}" height="${l}">\n        <defs>\n            <filter id="${a}" x="0" y="0" width="200%" height="200%">\n                <feOffset result="offOut" in="SourceAlpha" dx="3" dy="3" />\n                <feGaussianBlur result="blurOut" in="offOut" stdDeviation="3" />\n                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />\n            </filter>\n        </defs>\n        <rect rx="4" ry="4" width="95%" height="90%" fill="${r.containerBackground}" filter="url(#${a})" />\n        <svg width="100%">\n            <text x="8" y="3" font-size="13" font-family="Verdana" dy="0" fill="${r.textStroke}">${d}</text>\n        </svg>\n    </svg>`
            );
          };
        t.adjustTooltipPosition3D = (e, t, r) => {
          const { seriesViewRect: i } = r.parentSurface,
            o = r.x1,
            a = r.y1,
            s = (0, n.translateToNotScaled)(i.width) - o < e ? -e : 5,
            l = (0, n.translateToNotScaled)(i.height) - a < t ? -t : 5;
          (r.xCoordShift = s), (r.yCoordShift = l);
        };
      },
      23291: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseDataSeries3D = t.EDataSeriesType3D = void 0);
        const i = r(55023),
          o = r(3214);
        var a;
        ((a = t.EDataSeriesType3D || (t.EDataSeriesType3D = {})).Xyz3D = "Xyz"),
          (a.UniformGrid3D = "UniformGrid3D"),
          (a.NonUniformGrid3D = "NonUniformGrid3D");
        class s extends i.DeletableEntity {
          constructor(e, t) {
            var r;
            super(),
              (this.webAssemblyContext = e),
              (this.dataSeriesNameProperty =
                null !== (r = null == t ? void 0 : t.dataSeriesName) &&
                void 0 !== r
                  ? r
                  : this.dataSeriesNameProperty),
              (this.dataChanged = new o.EventHandler()),
              (this.isModifiedProperty = !0);
          }
          get dataSeriesName() {
            return this.dataSeriesNameProperty;
          }
          set dataSeriesName(e) {
            (this.dataSeriesNameProperty = e), this.notifyDataChanged();
          }
          get isModified() {
            return this.isModifiedProperty;
          }
          getIsDeleted() {
            return this.isDeleted;
          }
          delete() {
            (this.isDeleted = !0), (this.webAssemblyContext = void 0);
          }
          notifyDataChanged() {
            (this.isModifiedProperty = !0), this.dataChanged.raiseEvent();
          }
          resetModified() {
            this.isModifiedProperty = !1;
          }
          toJSON(e = !1) {
            const t = this.getOptions(e);
            return { type: this.type, options: t };
          }
          getOptions(e) {
            return { dataSeriesName: this.dataSeriesName };
          }
        }
        t.BaseDataSeries3D = s;
      },
      13426: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseGridDataSeries3D = void 0);
        const i = r(98140),
          o = r(23291);
        class a extends o.BaseDataSeries3D {
          constructor(e, t) {
            super(e, t), this.setYValues(null == t ? void 0 : t.yValues);
          }
          get yRange() {
            if (!this.yRangeCached) {
              let e = -Number.MAX_VALUE,
                t = Number.MAX_VALUE;
              for (let r = 0; r < this.zSizeProperty; r++)
                for (let i = 0; i < this.xSizeProperty; i++) {
                  const o = this.yValuesProperty[r][i];
                  (e = Math.max(o, e)), (t = Math.min(o, t));
                }
              this.yRangeCached = new i.NumberRange(t, e);
            }
            return this.yRangeCached;
          }
          get zSize() {
            return this.zSizeProperty;
          }
          get xSize() {
            return this.xSizeProperty;
          }
          setYValues(e) {
            if (!e || !e[0])
              return (
                (this.yValuesProperty = void 0),
                (this.xSizeProperty = 0),
                void (this.zSizeProperty = 0)
              );
            const t = e[0].length;
            e.forEach((e) => {
              if (!e)
                throw new Error(
                  "Each row in YValues must be defined. See how to declare a 2D array in Javascript here https://stackoverflow.com/a/966234/303612"
                );
              if (e.length !== t)
                throw new Error(
                  "Each row in YValues must be the same length, so that the overall 2D array is square"
                );
            });
            const r = e[0].length,
              i = e.length;
            (this.xSizeProperty = r),
              (this.zSizeProperty = i),
              (this.yValuesProperty = e),
              this.notifyDataChanged();
          }
          getYValues() {
            return this.yValuesProperty;
          }
          getYValue(e, t) {
            try {
              return this.yValuesProperty[e][t];
            } catch (r) {
              return console.log(`error at get z,x ${e}, ${t}`), 0;
            }
          }
          setYValue(e, t, r) {
            (this.yValuesProperty[e][t] = r), this.notifyDataChanged();
          }
          notifyDataChanged() {
            super.notifyDataChanged(), (this.yRangeCached = void 0);
          }
          getOptions(e) {
            const t = super.getOptions(e);
            if (e) return t;
            const r = { yValues: this.getYValues() };
            return Object.assign(t, r);
          }
        }
        t.BaseGridDataSeries3D = a;
      },
      75869: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformGridDataSeries3D = void 0);
        const i = r(98140),
          o = r(23291),
          a = r(13426);
        class s extends a.BaseGridDataSeries3D {
          constructor(e, t) {
            super(e, t),
              (this.type = o.EDataSeriesType3D.UniformGrid3D),
              (this.xStartProperty = (null == t ? void 0 : t.xStart) || 0),
              (this.xStepProperty = (null == t ? void 0 : t.xStep) || 1),
              (this.zStartProperty = (null == t ? void 0 : t.zStart) || 0),
              (this.zStepProperty = (null == t ? void 0 : t.zStep) || 1);
          }
          get xStart() {
            return this.xStartProperty;
          }
          set xStart(e) {
            (this.xStartProperty = e), this.notifyDataChanged();
          }
          get xStep() {
            return this.xStepProperty;
          }
          set xStep(e) {
            (this.xStepProperty = e), this.notifyDataChanged();
          }
          get zStart() {
            return this.zStartProperty;
          }
          set zStart(e) {
            (this.zStartProperty = e), this.notifyDataChanged();
          }
          get zStep() {
            return this.zStepProperty;
          }
          set zStep(e) {
            (this.zStepProperty = e), this.notifyDataChanged();
          }
          get xRange() {
            return new i.NumberRange(
              this.xStart,
              this.xStart + this.xStep * (this.xSize - 1)
            );
          }
          get zRange() {
            return new i.NumberRange(
              this.zStart,
              this.zStart + this.zStep * (this.zSize - 1)
            );
          }
          getX(e) {
            return this.xStart + e * this.xStep;
          }
          getZ(e) {
            return this.zStart + e * this.zStep;
          }
          getOptions(e) {
            const t = super.getOptions(e);
            if (e) return t;
            const r = {
              xStart: this.xStart,
              xStep: this.xStep,
              zStart: this.zStart,
              zStep: this.zStep,
            };
            return Object.assign(t, r);
          }
        }
        t.UniformGridDataSeries3D = s;
      },
      98102: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzDataSeries3D = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(23291);
        class n extends s.BaseDataSeries3D {
          constructor(e, t) {
            super(e, t),
              (this.type = s.EDataSeriesType3D.Xyz3D),
              (this.xValues = new e.SCRTDoubleVector()),
              (this.yValues = new e.SCRTDoubleVector()),
              (this.zValues = new e.SCRTDoubleVector()),
              (this.metadata = []),
              (null == t ? void 0 : t.xValues) &&
                (null == t ? void 0 : t.yValues) &&
                (null == t ? void 0 : t.zValues) &&
                this.appendRange(
                  t.xValues,
                  t.yValues,
                  t.zValues,
                  null == t ? void 0 : t.metadata
                );
          }
          getNativeXValues() {
            return this.xValues;
          }
          getNativeYValues() {
            return this.yValues;
          }
          getNativeZValues() {
            return this.zValues;
          }
          getMetadataValues() {
            return this.metadata;
          }
          get xRange() {
            const e = this.webAssemblyContext.NumberUtil.MinMax(this.xValues),
              t = new a.NumberRange(e.minD, e.maxD);
            return e.delete(), t;
          }
          get yRange() {
            const e = this.webAssemblyContext.NumberUtil.MinMax(this.yValues),
              t = new a.NumberRange(e.minD, e.maxD);
            return e.delete(), t;
          }
          get zRange() {
            const e = this.webAssemblyContext.NumberUtil.MinMax(this.zValues),
              t = new a.NumberRange(e.minD, e.maxD);
            return e.delete(), t;
          }
          append(e, t, r, i) {
            this.getIsDeleted() ||
              (this.xValues.push_back(e),
              this.yValues.push_back(t),
              this.zValues.push_back(r),
              this.metadata.push(i),
              this.notifyDataChanged());
          }
          appendRange(e, t, r, i) {
            if (!this.getIsDeleted()) {
              o.Guard.arraysSameLength(e, "xValues", t, "yValues"),
                o.Guard.arraysSameLength(t, "yValues", r, "zValues");
              const a = this.xValues,
                s = this.yValues,
                n = this.zValues;
              for (let o = 0; o < e.length; o++)
                if (
                  (a.push_back(e[o]), s.push_back(t[o]), n.push_back(r[o]), i)
                ) {
                  const e = i[o];
                  this.metadata.push(e);
                } else this.metadata.push(void 0);
              this.notifyDataChanged();
            }
          }
          update(e, t, r, i, o) {
            this.getIsDeleted() ||
              (this.xValues.set(e, t),
              this.yValues.set(e, r),
              this.zValues.set(e, i),
              (this.metadata[e] = o),
              this.notifyDataChanged());
          }
          insert(e, t, r, i, o) {
            if (!this.getIsDeleted()) {
              if (e < 0 || e >= this.count())
                throw new Error("Start index is out of range");
              this.xValues.insertAt(e, t),
                this.yValues.insertAt(e, r),
                this.zValues.insertAt(e, i),
                this.metadata.splice(e, 0, o),
                this.notifyDataChanged();
            }
          }
          insertRange(e, t, r, i, a) {
            if (!this.getIsDeleted()) {
              if (
                (o.Guard.arraysSameLength(t, "xValues", r, "yValues"),
                o.Guard.arraysSameLength(i, "zValues", r, "yValues"),
                e < 0 || e >= this.count())
              )
                throw new Error("Start index is out of range");
              const s = t.length;
              for (let o = 0; o < s; o++, e++)
                this.xValues.insertAt(e, t[o]),
                  this.yValues.insertAt(e, r[o]),
                  this.zValues.insertAt(e, i[o]),
                  this.metadata.splice(e, 0, a ? a[o] : void 0);
              this.notifyDataChanged();
            }
          }
          removeAt(e) {
            if (!this.getIsDeleted()) {
              if (e < 0 || e >= this.count())
                throw new Error("index is out of range");
              this.xValues.removeAt(e),
                this.yValues.removeAt(e),
                this.zValues.removeAt(e),
                this.metadata.splice(e, 1),
                this.notifyDataChanged();
            }
          }
          removeRange(e, t) {
            if (!this.getIsDeleted()) {
              if (e < 0 || e + t > this.count())
                throw new Error("index is out of range");
              this.xValues.removeRange(e, t),
                this.yValues.removeRange(e, t),
                this.zValues.removeRange(e, t),
                this.metadata.splice(e, t),
                this.notifyDataChanged();
            }
          }
          clear() {
            this.getIsDeleted() ||
              (this.xValues.clear(),
              this.yValues.clear(),
              this.zValues.clear(),
              (this.metadata = []),
              this.notifyDataChanged());
          }
          delete() {
            (this.xValues = (0, i.deleteSafe)(this.xValues)),
              (this.yValues = (0, i.deleteSafe)(this.yValues)),
              (this.zValues = (0, i.deleteSafe)(this.zValues)),
              (this.metadata = []),
              super.delete();
          }
          count() {
            return this.xValues ? this.xValues.size() : 0;
          }
          getOptions(e) {
            const t = super.getOptions(e);
            if (e) return t;
            const r = this.count(),
              i = new Array(r),
              o = new Array(r),
              a = new Array(r);
            for (let e = 0; e < r; e++)
              (i[e] = this.xValues.get(e)),
                (o[e] = this.yValues.get(e)),
                (a[e] = this.zValues.get(e));
            const s = {
              xValues: i,
              yValues: o,
              zValues: a,
              metadata: this.metadata,
            };
            return Object.assign(t, s);
          }
        }
        t.XyzDataSeries3D = n;
      },
      16110: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Vector3 = void 0);
        const i = r(23866);
        class o {
          constructor(e, t, r) {
            (this.xProperty = e), (this.yProperty = t), (this.zProperty = r);
          }
          static get zero() {
            return o.zeroVector;
          }
          static hydrate(e) {
            if (e) {
              const { x: t, y: r, z: i } = e;
              return new o(t, r, i);
            }
          }
          get x() {
            return this.xProperty;
          }
          get y() {
            return this.yProperty;
          }
          get z() {
            return this.zProperty;
          }
          toTsrVector3(e) {
            return (
              i.Guard.notNull(e, "webAssemblyContext"),
              new e.TSRVector3(this.x, this.y, this.z)
            );
          }
          subtract(e) {
            return new o(this.x - e.x, this.y - e.y, this.z - e.z);
          }
          add(e) {
            return new o(this.x + e.x, this.y + e.y, this.z + e.z);
          }
          scalarMultiply(e) {
            return new o(this.x * e, this.y * e, this.z * e);
          }
          dotProduct(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z;
          }
          crossProduct(e) {
            return new o(
              this.y * e.z - this.z * e.y,
              this.z * e.x - this.x * e.z,
              this.x * e.y - this.y * e.x
            );
          }
          get length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          normalize() {
            const e = 1 / this.length;
            if (0 === e)
              throw new Error("Vector3 magnitude is zero, cannot normalize!");
            (this.xProperty = this.xProperty * e),
              (this.yProperty = this.yProperty * e),
              (this.zProperty = this.zProperty * e);
          }
          toString() {
            return `Vector3 (${this.xProperty.toFixed(
              2
            )}, ${this.yProperty.toFixed(2)}, ${this.zProperty.toFixed(2)})`;
          }
          toJSON() {
            return { x: this.x, y: this.y, z: this.z };
          }
        }
        (t.Vector3 = o), (o.zeroVector = new o(0, 0, 0));
      },
      58042: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TooltipSvgAnnotation3D = void 0);
        const i = r(92415),
          o = r(84736),
          a = r(84690),
          s = r(91380),
          n = r(19145);
        class l extends a.SvgAnnotationBase {
          constructor(e) {
            var t, r, i, a, s, l, d, h;
            if (
              (super(e),
              (this.type = o.EAnnotationType.SVG),
              (this.surfaceTypes = [n.ESurfaceType.SciChart3DSurfaceType]),
              (this.tooltipLegendOffsetXProperty = 10),
              (this.tooltipLegendOffsetYProperty = 10),
              (this.isDirty = !0),
              (this.isHidden = !0),
              (this.titleProperty =
                null !== (t = null == e ? void 0 : e.title) && void 0 !== t
                  ? t
                  : this.titleProperty),
              (this.tooltipSvgTemplateProperty =
                null !== (r = null == e ? void 0 : e.tooltipSvgTemplate) &&
                void 0 !== r
                  ? r
                  : this.tooltipSvgTemplateProperty),
              (this.containerBackgroundProperty =
                null !== (i = null == e ? void 0 : e.containerBackground) &&
                void 0 !== i
                  ? i
                  : this.containerBackgroundProperty),
              (this.textStrokeProperty =
                null !== (a = null == e ? void 0 : e.textStroke) && void 0 !== a
                  ? a
                  : this.textStrokeProperty),
              (this.tooltipLegendTemplateProperty =
                null !== (s = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== s
                  ? s
                  : this.tooltipLegendTemplateProperty),
              (this.tooltipLegendOffsetXProperty =
                null !== (l = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== l
                  ? l
                  : this.tooltipLegendOffsetXProperty),
              (this.tooltipLegendOffsetYProperty =
                null !== (d = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== d
                  ? d
                  : this.tooltipLegendOffsetYProperty),
              (this.placementDivIdProperty =
                null !== (h = null == e ? void 0 : e.placementDivId) &&
                void 0 !== h
                  ? h
                  : this.placementDivId),
              (this.tooltipDataTemplateProperty =
                null == e ? void 0 : e.tooltipDataTemplate),
              this.placementDivId)
            ) {
              const e = document.querySelector(`[id='${this.placementDivId}']`);
              this.svgDivRoot = e;
            }
          }
          get seriesInfo() {
            return this.seriesInfoProperty;
          }
          set seriesInfo(e) {
            this.seriesInfoProperty !== e &&
              ((this.seriesInfoProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.SERIES_INFOS));
          }
          get title() {
            return this.titleProperty;
          }
          set title(e) {
            this.titleProperty !== e &&
              ((this.titleProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TITLE));
          }
          get tooltipSvgTemplate() {
            return this.tooltipSvgTemplateProperty;
          }
          set tooltipSvgTemplate(e) {
            (this.tooltipSvgTemplateProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_SVG_TEMPLATE);
          }
          get tooltipLegendTemplate() {
            return this.tooltipLegendTemplateProperty;
          }
          set tooltipLegendTemplate(e) {
            (this.tooltipLegendTemplateProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_TEMPLATE);
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_DATA_TEMPLATE);
          }
          get containerBackground() {
            return this.containerBackgroundProperty;
          }
          set containerBackground(e) {
            this.containerBackgroundProperty !== e &&
              ((this.containerBackgroundProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTAINER_BACKGROUND));
          }
          get tooltipLegendOffsetX() {
            return this.tooltipLegendOffsetXProperty;
          }
          set tooltipLegendOffsetX(e) {
            this.tooltipLegendOffsetXProperty !== e &&
              ((this.tooltipLegendOffsetXProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_OFFSET_X));
          }
          get tooltipLegendOffsetY() {
            return this.tooltipLegendOffsetYProperty;
          }
          set tooltipLegendOffsetY(e) {
            this.tooltipLegendOffsetYProperty !== e &&
              ((this.tooltipLegendOffsetYProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_OFFSET_Y));
          }
          get textStroke() {
            return this.textStrokeProperty;
          }
          set textStroke(e) {
            this.textStrokeProperty !== e &&
              ((this.textStrokeProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TEXT_STROKE));
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              this.notifyPropertyChanged("PLACEMENT_DIV_ID"));
          }
          update(e, t, r, i) {
            this.isDirty &&
              ((this.isDirty = !1),
              this.svg && this.clear(),
              this.create(e, t, r, i),
              this.placementDivId
                ? this.updateExternalLegendTooltip()
                : (this.updateTooltip(r, i), this.updateLegendTooltip()));
          }
          clear() {
            this.parentSurface &&
              !this.parentSurface.isDeleted &&
              this.svg &&
              (this.placementDivId
                ? this.svgDivRoot.removeChild(this.svg)
                : this.svgRoot.removeChild(this.svg),
              this.setSvg(void 0),
              this.svgLegend &&
                (this.svgRoot.removeChild(this.svgLegend),
                (this.svgLegend = void 0)));
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e), (this.isDirty = !0);
          }
          create(e, t, r, o) {
            if (!this.tooltipSvgTemplate)
              throw Error(
                "Please provide a tooltipSvgTemplate for CursorTooltipSvgAnnotation"
              );
            const a = this.tooltipSvgTemplate(this.seriesInfo, this),
              s = this.applySvgClipping(a, this.clipping);
            if (this.placementDivId) {
              const e = i.annotationHelpers.createSvg(
                s,
                this.svgDivRoot,
                this.nextSibling
              );
              this.setSvg(e);
            } else {
              const e = i.annotationHelpers.createSvg(
                s,
                this.svgRoot,
                this.nextSibling
              );
              this.setSvg(e);
            }
          }
          updateTooltip(e, t) {
            var r, i, o, a;
            const s = null !== (r = this.xCoordShift) && void 0 !== r ? r : 0,
              n = null !== (i = this.yCoordShift) && void 0 !== i ? i : 0;
            this.svg.style.display = this.isHidden ? "none" : "block";
            const l = s + (null !== (o = this.x1) && void 0 !== o ? o : 0) + e,
              d = n + (null !== (a = this.y1) && void 0 !== a ? a : 0) + t;
            isNaN(l) || isNaN(d)
              ? (this.svg.style.display = "none")
              : (this.setSvgAttribute("x", l), this.setSvgAttribute("y", d));
          }
          updateLegendTooltip() {
            if (this.tooltipLegendTemplate) {
              const e = this.seriesInfo
                ? this.tooltipLegendTemplate(this.seriesInfo, this)
                : "<svg></svg>";
              this.svgLegend && this.svgRoot.removeChild(this.svgLegend);
              const t = this.applySvgClipping(e, this.clipping),
                r = i.annotationHelpers.createSvg(
                  t,
                  this.svgRoot,
                  this.nextSibling
                );
              (this.svgLegend = r),
                this.svgLegend.setAttribute(
                  "x",
                  this.tooltipLegendOffsetX.toString()
                ),
                this.svgLegend.setAttribute(
                  "y",
                  this.tooltipLegendOffsetY.toString()
                );
            }
          }
          updateExternalLegendTooltip() {
            if (this.tooltipLegendTemplate) {
              const e = this.seriesInfo
                ? this.tooltipLegendTemplate(this.seriesInfo, this)
                : "<svg style='display: none'></svg>";
              this.svgLegend && this.svgLegend.removeChild(this.svgLegend);
              const t = this.applySvgClipping(e, this.clipping),
                r = i.annotationHelpers.createSvg(
                  t,
                  this.svgRoot,
                  this.nextSibling
                );
              this.svgLegend = r;
            }
          }
        }
        t.TooltipSvgAnnotation3D = l;
      },
      79135: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisBase3D = t.EWhichAxis = void 0);
        const i = r(45921),
          o = r(42241),
          a = r(14184),
          s = r(86127),
          n = r(98140),
          l = r(11043),
          d = r(52578),
          h = r(48008),
          u = r(23223);
        var c;
        !(function (e) {
          (e.xAxis = "xAxis"), (e.yAxis = "yAxis"), (e.zAxis = "zAxis");
        })((c = t.EWhichAxis || (t.EWhichAxis = {})));
        class p extends o.AxisCore {
          constructor(e, t) {
            var r, o, s, n, h;
            super(t),
              (this.getlabelStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r),
                    this.notifyPropertyChanged(u.PROPERTY.TEXT_STYLE),
                    !0
                  ),
                })),
              (this.labelStyleProperty = this.getlabelStyleProxy({
                alignment: void 0,
                dpiScaling: 96,
                fontFamily: (0, d.getFontFamily)(d.DEFAULT_FONT_FAMILY, !0),
                fontSize: 14,
                color: a.SciChartSurfaceBase.DEFAULT_THEME.labelForegroundBrush,
              })),
              (this.titleStyleProperty = this.getlabelStyleProxy({
                alignment: void 0,
                dpiScaling: 96,
                fontFamily: (0, d.getFontFamily)(d.DEFAULT_FONT_FAMILY, !0),
                fontSize: 14,
                color: a.SciChartSurfaceBase.DEFAULT_THEME.labelForegroundBrush,
              })),
              (this.labelDepthTestEnabledProperty = !1),
              (this.planeBorderColorProperty =
                a.SciChartSurfaceBase.DEFAULT_THEME.planeBorderColor),
              (this.axisPlaneBackgroundFillProperty =
                a.SciChartSurfaceBase.DEFAULT_THEME.axisPlaneBackgroundFill),
              (this.isYAxisProperty = !1),
              (this.isZAxisProperty = !1),
              (this.labelStyle = this.getlabelStyleProxy(
                Object.assign(
                  Object.assign({}, this.labelStyle),
                  null == t ? void 0 : t.labelStyle
                )
              )),
              (this.titleStyle = this.getlabelStyleProxy(
                Object.assign(
                  Object.assign({}, this.titleStyle),
                  null == t ? void 0 : t.axisTitleStyle
                )
              )),
              (null == t ? void 0 : t.labelProvider) &&
                ("getLabels" in (null == t ? void 0 : t.labelProvider) ||
                  (t.labelProvider = (0, i.createType)(
                    l.EBaseType.LabelProvider,
                    t.labelProvider.type,
                    e,
                    t.labelProvider.options
                  ))),
              (this.webAssemblyContext3D = e),
              (this.isXAxisProperty = !1),
              (this.tickLabelsOffsetProperty =
                null !== (r = null == t ? void 0 : t.tickLabelsOffset) &&
                void 0 !== r
                  ? r
                  : 10),
              (this.titleOffsetProperty =
                null !== (o = null == t ? void 0 : t.titleOffset) &&
                void 0 !== o
                  ? o
                  : 50),
              (this.planeBorderColorProperty =
                null !== (s = null == t ? void 0 : t.planeBorderColor) &&
                void 0 !== s
                  ? s
                  : this.planeBorderColorProperty),
              (this.planeBorderThicknessProperty =
                null !== (n = null == t ? void 0 : t.planeBorderThickness) &&
                void 0 !== n
                  ? n
                  : 2),
              (this.axisPlaneBackgroundFillProperty =
                null !== (h = null == t ? void 0 : t.planeBackgroundFill) &&
                void 0 !== h
                  ? h
                  : this.axisPlaneBackgroundFillProperty);
          }
          get labelStyle() {
            return this.labelStyleProperty;
          }
          set labelStyle(e) {
            const t = Object.assign(Object.assign({}, this.labelStyle), e);
            (this.labelStyleProperty = this.getlabelStyleProxy(t)),
              this.notifyPropertyChanged(u.PROPERTY.TEXT_STYLE);
          }
          get titleStyle() {
            return this.titleStyleProperty;
          }
          set titleStyle(e) {
            const t = Object.assign(Object.assign({}, this.titleStyle), e);
            (this.titleStyleProperty = this.getlabelStyleProxy(t)),
              this.notifyPropertyChanged(u.PROPERTY.TEXT_STYLE);
          }
          applyTheme(e) {
            var t, r, i, o, a, s;
            const n = this.parentSurface.previousThemeProvider;
            this.axisBandsFill === n.axisBandsFill &&
              (this.axisBandsFill = e.axisBandsFill),
              (null === (t = this.majorGridLineStyle) || void 0 === t
                ? void 0
                : t.color) === n.majorGridLineBrush &&
                (this.majorGridLineStyle = { color: e.majorGridLineBrush }),
              (null === (r = this.majorTickLineStyle) || void 0 === r
                ? void 0
                : r.color) === n.majorGridLineBrush &&
                (this.majorTickLineStyle = { color: e.majorGridLineBrush }),
              (null === (i = this.minorGridLineStyle) || void 0 === i
                ? void 0
                : i.color) === n.minorGridLineBrush &&
                (this.minorGridLineStyle = { color: e.minorGridLineBrush }),
              (null === (o = this.minorTickLineStyle) || void 0 === o
                ? void 0
                : o.color) === n.minorGridLineBrush &&
                (this.minorTickLineStyle = { color: e.minorGridLineBrush }),
              (null === (a = this.axisTitleStyle) || void 0 === a
                ? void 0
                : a.color) === n.axisTitleColor &&
                (this.axisTitleStyle = { color: e.axisTitleColor }),
              this.planeBorderColor === n.planeBorderColor &&
                (this.planeBorderColor = e.planeBorderColor),
              this.axisPlaneBackgroundFill === n.axisPlaneBackgroundFill &&
                (this.axisPlaneBackgroundFill = e.axisPlaneBackgroundFill),
              (null === (s = this.labelStyle) || void 0 === s
                ? void 0
                : s.color) === n.labelForegroundBrush &&
                (this.labelStyle.color = e.labelForegroundBrush);
          }
          get isYAxis() {
            return this.isYAxisProperty;
          }
          setIsYAxis(e) {
            (this.isYAxisProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.IS_Y_AXIS);
          }
          get isZAxis() {
            return this.isZAxisProperty;
          }
          setIsZAxis(e) {
            (this.isZAxisProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.IS_Z_AXIS);
          }
          get labelDepthTestEnabled() {
            return this.labelDepthTestEnabledProperty;
          }
          set labelDepthTestEnabled(e) {
            (this.labelDepthTestEnabledProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.LABEL_DEPTH_TEST);
          }
          get planeBorderThickness() {
            return this.planeBorderThicknessProperty;
          }
          set planeBorderThickness(e) {
            (this.planeBorderThicknessProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.PLANE_BORDER_THICKNESS);
          }
          get planeBorderColor() {
            return this.planeBorderColorProperty;
          }
          set planeBorderColor(e) {
            (this.planeBorderColorProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.PLANE_BORDER_COLOR);
          }
          get tickLabelAlignment() {
            return this.tickLabelAlignmentProperty;
          }
          set tickLabelAlignment(e) {
            (this.tickLabelAlignmentProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.TICK_LABEL_ALIGNMENT);
          }
          get positiveSideClipping() {
            return this.positiveSideClippingProperty;
          }
          set positiveSideClipping(e) {
            (this.positiveSideClippingProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.POSITIVE_SIDE_CLIPPING);
          }
          get negativeSideClipping() {
            return this.negativeSideClippingProperty;
          }
          set negativeSideClipping(e) {
            (this.negativeSideClippingProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.NEGATIVE_SIDE_CLIPPING);
          }
          get axisPlaneBackgroundFill() {
            return this.axisPlaneBackgroundFillProperty;
          }
          set axisPlaneBackgroundFill(e) {
            (this.axisPlaneBackgroundFillProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.AXIS_PLANE_BACKGROUND_FILL);
          }
          get titleOffset() {
            return this.titleOffsetProperty;
          }
          set titleOffset(e) {
            (this.titleOffsetProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.TITLE_OFFSET);
          }
          get backgroundColor() {
            return this.axisPlaneBackgroundFill;
          }
          set backgroundColor(e) {
            (this.axisPlaneBackgroundFill = e),
              this.notifyPropertyChanged(u.PROPERTY.BACKGROUND_COLOR);
          }
          get tickLabelsOffset() {
            return this.tickLabelsOffsetProperty;
          }
          set tickLabelsOffset(e) {
            (this.tickLabelsOffsetProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.TICK_LABELS_OFFSET);
          }
          onAttach(e, t, r, i) {
            (this.parentSurface = e),
              this.setIsXAxis(t),
              this.setIsYAxis(r),
              this.setIsZAxis(i);
          }
          toAxisDescriptor() {
            var e, t;
            const r = "transparent",
              {
                majorTickCoords: i,
                minorTickCoords: o,
                majorTickLabels: a,
              } = this.getTickCoordsAndLabels();
            return {
              axisTitle: this.isVisible
                ? Array.isArray(this.axisTitle)
                  ? this.axisTitle.join(" ")
                  : this.axisTitle
                : "",
              axisSize: this.getAxisSize(),
              backgroundColor: (0, h.parseColorToTArgb)(
                this.axisPlaneBackgroundFill || r
              ),
              bandColor: (0, h.parseColorToTArgb)(
                this.axisBandsFill || "#202123"
              ),
              borderColor: (0, h.parseColorToTArgb)(this.planeBorderColor || r),
              borderThickness: this.planeBorderThickness,
              drawBands: this.isVisible && this.drawMajorBands,
              drawLabels: this.isVisible && this.drawLabels,
              drawMajorGridlines: this.isVisible && this.drawMajorGridLines,
              drawMajorTicks: this.isVisible && this.drawMajorTickLines,
              drawMinorGridlines: this.isVisible && this.drawMinorGridLines,
              drawMinorTicks: this.isVisible && this.drawMinorTickLines,
              isVisible: this.isVisible,
              labelDepthTestEnabled: this.labelDepthTestEnabled,
              labelStyle: {
                alignment: this.labelStyle.alignment,
                dpiScaling: this.labelStyle.dpiScaling / 96,
                fontFamily: this.labelStyle.fontFamily,
                fontSize: this.labelStyle.fontSize * s.DpiHelper.PIXEL_RATIO,
                foreground: (0, h.parseColorToUIntAbgr)(
                  null !== (e = this.labelStyle.color) && void 0 !== e
                    ? e
                    : this.parentSurface.themeProvider.labelForegroundBrush
                ),
              },
              majorCoordinates: i,
              majorLineStyle: g(this.majorGridLineStyle),
              minorLineStyle: g(this.minorGridLineStyle),
              majorTickStyle: y(this.majorTickLineStyle),
              minorTickStyle: y(this.minorTickLineStyle),
              minorCoordinates: o,
              smoothLabelOverlapAvoidance: !1,
              tickLabels: a,
              tickLabelsOffset: this.tickLabelsOffset * s.DpiHelper.PIXEL_RATIO,
              titleOffset: this.titleOffset * s.DpiHelper.PIXEL_RATIO,
              titleStyle: {
                alignment: this.titleStyle.alignment,
                dpiScaling: this.titleStyle.dpiScaling / 96,
                fontFamily: this.titleStyle.fontFamily,
                fontSize: this.titleStyle.fontSize * s.DpiHelper.PIXEL_RATIO,
                foreground: (0, h.parseColorToUIntAbgr)(
                  null !== (t = this.titleStyle.color) && void 0 !== t
                    ? t
                    : this.parentSurface.themeProvider.labelForegroundBrush
                ),
              },
            };
          }
          validateAxis() {}
          getMaximumRange() {
            var e, t, r, i, o;
            let a = new n.NumberRange(NaN, NaN);
            if (
              (null ===
                (t =
                  null === (e = this.parentSurface) || void 0 === e
                    ? void 0
                    : e.renderableSeries) || void 0 === t
                ? void 0
                : t.size()) > 0
            ) {
              let e;
              if (this.isXAxis) e = c.xAxis;
              else if (this.isYAxis) e = c.yAxis;
              else {
                if (!this.isZAxis)
                  throw Error(
                    "AxisBase3D: isXAxis, isYAxis, isZAxis flag are not set"
                  );
                e = c.zAxis;
              }
              (a =
                null !==
                  (r = this.getMaximumRangeAs(
                    this.parentSurface.renderableSeries,
                    e
                  )) && void 0 !== r
                  ? r
                  : a),
                a.isZero() && (a = this.coerceZeroVisibleRange(a)),
                (null === (i = this.growBy) || void 0 === i
                  ? void 0
                  : i.isDefined()) && (a = a.growBy(this.growBy));
            }
            const s = (
              null === (o = this.visibleRange) || void 0 === o
                ? void 0
                : o.isDefined()
            )
              ? this.visibleRange
              : this.getDefaultNonZeroRange();
            return (null == a ? void 0 : a.isDefined()) ? a : s;
          }
          getMaximumRangeAs(e, t) {
            let r;
            return (
              e.asArray().forEach((e) => {
                if (e.isVisible && e.dataSeries) {
                  const i =
                    t === c.xAxis
                      ? e.dataSeries.xRange
                      : t === c.yAxis
                      ? e.dataSeries.yRange
                      : e.dataSeries.zRange;
                  (null == i ? void 0 : i.isDefined()) &&
                    (r = r ? i.union(r) : i);
                }
              }),
              r
            );
          }
          getAxisSize() {
            if (!this.parentSurface) return 0;
            const e = this.parentSurface.worldDimensions;
            if (!e)
              throw new Error(
                "Must set property sciChart3DSurface.worldDimensions to a valid Vector3 with X,Y,Z world size"
              );
            return this.isXAxis ? e.x : this.isYAxis ? e.y : e.z;
          }
          getLabels(e) {
            return e.map((e) => this.labelProvider.formatLabel(e));
          }
          getTicks() {
            const e = this.getMaxAutoTicks();
            if (this.autoTicks) {
              const t = this.deltaCalculator.getDeltaFromRange(
                this.visibleRange.min,
                this.visibleRange.max,
                this.minorsPerMajor,
                e
              );
              (this.minorDeltaProperty = t.min),
                (this.majorDeltaProperty = t.max);
            }
            return {
              majorTicks: this.tickProvider.getMajorTicks(
                this.minorDeltaProperty,
                this.majorDeltaProperty,
                this.visibleRange
              ),
              minorTicks: this.tickProvider.getMinorTicks(
                this.minorDeltaProperty,
                this.majorDeltaProperty,
                this.visibleRange
              ),
            };
          }
          getTickCoordsAndLabels() {
            const e = this.getCurrentCoordinateCalculator(),
              t = (t) => t.map((t) => e.getCoordinate(t)),
              { majorTicks: r, minorTicks: i } = this.getTicks();
            return {
              majorTicks: r,
              majorTickLabels: this.getLabels(r),
              majorTickCoords: t(r),
              minorTicks: i,
              minorTickCoords: t(i),
            };
          }
          toJSON() {
            const e = {
              autoRange: this.autoRange,
              autoTicks: this.autoTicks,
              axisTitle: this.axisTitle,
              axisTitleStyle: this.titleStyle,
              drawLabels: this.drawLabels,
              drawMajorBands: this.drawMajorBands,
              drawMajorGridLines: this.drawMajorGridLines,
              drawMajorTickLines: this.drawMajorTickLines,
              drawMinorGridLines: this.drawMinorGridLines,
              drawMinorTickLines: this.drawMinorTickLines,
              flippedCoordinates: this.flippedCoordinates,
              growBy: this.growBy,
              id: this.id,
              isVisible: this.isVisible,
              labelStyle: this.labelStyle,
              majorGridLineStyle: this.majorGridLineStyle,
              majorTickLineStyle: this.majorTickLineStyle,
              maxAutoTicks: this.maxAutoTicks,
              minorGridLineStyle: this.minorGridLineStyle,
              minorTickLineStyle: this.minorTickLineStyle,
              visibleRange: this.hasDefaultVisibleRange()
                ? void 0
                : this.visibleRange,
              minorsPerMajor: this.minorsPerMajor,
              majorDelta: this.majorDelta,
              minorDelta: this.minorDelta,
              labelProvider: this.labelProvider.toJSON(),
            };
            return { type: this.type, options: e };
          }
        }
        t.AxisBase3D = p;
        const g = (e) => ({
            stroke: (0, h.parseColorToTArgb)(e.color),
            strokeThickness: e.strokeThickness * s.DpiHelper.PIXEL_RATIO,
            start: 1,
            end: 1,
          }),
          y = (e) => ({
            stroke: (0, h.parseColorToTArgb)(e.color),
            strokeThickness: e.strokeThickness * s.DpiHelper.PIXEL_RATIO,
            start: 0,
            end: e.tickSize * s.DpiHelper.PIXEL_RATIO,
          });
      },
      22054: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toScrtTextStyle =
            t.updateScrtLineStyle =
            t.updateScrtAxisDescriptor =
            t.AxisCubeEntity =
              void 0);
        const i = r(34116),
          o = r(11727),
          a = r(85418),
          s = r(77103);
        class n extends a.BaseSceneEntity3D {
          constructor(e, t) {
            super(e),
              (this.type = i.ESceneEntityType.AxisCubeEntity),
              (this.sciChart3DSurface = t),
              this.setNativeEntity(e.SCRTAxisCubeEntity.implement(this));
          }
          Update(e) {
            var r, i;
            if (!this.currentRenderPassData) return;
            const o = this.nativeEntity,
              a = o.GetDescriptorPtr();
            (a.m_bZxPlaneVisible = this.sciChart3DSurface.isZXPlaneVisible),
              (a.m_bXyPlaneVisible = this.sciChart3DSurface.isXYPlaneVisible),
              (a.m_bZyPlaneVisible = this.sciChart3DSurface.isZYPlaneVisible);
            const {
              sceneDescriptor: {
                axisCubeDescriptor: {
                  xAxisDescriptor: n,
                  yAxisDescriptor: l,
                  zAxisDescriptor: d,
                },
              },
            } = this.currentRenderPassData;
            ((0, s.getDescriptorsEqual)(n, this.lastXDescriptor) &&
              (0, s.getDescriptorsEqual)(l, this.lastYDescriptor) &&
              (0, s.getDescriptorsEqual)(d, this.lastZDescriptor)) ||
              o.DestroyMeshes(),
              (this.lastXDescriptor = n),
              (this.lastYDescriptor = l),
              (this.lastZDescriptor = d),
              [
                [a.GetXAxisDescPtr(), n],
                [a.GetYAxisDescPtr(), l],
                [a.GetZAxisDescPtr(), d],
              ].forEach((e) =>
                (0, t.updateScrtAxisDescriptor)(
                  this.webAssemblyContext,
                  e[0],
                  e[1]
                )
              ),
              super.Update(e),
              (null === (r = this.sciChart3DSurface) || void 0 === r
                ? void 0
                : r.isAxisCubeRendered) ||
                (null === (i = this.sciChart3DSurface) ||
                  void 0 === i ||
                  i.setIsAxisCubeRendered(),
                setTimeout(() => {
                  var e;
                  return null === (e = this.sciChart3DSurface) || void 0 === e
                    ? void 0
                    : e.invalidateElement();
                }, 0));
          }
        }
        (t.AxisCubeEntity = n),
          (t.updateScrtAxisDescriptor = (e, r, i) => {
            var a;
            (r.m_strTitle =
              null !== (a = i.axisTitle) && void 0 !== a ? a : ""),
              (r.m_fRangeSize = i.axisSize),
              (r.m_fTitleOffset = i.titleOffset),
              (r.m_fTextOffset = i.tickLabelsOffset),
              (r.m_bBandsEnabled = i.drawBands),
              (r.m_bLabelsEnabled = i.drawLabels),
              (r.m_bMajorLinesEnabled = i.drawMajorGridlines),
              (r.m_bMajorTicksEnabled = i.drawMajorTicks),
              (r.m_bMinorLinesEnabled = i.drawMinorGridlines),
              (r.m_bMinorTicksEnabled = i.drawMinorTicks),
              (r.m_fBorderThickness = i.borderThickness),
              (0, o.updateTsrVector4)(i.borderColor, r.GetBorderColorPtr()),
              (0, o.updateTsrVector4)(
                i.backgroundColor,
                r.GetBackgroundColorPtr()
              ),
              (0, o.updateTsrVector4)(i.bandColor, r.GetBandColorPtr()),
              (0, t.updateScrtLineStyle)(
                i.majorLineStyle,
                r.GetMajorLineStylePtr()
              ),
              (0, t.updateScrtLineStyle)(
                i.minorLineStyle,
                r.GetMinorLineStylePtr()
              ),
              (0, t.toScrtTextStyle)(i.labelStyle, r.GetTextStylePtr()),
              (0, t.toScrtTextStyle)(i.titleStyle, r.GetTitleTextStylePtr()),
              (0, t.updateScrtLineStyle)(
                i.majorTickStyle,
                r.GetMajorTickStylePtr()
              ),
              (0, t.updateScrtLineStyle)(
                i.minorTickStyle,
                r.GetMinorTickStylePtr()
              );
            const s = new e.FloatVector();
            i.majorCoordinates.forEach((e) => s.push_back(e)),
              r.SetMajors(s),
              s.delete();
            const n = new e.FloatVector();
            i.minorCoordinates.forEach((e) => n.push_back(e)),
              r.SetMinors(n),
              n.delete();
            const l = new e.WStringVector();
            i.tickLabels.forEach((e) => l.push_back(e)),
              r.SetMajorLabels(l),
              l.delete();
          }),
          (t.updateScrtLineStyle = (e, t) => {
            (t.m_fStrokeThickness = e.strokeThickness),
              (t.m_fStart = e.start),
              (t.m_fEnd = e.end),
              (0, o.updateTsrVector4)(e.stroke, t.GetStrokeColorPtr());
          }),
          (t.toScrtTextStyle = (e, t) => (
            (t.m_fSize = e.fontSize),
            (t.m_strFont = e.fontFamily),
            (t.m_uiARGBColor = e.foreground),
            (t.m_fDpiScaling = e.dpiScaling),
            e.alignment && t.SetAlignment(e.alignment),
            t
          ));
      },
      99441: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAxisSideClipping = void 0),
          ((r = t.EAxisSideClipping || (t.EAxisSideClipping = {})).Default =
            "Default"),
          (r.None = "None"),
          (r.VisibleRange = "VisibleRange");
      },
      69412: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ETextAlignment3D = void 0),
          ((r = t.ETextAlignment3D || (t.ETextAlignment3D = {})).Default =
            "Default"),
          (r.Camera = "Camera"),
          (r.ScreenHorizontal = "ScreenHorizontal"),
          (r.ScreenAutoRotated = "ScreenAutoRotated");
      },
      77103: (e, t) => {
        "use strict";
        function r(e, t) {
          return (
            (void 0 !== e || void 0 === t) &&
            (void 0 !== t || void 0 === e) &&
            ((void 0 === e && void 0 === t) ||
              (e.start === t.start &&
                e.end === t.end &&
                i(e.stroke, t.stroke) &&
                e.strokeThickness === t.strokeThickness))
          );
        }
        function i(e, t) {
          return (
            (void 0 !== e || void 0 === t) &&
            (void 0 !== t || void 0 === e) &&
            ((void 0 === e && void 0 === t) ||
              (e.red === t.red &&
                e.green === t.green &&
                e.blue === t.blue &&
                e.opacity === t.opacity))
          );
        }
        function o(e, t) {
          return (
            (void 0 !== e || void 0 === t) &&
            (void 0 !== t || void 0 === e) &&
            ((void 0 === e && void 0 === t) ||
              (e.alignment === t.alignment &&
                e.dpiScaling === t.dpiScaling &&
                e.fontFamily === t.fontFamily &&
                e.fontSize === t.fontSize &&
                e.foreground === t.foreground))
          );
        }
        function a(e, t) {
          if (void 0 === e && void 0 !== t) return !1;
          if (void 0 === t && void 0 !== e) return !1;
          if (void 0 === t && void 0 === e) return !0;
          if (e.length !== t.length) return !1;
          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
          return !0;
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getArraysEqual =
            t.getTextStylesEqual =
            t.getTArgbEqual =
            t.getLineStylesEqual =
            t.getDescriptorsEqual =
              void 0),
          (t.getDescriptorsEqual = function (e, t) {
            return void 0 === e
              ? void 0 === t
              : void 0 === t
              ? void 0 === e
              : e.axisTitle === t.axisTitle &&
                e.axisSize === t.axisSize &&
                i(e.backgroundColor, t.backgroundColor) &&
                i(e.bandColor, t.bandColor) &&
                i(e.borderColor, t.borderColor) &&
                a(e.majorCoordinates, t.majorCoordinates) &&
                a(e.minorCoordinates, t.minorCoordinates) &&
                a(e.tickLabels, t.tickLabels) &&
                r(e.majorLineStyle, t.majorLineStyle) &&
                r(e.minorLineStyle, t.minorLineStyle) &&
                r(e.majorTickStyle, t.majorTickStyle) &&
                r(e.minorTickStyle, t.minorTickStyle) &&
                o(e.titleStyle, t.titleStyle) &&
                o(e.labelStyle, t.labelStyle) &&
                e.drawMajorGridlines === t.drawMajorGridlines &&
                e.drawMinorGridlines === t.drawMinorGridlines &&
                e.drawMajorTicks === t.drawMajorTicks &&
                e.drawMinorTicks === t.drawMinorTicks &&
                e.drawBands === t.drawBands &&
                e.drawLabels === t.drawLabels &&
                e.isVisible === t.isVisible &&
                e.borderThickness === t.borderThickness &&
                e.labelDepthTestEnabled === t.labelDepthTestEnabled &&
                e.titleOffset === t.titleOffset &&
                e.tickLabelsOffset === t.tickLabelsOffset &&
                e.smoothLabelOverlapAvoidance === t.smoothLabelOverlapAvoidance;
          }),
          (t.getLineStylesEqual = r),
          (t.getTArgbEqual = i),
          (t.getTextStylesEqual = o),
          (t.getArraysEqual = a);
      },
      48936: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericAxis3D = void 0);
        const i = r(33166),
          o = r(40194),
          a = r(3346),
          s = r(40059),
          n = r(39920),
          l = r(10276),
          d = r(31194),
          h = r(98140),
          u = r(2192),
          c = r(79135);
        class p extends c.AxisBase3D {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.type = u.EAxisType.NumericAxis3D),
              (this.tickProvider = new a.NumericTickProvider(
                this.webAssemblyContext3D
              )),
              (this.deltaCalculator = new s.NumericDeltaCalculator(
                this.webAssemblyContext3D
              )),
              (null == t ? void 0 : t.precision) &&
                (t.labelPrecision = t.precision),
              (this.labelProvider =
                null !== (r = null == t ? void 0 : t.labelProvider) &&
                void 0 !== r
                  ? r
                  : new n.NumericLabelProvider(t));
          }
          getDefaultNonZeroRange() {
            return new h.NumberRange(0, 10);
          }
          animateVisibleRange(e, t, r = l.easing.outCubic, i = () => {}) {
            var o;
            return t <= 0
              ? ((this.visibleRange = e || this.visibleRange), void i())
              : (null === (o = this.visibleRangeAnimationToken) ||
                  void 0 === o ||
                  o.cancel(),
                (this.visibleRangeAnimationToken =
                  d.NumberRangeAnimator.animate(
                    this.visibleRange,
                    e,
                    t,
                    (e) => {
                      this.visibleRange = e;
                    },
                    () => {
                      (this.visibleRangeAnimationToken = void 0), i();
                    },
                    r
                  )),
                this.parentSurface.addAnimation(
                  this.visibleRangeAnimationToken
                ),
                this.visibleRangeAnimationToken);
          }
          getCurrentCoordinateCalculatorInternal() {
            const e = this.visibleRange.min,
              t = this.visibleRange.max,
              r = this.getAxisSize();
            return this.flippedCoordinatesProperty
              ? new o.NumericCoordinateCalculator(
                  this.webAssemblyContext3D,
                  r,
                  e,
                  t
                )
              : new i.FlippedNumericCoordinateCalculator(
                  this.webAssemblyContext3D,
                  r,
                  e,
                  t
                );
          }
        }
        t.NumericAxis3D = p;
      },
      23223: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TEXT_STYLE_PROPERTY = t.PROPERTY = void 0),
          ((i = t.PROPERTY || (t.PROPERTY = {})).AXIS_PLANE_BACKGROUND_FILL =
            "AXIS_PLANE_BACKGROUND_FILL"),
          (i.IS_Y_AXIS = "IS_Y_AXIS"),
          (i.IS_Z_AXIS = "IS_Z_AXIS"),
          (i.LABEL_DEPTH_TEST = "LABEL_DEPTH_TEST"),
          (i.NEGATIVE_SIDE_CLIPPING = "NEGATIVE_SIDE_CLIPPING"),
          (i.PLANE_BORDER_COLOR = "PLANE_BORDER_COLOR"),
          (i.PLANE_BORDER_THICKNESS = "PLANE_BORDER_THICKNESS"),
          (i.POSITIVE_SIDE_CLIPPING = "POSITIVE_SIDE_CLIPPING"),
          (i.TEXT_STYLE = "TEXT_STYLE"),
          (i.TICK_LABEL_ALIGNMENT = "TICK_LABEL_ALIGNMENT"),
          (i.TICK_LABELS_OFFSET = "TICK_LABELS_OFFSET"),
          (i.TITLE_OFFSET = "TITLE_OFFSET"),
          (i.BACKGROUND_COLOR = "BACKGROUND_COLOR"),
          ((r =
            t.TEXT_STYLE_PROPERTY || (t.TEXT_STYLE_PROPERTY = {})).ALIGNMENT =
            "ALIGNMENT"),
          (r.DPI_SCALING = "DPI_SCALING"),
          (r.FONT_FAMILY = "FONT_FAMILY"),
          (r.FONT_SIZE = "FONT_SIZE"),
          (r.FOREGROUND = "FOREGROUND");
      },
      17542: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).CAMERA_POSITION =
            "CAMERA_POSITION"),
          (r.CAMERA_TARGET = "CAMERA_TARGET"),
          (r.CAMERA_ORTHOHEIGHT = "CAMERA_ORTHOHEIGHT"),
          (r.CAMERA_ORTHOWIDTH = "CAMERA_ORTHOWIDTH"),
          (r.CAMERA_FIELDOFVIEW = "CAMERA_FIELDOFVIEW"),
          (r.CAMERA_PROJECTIONMODE = "CAMERA_PROJECTIONMODE"),
          (r.CAMERA_ISATTACHED = "CAMERA_ISATTACHED"),
          (r.CAMERA_ORBITALPITCH = "CAMERA_ORBITALPITCH"),
          (r.CAMERA_ORBITALYAW = "CAMERA_ORBITALYAW"),
          (r.CAMERA_RADIUS = "CAMERA_RADIUS"),
          (r.CAMERA_FORWARD = "CAMERA_FORWARD"),
          (r.CAMERA_SIDE = "CAMERA_SIDE"),
          (r.CAMERA_UP = "CAMERA_UP"),
          (r.CAMERA_UPGLOBAL = "CAMERA_UPGLOBAL"),
          (r.CAMERA_ASPECTRATIO = "CAMERA_ASPECTRATIO"),
          (r.CAMERA_ID = "CAMERA_ID"),
          (r.CAMERA_FARCLIP = "CAMERA_FARCLIP"),
          (r.CAMERA_NEARCLIP = "CAMERA_NEARCLIP"),
          (r.PLANE_VISIBILITY = "PLANE_VISIBILITY"),
          (r.SURFACE_CAMERA = "SURFACE_CAMERA"),
          (r.SURFACE_XAXIS = "SURFACE_XAXIS"),
          (r.SURFACE_YAXIS = "SURFACE_YAXIS"),
          (r.SURFACE_ZAXIS = "SURFACE_ZAXIS"),
          (r.SURFACE_VIEWPORT_MANAGER = "SURFACE_VIEWPORT_MANAGER"),
          (r.SURFACE_WORLD_DIMENSIONS = "SURFACE_WORLD_DIMENSIONS");
      },
      36561: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DefaultViewportManager3D = void 0);
        const i = r(61981);
        class o extends i.ViewportManager3DBase {}
        t.DefaultViewportManager3D = o;
      },
      1989: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GizmoEntity = void 0);
        const i = r(34116),
          o = r(85418);
        class a extends o.BaseSceneEntity3D {
          constructor(e) {
            super(e),
              (this.type = i.ESceneEntityType.GizmoEntity),
              this.setNativeEntity(e.SCRTXyzGizmoEntity.implement(this));
          }
          get enableGizmo() {
            return this.nativeEntity.GetOverrideEnableGizmo();
          }
          set enableGizmo(e) {
            this.nativeEntity.SetOverrideEnableGizmo(e);
          }
        }
        t.GizmoEntity = a;
      },
      49706: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseMeshPointMarker3D = void 0);
        const i = r(71906);
        class o extends i.BasePointMarker3D {
          constructor(e, t) {
            super(e, t);
          }
          get markerType() {
            return i.EMarkerType.InstancedMesh;
          }
          toJSON() {
            const e = { fill: this.fill, size: this.size };
            return { type: this.type, options: e };
          }
        }
        t.BaseMeshPointMarker3D = o;
      },
      71906: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePointMarker3D = t.EMarkerType = void 0);
        const i = r(3214),
          o = r(23866),
          a = r(50605),
          s = r(88862);
        var n;
        ((n = t.EMarkerType || (t.EMarkerType = {})).Pixel = "Pixel"),
          (n.TexturedQuad = "TexturedQuad"),
          (n.InstancedMesh = "InstancedMesh"),
          (t.BasePointMarker3D = class {
            constructor(e, t) {
              var r, a;
              (this.fillProperty = "#FF3333"),
                (this.sizeProperty = 3),
                o.Guard.notNull(e, "webAssemblyContext"),
                (this.webAssemblyContext = e),
                (this.propertyChanged = new i.EventHandler()),
                (this.fillProperty =
                  null !== (r = null == t ? void 0 : t.fill) && void 0 !== r
                    ? r
                    : this.fillProperty),
                (this.sizeProperty =
                  null !== (a = null == t ? void 0 : t.size) && void 0 !== a
                    ? a
                    : this.sizeProperty);
            }
            get fill() {
              return this.fillProperty;
            }
            set fill(e) {
              (this.fillProperty = e),
                this.notifyPropertyChanged(s.PROPERTY.FILL);
            }
            get size() {
              return this.sizeProperty;
            }
            set size(e) {
              (this.sizeProperty = e),
                this.notifyPropertyChanged(s.PROPERTY.SIZE);
            }
            notifyPropertyChanged(e) {
              var t;
              null === (t = this.propertyChanged) ||
                void 0 === t ||
                t.raiseEvent(new a.PropertyChangedEventArgs(e));
            }
            toJSON() {
              const e = { fill: this.fill, size: this.size };
              return { type: this.type, options: e };
            }
          });
      },
      29336: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseTexturePointMarker3D = void 0);
        const i = r(71906);
        class o extends i.BasePointMarker3D {
          constructor(e, t) {
            super(e, t);
          }
          get markerType() {
            return i.EMarkerType.TexturedQuad;
          }
        }
        t.BaseTexturePointMarker3D = o;
      },
      88862: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).FILL = "Fill"),
          (r.SIZE = "Size");
      },
      37622: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TrianglePointMarker3D =
            t.EllipsePointMarker3D =
            t.QuadPointMarker =
            t.PixelPointMarker3D =
            t.CylinderPointMarker3D =
            t.PyramidPointMarker3D =
            t.CubePointMarker3D =
            t.SpherePointMarker3D =
              void 0);
        const i = r(56356),
          o = r(49706),
          a = r(71906),
          s = r(29336);
        class n extends o.BaseMeshPointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Sphere);
          }
          get pointsMesh() {
            return this.webAssemblyContext.SCRTGetTemplateMesh(
              this.webAssemblyContext.eSCRTMesh.SCRT_MESH_SPHERE
            );
          }
        }
        t.SpherePointMarker3D = n;
        class l extends o.BaseMeshPointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Cube);
          }
          get pointsMesh() {
            return this.webAssemblyContext.SCRTGetTemplateMesh(
              this.webAssemblyContext.eSCRTMesh.SCRT_MESH_CUBE
            );
          }
        }
        t.CubePointMarker3D = l;
        class d extends o.BaseMeshPointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Pyramid);
          }
          get pointsMesh() {
            return this.webAssemblyContext.SCRTGetTemplateMesh(
              this.webAssemblyContext.eSCRTMesh.SCRT_MESH_PYRAMID
            );
          }
        }
        t.PyramidPointMarker3D = d;
        class h extends o.BaseMeshPointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Cylinder);
          }
          get pointsMesh() {
            return this.webAssemblyContext.SCRTGetTemplateMesh(
              this.webAssemblyContext.eSCRTMesh.SCRT_MESH_CYLINDER
            );
          }
        }
        t.CylinderPointMarker3D = h;
        class u extends a.BasePointMarker3D {
          constructor(e, t) {
            super(e, t),
              (this.type = i.EPointMarker3DType.Pixel),
              (this.size = 0);
          }
          get markerType() {
            return a.EMarkerType.Pixel;
          }
        }
        t.PixelPointMarker3D = u;
        class c extends s.BaseTexturePointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Quad);
          }
          get pointsTexture() {
            return this.webAssemblyContext.SCRTGetTemplateTexture(
              this.webAssemblyContext.eSCRTTexture.SCRT_TEXTURE_SOLIDWHITE
            );
          }
        }
        t.QuadPointMarker = c;
        class p extends s.BaseTexturePointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Ellipse);
          }
          get pointsTexture() {
            return this.webAssemblyContext.SCRTGetTemplateTexture(
              this.webAssemblyContext.eSCRTTexture.SCRT_TEXTURE_CIRCLE
            );
          }
        }
        t.EllipsePointMarker3D = p;
        class g extends s.BaseTexturePointMarker3D {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarker3DType.Triangle);
          }
          get pointsTexture() {
            return this.webAssemblyContext.SCRTGetTemplateTexture(
              this.webAssemblyContext.eSCRTTexture.SCRT_TEXTURE_TRIANGLE
            );
          }
        }
        t.TrianglePointMarker3D = g;
      },
      33517: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisCubeDescriptor = void 0),
          (t.AxisCubeDescriptor = class {});
      },
      85418: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseSceneEntity3D = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(23866),
          s = r(37796),
          n = r(34116),
          l = r(73538);
        class d extends i.DeletableEntity {
          constructor(e) {
            super(),
              (this.id = (0, l.generateGuid)()),
              (this.isVisible = !0),
              (this.entityIdProperty = void 0),
              (this.isDeletedProperty = !1),
              a.Guard.notNull(e, "webAssemblyContext"),
              (this.webAssemblyContext = e),
              (this.detachChild = this.detachChild.bind(this)),
              (this.attachChild = this.attachChild.bind(this)),
              (this.children = new s.ObservableArray()),
              this.children.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach(this.detachChild),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach(this.attachChild);
              }),
              (this.onDpiChanged = this.onDpiChanged.bind(this));
          }
          get entityIdProvider() {
            return this.entityIdProviderProperty;
          }
          set entityIdProvider(e) {
            (this.entityIdProviderProperty = e),
              !this.entityId &&
                this.entityIdProviderProperty &&
                (this.entityId =
                  this.entityIdProviderProperty.getNextEntityId()),
              this.visitEntities((t) => {
                t !== this && (t.entityIdProvider = e);
              });
          }
          get entityId() {
            return this.entityIdProperty;
          }
          set entityId(e) {
            var t;
            (this.entityIdProperty = e),
              null === (t = this.nativeEntityProperty) ||
                void 0 === t ||
                t.SetEntityId(e),
              this.invalidateScene();
          }
          getRoot() {
            if (this.type === n.ESceneEntityType.RootSceneEntity) return this;
            let e = this.parent;
            for (; void 0 !== e; ) {
              if (e.type === n.ESceneEntityType.RootSceneEntity) return e;
              e = e.parent;
            }
          }
          delete() {
            var e;
            (this.isDeletedProperty = !0),
              this.children
                .asArray()
                .forEach((e) => !e.isDeletedProperty && e.delete()),
              null === (e = this.entityIdProvider) ||
                void 0 === e ||
                e.releaseEntityId(this.entityId),
              this.nativeEntity &&
                this.world &&
                this.world.RemoveEntity(this.nativeEntity),
              (this.nativeEntityProperty = (0, o.deleteSafe)(
                this.nativeEntityProperty
              )),
              (this.webAssemblyContext = void 0);
          }
          Update(e) {
            if (this.currentRenderPassData) {
              if (!this.nativeEntity)
                throw new Error(
                  "BaseSceneEntity.nativeSceneEntity must be set by calling setEntity() in the constructor"
                );
              this.isVisible && this.nativeEntity.Update(e);
            }
          }
          Render() {
            if (this.currentRenderPassData) {
              if (!this.nativeEntity)
                throw new Error(
                  "BaseSceneEntity.nativeSceneEntity must be set by calling setEntity() in the constructor"
                );
              this.isVisible && this.nativeEntity.Render();
            }
          }
          onEngineRestart() {}
          onDpiChanged(e) {}
          setRenderPassData(e) {
            this.currentRenderPassData = e;
          }
          getEntity(e) {
            for (let t = 0; t < this.children.size(); t++) {
              const r = this.children.get(t);
              if (r.type === e) return r;
            }
          }
          invalidateScene() {
            var e, t;
            null ===
              (t =
                null === (e = this.rootSceneEntity) || void 0 === e
                  ? void 0
                  : e.parentSurface) ||
              void 0 === t ||
              t.invalidateElement();
          }
          onAttached() {
            this.parent.type, n.ESceneEntityType.SCRTSceneEntity;
          }
          onDetached() {}
          visitEntities(e) {
            e(this),
              this.children.asArray().forEach((t) => {
                t.visitEntities(e);
              });
          }
          get nativeEntity() {
            return this.nativeEntityProperty;
          }
          attachChild(e) {
            var t;
            null === (t = this.nativeEntity) ||
              void 0 === t ||
              t.AddChildEntityInternal(e.nativeEntity),
              (e.parent = this),
              (e.entityIdProvider = this.entityIdProvider),
              e.onAttached();
          }
          detachChild(e) {
            var t;
            null === (t = this.nativeEntity) ||
              void 0 === t ||
              t.RemoveChildEntityInternal(e.nativeEntity),
              e.onDetached(),
              (e.parent = void 0);
          }
          setNativeEntity(e) {
            var t;
            (this.nativeEntityProperty = e),
              this.entityId &&
                (null === (t = this.nativeEntityProperty) ||
                  void 0 === t ||
                  t.SetEntityId(this.entityId));
          }
          get world() {
            var e, t;
            return null ===
              (t =
                null === (e = this.getRoot()) || void 0 === e
                  ? void 0
                  : e.parentSurface) || void 0 === t
              ? void 0
              : t.getSceneWorld();
          }
        }
        t.BaseSceneEntity3D = d;
      },
      84501: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnSceneEntity = void 0);
        const i = r(56744),
          o = r(34116),
          a = r(48008),
          s = r(23291),
          n = r(60063),
          l = r(61325),
          d = r(75816);
        class h extends l.RenderableSeriesSceneEntity {
          constructor(e, t) {
            super(e, t, new d.RenderableSeriesSceneEntityState()),
              (this.type = o.ESceneEntityType.ColumnSceneEntity),
              this.setNativeEntity(e.SCRTColumnsSceneEntity.implement(this));
          }
          delete() {
            (this.instanceColors = (0, i.deleteSafe)(this.instanceColors)),
              (this.instanceScales = (0, i.deleteSafe)(this.instanceScales)),
              super.delete();
          }
          Render() {
            super.Render();
          }
          notifySeriesPropertyChanged(e) {
            e === n.PROPERTY.POINT_MARKER3D ||
            e === n.PROPERTY.USE_METADATA_COLORS ||
            e === n.PROPERTY.FILL
              ? this.updateSeries()
              : e === n.PROPERTY.OPACITY
              ? this.nativeEntity.SetOpacity(this.parentSeries.opacity)
              : (e !== n.PROPERTY.DATA_POINT_WIDTH_X &&
                  e !== n.PROPERTY.DATA_POINT_WIDTH_Z) ||
                this.updateSeries(),
              super.notifySeriesPropertyChanged(e);
          }
          hitTest(e) {
            return super.hitTestXyz(e);
          }
          updateSeries() {
            const e = this.parentSeries.dataSeries;
            if (!e || !this.currentRenderPassData) return;
            if (e.type !== s.EDataSeriesType3D.Xyz3D)
              throw new Error(
                "DataSeries type for a ColumnRenderableSeries3D must be XyzDataSeries3D"
              );
            const t = this.parentSeries.pointMarker;
            if (!t)
              throw new Error(
                "To render 3D Columns you must provider a PointMarker on BaseRenderableSeries3D"
              );
            this.parentSeries.fill && (t.fill = this.parentSeries.fill),
              this.nativeEntity.SetInstanceSize(
                this.parentSeries.getDataPointWidth(
                  this.currentRenderPassData,
                  this.parentSeries.dataPointWidthX,
                  this.parentSeries.dataPointWidthZ
                )
              ),
              this.nativeEntity.SetInstanceMesh(t.pointsMesh);
            const r = (0, a.parseColorToUIntArgb)(t.fill);
            this.nativeEntity.SetColor(r);
            const o = e.getNativeXValues(),
              n = e.getNativeYValues(),
              l = e.getNativeZValues(),
              d = e.getMetadataValues(),
              h = e.count(),
              { colors: u, scales: c } = this.rebuildPointMetadata(d, h, r);
            let p;
            try {
              (p = new this.webAssemblyContext.SCRTColumnsSceneEntityParams()),
                (p.m_bUseDefaultColors = !this.parentSeries.useMetadataColors),
                (p.m_bUseDefaultScale = !1),
                p.SetCoordinateCalculators(
                  this.currentRenderPassData.xCalc.nativeCalculator,
                  this.currentRenderPassData.yCalc.nativeCalculator,
                  this.currentRenderPassData.zCalc.nativeCalculator
                ),
                this.nativeEntity.UpdateMeshesVec(o, n, l, c, u, p),
                this.nativeEntity.SetOpacity(this.parentSeries.opacity);
            } finally {
              (0, i.deleteSafe)(p);
            }
          }
          rebuildPointMetadata(e, t, r) {
            return (
              this.instanceColors ||
                (this.instanceColors =
                  new this.webAssemblyContext.UIntVector()),
              this.instanceScales ||
                (this.instanceScales =
                  new this.webAssemblyContext.FloatVector()),
              this.instanceColors.resize(t, r),
              this.instanceScales.resize(t, 1),
              e.forEach((e, t) => {
                if (e) {
                  const r = e.vertexColor;
                  r && this.instanceColors.set(t, r),
                    e.pointScale && this.instanceScales.set(t, e.pointScale);
                }
              }),
              { colors: this.instanceColors, scales: this.instanceScales }
            );
          }
        }
        t.ColumnSceneEntity = h;
      },
      26079: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CrosshairLinesSceneEntity = void 0);
        const i = r(56744),
          o = r(34116),
          a = r(48008),
          s = r(16110),
          n = r(85418);
        class l extends n.BaseSceneEntity3D {
          constructor(e) {
            super(e),
              (this.type = o.ESceneEntityType.Custom),
              (this.strokeThickness = 2),
              (this.stroke = "#FF6600"),
              (this.antiAliased = !0),
              this.setNativeEntity(e.SCRTSceneEntity.implement(this));
          }
          delete() {
            super.delete(),
              (this.linesMesh = (0, i.deleteSafe)(this.linesMesh));
          }
          Render() {
            if (
              !(
                this.isVisible &&
                this.worldDimensions &&
                this.cameraPosition &&
                this.location
              )
            )
              return;
            const e = this.getWallVector();
            this.linesMesh = (0, i.deleteSafe)(this.linesMesh);
            const t = new this.webAssemblyContext.SCRTLinesMesh(
              this.strokeThickness,
              !1,
              this.antiAliased
            );
            t.SetVertexColor((0, a.parseColorToUIntArgb)(this.stroke)),
              this.inInWorldDimensions(
                this.location.x,
                this.location.y,
                0,
                this.worldDimensions
              ) &&
                (t.SetVertex3(
                  this.location.x,
                  this.location.y,
                  this.location.z
                ),
                t.SetVertex3(this.location.x, this.location.y, e.z)),
              this.inInWorldDimensions(
                this.location.x,
                0,
                this.location.z,
                this.worldDimensions
              ) &&
                (t.SetVertex3(
                  this.location.x,
                  this.location.y,
                  this.location.z
                ),
                t.SetVertex3(this.location.x, e.y, this.location.z)),
              this.inInWorldDimensions(
                0,
                this.location.y,
                0,
                this.worldDimensions
              ) &&
                (t.SetVertex3(
                  this.location.x,
                  this.location.y,
                  this.location.z
                ),
                t.SetVertex3(e.x, this.location.y, this.location.z)),
              t.Freeze(),
              t.Render();
          }
          inInWorldDimensions(e, t, r, i) {
            return (
              t >= 0 &&
              t <= i.y &&
              r >= -i.z / 2 &&
              r <= i.z / 2 &&
              e >= -i.x / 2 &&
              e <= i.x / 2
            );
          }
          getWallVector() {
            const e =
                this.cameraPosition.dotProduct(new s.Vector3(1, 0, 0)) > 0
                  ? 0.5 * -this.worldDimensions.x
                  : 0.5 * this.worldDimensions.x,
              t =
                this.cameraPosition.dotProduct(new s.Vector3(0, 1, 0)) > 0
                  ? 0
                  : this.worldDimensions.y,
              r =
                this.cameraPosition.dotProduct(new s.Vector3(0, 0, 1)) > 0
                  ? 0.5 * -this.worldDimensions.z
                  : 0.5 * this.worldDimensions.z;
            return new s.Vector3(e, t, r);
          }
        }
        t.CrosshairLinesSceneEntity = l;
      },
      21240: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DefaultEntityIdProvider = void 0),
          (t.DefaultEntityIdProvider = class {
            constructor() {
              (this.currentId = -1), (this.maxId = 4294967295);
            }
            getNextEntityId() {
              const e = ++this.currentId;
              if (e >= this.maxId)
                throw new Error(
                  "The max Mesh ID has been exceeded.  Please see https://www.scichart.com/questions/wpf/maximum-mesh-id"
                );
              return e;
            }
            releaseEntityId(e) {}
          });
      },
      54005: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PointLine3DSceneEntity = void 0);
        const i = r(56744),
          o = r(34116),
          a = r(48008),
          s = r(23291),
          n = r(60063),
          l = r(71906),
          d = r(61325),
          h = r(75816);
        class u extends d.RenderableSeriesSceneEntity {
          constructor(e, t) {
            super(e, t, new h.RenderableSeriesSceneEntityState()),
              (this.type = o.ESceneEntityType.PointLine3DSceneEntity),
              this.setNativeEntity(
                e.SCRTPointLine3DSceneEntity.implement(this)
              );
          }
          delete() {
            (this.pointColors = (0, i.deleteSafe)(this.pointColors)),
              (this.pointScales = (0, i.deleteSafe)(this.pointScales)),
              super.delete();
          }
          Render() {
            this.nativeEntity.SetOpacity(this.parentSeries.opacity),
              super.Render();
          }
          notifySeriesPropertyChanged(e) {
            e === n.PROPERTY.STROKE_THICKNESS &&
              this.nativeEntity.SetLineStrokeThickness(
                this.parentSeries.strokeThickness
              ),
              e === n.PROPERTY.STROKE &&
                this.nativeEntity.SetStrokeColor(
                  (0, a.parseColorToUIntArgb)(this.parentSeries.stroke)
                ),
              e === n.PROPERTY.POINT_MARKER3D && this.updateSeries(),
              super.notifySeriesPropertyChanged(e);
          }
          hitTest(e) {
            return super.hitTestXyz(e);
          }
          updateSeries() {
            const e = this.parentSeries.dataSeries;
            if (!e || !this.currentRenderPassData) return;
            if (e.type !== s.EDataSeriesType3D.Xyz3D)
              throw new Error(
                "DataSeries type for a PointLineRenderableSeries3D must be XyzDataSeries3D"
              );
            const t = (0, a.parseColorToUIntArgb)(this.parentSeries.stroke);
            this.nativeEntity.SetLineStrokeThickness(
              this.parentSeries.strokeThickness
            ),
              this.nativeEntity.SetIsLineStrips(this.parentSeries.isLineStrip),
              this.nativeEntity.SetIsLineAntialiased(
                this.parentSeries.isAntiAliased
              ),
              this.nativeEntity.SetStrokeColor(t),
              this.updatePointMarker(this.parentSeries.pointMarker);
            const r = e.getNativeXValues(),
              o = e.getNativeYValues(),
              n = e.getNativeZValues(),
              l = e.getMetadataValues(),
              d = e.count(),
              {
                lineColors: h,
                pointColors: u,
                scales: c,
                hasDefaultColors: p,
                hasDefaultScales: g,
              } = this.rebuildPointMetadata(l, d, t);
            let y;
            try {
              (y =
                new this.webAssemblyContext.SCRTPointLines3DSceneEntityParams()),
                (y.useDefaultColors = p),
                (y.useDefaultScale = g),
                y.SetCoordinateCalculators(
                  this.currentRenderPassData.xCalc.nativeCalculator,
                  this.currentRenderPassData.yCalc.nativeCalculator,
                  this.currentRenderPassData.zCalc.nativeCalculator
                ),
                this.nativeEntity.UpdateMeshesVec(r, o, n, u, h, c, y);
            } finally {
              (0, i.deleteSafe)(y);
            }
          }
          updatePointMarker(e) {
            const t = this.webAssemblyContext.eSCRT_POINT_MARKER_TYPE;
            if (void 0 === e || e.markerType === l.EMarkerType.Pixel)
              this.nativeEntity.SetPointMarkerType(
                t.SCRT_POINT_MARKER_TYPE_PIXEL
              ),
                this.nativeEntity.SetPointSize(0);
            else if (e.markerType === l.EMarkerType.InstancedMesh) {
              const r = e;
              if (!r.pointsMesh)
                throw new Error(
                  "Expected a BaseMeshPointMarker3D.pointsMesh on 3D pointmarker of type InstancedMesh"
                );
              this.nativeEntity.SetPointMarkerType(
                t.SCRT_POINT_MARKER_TYPE_INSTANCED_MESH
              ),
                this.nativeEntity.SetPointSize(e.size),
                this.nativeEntity.SetPointMarkerMesh(r.pointsMesh);
            } else {
              if (e.markerType !== l.EMarkerType.TexturedQuad)
                throw new Error(
                  "PointLine3DSceneEntity: Unknown pointMarker.markerType " +
                    e.markerType
                );
              {
                const r = e;
                if (!r.pointsTexture)
                  throw new Error(
                    "Expected a BaseTexturePointMarker3D.pointsTexture on 3D pointmarker of type TexturedQuad"
                  );
                this.nativeEntity.SetPointMarkerType(
                  t.SCRT_POINT_MARKER_TYPE_TEXTURED_QUAD
                ),
                  this.nativeEntity.SetPointSize(e.size),
                  this.nativeEntity.SetPointMarkerTexture(r.pointsTexture);
              }
            }
          }
          rebuildPointMetadata(e, t, r) {
            this.pointColors ||
              (this.pointColors = new this.webAssemblyContext.UIntVector()),
              this.pointScales ||
                (this.pointScales = new this.webAssemblyContext.FloatVector()),
              this.pointColors.resize(t, r),
              this.pointScales.resize(t, 1);
            let i = !0,
              o = !0;
            return (
              e.forEach((e, t) => {
                var r;
                if (e) {
                  const a =
                    null !== (r = e.vertexColorAbgr) && void 0 !== r
                      ? r
                      : e.vertexColor;
                  a && ((o = !1), this.pointColors.set(t, a)),
                    e.pointScale &&
                      ((i = !1), this.pointScales.set(t, e.pointScale));
                }
              }),
              {
                lineColors: this.pointColors,
                pointColors: this.pointColors,
                scales: this.pointScales,
                hasDefaultScales: i,
                hasDefaultColors: o,
              }
            );
          }
        }
        t.PointLine3DSceneEntity = u;
      },
      72476: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderPassInfo3D = void 0),
          (t.RenderPassInfo3D = class {});
      },
      61325: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderableSeriesSceneEntity = void 0);
        const i = r(56172),
          o = r(85418);
        class a extends o.BaseSceneEntity3D {
          constructor(e, t, r) {
            super(e),
              (this.parentSeries = t),
              (this.state = r),
              this.state.setInitialState(),
              (this.hitTest = this.hitTest.bind(this));
          }
          Update(e) {
            this.currentRenderPassData &&
              (this.state.validate(
                this.parentSeries,
                this.currentRenderPassData
              ) ||
                (this.updateSeries(),
                this.state.reset(
                  this.parentSeries,
                  this.currentRenderPassData
                )),
              super.Update(e));
          }
          onEngineRestart() {
            super.onEngineRestart(), this.state.setInitialState();
          }
          notifySeriesPropertyChanged(e) {
            this.state.setRenderableSeriesPropertyChanged();
          }
          hitTestXyz(e) {
            var t;
            const r = Math.round(e.x),
              o = Math.round(e.y),
              a = this.webAssemblyContext.SCRTGetSelectionInfo(r, o),
              s = new i.HitTestInfo3D(this.parentSeries, !1);
            return (
              (s.isHit =
                a.m_uiSelectionIndex > 0 &&
                (null === (t = a.GetEntity()) || void 0 === t
                  ? void 0
                  : t.GetEntityId()) === this.entityId),
              (s.selectionIndex = s.isHit ? a.m_uiSelectionIndex : -1),
              (s.hitTestPoint = e),
              s
            );
          }
        }
        t.RenderableSeriesSceneEntity = a;
      },
      75816: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderableSeriesSceneEntityState = void 0),
          (t.RenderableSeriesSceneEntityState = class {
            constructor(
              e = !0,
              t = !0,
              r = !0,
              i = !0,
              o = {
                xVisibleMin: 0,
                xVisibleMax: 0,
                yVisibleMin: 0,
                yVisibleMax: 0,
                zVisibleMin: 0,
                zVisibleMax: 0,
                xWorldDimension: 0,
                yWorldDimension: 0,
                zWorldDimension: 0,
              }
            ) {
              (this.isInitialStateProperty = e),
                (this.isDataSeriesModifiedProperty = t),
                (this.isRenderableSeriesPropertyChangedProperty = r),
                (this.isAxisCubeStateChangedProperty = i),
                (this.axisCubeState = o);
            }
            get isInitialState() {
              return this.isInitialStateProperty;
            }
            setInitialState() {
              this.isInitialStateProperty = !0;
            }
            get isDataSeriesModified() {
              return this.isDataSeriesModifiedProperty;
            }
            get isRenderableSeriesPropertyChanged() {
              return this.isRenderableSeriesPropertyChangedProperty;
            }
            setRenderableSeriesPropertyChanged() {
              this.isRenderableSeriesPropertyChangedProperty = !0;
            }
            get isAxisCubeStateChanged() {
              return this.isAxisCubeStateChangedProperty;
            }
            validate(e, t) {
              this.isDataSeriesModifiedProperty = e.dataSeries.isModified;
              const r = 0.001;
              return (
                (this.isAxisCubeStateChangedProperty =
                  Math.abs(
                    this.axisCubeState.xVisibleMin - t.xCalc.visibleMin
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.xVisibleMax - t.xCalc.visibleMax
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.yVisibleMin - t.yCalc.visibleMin
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.yVisibleMax - t.yCalc.visibleMax
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.zVisibleMin - t.zCalc.visibleMin
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.zVisibleMax - t.zCalc.visibleMax
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.xWorldDimension - t.worldDimensions.x
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.yWorldDimension - t.worldDimensions.y
                  ) > r ||
                  Math.abs(
                    this.axisCubeState.zWorldDimension - t.worldDimensions.z
                  ) > r),
                !(
                  this.isInitialState ||
                  this.isDataSeriesModified ||
                  this.isDataSeriesModified ||
                  this.isAxisCubeStateChanged
                )
              );
            }
            reset(e, t) {
              (this.isInitialStateProperty = !1),
                (this.isDataSeriesModifiedProperty = !1),
                (this.isRenderableSeriesPropertyChangedProperty = !1),
                (this.isAxisCubeStateChangedProperty = !1),
                (this.axisCubeState = {
                  xVisibleMin: t.xCalc.visibleMin,
                  xVisibleMax: t.xCalc.visibleMax,
                  yVisibleMin: t.yCalc.visibleMin,
                  yVisibleMax: t.yCalc.visibleMax,
                  zVisibleMin: t.zCalc.visibleMin,
                  zVisibleMax: t.zCalc.visibleMax,
                  xWorldDimension: t.worldDimensions.x,
                  yWorldDimension: t.worldDimensions.y,
                  zWorldDimension: t.worldDimensions.z,
                }),
                e.dataSeries.resetModified();
            }
          });
      },
      77162: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ScatterPointsSceneEntity = void 0);
        const i = r(56744),
          o = r(34116),
          a = r(48008),
          s = r(23291),
          n = r(71906),
          l = r(60063),
          d = r(61325),
          h = r(75816);
        class u extends d.RenderableSeriesSceneEntity {
          constructor(e, t) {
            super(e, t, new h.RenderableSeriesSceneEntityState()),
              (this.type = o.ESceneEntityType.ScatterPointsSceneEntity),
              this.setNativeEntity(e.SCRTPoint3DSceneEntity.implement(this));
          }
          delete() {
            (this.pointColors = (0, i.deleteSafe)(this.pointColors)),
              (this.pointScales = (0, i.deleteSafe)(this.pointScales)),
              super.delete();
          }
          Render() {
            this.nativeEntity.SetOpacity(this.parentSeries.opacity),
              super.Render();
          }
          notifySeriesPropertyChanged(e) {
            e === l.PROPERTY.POINT_MARKER3D && this.updateSeries(),
              super.notifySeriesPropertyChanged(e);
          }
          hitTest(e) {
            return super.hitTestXyz(e);
          }
          updateSeries() {
            const e = this.parentSeries.dataSeries;
            if (!e || !this.currentRenderPassData) return;
            if (e.type !== s.EDataSeriesType3D.Xyz3D)
              throw new Error(
                "DataSeries type for a ScatterRenderableSeries3D must be XyzDataSeries3D"
              );
            const t = this.parentSeries.pointMarker;
            if (!t)
              throw new Error(
                "To render 3D Scatter, bubble or point-clouds, you must provider a PointMarker on BaseRenderableSeries3D"
              );
            const r = this.webAssemblyContext.eSCRT_POINT_MARKER_TYPE,
              o = (0, a.parseColorToUIntArgb)(t.fill);
            switch (t.markerType) {
              case n.EMarkerType.Pixel:
                this.nativeEntity.SetPointMarkerType(
                  r.SCRT_POINT_MARKER_TYPE_PIXEL
                ),
                  this.nativeEntity.SetPointSize(0),
                  this.nativeEntity.SetPointColor(o);
                break;
              case n.EMarkerType.TexturedQuad:
                const e = t;
                if (!e.pointsTexture)
                  throw new Error(
                    "Expected a BaseTexturePointMarker3D.pointsTexture on 3D pointmarker of type TexturedQuad"
                  );
                this.nativeEntity.SetPointMarkerType(
                  r.SCRT_POINT_MARKER_TYPE_TEXTURED_QUAD
                ),
                  this.nativeEntity.SetPointSize(t.size),
                  this.nativeEntity.SetPointColor(o),
                  this.nativeEntity.SetPointMarkerTexture(e.pointsTexture);
                break;
              case n.EMarkerType.InstancedMesh:
                const i = t;
                if (!i.pointsMesh)
                  throw new Error(
                    "Expected a BaseMeshPointMarker3D.pointsMesh on 3D pointmarker of type InstancedMesh"
                  );
                this.nativeEntity.SetPointMarkerType(
                  r.SCRT_POINT_MARKER_TYPE_INSTANCED_MESH
                ),
                  this.nativeEntity.SetPointSize(t.size),
                  this.nativeEntity.SetPointColor(o),
                  this.nativeEntity.SetPointMarkerMesh(i.pointsMesh);
                break;
              default:
                throw new Error(
                  "Unknown pointMarker.markerType " + t.markerType
                );
            }
            const l = e.getNativeXValues(),
              d = e.getNativeYValues(),
              h = e.getNativeZValues(),
              u = e.getMetadataValues(),
              c = e.count(),
              { colors: p, scales: g } = this.rebuildPointMetadata(u, c, o);
            let y;
            try {
              (y = new this.webAssemblyContext.SCRTPoint3DSceneEntityParams()),
                (y.useDefaultColors = !1),
                (y.useDefaultScale = !1),
                y.SetCoordinateCalculators(
                  this.currentRenderPassData.xCalc.nativeCalculator,
                  this.currentRenderPassData.yCalc.nativeCalculator,
                  this.currentRenderPassData.zCalc.nativeCalculator
                ),
                this.nativeEntity.UpdateMeshesVec(l, d, h, p, g, y);
            } finally {
              (0, i.deleteSafe)(y);
            }
          }
          rebuildPointMetadata(e, t, r) {
            return (
              this.pointColors ||
                (this.pointColors = new this.webAssemblyContext.UIntVector()),
              this.pointScales ||
                (this.pointScales = new this.webAssemblyContext.FloatVector()),
              this.pointColors.resize(t, r),
              this.pointScales.resize(t, 1),
              e.forEach((e, t) => {
                var r;
                if (e) {
                  const i =
                    null !== (r = e.vertexColorAbgr) && void 0 !== r
                      ? r
                      : e.vertexColor;
                  i && this.pointColors.set(t, i),
                    e.pointScale && this.pointScales.set(t, e.pointScale);
                }
              }),
              { colors: this.pointColors, scales: this.pointScales }
            );
          }
        }
        t.ScatterPointsSceneEntity = u;
      },
      41859: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SceneDescriptor = void 0),
          (t.SceneDescriptor = class {});
      },
      98694: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SurfaceMeshSceneEntity = t.SurfaceMeshSceneEntityState = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(75772),
          n = r(34116),
          l = r(48008),
          d = r(11727),
          h = r(23291),
          u = r(60063),
          c = r(56172),
          p = r(10435),
          g = r(61325),
          y = r(75816);
        var f;
        !(function (e) {
          (e[(e.SCRT_GRID_DRAWING_FEATURES_SOLID = 1)] =
            "SCRT_GRID_DRAWING_FEATURES_SOLID"),
            (e[(e.SCRT_GRID_DRAWING_FEATURES_WIREFRAME = 2)] =
              "SCRT_GRID_DRAWING_FEATURES_WIREFRAME"),
            (e[(e.SCRT_GRID_DRAWING_FEATURES_CONTOURS = 4)] =
              "SCRT_GRID_DRAWING_FEATURES_CONTOURS"),
            (e[(e.SCRT_GRID_DRAWING_FEATURES_SKIRT = 8)] =
              "SCRT_GRID_DRAWING_FEATURES_SKIRT");
        })(f || (f = {}));
        class v extends y.RenderableSeriesSceneEntityState {
          get isColorMapTextureInvalid() {
            return this.isColorMapTextureInvalidProperty;
          }
          setColorMapTextureInvalid() {
            this.isColorMapTextureInvalidProperty = !0;
          }
          validate(e, t) {
            return super.validate(e, t) && this.isColorMapTextureInvalid;
          }
          reset(e, t) {
            super.reset(e, t), (this.isColorMapTextureInvalidProperty = !1);
          }
        }
        t.SurfaceMeshSceneEntityState = v;
        class m extends g.RenderableSeriesSceneEntity {
          constructor(e, t) {
            var r;
            super(e, t, new v()),
              (this.type = n.ESceneEntityType.SurfaceMeshSceneEntity),
              this.setNativeEntity(e.SCRTGridMeshEntity.implement(this)),
              (this.colorMapTexture = (0, i.deleteSafe)(this.colorMapTexture)),
              (this.colorMapTexture =
                null === (r = this.parentSeries.meshColorPalette) ||
                void 0 === r
                  ? void 0
                  : r.getTexture(this.parentSeries.colorMapTextureSize));
          }
          notifySeriesPropertyChanged(e) {
            (e !== u.PROPERTY.MESH_COLOR_PALETTE &&
              e !== u.PROPERTY.MESH_PALETTE_MODE &&
              e !== u.PROPERTY.MESH_RESOLUTION &&
              e !== u.PROPERTY.COLOR_MAP_TEXTURE_SIZE) ||
              this.state.setColorMapTextureInvalid(),
              super.notifySeriesPropertyChanged(e);
          }
          delete() {
            super.delete(),
              (this.colorMapTexture = (0, i.deleteSafe)(this.colorMapTexture));
          }
          hitTest(e) {
            var t;
            const r = Math.round(e.x),
              i = Math.round(e.y),
              o = this.webAssemblyContext.SCRTGetSelectionInfo(r, i),
              a = new c.HitTestInfo3D(this.parentSeries, !1);
            return (
              (a.isHit =
                (null === (t = o.GetEntity()) || void 0 === t
                  ? void 0
                  : t.GetEntityId()) === this.entityId),
              (a.selectionIjIndices = a.isHit
                ? new s.Point(o.m_uiHeightMapIndexI, o.m_uiHeightMapIndexJ)
                : void 0),
              (a.hitTestPoint = e),
              a
            );
          }
          Render() {
            if (!this.currentRenderPassData) return;
            if (!this.colorMapTexture || !this.parentSeries.dataSeries)
              return void console.log(
                "Cannot draw a SurfaceMeshRenderableSeries3D without a meshColorPalette or dataSeries!"
              );
            let e;
            this.nativeEntity.SetOpacity(this.parentSeries.opacity);
            try {
              e = new this.webAssemblyContext.SCRTGridDrawingProperties();
              let t = 0;
              this.hasFlag(this.parentSeries.drawMeshAs, [
                p.EDrawMeshAs.SOLID_WIREFRAME,
                p.EDrawMeshAs.SOLID_WIREFRAME,
                p.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS,
              ]) && (t |= f.SCRT_GRID_DRAWING_FEATURES_WIREFRAME),
                this.hasFlag(this.parentSeries.drawMeshAs, [
                  p.EDrawMeshAs.SOLID_WIREFRAME,
                  p.EDrawMeshAs.SOLID_MESH,
                  p.EDrawMeshAs.SOLID_WITH_CONTOURS,
                  p.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS,
                ]) && (t |= f.SCRT_GRID_DRAWING_FEATURES_SOLID),
                this.hasFlag(this.parentSeries.drawMeshAs, [
                  p.EDrawMeshAs.CONTOURS,
                  p.EDrawMeshAs.SOLID_WITH_CONTOURS,
                  p.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS,
                ]) && (t |= f.SCRT_GRID_DRAWING_FEATURES_CONTOURS),
                this.parentSeries.drawSkirt &&
                  (t |= f.SCRT_GRID_DRAWING_FEATURES_SKIRT);
              const r = this.hasFlag(this.parentSeries.meshPaletteMode, [
                  p.EMeshPaletteMode.HEIGHT_MAP_INTERPOLATED,
                  p.EMeshPaletteMode.HEIGHT_MAP_SOLID_CELLS,
                ]),
                i = this.hasFlag(this.parentSeries.meshPaletteMode, [
                  p.EMeshPaletteMode.HEIGHT_MAP_SOLID_CELLS,
                  p.EMeshPaletteMode.TEXTURED_SOLID_CELLS,
                ]);
              if (
                (e.SetDrawMeshAsInteger(t),
                (e.m_bUseGradient = r),
                (e.m_bUseSolidCells = i),
                (e.m_fStrokeThickness = this.parentSeries.strokeThickness),
                (e.m_fContourThickness =
                  this.parentSeries.contourStrokeThickness),
                (e.m_fContourInterval = this.parentSeries.contourInterval),
                (e.m_fContourOffset = this.parentSeries.contourOffset),
                this.parentSeries.stroke)
              ) {
                const t = (0, l.parseColorToTArgb)(this.parentSeries.stroke);
                (0, d.updateTsrVector4)(t, e.GetWireframeStrokePtr());
              }
              this.parentSeries.contourStroke &&
                (0, d.updateTsrVector4)(
                  (0, l.parseColorToTArgb)(this.parentSeries.contourStroke),
                  e.GetContourColorPtr()
                ),
                (e.m_fHardNormals = this.parentSeries.cellHardnessFactor),
                (e.m_fHighlight = this.parentSeries.highlight),
                (e.m_fShininess = this.parentSeries.shininess),
                (e.m_fLightingAmount = this.parentSeries.lightingFactor),
                this.nativeEntity.SetGridDrawingProperties(e);
            } finally {
              (0, i.deleteSafe)(e);
            }
            const t = this.currentRenderPassData.xCalc,
              r = this.currentRenderPassData.yCalc,
              o = this.currentRenderPassData.zCalc;
            let s, n, h, u, c, g;
            try {
              const e = new a.NumberRange(
                this.parentSeries.minimum,
                this.parentSeries.maximum
              );
              (s = this.rangeToSCRTAxisRange(
                this.webAssemblyContext,
                t,
                this.parentSeries.dataSeries.xRange
              )),
                (n = this.rangeToSCRTAxisRange(this.webAssemblyContext, r, e)),
                (h = this.rangeToSCRTAxisRange(
                  this.webAssemblyContext,
                  o,
                  this.parentSeries.dataSeries.zRange
                )),
                this.nativeEntity.SetMeshRange(s, n, h),
                (u = this.toSCRTAxisRange(
                  this.webAssemblyContext,
                  t,
                  t.visibleMin,
                  t.visibleMax
                )),
                (c = this.toSCRTAxisRange(
                  this.webAssemblyContext,
                  r,
                  r.visibleMin,
                  r.visibleMax
                )),
                (g = this.toSCRTAxisRange(
                  this.webAssemblyContext,
                  o,
                  o.visibleMin,
                  o.visibleMax
                )),
                this.nativeEntity.SetVisibleRange(u, c, g);
            } finally {
              (0, i.deleteSafe)(s),
                (0, i.deleteSafe)(n),
                (0, i.deleteSafe)(h),
                (0, i.deleteSafe)(u),
                (0, i.deleteSafe)(c),
                (0, i.deleteSafe)(g);
            }
            const y = this.parentSeries.yOffset
              ? r.getCoordinate(this.parentSeries.yOffset)
              : 0;
            this.nativeEntity.SetHeightmapScaleOffset(
              this.parentSeries.heightScaleFactor,
              y
            ),
              this.nativeEntity.SetTexture(this.colorMapTexture.getTexture()),
              super.Render();
          }
          updateSeries() {
            var e;
            const t = this.parentSeries.dataSeries;
            if (t) {
              o.Guard.isTrue(
                t.type === h.EDataSeriesType3D.UniformGrid3D ||
                  t.type === h.EDataSeriesType3D.NonUniformGrid3D,
                "SurfaceMeshSceneEntity dataSeries must be type UniformGrid3D or NonUniformGrid3D"
              );
              const r = t.xSize,
                a = t.zSize;
              o.Guard.notNull(
                this.currentRenderPassData,
                "SurfaceMeshSceneEntity.currentRenderPassData"
              ),
                this.state.isColorMapTextureInvalid &&
                  ((this.colorMapTexture = (0, i.deleteSafe)(
                    this.colorMapTexture
                  )),
                  (this.colorMapTexture =
                    null === (e = this.parentSeries.meshColorPalette) ||
                    void 0 === e
                      ? void 0
                      : e.getTexture(this.parentSeries.colorMapTextureSize)));
              const s = this.state.isInitialState,
                n = this.state.isDataSeriesModified;
              if (s) {
                let e;
                switch (this.parentSeries.meshResolution) {
                  case p.EMeshResolution.MESH_RESOLUTION_X1:
                    e =
                      this.webAssemblyContext.eSCRTGridMeshResolution
                        .SCRT_GRID_MESH_RES_X1;
                    break;
                  case p.EMeshResolution.MESH_RESOLUTION_X2:
                    e =
                      this.webAssemblyContext.eSCRTGridMeshResolution
                        .SCRT_GRID_MESH_RES_X2;
                    break;
                  case p.EMeshResolution.MESH_RESOLUTION_X4:
                    e =
                      this.webAssemblyContext.eSCRTGridMeshResolution
                        .SCRT_GRID_MESH_RES_X4;
                    break;
                  default:
                    throw Error(
                      "Unknown SurfaceMeshSceneEntity.meshResolution " +
                        this.parentSeries.meshResolution
                    );
                }
                const t = new this.webAssemblyContext.FloatVector(),
                  o = new this.webAssemblyContext.FloatVector(),
                  s = new this.webAssemblyContext.UIntVector();
                t.resize(r * a, 0),
                  o.resize(r * a, 0),
                  s.resize(r * a, 0),
                  this.nativeEntity.UpdateMeshesVec(t, o, s, r, a, e),
                  (0, i.deleteSafe)(t),
                  (0, i.deleteSafe)(o),
                  (0, i.deleteSafe)(s);
              }
              if (n) {
                const e = new this.webAssemblyContext.FloatVector(),
                  o = r * a;
                e.reserve(o);
                const s = this.currentRenderPassData.yCalc;
                for (let r = 0; r < t.zSize; r++)
                  for (let i = 0; i < t.xSize; i++)
                    e.push_back(s.getCoordinate(t.getYValue(r, i)));
                this.nativeEntity.UpdateHeightCoordinatesVec(e, r, a),
                  (0, i.deleteSafe)(e);
              }
            }
          }
          hasFlag(e, t) {
            return t.some((t) => t === e);
          }
          toSCRTAxisRange(e, t, r, i) {
            const o = new e.SCRTAxisRange();
            return (
              (o.m_fMin = t ? t.getCoordinate(r) : r),
              (o.m_fMax = t ? t.getCoordinate(i) : i),
              (o.m_fDiff = t ? t.getCoordinate(i - r) : i - r),
              o
            );
          }
          rangeToSCRTAxisRange(e, t, r) {
            return this.toSCRTAxisRange(e, t, r.min, r.max);
          }
        }
        t.SurfaceMeshSceneEntity = m;
      },
      83653: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseRenderableSeries3D = void 0);
        const i = r(45921),
          o = r(55023),
          a = r(56744),
          s = r(11043),
          n = r(73538),
          l = r(23291),
          d = r(60063),
          h = r(45265),
          u = r(94574),
          c = r(80995),
          p = r(19221);
        class g extends o.DeletableEntity {
          constructor(e, t) {
            var r, o, a;
            super(),
              (this.id =
                null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                  ? r
                  : (0, n.generateGuid)()),
              (this.webAssemblyContext = e),
              (this.dataSeriesDataChanged =
                this.dataSeriesDataChanged.bind(this)),
              (this.pointMarkerPropertyChanged =
                this.pointMarkerPropertyChanged.bind(this)),
              (this.onDpiChanged = this.onDpiChanged.bind(this)),
              (this.hitTest = this.hitTest.bind(this)),
              (this.enrichHitTest = this.enrichHitTest.bind(this)),
              (this.dataSeries = (null == t ? void 0 : t.dataSeries) || void 0),
              (this.isVisibleProperty =
                void 0 === (null == t ? void 0 : t.isVisible) ||
                (null == t ? void 0 : t.isVisible)),
              (null == t ? void 0 : t.pointMarker) &&
                "options" in t.pointMarker &&
                (t.pointMarker = (0, i.createType)(
                  s.EBaseType.PointMarker3D,
                  t.pointMarker.type,
                  e,
                  t.pointMarker.options
                )),
              (this.pointMarkerProperty =
                null !== (o = null == t ? void 0 : t.pointMarker) &&
                void 0 !== o
                  ? o
                  : this.pointMarkerProperty),
              (this.strokeProperty =
                (null == t ? void 0 : t.stroke) || "#FFFFFF"),
              (this.shininessProperty =
                void 0 === (null == t ? void 0 : t.shininess)
                  ? 64
                  : t.shininess),
              (this.opacityProperty =
                null !== (a = null == t ? void 0 : t.opacity) && void 0 !== a
                  ? a
                  : 1);
          }
          applyTheme(e) {}
          get opacity() {
            return this.opacityProperty;
          }
          set opacity(e) {
            (this.opacityProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.OPACITY);
          }
          get sceneEntity() {
            return this.sceneEntityProperty;
          }
          get shininess() {
            return this.shininessProperty;
          }
          set shininess(e) {
            (this.shininessProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.SHININESS);
          }
          get paletteProvider() {
            return this.paletteProviderProperty;
          }
          set paletteProvider(e) {
            (this.paletteProviderProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.PALETTE_PROVIDER);
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.STROKE);
          }
          get dataSeries() {
            return this.dataSeriesProperty;
          }
          set dataSeries(e) {
            var t, r;
            (this.dataSeriesProperty = e),
              null === (t = this.dataSeriesProperty) ||
                void 0 === t ||
                t.dataChanged.unsubscribe(this.dataSeriesDataChanged),
              (this.dataSeriesProperty = e),
              null === (r = this.dataSeriesProperty) ||
                void 0 === r ||
                r.dataChanged.subscribe(this.dataSeriesDataChanged),
              this.notifyPropertyChanged(d.PROPERTY.DATA_SERIES);
          }
          get pointMarker() {
            return this.pointMarkerProperty;
          }
          set pointMarker(e) {
            this.detachPointMarker(this.pointMarkerProperty),
              (this.pointMarkerProperty = e),
              this.attachPointMarker(this.pointMarkerProperty),
              this.notifyPropertyChanged(d.PROPERTY.POINT_MARKER3D);
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          set parentSurface(e) {
            (this.parentSurfaceProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.PARENT_SURFACE);
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            (this.isVisibleProperty = e),
              this.sceneEntityProperty &&
                (this.sceneEntityProperty.isVisible = this.isVisibleProperty),
              this.notifyPropertyChanged(d.PROPERTY.IS_VISIBLE);
          }
          onAttach(e) {
            if (((this.parentSurface = e), this.invalidateParentCallback))
              throw new Error(
                "Invalid operation in sciChart3DSurface.attachSeries, this series has already been attached to a SciChart3DSurface. Please detach it from a SciChart3DSurface before attaching to another"
              );
            this.invalidateParentCallback = e.invalidateElement;
          }
          onDetach() {
            (this.invalidateParentCallback = void 0),
              (this.parentSurface = void 0);
          }
          delete() {
            (this.sceneEntityProperty = (0, a.deleteSafe)(
              this.sceneEntityProperty
            )),
              (this.dataSeries = (0, a.deleteSafe)(this.dataSeries));
          }
          onDpiChanged(e) {
            var t;
            null === (t = this.sceneEntityProperty) ||
              void 0 === t ||
              t.onDpiChanged(e);
          }
          hitTest(e) {
            if (this.parentSurface && !this.parentSurface.isHitTestEnabled)
              throw new Error(
                "Enable hit-test functions by setting SciChart3DSurface.isHitTestEnabled = true"
              );
            const t = this.sceneEntity.hitTest;
            return t ? this.enrichHitTest(t(e)) : u.SeriesInfo3D.empty();
          }
          dataSeriesDataChanged() {
            this.invalidateParentCallback && this.invalidateParentCallback();
          }
          enrichHitTest(e) {
            var t;
            const r =
              null === (t = e.associatedSeries) || void 0 === t
                ? void 0
                : t.dataSeries;
            if (!r) return u.SeriesInfo3D.empty();
            switch (r.type) {
              case l.EDataSeriesType3D.Xyz3D:
                return new p.XyzSeriesInfo3D(this, e);
              case l.EDataSeriesType3D.UniformGrid3D:
                return new c.SurfaceMeshSeriesInfo3D(this, e);
              default:
                throw new Error("Unknown data series type " + r.type);
            }
          }
          setSceneEntity(e) {
            (this.sceneEntityProperty = e),
              this.sceneEntityProperty &&
                (this.sceneEntityProperty.isVisible = this.isVisible),
              this.notifyPropertyChanged(d.PROPERTY.SCENE_ENTITY);
          }
          notifyPropertyChanged(e) {
            var t;
            null === (t = this.sceneEntityProperty) ||
              void 0 === t ||
              t.notifySeriesPropertyChanged(e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          attachPointMarker(e) {
            e && e.propertyChanged.subscribe(this.pointMarkerPropertyChanged);
          }
          detachPointMarker(e) {
            e && e.propertyChanged.unsubscribe(this.pointMarkerPropertyChanged);
          }
          pointMarkerPropertyChanged(e) {
            this.notifyPropertyChanged("pointMarker." + e.propertyName);
          }
          toJSON(e = !1) {
            var t;
            const r = this.getOptions(),
              i =
                null === (t = this.dataSeries) || void 0 === t
                  ? void 0
                  : t.toJSON(e),
              o = null == i ? void 0 : i.options;
            return this.type === h.ESeriesType3D.PointLineRenderableSeries3D ||
              this.type === h.ESeriesType3D.ScatterRenderableSeries3D ||
              this.type === h.ESeriesType3D.ColumnRenderableSeries3D
              ? { type: this.type, options: r, xyzData: o }
              : this.type === h.ESeriesType3D.SurfaceMeshRenderableSeries3D
              ? { type: this.type, options: r, uniformGridData: o }
              : { type: this.type, options: r };
          }
          getOptions() {
            var e;
            return {
              id: this.id,
              isVisible: this.isVisible,
              opacity: this.opacity,
              pointMarker:
                null === (e = this.pointMarker) || void 0 === e
                  ? void 0
                  : e.toJSON(),
              stroke: this.stroke,
              shininess: this.shininess,
            };
          }
        }
        t.BaseRenderableSeries3D = g;
      },
      56675: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnRenderableSeries3D = void 0);
        const i = r(37622),
          o = r(84501),
          a = r(83653),
          s = r(60063),
          n = r(45265);
        class l extends a.BaseRenderableSeries3D {
          constructor(e, t) {
            var r, a, s, l;
            super(e, t),
              (this.type = n.ESeriesType3D.ColumnRenderableSeries3D),
              (this.dataPointWidthXProperty = 1),
              (this.dataPointWidthZProperty = 1),
              (this.useMetadataColorsProperty = !1),
              (this.fillProperty = "#FF3333"),
              (this.dataPointWidthXProperty =
                null !== (r = null == t ? void 0 : t.dataPointWidthX) &&
                void 0 !== r
                  ? r
                  : this.dataPointWidthXProperty),
              (this.dataPointWidthZProperty =
                null !== (a = null == t ? void 0 : t.dataPointWidthZ) &&
                void 0 !== a
                  ? a
                  : this.dataPointWidthZProperty),
              (this.useMetadataColors =
                null !== (s = null == t ? void 0 : t.useMetadataColors) &&
                void 0 !== s
                  ? s
                  : this.useMetadataColors),
              (this.fillProperty =
                null !== (l = null == t ? void 0 : t.fill) && void 0 !== l
                  ? l
                  : this.fill),
              (null == t ? void 0 : t.pointMarker) ||
                (this.pointMarkerProperty = new i.CubePointMarker3D(e, {
                  fill: this.fill,
                })),
              this.setSceneEntity(new o.ColumnSceneEntity(e, this));
          }
          get pointMarker() {
            return this.pointMarkerProperty;
          }
          set pointMarker(e) {
            this.detachPointMarker(this.pointMarkerProperty),
              (this.pointMarkerProperty = e),
              this.attachPointMarker(this.pointMarkerProperty),
              this.notifyPropertyChanged(s.PROPERTY.POINT_MARKER3D);
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL);
          }
          get dataPointWidthX() {
            return this.dataPointWidthXProperty;
          }
          set dataPointWidthX(e) {
            (this.dataPointWidthXProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.DATA_POINT_WIDTH_X);
          }
          get dataPointWidthZ() {
            return this.dataPointWidthZProperty;
          }
          set dataPointWidthZ(e) {
            (this.dataPointWidthZProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.DATA_POINT_WIDTH_Z);
          }
          get useMetadataColors() {
            return this.useMetadataColorsProperty;
          }
          set useMetadataColors(e) {
            (this.useMetadataColorsProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.USE_METADATA_COLORS);
          }
          getDataPointWidth(e, t, r) {
            if (!e) return 0;
            const i = Math.abs(
                e.xCalc.getCoordinate(0) - e.xCalc.getCoordinate(t)
              ),
              o = Math.abs(e.zCalc.getCoordinate(0) - e.zCalc.getCoordinate(r));
            return Math.min(i, o);
          }
          getOptions() {
            const e = super.getOptions(),
              t = {
                pointMarker: this.pointMarker,
                dataPointWidthX: this.dataPointWidthX,
                dataPointWidthZ: this.dataPointWidthZ,
                useMetadataColors: this.useMetadataColors,
                fill: this.fill,
              };
            return Object.assign(e, t);
          }
        }
        t.ColumnRenderableSeries3D = l;
      },
      60063: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).CELL_HARDNESS_FACTOR =
            "CELL_HARDNESS_FACTOR"),
          (r.COLOR_MAP_TEXTURE_SIZE = "COLOR_MAP_TEXTURE_SIZE"),
          (r.CONTOUR_STROKE = "CONTOUR_STROKE"),
          (r.CONTOUR_OFFSET = "CONTOUR_OFFSET"),
          (r.CONTOUR_INTERVAL = "CONTOUR_INTERVAL"),
          (r.CONTOUR_STROKE_THICKNESS = "CONTOUR_STROKE_THICKNESS"),
          (r.DATA_POINT_WIDTH_X = "DATA_POINT_WIDTH_X"),
          (r.DATA_POINT_WIDTH_Z = "DATA_POINT_WIDTH_Z"),
          (r.DATA_SERIES = "DATA_SERIES"),
          (r.DRAW_MESH_AS = "DRAW_MESH_AS"),
          (r.DRAW_SKIRT = "DRAW_SKIRT"),
          (r.FILL = "FILL"),
          (r.GRADIENT_STOPS = "GRADIENT_STOPS"),
          (r.HEIGHT_SCALE_FACTOR = "HEIGHT_SCALE_FACTOR"),
          (r.HIGHLIGHT = "HIGHLIGHT"),
          (r.IS_ANTIALIASED = "IS_ANTIALIASED"),
          (r.IS_LINE_STRIP = "IS_LINE_STRIP"),
          (r.IS_VISIBLE = "IS_VISIBLE"),
          (r.LIGHTING_FACTOR = "LIGHTING_FACTOR"),
          (r.MAXIMUM = "MAXIMUM"),
          (r.MESH_COLOR_PALETTE = "MESH_COLOR_PALETTE"),
          (r.MESH_PALETTE_MODE = "MESH_PALETTE_MODE"),
          (r.MESH_RESOLUTION = "MESH_RESOLUTION"),
          (r.MINIMUM = "MINIMUM"),
          (r.OPACITY = "OPACITY"),
          (r.PALETTE_PROVIDER = "PALETTE_PROVIDER"),
          (r.PARENT_SURFACE = "PARENT_SURFACE"),
          (r.POINT_MARKER3D = "POINT_MARKER3D"),
          (r.SCENE_ENTITY = "SCENE_ENTITY"),
          (r.SHININESS = "SHININESS"),
          (r.STROKE = "STROKE"),
          (r.STROKE_THICKNESS = "STROKE_THICKNESS"),
          (r.USE_METADATA_COLORS = "USE_METADATA_COLORS"),
          (r.Y_OFFSET = "Y_OFFSET");
      },
      45265: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ESeriesType3D = void 0),
          ((r =
            t.ESeriesType3D ||
            (t.ESeriesType3D = {})).ScatterRenderableSeries3D =
            "ScatterRenderableSeries3D"),
          (r.SurfaceMeshRenderableSeries3D = "SurfaceMeshRenderableSeries3D"),
          (r.PointLineRenderableSeries3D = "PointLineRenderableSeries3D"),
          (r.ColumnRenderableSeries3D = "ColumnRenderableSeries3D");
      },
      56172: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HitTestInfo3D = void 0);
        class r {
          constructor(e, t = !1) {
            (this.isEmpty = t), (this.associatedSeries = e);
          }
          static empty() {
            return new r(void 0, !0);
          }
        }
        t.HitTestInfo3D = r;
      },
      39927: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PointLineRenderableSeries3D = void 0);
        const i = r(54005),
          o = r(83653),
          a = r(60063),
          s = r(45265);
        class n extends o.BaseRenderableSeries3D {
          constructor(e, t) {
            var r, o, a;
            super(e, t),
              (this.type = s.ESeriesType3D.PointLineRenderableSeries3D),
              (this.strokeThicknessProperty =
                null !== (r = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== r
                  ? r
                  : 2),
              (this.isLineStripProperty =
                null === (o = null == t ? void 0 : t.isLineStrip) ||
                void 0 === o ||
                o),
              (this.isAntiAliasedProperty =
                null === (a = null == t ? void 0 : t.isAntiAliased) ||
                void 0 === a ||
                a),
              this.setSceneEntity(new i.PointLine3DSceneEntity(e, this));
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.STROKE_THICKNESS);
          }
          get isLineStrip() {
            return this.isLineStripProperty;
          }
          set isLineStrip(e) {
            (this.isLineStripProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.IS_LINE_STRIP);
          }
          get isAntiAliased() {
            return this.isAntiAliasedProperty;
          }
          set isAntiAliased(e) {
            (this.isAntiAliasedProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.IS_ANTIALIASED);
          }
          getOptions() {
            const e = super.getOptions(),
              t = {
                strokeThickness: this.strokeThickness,
                isLineStrip: this.isLineStrip,
                isAntiAliased: this.isAntiAliased,
              };
            return Object.assign(e, t);
          }
        }
        t.PointLineRenderableSeries3D = n;
      },
      72954: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ScatterRenderableSeries3D = void 0);
        const i = r(77162),
          o = r(83653),
          a = r(45265);
        class s extends o.BaseRenderableSeries3D {
          constructor(e, t) {
            super(e, t),
              (this.type = a.ESeriesType3D.ScatterRenderableSeries3D),
              this.setSceneEntity(new i.ScatterPointsSceneEntity(e, this));
          }
        }
        t.ScatterRenderableSeries3D = s;
      },
      94574: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesInfo3D = void 0);
        class r {
          constructor(e, t) {
            var r;
            (this.isEmpty = !1),
              (this.renderableSeries = e),
              (this.dataSeriesName =
                null === (r = null == e ? void 0 : e.dataSeries) || void 0 === r
                  ? void 0
                  : r.dataSeriesName),
              (this.isHit = t.isHit),
              (this.hitTestInfo = t);
          }
          static empty() {
            const e = new r(void 0, void 0);
            return (e.isEmpty = !0), e;
          }
        }
        t.SeriesInfo3D = r;
      },
      80995: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SurfaceMeshSeriesInfo3D = void 0);
        const i = r(21670),
          o = r(23291),
          a = r(16110),
          s = r(94574);
        class n extends s.SeriesInfo3D {
          constructor(e, t) {
            super(e, t),
              (this.dataSeriesType = o.EDataSeriesType3D.UniformGrid3D),
              this.enrichSeriesInfo();
          }
          enrichSeriesInfo() {
            if (!this.isHit || !this.renderableSeries) return;
            const e = this.renderableSeries.dataSeries;
            if (!e) return;
            const t = {
                x: this.hitTestInfo.selectionIjIndices.x,
                z: this.hitTestInfo.selectionIjIndices.y,
              },
              r = { x: e.getX(t.x), y: e.getYValue(t.z, t.x), z: e.getZ(t.z) },
              o = {
                x: e.getX(t.x + 1),
                y: e.getYValue(t.z, t.x + 1),
                z: e.getZ(t.z),
              },
              s = {
                x: e.getX(t.x),
                y: e.getYValue(t.z + 1, t.x),
                z: e.getZ(t.z + 1),
              },
              n = {
                x: e.getX(t.x + 1),
                y: e.getYValue(t.z + 1, t.x + 1),
                z: e.getZ(t.z + 1),
              },
              l = this.renderableSeries.parentSurface;
            if (!(l && l.xAxis && l.yAxis && l.zAxis)) return;
            const d = l.xAxis.getCurrentCoordinateCalculator(),
              h = l.yAxis.getCurrentCoordinateCalculator(),
              u = l.zAxis.getCurrentCoordinateCalculator(),
              c = new a.Vector3(
                d.getCoordinate(r.x),
                h.getCoordinate(r.y),
                u.getCoordinate(r.z)
              ),
              p = new a.Vector3(
                d.getCoordinate(o.x),
                h.getCoordinate(o.y),
                u.getCoordinate(o.z)
              ),
              g = new a.Vector3(
                d.getCoordinate(s.x),
                h.getCoordinate(s.y),
                u.getCoordinate(s.z)
              ),
              y = new a.Vector3(
                d.getCoordinate(n.x),
                h.getCoordinate(n.y),
                u.getCoordinate(n.z)
              ),
              f = l.worldToScreenCoord(c),
              v = l.worldToScreenCoord(p),
              m = l.worldToScreenCoord(g),
              S = l.worldToScreenCoord(y),
              P = (0, i.calcDistance)(
                f.x,
                f.y,
                this.hitTestInfo.hitTestPoint.x,
                this.hitTestInfo.hitTestPoint.y
              ),
              C = (0, i.calcDistance)(
                v.x,
                v.y,
                this.hitTestInfo.hitTestPoint.x,
                this.hitTestInfo.hitTestPoint.y
              ),
              b = (0, i.calcDistance)(
                m.x,
                m.y,
                this.hitTestInfo.hitTestPoint.x,
                this.hitTestInfo.hitTestPoint.y
              ),
              x = (0, i.calcDistance)(
                S.x,
                S.y,
                this.hitTestInfo.hitTestPoint.x,
                this.hitTestInfo.hitTestPoint.y
              ),
              A = 0.5 * l.worldDimensions.x,
              T = 0.5 * l.worldDimensions.z,
              E = Math.min(P, C, b, x);
            E === P &&
              ((this.xIndex = t.x),
              (this.zIndex = t.z),
              (this.xValue = r.x),
              (this.yValue = r.y),
              (this.zValue = r.z),
              (this.hitWorldCoords = new a.Vector3(c.x - A, c.y, c.z - T))),
              E === b &&
                ((this.xIndex = t.x),
                (this.zIndex = t.z + 1),
                (this.xValue = s.x),
                (this.yValue = s.y),
                (this.zValue = s.z),
                (this.hitWorldCoords = new a.Vector3(g.x - A, g.y, g.z - T))),
              E === C &&
                ((this.xIndex = t.x + 1),
                (this.zIndex = t.z),
                (this.xValue = o.x),
                (this.yValue = o.y),
                (this.zValue = o.z),
                (this.hitWorldCoords = new a.Vector3(p.x - A, p.y, p.z - T))),
              E === x &&
                ((this.xIndex = t.x + 1),
                (this.zIndex = t.z + 1),
                (this.xValue = n.x),
                (this.yValue = n.y),
                (this.zValue = n.z),
                (this.hitWorldCoords = new a.Vector3(y.x - A, y.y, y.z - T)));
          }
        }
        t.SurfaceMeshSeriesInfo3D = n;
      },
      28009: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GradientColorPalette = void 0);
        const i = r(35992),
          o = r(84745),
          a = r(23866),
          s = r(28436),
          n = r(60063),
          l = r(46294);
        class d extends l.MeshColorPalette {
          constructor(e, t) {
            super(e),
              (this.type = s.EPaletteProviderType.Gradient3D),
              (this.gradientStops = (null == t ? void 0 : t.gradientStops) || [
                { offset: 0, color: "Red" },
                { offset: 1, color: "Green" },
              ]);
          }
          get gradientStops() {
            return this.gradientStopsProperty;
          }
          set gradientStops(e) {
            (this.gradientStopsProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.GRADIENT_STOPS);
          }
          getTexture(e) {
            if (o.IS_TEST_ENV) return;
            a.Guard.notNull(e, "size"),
              a.Guard.isTrue(e.width > 0, "size.width must be greater than 0"),
              a.Guard.isTrue(
                e.height > 0,
                "size.height must be greater than 0"
              ),
              a.Guard.notNull(
                this.gradientStopsProperty,
                "GradientColorPalette.gradientStops"
              );
            const t = new i.CanvasTexture(
              this.webAssemblyContext,
              e.width,
              e.height
            );
            t.clear();
            const r = t.getContext(),
              s = e.width,
              n = r.createLinearGradient(0, 0, s, 0);
            return (
              this.gradientStops.forEach((e) => {
                n.addColorStop(e.offset, e.color);
              }),
              (r.fillStyle = n),
              r.fillRect(0, 0, e.width, e.height),
              t.copyTexture(),
              t
            );
          }
          getOptions() {
            return { gradientStops: this.gradientStops };
          }
        }
        t.GradientColorPalette = d;
      },
      46294: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MeshColorPalette = void 0);
        const i = r(3214),
          o = r(50605);
        t.MeshColorPalette = class {
          constructor(e) {
            (this.webAssemblyContext = e),
              (this.propertyChanged = new i.EventHandler());
          }
          notifyPropertyChanged(e) {
            var t;
            null === (t = this.propertyChanged) ||
              void 0 === t ||
              t.raiseEvent(new o.PropertyChangedEventArgs(e));
          }
          toJSON() {
            return { type: this.type, options: this.getOptions() };
          }
        };
      },
      25889: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SolidColorBrushPalette = void 0);
        const i = r(35992),
          o = r(84745),
          a = r(23866),
          s = r(28436),
          n = r(48008),
          l = r(60063),
          d = r(46294);
        class h extends d.MeshColorPalette {
          constructor(e, t) {
            super(e),
              (this.type = s.EPaletteProviderType.Solid3D),
              (this.fillProperty = (null == t ? void 0 : t.fill) || "#777777");
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.FILL);
          }
          getTexture(e) {
            if (
              (a.Guard.notNull(e, "size"),
              a.Guard.isTrue(e.width > 0, "size.width must be greater than 0"),
              a.Guard.isTrue(
                e.height > 0,
                "size.height must be greater than 0"
              ),
              o.IS_TEST_ENV)
            )
              return;
            const t = (0, n.parseColorToUIntArgb)(this.fill);
            if (isNaN(t))
              throw Error(
                `SolidColorBrushPalette.fill ${this.fill} cannot be converted to an ABGR color`
              );
            const r = new i.CanvasTexture(
              this.webAssemblyContext,
              e.width,
              e.height
            );
            r.clear();
            const s = r.getContext();
            return (
              (s.fillStyle = this.fill),
              s.fillRect(0, 0, e.width, e.height),
              r.copyTexture(),
              r
            );
          }
          getOptions() {
            return { fill: this.fill };
          }
        }
        t.SolidColorBrushPalette = h;
      },
      10435: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SurfaceMeshRenderableSeries3D =
            t.EMeshResolution =
            t.EMeshPaletteMode =
            t.EDrawMeshAs =
              void 0);
        const i = r(45921),
          o = r(11043),
          a = r(22022),
          s = r(98694),
          n = r(83653),
          l = r(60063),
          d = r(45265);
        var h, u, c;
        !(function (e) {
          (e.WIREFRAME = "WIREFRAME"),
            (e.SOLID_WIREFRAME = "SOLID_WIREFRAME"),
            (e.SOLID_WIREFRAME_WITH_CONTOURS = "SOLID_WIREFRAME_WITH_CONTOURS"),
            (e.SOLID_MESH = "SOLID_MESH"),
            (e.SOLID_WITH_CONTOURS = "SOLID_WITH_CONTOURS"),
            (e.CONTOURS = "CONTOURS");
        })((h = t.EDrawMeshAs || (t.EDrawMeshAs = {}))),
          (function (e) {
            (e.HEIGHT_MAP_INTERPOLATED = "HEIGHT_MAP_INTERPOLATED"),
              (e.HEIGHT_MAP_SOLID_CELLS = "HEIGHT_MAP_SOLID_CELLS"),
              (e.TEXTURED_SOLID_CELLS = "TEXTURED_SOLID_CELLS");
          })((u = t.EMeshPaletteMode || (t.EMeshPaletteMode = {}))),
          (function (e) {
            (e[(e.MESH_RESOLUTION_X1 = 1)] = "MESH_RESOLUTION_X1"),
              (e[(e.MESH_RESOLUTION_X2 = 2)] = "MESH_RESOLUTION_X2"),
              (e[(e.MESH_RESOLUTION_X4 = 4)] = "MESH_RESOLUTION_X4");
          })((c = t.EMeshResolution || (t.EMeshResolution = {})));
        class p extends n.BaseRenderableSeries3D {
          constructor(e, t) {
            super(e, t),
              (this.drawMeshAsProperty =
                (null == t ? void 0 : t.drawMeshAs) || h.SOLID_WIREFRAME),
              (this.strokeThicknessProperty =
                void 0 !== (null == t ? void 0 : t.strokeThickness)
                  ? null == t
                    ? void 0
                    : t.strokeThickness
                  : 1),
              (this.drawSkirtProperty =
                void 0 === (null == t ? void 0 : t.drawSkirt) ||
                (null == t ? void 0 : t.drawSkirt)),
              (this.minimumProperty =
                void 0 !== (null == t ? void 0 : t.minimum)
                  ? null == t
                    ? void 0
                    : t.minimum
                  : 0),
              (this.maximumProperty =
                void 0 !== (null == t ? void 0 : t.maximum)
                  ? null == t
                    ? void 0
                    : t.maximum
                  : 1),
              (this.meshPaletteModeProperty =
                (null == t ? void 0 : t.meshPaletteMode) ||
                u.HEIGHT_MAP_INTERPOLATED),
              (this.colorMapTextureSizeProperty =
                (null == t ? void 0 : t.colorMapTextureSize) ||
                new a.Size(1024, 1)),
              (this.heightScaleFactorProperty =
                void 0 !== (null == t ? void 0 : t.heightScaleFactor)
                  ? null == t
                    ? void 0
                    : t.heightScaleFactor
                  : 1),
              (this.meshResolutionProperty =
                (null == t ? void 0 : t.meshResolution) ||
                c.MESH_RESOLUTION_X1),
              (this.yOffsetProperty =
                void 0 !== (null == t ? void 0 : t.yOffset)
                  ? null == t
                    ? void 0
                    : t.yOffset
                  : 0),
              (this.cellHardnessFactorProperty =
                void 0 !== (null == t ? void 0 : t.cellHardnessFactor)
                  ? null == t
                    ? void 0
                    : t.cellHardnessFactor
                  : 1),
              (this.lightingFactorProperty =
                void 0 !== (null == t ? void 0 : t.lightingFactor)
                  ? null == t
                    ? void 0
                    : t.lightingFactor
                  : 0.8),
              (this.contourStrokeThicknessProperty =
                void 0 !== (null == t ? void 0 : t.contourStrokeThickness)
                  ? null == t
                    ? void 0
                    : t.contourStrokeThickness
                  : 2),
              (this.contourIntervalProperty =
                void 0 !== (null == t ? void 0 : t.contourInterval)
                  ? null == t
                    ? void 0
                    : t.contourInterval
                  : 20),
              (this.contourOffsetProperty =
                void 0 !== (null == t ? void 0 : t.contourOffset)
                  ? t.contourOffset
                  : 0.1),
              (this.contourStrokeProperty =
                (null == t ? void 0 : t.contourStroke) || "#FFFFFF"),
              (this.highlightProperty =
                void 0 !== (null == t ? void 0 : t.highlight)
                  ? null == t
                    ? void 0
                    : t.highlight
                  : 0.05),
              (null == t ? void 0 : t.meshColorPalette) &&
                ("getTexture" in t.meshColorPalette ||
                  (t.meshColorPalette = (0, i.createType)(
                    o.EBaseType.PaletteProvider,
                    t.meshColorPalette.type,
                    e,
                    t.meshColorPalette.options
                  ))),
              (this.meshColorPaletteProperty =
                null == t ? void 0 : t.meshColorPalette),
              this.setSceneEntity(new s.SurfaceMeshSceneEntity(e, this));
          }
          get type() {
            return d.ESeriesType3D.SurfaceMeshRenderableSeries3D;
          }
          get colorMapTextureSize() {
            return this.colorMapTextureSizeProperty;
          }
          set colorMapTextureSize(e) {
            (this.colorMapTextureSizeProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.COLOR_MAP_TEXTURE_SIZE);
          }
          get drawMeshAs() {
            return this.drawMeshAsProperty;
          }
          set drawMeshAs(e) {
            (this.drawMeshAsProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.DRAW_MESH_AS);
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.STROKE_THICKNESS);
          }
          get drawSkirt() {
            return this.drawSkirtProperty;
          }
          set drawSkirt(e) {
            (this.drawSkirtProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.DRAW_SKIRT);
          }
          get meshColorPalette() {
            return this.meshColorPaletteProperty;
          }
          set meshColorPalette(e) {
            (this.meshColorPaletteProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.MESH_COLOR_PALETTE);
          }
          get minimum() {
            return this.minimumProperty;
          }
          set minimum(e) {
            (this.minimumProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.MINIMUM);
          }
          get maximum() {
            return this.maximumProperty;
          }
          set maximum(e) {
            (this.maximumProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.MAXIMUM);
          }
          get meshPaletteMode() {
            return this.meshPaletteModeProperty;
          }
          set meshPaletteMode(e) {
            (this.meshPaletteModeProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.MESH_PALETTE_MODE);
          }
          get heightScaleFactor() {
            return this.heightScaleFactorProperty;
          }
          set heightScaleFactor(e) {
            (this.heightScaleFactorProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.HEIGHT_SCALE_FACTOR);
          }
          get meshResolution() {
            return this.meshResolutionProperty;
          }
          set meshResolution(e) {
            (this.meshResolutionProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.MESH_RESOLUTION);
          }
          get yOffset() {
            return this.yOffsetProperty;
          }
          set yOffset(e) {
            (this.yOffsetProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.Y_OFFSET);
          }
          get cellHardnessFactor() {
            return this.cellHardnessFactorProperty;
          }
          set cellHardnessFactor(e) {
            (this.cellHardnessFactorProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CELL_HARDNESS_FACTOR);
          }
          get lightingFactor() {
            return this.lightingFactorProperty;
          }
          set lightingFactor(e) {
            (this.lightingFactorProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.LIGHTING_FACTOR);
          }
          get contourStrokeThickness() {
            return this.contourStrokeThicknessProperty;
          }
          set contourStrokeThickness(e) {
            (this.contourStrokeThicknessProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CONTOUR_STROKE_THICKNESS);
          }
          get contourInterval() {
            return this.contourIntervalProperty;
          }
          set contourInterval(e) {
            (this.contourIntervalProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CONTOUR_INTERVAL);
          }
          get contourOffset() {
            return this.contourOffsetProperty;
          }
          set contourOffset(e) {
            (this.contourOffsetProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CONTOUR_OFFSET);
          }
          get contourStroke() {
            return this.contourStrokeProperty;
          }
          set contourStroke(e) {
            (this.contourStrokeProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CONTOUR_STROKE);
          }
          get highlight() {
            return this.highlightProperty;
          }
          set highlight(e) {
            (this.highlightProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.HIGHLIGHT);
          }
          getOptions() {
            const e = super.getOptions(),
              t = {
                colorMapTextureSize: this.colorMapTextureSize,
                meshResolution: this.meshResolution,
                strokeThickness: this.strokeThickness,
                contourStrokeThickness: this.contourStrokeThickness,
                meshPaletteMode: this.meshPaletteMode,
                heightScaleFactor: this.heightScaleFactor,
                contourStroke: this.contourStroke,
                drawMeshAs: this.drawMeshAs,
                drawSkirt: this.drawSkirt,
                meshColorPalette: this.meshColorPalette,
                minimum: this.minimum,
                maximum: this.maximum,
                yOffset: this.yOffset,
                cellHardnessFactor: this.cellHardnessFactor,
                lightingFactor: this.lightingFactor,
                contourInterval: this.contourInterval,
                contourOffset: this.contourOffset,
                highlight: this.highlight,
              };
            return Object.assign(e, t);
          }
        }
        t.SurfaceMeshRenderableSeries3D = p;
      },
      19221: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzSeriesInfo3D = void 0);
        const i = r(23291),
          o = r(16110),
          a = r(94574);
        class s extends a.SeriesInfo3D {
          constructor(e, t) {
            super(e, t),
              (this.dataSeriesType = i.EDataSeriesType3D.Xyz3D),
              this.enrichSeriesInfo();
          }
          enrichSeriesInfo() {
            if (!this.isHit || !this.renderableSeries) return;
            this.dataSeriesIndex = this.hitTestInfo.selectionIndex - 1;
            const e = this.renderableSeries.dataSeries;
            if (e) {
              (this.xValue = e.getNativeXValues().get(this.dataSeriesIndex)),
                (this.yValue = e.getNativeYValues().get(this.dataSeriesIndex)),
                (this.zValue = e.getNativeZValues().get(this.dataSeriesIndex));
              const t = e.getMetadataValues();
              t &&
                t.length > this.dataSeriesIndex &&
                (this.pointMetadata = t[this.dataSeriesIndex]);
              const r = this.renderableSeries.parentSurface;
              if (r) {
                const e = 0.5 * r.worldDimensions.x,
                  t = 0.5 * r.worldDimensions.z,
                  i =
                    r.xAxis
                      .getCurrentCoordinateCalculator()
                      .getCoordinate(this.xValue) - e,
                  a = r.yAxis
                    .getCurrentCoordinateCalculator()
                    .getCoordinate(this.yValue),
                  s =
                    r.zAxis
                      .getCurrentCoordinateCalculator()
                      .getCoordinate(this.zValue) - t;
                this.hitWorldCoords = new o.Vector3(i, a, s);
              }
            }
          }
        }
        t.XyzSeriesInfo3D = s;
      },
      228: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RootSceneEntity = void 0);
        const i = r(34116),
          o = r(85418),
          a = r(21240),
          s = r(23866);
        class n extends o.BaseSceneEntity3D {
          constructor(e, t) {
            super(e),
              (this.type = i.ESceneEntityType.RootSceneEntity),
              s.Guard.notNull(t, "parentSurface"),
              (this.parentSurface = t),
              (this.entityIdProvider = new a.DefaultEntityIdProvider());
          }
          attachChild(e) {
            (null == e ? void 0 : e.nativeEntity) &&
              this.world.AddEntity(e.nativeEntity),
              (e.entityIdProvider = this.entityIdProvider),
              (e.parent = this),
              e.onAttached();
          }
          detachChild(e) {
            (null == e ? void 0 : e.nativeEntity) &&
              this.world.RemoveEntity(e.nativeEntity),
              e.onDetached(),
              (e.parent = void 0);
          }
        }
        t.RootSceneEntity = n;
      },
      20254: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChart3DRenderer = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(87459),
          s = r(12785),
          n = r(77376),
          l = r(16602),
          d = r(33517),
          h = r(72476),
          u = r(41859);
        class c {
          constructor(e, t) {
            (this.isInvalidated = !1),
              o.Guard.notNull(e, "scs"),
              (this.scs = e),
              (this.wasmContext = t);
          }
          static getSceneDescriptor(e) {
            var t, r, i;
            const o = new u.SceneDescriptor();
            return (
              (o.axisCubeDescriptor = new d.AxisCubeDescriptor()),
              (o.axisCubeDescriptor.dimensions = e.worldDimensions),
              (o.axisCubeDescriptor.isVisible = !0),
              (o.axisCubeDescriptor.xAxisDescriptor =
                null === (t = e.xAxis) || void 0 === t
                  ? void 0
                  : t.toAxisDescriptor()),
              (o.axisCubeDescriptor.yAxisDescriptor =
                null === (r = e.yAxis) || void 0 === r
                  ? void 0
                  : r.toAxisDescriptor()),
              (o.axisCubeDescriptor.zAxisDescriptor =
                null === (i = e.zAxis) || void 0 === i
                  ? void 0
                  : i.toAxisDescriptor()),
              o
            );
          }
          static prepareRenderData(e) {
            const t = new h.RenderPassInfo3D();
            return (
              (t.xCalc = e.xAxis.getCurrentCoordinateCalculator()),
              (t.yCalc = e.yAxis.getCurrentCoordinateCalculator()),
              (t.zCalc = e.zAxis.getCurrentCoordinateCalculator()),
              (t.worldDimensions = e.worldDimensions),
              (t.sceneDescriptor = c.getSceneDescriptor(e)),
              t
            );
          }
          static tryPerformAutoRangeOn(e, t) {
            if (
              ((!e.hasValidVisibleRange() || e.hasDefaultVisibleRange()) &&
                e.autoRange === s.EAutoRange.Once) ||
              e.autoRange === s.EAutoRange.Always
            ) {
              const r = t.viewportManager.calculateAutoRange(e);
              r &&
                r !== e.visibleRange &&
                e.isValidRange(r) &&
                (e.visibleRange = r);
            }
          }
          render() {
            var e, t;
            if (this.scs.isDeleted || !this.scs.isInitialized) return;
            this.isInvalidated = !1;
            const r = l.PerformanceDebugHelper.mark(
              l.EPerformanceMarkType.RenderStart,
              {
                contextId: this.scs.id,
                level: l.EPerformanceDebugLevel.Verbose,
              }
            );
            this.isSurfaceValid(this.scs),
              this.scs.webAssemblyContext3D.SCRTSetIsSelectionBufferEnabled(
                this.scs.isHitTestEnabled
              );
            const i = this.scs.getSceneWorld();
            if (!i)
              return void console.warn(
                "SciChart3DRenderer: Undefined scene world!"
              );
            this.wasmContext.SCRTSetActiveWorld(i),
              this.updateWorldDimensions(i, this.scs.worldDimensions);
            const o = i.GetMainCamera();
            this.scs.camera.updateEngineCamera(o);
            const { width: s, height: n } = this.scs.viewportManager,
              d = new a.Rect(0, 0, s, n);
            this.scs.setSeriesViewRect(d);
            const h = this.previousTime
              ? Date.now() - this.previousTime
              : void 0;
            this.previousTime = Date.now();
            const u = l.PerformanceDebugHelper.mark(
              l.EPerformanceMarkType.GenericAnimationStart,
              {
                contextId: this.scs.id,
                level: l.EPerformanceDebugLevel.Verbose,
              }
            );
            this.scs.genericAnimationsRun.raiseEvent(),
              this.scs.onAnimate(h),
              l.PerformanceDebugHelper.mark(
                l.EPerformanceMarkType.GenericAnimationEnd,
                {
                  contextId: this.scs.id,
                  relatedId:
                    null === (e = null == u ? void 0 : u.detail) || void 0 === e
                      ? void 0
                      : e.relatedId,
                  level: l.EPerformanceDebugLevel.Verbose,
                }
              ),
              this.scs.updateBackground(),
              this.prepareAxes(this.scs.xAxis, this.scs.yAxis, this.scs.zAxis);
            const p = c.prepareRenderData(this.scs);
            this.scs.rootEntity.visitEntities((e) => e.setRenderPassData(p)),
              [
                ...this.scs.annotations.asArray(),
                ...this.scs.modifierAnnotations.asArray(),
              ]
                .filter((e) => e.isDomAnnotation)
                .forEach((e) => {
                  var t;
                  const r = l.PerformanceDebugHelper.mark(
                    l.EPerformanceMarkType.DrawAnnotationStart,
                    {
                      contextId: e.id,
                      parentContextId: this.scs.id,
                      level: l.EPerformanceDebugLevel.Verbose,
                    }
                  );
                  e.update(void 0, void 0, 0, 0),
                    l.PerformanceDebugHelper.mark(
                      l.EPerformanceMarkType.DrawAnnotationEnd,
                      {
                        contextId: e.id,
                        parentContextId: this.scs.id,
                        relatedId:
                          null === (t = null == r ? void 0 : r.detail) ||
                          void 0 === t
                            ? void 0
                            : t.relatedId,
                        level: l.EPerformanceDebugLevel.Verbose,
                      }
                    );
                }),
              this.updateWatermark(),
              this.scs.onSciChartRendered(),
              this.scs.isRunningAnimation &&
                setTimeout(this.scs.invalidateElement, 0),
              l.PerformanceDebugHelper.mark(l.EPerformanceMarkType.RenderEnd, {
                contextId: this.scs.id,
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                level: l.EPerformanceDebugLevel.Verbose,
              });
          }
          updateWatermark() {
            const e = this.scs.getMainCanvas().clientHeight,
              t = this.scs.getMainCanvas().clientWidth,
              { left: r, bottom: i } = n.watermarkHelpers.calcPosition(
                t,
                e,
                this.scs.watermarkPosition,
                !0
              );
            this.scs.updateWatermark(r, i);
          }
          isSurfaceValid(e, t) {
            if (!e.xAxis)
              throw new Error(
                "Unable to draw SciChart3DSurface as the xAxis is undefined"
              );
            if (!e.yAxis)
              throw new Error(
                "Unable to draw SciChart3DSurface as the yAxis is undefined"
              );
            if (!e.zAxis)
              throw new Error(
                "Unable to draw SciChart3DSurface as the zAxis is undefined"
              );
            return !0;
          }
          prepareAxes(...e) {
            e.forEach((e) => {
              e.validateAxis(),
                c.tryPerformAutoRangeOn(e, this.scs),
                (e.isMeasured = !0);
            });
          }
          updateWorldDimensions(e, t) {
            let r;
            o.Guard.notNull(t, "worldDimensions");
            try {
              (r = this.scs.worldDimensions.toTsrVector3(this.wasmContext)),
                e.SetWorldDimensions(r);
            } finally {
              (0, i.deleteSafe)(r);
            }
          }
        }
        t.SciChart3DRenderer = c;
      },
      52361: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChart3DSurface = t.sciChartConfig3D = void 0);
        const o = r(14184),
          a = r(86127),
          s = r(84745),
          n = r(56744),
          l = r(37796),
          d = r(75772),
          h = r(3810),
          u = r(16110),
          c = r(22054),
          p = r(17542),
          g = r(38051),
          y = r(86753),
          f = r(36561),
          v = r(1989),
          m = r(228),
          S = r(20254),
          P = r(34238),
          C = r(85479),
          b = r(62049),
          x = r(99263),
          A = r(23447),
          T = r(3214),
          E = r(87108),
          R = r(16602),
          D = r(87459),
          w = r(9254),
          M = r(19145),
          L = r(91465),
          O = r(25606);
        t.sciChartConfig3D = {};
        class I extends o.SciChartSurfaceBase {
          constructor(e, t) {
            var r, i, o, n;
            super(e, null == t ? void 0 : t.canvases),
              (this.watermarkPosition = C.SciChartDefaults.watermarkPosition),
              (this.preRender = new T.EventHandler()),
              (this.showErrors = !0),
              (this.animationList = []),
              (this.isAxisCubeRenderedProperty = !1),
              (this.isHitTestEnabledProperty = !1),
              (this.isZXPlaneVisibleProperty = !0),
              (this.isXYPlaneVisibleProperty = !0),
              (this.isZYPlaneVisibleProperty = !0);
            const d =
                null !==
                  (i =
                    null === (r = this.domCanvas2D) || void 0 === r
                      ? void 0
                      : r.width) && void 0 !== i
                  ? i
                  : s.DEFAULT_WIDTH,
              h =
                null !==
                  (n =
                    null === (o = this.domCanvas2D) || void 0 === o
                      ? void 0
                      : o.height) && void 0 !== n
                  ? n
                  : s.DEFAULT_HEIGHT;
            if (((this.webAssemblyContext3D = e), !s.IS_TEST_ENV)) {
              const t = d / a.DpiHelper.PIXEL_RATIO,
                r = h / a.DpiHelper.PIXEL_RATIO;
              this.isCopyCanvasSurface
                ? this.changeMasterCanvasViewportSize(e, t, r)
                : this.changeWebGLCanvasViewportSize(e, t, r);
            }
            (this.invalidateElement = this.invalidateElement.bind(this)),
              (this.sciChart3DRenderer = new S.SciChart3DRenderer(this, e)),
              (this.viewportManager = new f.DefaultViewportManager3D(d, h)),
              (this.worldDimensionsProperty =
                (null == t ? void 0 : t.worldDimensions) ||
                new u.Vector3(300, 200, 300)),
              (this.detachSeries = this.detachSeries.bind(this)),
              (this.attachSeries = this.attachSeries.bind(this)),
              (this.renderableSeries = new l.ObservableArray()),
              this.renderableSeries.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach((e) => this.detachSeries(e)),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach((e) => this.attachSeries(e));
              }),
              (this.childPropertyChanged =
                this.childPropertyChanged.bind(this)),
              (this.sceneWorldProperty =
                new this.webAssemblyContext3D.SCRTSceneWorld()),
              this.sceneWorldProperty.Init(),
              (this.rootEntity = new m.RootSceneEntity(e, this)),
              (this.axisCubeEntity = new c.AxisCubeEntity(e, this)),
              this.rootEntity.children.add(this.axisCubeEntity),
              (this.gizmoEntity = new v.GizmoEntity(e)),
              this.rootEntity.children.add(this.gizmoEntity),
              s.IS_TEST_ENV ||
                ((this.watermarkProperties = new e.SCRTWaterMarkProperties()),
                (this.watermarkProperties.m_fCanvasWidth = d),
                (this.watermarkPropertyPosition = new e.TSRVector2(0, 0)),
                this.watermarkProperties.SetPosition(
                  this.watermarkPropertyPosition
                ),
                this.watermarkProperties.SetOpacity(0.5),
                e.SCRT3DSetWaterMarkProperties(this.watermarkProperties));
          }
          static createSingle(e, t) {
            const r = R.PerformanceDebugHelper.mark(
              R.EPerformanceMarkType.InitializationStart,
              { contextId: null == t ? void 0 : t.id }
            );
            return (0, y.createSingle3dInternal)(e, t).then((e) => {
              var i;
              return (
                e.sciChart3DSurface.applyOptions(t),
                R.PerformanceDebugHelper.mark(
                  R.EPerformanceMarkType.InitializationEnd,
                  {
                    parentContextId: e.sciChart3DSurface.domCanvas2D.id,
                    contextId: e.sciChart3DSurface.id,
                    relatedId:
                      null === (i = null == r ? void 0 : r.detail) ||
                      void 0 === i
                        ? void 0
                        : i.relatedId,
                  }
                ),
                e
              );
            });
          }
          static configure(e) {
            var r;
            t.sciChartConfig3D.wasmUrl =
              null !== (r = null == e ? void 0 : e.wasmUrl) && void 0 !== r
                ? r
                : void 0;
          }
          static useWasmFromCDN() {
            t.sciChartConfig3D.wasmUrl = `https://cdn.jsdelivr.net/npm/scichart@${P.libraryVersion}/_wasm/scichart3d.wasm`;
          }
          static loadWasmFromCDN() {
            return I.useWasmFromCDN();
          }
          static loadWasmLocal() {
            return I.configure(void 0);
          }
          static create(e, t) {
            const r = R.PerformanceDebugHelper.mark(
              R.EPerformanceMarkType.InitializationStart,
              { contextId: null == t ? void 0 : t.id }
            );
            return s.IS_TEST_ENV
              ? this.createTest(e, t)
              : (0, g.createMultichart3d)(e, t).then((e) => {
                  var i, o;
                  return (
                    e.sciChart3DSurface.applyOptions(t),
                    R.PerformanceDebugHelper.mark(
                      R.EPerformanceMarkType.InitializationEnd,
                      {
                        parentContextId: e.sciChart3DSurface.domCanvas2D.id,
                        contextId:
                          null === (i = e.sciChart3DSurface) || void 0 === i
                            ? void 0
                            : i.id,
                        relatedId:
                          null === (o = null == r ? void 0 : r.detail) ||
                          void 0 === o
                            ? void 0
                            : o.relatedId,
                      }
                    ),
                    e
                  );
                });
          }
          static disposeSharedWasmContext() {
            0 === x.sciChart3DDestinations.length &&
              0 === x.sciChartDestinations.length &&
              ((0, A.disposeMultiChart)(), (0, g.disposeMultiChart3d)()),
              super.disposeSharedWasmContext();
          }
          static createTest(e, r) {
            var i, o;
            const a = O.default.initCanvas(
                e,
                null !== (i = null == r ? void 0 : r.widthAspect) &&
                  void 0 !== i
                  ? i
                  : 0,
                null !== (o = null == r ? void 0 : r.heightAspect) &&
                  void 0 !== o
                  ? o
                  : 0,
                O.default.ECanvasType.canvas2D
              ),
              s = new I(t.sciChartConfig3D.testWasm, { canvases: a });
            return (
              s.applyTheme(null == r ? void 0 : r.theme),
              s.applyOptions(r),
              new Promise((e) =>
                e({ wasmContext: s.webAssemblyContext3D, sciChart3DSurface: s })
              )
            );
          }
          getSceneWorld() {
            return this.sceneWorldProperty;
          }
          worldToScreenCoord(e) {
            const t = this.getSceneWorld();
            if (!t) return;
            const r = e.toTsrVector3(this.webAssemblyContext3D),
              i = t.TransformWorldToScreenCoords(r),
              o = new d.Point(i.x, i.y);
            return i.delete(), r.delete(), o;
          }
          delete(e = !0) {
            this.renderableSeries.asArray().forEach((e) => e.delete()),
              this.renderableSeries.clear(),
              (this.xAxis = (0, n.deleteSafe)(this.xAxis)),
              (this.yAxis = (0, n.deleteSafe)(this.yAxis)),
              (this.zAxis = (0, n.deleteSafe)(this.zAxis)),
              (this.rootEntity = (0, n.deleteSafe)(this.rootEntity)),
              (this.watermarkProperties = (0, n.deleteSafe)(
                this.watermarkProperties
              )),
              (this.watermarkPropertyPosition = (0, n.deleteSafe)(
                this.watermarkPropertyPosition
              )),
              (this.sceneWorldProperty = (0, n.deleteSafe)(
                this.sceneWorldProperty
              )),
              s.IS_TEST_ENV ||
                this.webAssemblyContext3D.SCRTSetActiveWorld(null),
              this.clearRootElement(e),
              super.delete();
          }
          get enableGizmo() {
            return this.gizmoEntity.enableGizmo;
          }
          set enableGizmo(e) {
            this.gizmoEntity.enableGizmo = e;
          }
          get viewportManager() {
            return this.viewportManagerProperty;
          }
          set viewportManager(e) {
            var t, r;
            null === (t = this.viewportManagerProperty) ||
              void 0 === t ||
              t.detachSciChartSurface(),
              (this.viewportManagerProperty = e),
              null === (r = this.viewportManagerProperty) ||
                void 0 === r ||
                r.attachSciChartSurface(this),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_VIEWPORT_MANAGER);
          }
          get worldDimensions() {
            return this.worldDimensionsProperty;
          }
          set worldDimensions(e) {
            (this.worldDimensionsProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_WORLD_DIMENSIONS);
          }
          get isZXPlaneVisible() {
            return this.isZXPlaneVisibleProperty;
          }
          set isZXPlaneVisible(e) {
            (this.isZXPlaneVisibleProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.PLANE_VISIBILITY);
          }
          get isXYPlaneVisible() {
            return this.isXYPlaneVisibleProperty;
          }
          set isXYPlaneVisible(e) {
            (this.isXYPlaneVisibleProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.PLANE_VISIBILITY);
          }
          get isZYPlaneVisible() {
            return this.isZYPlaneVisibleProperty;
          }
          set isZYPlaneVisible(e) {
            (this.isZYPlaneVisibleProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.PLANE_VISIBILITY);
          }
          get camera() {
            return this.cameraProperty;
          }
          set camera(e) {
            var t, r;
            null === (t = this.cameraProperty) ||
              void 0 === t ||
              t.propertyChanged.unsubscribe(this.childPropertyChanged),
              (this.cameraProperty = e),
              null === (r = this.cameraProperty) ||
                void 0 === r ||
                r.propertyChanged.subscribe(this.childPropertyChanged),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_CAMERA);
          }
          get xAxis() {
            return this.xAxisProperty;
          }
          set xAxis(e) {
            this.detachAxis(this.xAxisProperty),
              (this.xAxisProperty = e),
              this.attachAxis(this.xAxisProperty),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_XAXIS);
          }
          get yAxis() {
            return this.yAxisProperty;
          }
          set yAxis(e) {
            this.detachAxis(this.yAxisProperty),
              (this.yAxisProperty = e),
              this.attachAxis(this.yAxisProperty),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_YAXIS);
          }
          get zAxis() {
            return this.zAxisProperty;
          }
          set zAxis(e) {
            this.detachAxis(this.zAxisProperty),
              (this.zAxisProperty = e),
              this.attachAxis(this.zAxisProperty),
              this.notifyPropertyChanged(p.PROPERTY.SURFACE_ZAXIS);
          }
          set isHitTestEnabled(e) {
            e !== this.isHitTestEnabledProperty &&
              ((this.isHitTestEnabledProperty = e), this.invalidateElement());
          }
          get isHitTestEnabled() {
            return this.isHitTestEnabledProperty;
          }
          setIsAxisCubeRendered() {
            this.isAxisCubeRenderedProperty = !0;
          }
          get isAxisCubeRendered() {
            return this.isAxisCubeRenderedProperty;
          }
          get chartViewRect() {
            return new D.Rect(
              0,
              0,
              this.viewportManager.width,
              this.viewportManager.height
            );
          }
          invalidateElement(e) {
            var t, r, i;
            if (
              (w.Logger.debug(
                `Invalidating ${
                  null !==
                    (r =
                      null === (t = this.domChartRoot) || void 0 === t
                        ? void 0
                        : t.id) && void 0 !== r
                    ? r
                    : this.id
                }: force=${null == e ? void 0 : e.force} isSuspended=${
                  this.isSuspended
                } isInitialized=${this.isInitialized}.`
              ),
              ((null == e ? void 0 : e.force) ||
                (!this.isSuspended && !this.isDeleted && this.isInitialized)) &&
                (R.PerformanceDebugHelper.mark(
                  this.sciChart3DRenderer.isInvalidated
                    ? R.EPerformanceMarkType.Invalidate
                    : R.EPerformanceMarkType.LeadingInvalidate,
                  { contextId: this.id }
                ),
                !this.sciChart3DRenderer.isInvalidated))
            ) {
              if (
                null ===
                  (i = b.WebGlHelper.getContext(
                    this.webAssemblyContext3D.canvas
                  )) || void 0 === i
                  ? void 0
                  : i.isContextLost()
              )
                return;
              this.sciChart3DRenderer.isInvalidated = !0;
              const e = this.domCanvas2D
                ? this.domCanvas2D.id
                : "undefinedCanvasId";
              this.webAssemblyContext3D.TSRRequestCanvasDraw(e);
            }
          }
          onDpiChanged(e) {
            var t, r;
            this.renderableSeries.asArray().forEach((t) => t.onDpiChanged(e)),
              this.changeViewportSize(
                null === (t = this.getMainCanvas()) || void 0 === t
                  ? void 0
                  : t.clientWidth,
                null === (r = this.getMainCanvas()) || void 0 === r
                  ? void 0
                  : r.clientHeight
              ),
              super.onDpiChanged(e);
          }
          get surfaceType() {
            return M.ESurfaceType.SciChart3DSurfaceType;
          }
          get isInvalidated() {
            var e;
            return null === (e = this.sciChart3DRenderer) || void 0 === e
              ? void 0
              : e.isInvalidated;
          }
          onSciChartRendered() {
            this.chartModifiers.asArray().forEach((e) => {
              e.onParentSurfaceRendered();
            });
          }
          doDrawingLoop() {
            try {
              this.preRender.raiseEvent(), this.sciChart3DRenderer.render();
              const e = this.isInvalidated;
              R.PerformanceDebugHelper.mark(
                e
                  ? R.EPerformanceMarkType.Rendered
                  : R.EPerformanceMarkType.FullStateRendered,
                { contextId: this.id }
              ),
                this.rendered.raiseEvent(e),
                this.renderedToWebGl.raiseEvent(this.isInvalidated),
                this.isCopyCanvasSurface ||
                  this.renderedToDestination.raiseEvent(this.isInvalidated),
                (this.painted.handlers.length > 0 ||
                  R.PerformanceDebugHelper.enableDebug) &&
                  (0, R.runAfterFramePaint)(() => {
                    R.PerformanceDebugHelper.mark(
                      R.EPerformanceMarkType.Painted,
                      { contextId: this.id }
                    ),
                      this.painted.raiseEvent();
                  });
            } catch (e) {
              if ("BindingError" === e.name)
                console.error(e),
                  console.warn(
                    "Binding errors can occur if a previous chart using the same div id was not deleted correctly, or if you try to share data or series between charts that use different webassembly contexts."
                  );
              else {
                if (!this.domChartRoot) throw e;
                this.showErrors &&
                  console.error(
                    `Error from chart in div ${this.domChartRoot.id}:`,
                    e
                  );
              }
            }
          }
          applyTheme(e) {
            var t, r, i;
            super.applyTheme(e),
              this.renderableSeries.asArray().forEach((t) => t.applyTheme(e)),
              null === (t = this.xAxis) || void 0 === t || t.applyTheme(e),
              null === (r = this.yAxis) || void 0 === r || r.applyTheme(e),
              null === (i = this.zAxis) || void 0 === i || i.applyTheme(e),
              this.invalidateElement();
          }
          changeViewportSize(e, t) {
            if (!e || !t || this.isDeleted) return;
            const r = e * a.DpiHelper.PIXEL_RATIO,
              i = t * a.DpiHelper.PIXEL_RATIO;
            this.viewportManager.setSize(r, i),
              this.isCopyCanvasSurface
                ? (this.changeMasterCanvasViewportSize(
                    this.webAssemblyContext3D,
                    e,
                    t
                  ),
                  this.domCanvas2D &&
                    a.DpiHelper.setSize(this.domCanvas2D, e, t))
                : this.changeWebGLCanvasViewportSize(
                    this.webAssemblyContext3D,
                    e,
                    t
                  ),
              this.invalidateElement();
          }
          getAnimations() {
            return this.animationList;
          }
          addAnimation(...e) {
            void 0 !== e &&
              (e.forEach((e) => this.animationList.push(e)),
              this.invalidateElement());
          }
          get isRunningAnimation() {
            return this.animationList.some((e) => !e.isComplete);
          }
          onAnimate(e) {
            if (e) {
              const t = [];
              for (let r = 0; r < this.animationList.length; r++) {
                const i = this.animationList[r];
                i.isComplete ||
                  (i.update(e),
                  i.isComplete || (this.invalidateElement(), t.push(i)));
              }
              this.animationList = t;
            }
          }
          getXAxisById(e) {
            return this.xAxis;
          }
          getDefaultXAxis() {
            return this.xAxis;
          }
          getYAxisById(e) {
            return this.yAxis;
          }
          getDefaultYAxis() {
            return this.yAxis;
          }
          updateWatermark(e, t) {
            var r, i;
            if (!s.IS_TEST_ENV) {
              (this.watermarkPropertyPosition.x = e),
                (this.watermarkPropertyPosition.y = t),
                (this.watermarkProperties.m_fCanvasWidth =
                  null === (r = this.getMainCanvas()) || void 0 === r
                    ? void 0
                    : r.clientWidth),
                this.watermarkProperties.SetPosition(
                  this.watermarkPropertyPosition
                );
              const o =
                null === (i = this.themeProvider) || void 0 === i
                  ? void 0
                  : i.isLightBackground;
              (this.watermarkProperties.m_bIsDarkBackground =
                void 0 !== o && !o),
                this.webAssemblyContext3D.SCRT3DSetWaterMarkProperties(
                  this.watermarkProperties
                );
            }
          }
          getSeriesViewRectPadding(e) {
            return E.Thickness.fromNumber(0);
          }
          updateBackground() {
            var e;
            this.applySciChartBackground(
              null !== (e = this.backgroundProperty) && void 0 !== e
                ? e
                : this.themeProvider.sciChartBackground
            );
          }
          registerFont(e, t) {
            return i(this, void 0, void 0, function* () {
              return (
                e.includes(".") || (e += ".ttf"),
                (this.showErrors = !1),
                new Promise((r, i) => {
                  const o =
                    this.webAssemblyContext3D.SCRTFileLoadCallbackInterface.implement(
                      {
                        OnLoadComplete(i, o) {
                          i
                            ? r(!0)
                            : (console.error(
                                `Failed to load ${e} from ${t}.  Error: ${o}`
                              ),
                              r(!1));
                        },
                      }
                    );
                  this.webAssemblyContext3D.SCRTRegisterFile(e, t, o);
                }).then(() => (this.showErrors = !0))
              );
            });
          }
          applyOptions(e) {
            var t, r, i;
            super.applyOptions(e),
              (this.camera = new h.CameraController(
                this.webAssemblyContext3D,
                null == e ? void 0 : e.cameraOptions
              )),
              (null == e ? void 0 : e.worldDimensions) &&
                (this.worldDimensions = u.Vector3.hydrate(e.worldDimensions)),
              (null == e ? void 0 : e.background) &&
                (this.background = e.background),
              (this.isZXPlaneVisibleProperty =
                null !== (t = null == e ? void 0 : e.isZXPlaneVisible) &&
                void 0 !== t
                  ? t
                  : this.isZXPlaneVisibleProperty),
              (this.isXYPlaneVisibleProperty =
                null !== (r = null == e ? void 0 : e.isXYPlaneVisible) &&
                void 0 !== r
                  ? r
                  : this.isXYPlaneVisibleProperty),
              (this.isZYPlaneVisibleProperty =
                null !== (i = null == e ? void 0 : e.isZYPlaneVisible) &&
                void 0 !== i
                  ? i
                  : this.isZYPlaneVisibleProperty);
          }
          attachChartModifier(e) {
            super.attachChartModifier(e),
              e.setParentSurface(this),
              (e.invalidateParentCallback = this.invalidateElement),
              e.onAttach(),
              this.invalidateElement();
          }
          applySciChartBackground(e) {
            this.domChartRoot && (this.domChartRoot.style.background = e),
              this.webAssemblyContext3D.SCRT3DSetClearColor(0, 0, 0, 0);
          }
          detachSeries(e) {
            this.rootEntity && this.rootEntity.children.remove(e.sceneEntity),
              e.onDetach(),
              this.invalidateElement();
          }
          attachSeries(e) {
            if ((e.onAttach(this), !e.sceneEntity))
              throw new Error(
                "IRenderableSeries3D.sceneEntity must be set before attaching to SciChart3DSurface"
              );
            this.rootEntity && this.rootEntity.children.add(e.sceneEntity),
              this.invalidateElement();
          }
          detachAxis(e) {
            e &&
              ((e.invalidateParentCallback = void 0),
              (e.parentSurface = void 0));
          }
          attachAxis(e) {
            if (e) {
              if (e.invalidateParentCallback)
                throw new Error(
                  "Invalid operation in sciChart3DSurface.attachAxis, this axis has already been attached to a SciChart3DSurface. Please detach it from a SciChart3DSurface before attaching to another"
                );
              e.onAttach(
                this,
                e === this.xAxis,
                e === this.yAxis,
                e === this.zAxis
              ),
                this.themeProviderProperty &&
                  e.applyTheme(this.themeProviderProperty),
                (e.invalidateParentCallback = this.invalidateElement);
            }
          }
          childPropertyChanged(e) {
            this.invalidateElement();
          }
          getNextState(e = !1) {
            return i(this, void 0, void 0, function* () {
              return (
                yield this.nextStateRender({
                  resumeBefore: !0,
                  invalidateOnResume: !0,
                  suspendAfter: !0,
                }),
                this.toJSON(e)
              );
            });
          }
          getOptions() {
            let e;
            return (
              (e =
                "toJSON" in this.themeProvider
                  ? this.themeProvider.toJSON()
                  : this.themeProvider),
              {
                id: this.id,
                cameraOptions: this.camera.toJSON(),
                worldDimensions: this.worldDimensions,
                isXYPlaneVisible: this.isXYPlaneVisible,
                isZYPlaneVisible: this.isZYPlaneVisible,
                isZXPlaneVisible: this.isZXPlaneVisible,
                heightAspect: this.heightAspect,
                widthAspect: this.widthAspect,
                theme: e,
                background: this.background,
                loader: this.loaderJson,
                disableAspect: this.disableAspect,
                touchAction: this.touchActionProperty,
                freezeWhenOutOfView: this.freezeWhenOutOfView,
              }
            );
          }
          toJSON(e = !1) {
            const t = this.getOptions();
            return {
              type: L.ESciChartSurfaceType.Default3D,
              surface: t,
              xAxis: this.xAxis.toJSON(),
              yAxis: this.yAxis.toJSON(),
              zAxis: this.zAxis.toJSON(),
              series: this.renderableSeries.asArray().map((t) => t.toJSON(e)),
              modifiers: this.chartModifiers.asArray().map((e) => e.toJSON()),
              onCreated: this.onCreatedName,
              createSingle: !this.isCopyCanvasSurface,
            };
          }
        }
        t.SciChart3DSurface = I;
      },
      61981: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ViewportManager3DBase = void 0);
        const i = r(12785);
        t.ViewportManager3DBase = class {
          constructor(e, t) {
            (this.width = e), (this.height = t);
          }
          setSize(e, t) {
            (this.width = e), (this.height = t);
          }
          attachSciChartSurface(e) {
            if (this.isAttached)
              throw Error(
                "This ViewportManager instance is already attached to a SciChart3DSurface. Detach it before attaching to another"
              );
            (this.parentSurface = e), (this.isAttached = !0);
          }
          detachSciChartSurface() {
            (this.isAttached = !1), (this.parentSurface = void 0);
          }
          calculateAutoRange(e) {
            if (
              e.autoRange === i.EAutoRange.Always ||
              e.autoRange === i.EAutoRange.Once
            ) {
              const t = e.getMaximumRange();
              if (t && t.isDefined) return t;
            }
            return e.visibleRange;
          }
        };
      },
      38051: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.disposeMultiChart3d = t.createMultichart3d = void 0);
        const o = r(5877),
          a = r(13639),
          s = r(84518),
          n = r(66570),
          l = r(85479),
          d = r(25606),
          h = r(14184),
          u = r(34238),
          c = r(55023),
          p = r(99263),
          g = r(73538),
          y = r(9254),
          f = (r(27307), r(16602)),
          v = r(43621),
          m = r(52361),
          S = {
            id: void 0,
            wasmContext: void 0,
            getChildSurfaces: void 0,
            createChildSurface: void 0,
          };
        let P, C;
        (t.createMultichart3d = (e, t) =>
          i(void 0, void 0, void 0, function* () {
            var r, i, o, a, s, l, c, p, g;
            d.default.checkChartDivExists(e);
            const y = d.default.initCanvas(
                e,
                null !== (r = null == t ? void 0 : t.widthAspect) &&
                  void 0 !== r
                  ? r
                  : 0,
                null !== (i = null == t ? void 0 : t.heightAspect) &&
                  void 0 !== i
                  ? i
                  : 0,
                d.default.ECanvasType.canvas2D,
                void 0,
                null == t ? void 0 : t.touchAction
              ),
              m =
                null !== (o = null == t ? void 0 : t.loader) && void 0 !== o
                  ? o
                  : new n.DefaultSciChartLoader(),
              C =
                null === (a = m.addChartLoader) || void 0 === a
                  ? void 0
                  : a.call(
                      m,
                      y.domDivContainer,
                      null !== (s = null == t ? void 0 : t.theme) &&
                        void 0 !== s
                        ? s
                        : h.SciChartSurfaceBase.DEFAULT_THEME
                    );
            try {
              const e =
                  null === (l = y.domCanvas2D) || void 0 === l ? void 0 : l.id,
                r = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.EngineInitStart,
                  { parentContextId: e }
                );
              if (
                !S.wasmContext ||
                !S.createChildSurface ||
                !S.getChildSurfaces
              ) {
                P || ((0, v.forceReapplyLicense3D)(), (P = b()));
                const e = yield P;
                (0, u.checkBuildStamp)(e.wasmContext),
                  (S.id = e.id),
                  (S.wasmContext = e.wasmContext),
                  (S.createChildSurface = e.createChildSurface),
                  (S.getChildSurfaces = e.getChildSurfaces);
              }
              f.PerformanceDebugHelper.mark(
                f.EPerformanceMarkType.EngineInitEnd,
                {
                  relatedId:
                    null === (c = null == r ? void 0 : r.detail) || void 0 === c
                      ? void 0
                      : c.relatedId,
                  contextId: S.id,
                  parentContextId: e,
                }
              );
              const { createChildSurface: i, wasmContext: o } = S,
                a = i(
                  y.domChartRoot.id,
                  y,
                  null !== (p = null == t ? void 0 : t.theme) && void 0 !== p
                    ? p
                    : h.SciChartSurfaceBase.DEFAULT_THEME
                );
              return new Promise((e) => {
                setTimeout(() => {
                  var t;
                  null === (t = m.removeChartLoader) ||
                    void 0 === t ||
                    t.call(m, y.domDivContainer, C),
                    a.setIsInitialized(),
                    e({ wasmContext: o, sciChart3DSurface: a });
                }, 0);
              });
            } catch (e) {
              return (
                console.error(e),
                null === (g = m.removeChartLoader) ||
                  void 0 === g ||
                  g.call(m, y.domDivContainer, C),
                Promise.reject(e)
              );
            }
          })),
          (t.disposeMultiChart3d = () => {
            C && C(),
              (S.createChildSurface = void 0),
              (S.getChildSurfaces = void 0),
              (S.wasmContext = void 0),
              (P = void 0),
              s.licenseManager.clear();
          });
        const b = () => {
            const e = (e, t, r, i, o, a) => {
              const s = (0, h.createChartDestination)(r.domCanvas2D);
              if (!s) return void r.delete();
              const n = e.SCRTSurfaceDestination.implement(s);
              a.AddDestination(n),
                p.sciChart3DDestinations.push({
                  canvasElementId: t,
                  sciChartSurface: r,
                  width: i,
                  height: o,
                });
            };
            return new Promise((t, r) => {
              const i = (0, h.getLocateFile)(m.sciChartConfig3D);
              new o({ locateFile: i, noInitialRun: !0 })
                .then((r) => {
                  const i = (0, g.generateGuid)();
                  let o = (0, c.createWasmContextRevocableProxy)(r, i);
                  const s = o.proxy;
                  C = () => {
                    s.TSRRequestExit(),
                      P.delete(),
                      s
                        .SCRTGetGlobalSampleChartInterface()
                        .SetFrameRenderer(null),
                      s.SCRTGetGlobalSampleChartInterface().delete(),
                      s.SCRTSetGlobalSampleChartInterface(null),
                      b.delete(),
                      s.SCRTSetGlobalCopyToDestinationInterface(null),
                      o.revoke(),
                      (o = void 0),
                      (C = void 0);
                  };
                  const n = () =>
                      p.sciChart3DDestinations.map((e) => e.sciChartSurface),
                    u = (t, r, i) => {
                      const o = d.default.getCanvas2dId(t),
                        a = p.sciChart3DDestinations.filter(
                          (e) => e.canvasElementId !== o
                        );
                      for (
                        S.ClearDestinations(),
                          p.sciChart3DDestinations
                            .filter((e) => e.canvasElementId === o)
                            .forEach((e) => e.sciChartSurface.delete());
                        p.sciChart3DDestinations.length > 0;

                      )
                        p.sciChart3DDestinations.pop();
                      a.forEach((t) =>
                        e(
                          s,
                          t.canvasElementId,
                          t.sciChartSurface,
                          t.width,
                          t.height,
                          S
                        )
                      );
                      const n = ((e, t, r, i) => {
                        const o = new m.SciChart3DSurface(e, { canvases: r });
                        o.applyTheme(i),
                          o.setDestinations(p.sciChart3DDestinations);
                        const a = d.default.subscribeToResize(
                          r.domChartRoot,
                          r.aspect,
                          o
                        );
                        return o.addDeletable(a), o;
                      })(s, 0, r, i);
                      return (
                        n.addDeletable({
                          delete: () => {
                            m.SciChart3DSurface.autoDisposeWasmContext &&
                              0 === n.otherSurfaces.length &&
                              (m.SciChart3DSurface.wasmContextDisposeTimeout
                                ? setTimeout(() => {
                                    0 === p.sciChart3DDestinations.length &&
                                      m.SciChart3DSurface.disposeSharedWasmContext();
                                  }, m.SciChart3DSurface.wasmContextDisposeTimeout)
                                : m.SciChart3DSurface.disposeSharedWasmContext());
                          },
                        }),
                        e(
                          s,
                          o,
                          n,
                          r.domCanvas2D.width,
                          r.domCanvas2D.height,
                          S
                        ),
                        (0, v.applyLicense3D)(s, n, !1),
                        n
                      );
                    };
                  s.canvas = (0, h.getMasterCanvas)();
                  const f = {
                      InitializeChart() {
                        t({
                          id: i,
                          getChildSurfaces: n,
                          createChildSurface: u,
                          wasmContext: s,
                        });
                      },
                      Draw(e) {
                        y.Logger.debug("Draw", e);
                        const t = p.sciChart3DDestinations.find(
                          (t) => t.canvasElementId === e
                        );
                        t && t.sciChartSurface.doDrawingLoop();
                      },
                      Update(e) {},
                      ShutDownChart() {},
                    },
                    S = s.SCRTSampleChartInterface.implement(f),
                    P = new s.SCRTFrameRenderer3D();
                  S.SetFrameRenderer(P),
                    S.SetFPSCounterEnabled(!1),
                    S.SetWasmBufferSizesKb(
                      l.SciChartDefaults.wasmBufferSizesKb
                    ),
                    s.SCRTSetGlobalSampleChartInterface(S);
                  const b = s.SCRTCopyToDestinationInterface.implement({
                    CopyToDestination: (0, a.copyToCanvas)(
                      h.SciChartSurfaceBase.domMasterCanvas,
                      x
                    ),
                  });
                  s.SCRTSetGlobalCopyToDestinationInterface(b),
                    s.TSRSetDrawRequestsEnabled(!0),
                    h.SciChartSurfaceBase.domMasterCanvas &&
                      s.SCRTSetMainWindowSize(
                        h.SciChartSurfaceBase.domMasterCanvas.width,
                        h.SciChartSurfaceBase.domMasterCanvas.height
                      ),
                    s.callMain();
                })
                .catch((e) => {
                  console.error(e),
                    r(
                      "Could not load SciChart WebAssembly module.\n            Check your build process and ensure that your scichart3d.wasm, scichart3d.data and scichart3d.js files are from the same version"
                    );
                });
            });
          },
          x = (e) =>
            p.sciChart3DDestinations.find((t) => t.canvasElementId === e);
      },
      86753: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createSingle3dInternal = void 0);
        const i = r(5877),
          o = r(84518),
          a = r(66570),
          s = r(85479),
          n = r(25606),
          l = r(14184),
          d = r(34238),
          h = r(55023),
          u = r(62049),
          c = r(9254),
          p = r(16602),
          g = r(43621),
          y = r(52361);
        t.createSingle3dInternal = (e, t) =>
          new Promise((r, o) => {
            var s, c, g, v, m;
            const S = n.default.initCanvas(
                e,
                null !== (s = null == t ? void 0 : t.widthAspect) &&
                  void 0 !== s
                  ? s
                  : 0,
                null !== (c = null == t ? void 0 : t.heightAspect) &&
                  void 0 !== c
                  ? c
                  : 0,
                void 0,
                void 0,
                null == t ? void 0 : t.touchAction
              ),
              P =
                null !== (g = null == t ? void 0 : t.loader) && void 0 !== g
                  ? g
                  : new a.DefaultSciChartLoader(),
              C =
                null === (v = P.addChartLoader) || void 0 === v
                  ? void 0
                  : v.call(
                      P,
                      S.domDivContainer,
                      null !== (m = null == t ? void 0 : t.theme) &&
                        void 0 !== m
                        ? m
                        : l.SciChartSurfaceBase.DEFAULT_THEME
                    ),
              b = p.PerformanceDebugHelper.mark(
                p.EPerformanceMarkType.EngineInitStart,
                { parentContextId: S.domCanvas2D.id }
              ),
              x = u.WebGlHelper.getWebGlSupport();
            if (x !== u.EWebGLSupport.WebGL2 && x !== u.EWebGLSupport.WebGL1)
              throw Error("Sorry Your browser does not support WebGL.");
            {
              const e = (0, l.getLocateFile)(y.sciChartConfig3D);
              new i({ locateFile: e, noInitialRun: !0 })
                .then((e) => {
                  var i, o;
                  null === (i = P.removeChartLoader) ||
                    void 0 === i ||
                    i.call(P, S.domDivContainer, C),
                    (e.doNotCaptureKeyboard = !0);
                  let a = (0, h.createWasmContextRevocableProxy)(
                    e,
                    S.domCanvas2D.id
                  );
                  f(
                    a.proxy,
                    S,
                    (e) => {
                      e.sciChart3DSurface.addDeletable({
                        delete: () => {
                          a.revoke(), (a = void 0);
                        },
                      }),
                        p.PerformanceDebugHelper.mark(
                          p.EPerformanceMarkType.EngineInitEnd,
                          {
                            relatedId: null == b ? void 0 : b.detail.relatedId,
                            contextId: e.sciChart3DSurface.id,
                            parentContextId: S.domCanvas2D.id,
                          }
                        ),
                        r(e);
                    },
                    null !== (o = null == t ? void 0 : t.theme) && void 0 !== o
                      ? o
                      : l.SciChartSurfaceBase.DEFAULT_THEME
                  ),
                    (0, d.checkBuildStamp)(e);
                })
                .catch((e) => {
                  var t;
                  throw (
                    (null === (t = P.removeChartLoader) ||
                      void 0 === t ||
                      t.call(P, S.domDivContainer, C),
                    e)
                  );
                });
            }
          });
        const f = (e, t, r, i) => {
          let a;
          e.canvas = t.domCanvasWebGL;
          const l = {
              InitializeChart() {
                (a = new y.SciChart3DSurface(e, { canvases: t })),
                  a.applyTheme(i),
                  a.addDeletable({
                    delete: () => {
                      e.TSRRequestExit(),
                        h.delete(),
                        e
                          .SCRTGetGlobalSampleChartInterface()
                          .SetFrameRenderer(null),
                        e.SCRTGetGlobalSampleChartInterface().delete(),
                        e.SCRTSetGlobalSampleChartInterface(null),
                        o.licenseManager.clear();
                    },
                  }),
                  setTimeout(() => {
                    a.invalidateElement(), (0, g.applyLicense3D)(e, a, !0);
                    const i = n.default.subscribeToResize(
                      t.domChartRoot,
                      t.aspect,
                      a
                    );
                    a.addDeletable(i),
                      a.setIsInitialized(),
                      r({ wasmContext: e, sciChart3DSurface: a });
                  }, 0);
              },
              Draw(e) {
                c.Logger.debug("Draw", e), a.isInitialized && a.doDrawingLoop();
              },
              Update(e) {},
              ShutDownChart() {},
            },
            d = e.SCRTSampleChartInterface.implement(l),
            h = new e.SCRTFrameRenderer3D();
          d.SetFrameRenderer(h),
            d.SetFPSCounterEnabled(!1),
            d.SetWasmBufferSizesKb(s.SciChartDefaults.wasmBufferSizesKb),
            e.SCRTSetGlobalSampleChartInterface(d),
            e.callMain();
        };
      },
      43621: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.applyLicense3D = t.forceReapplyLicense3D = void 0);
        const i = r(84518);
        t.forceReapplyLicense3D = () => {
          o = !0;
        };
        let o = !0;
        t.applyLicense3D = (e, t, r) => {
          r || o
            ? ((0, i.setCallbacks3D)(
                ((e, t) => ({
                  getLicenseChallenge3D: () => ({
                    challenge: e.SCRTCredentials.GetLicenseChallenge(),
                    orderId: e.SCRTCredentials.GetOrderId(),
                  }),
                  setChallengeResponse3D: (t) =>
                    e.SCRTCredentials.ApplyLicenseResponse(t),
                  setNewLicense3D: (r) => {
                    let o,
                      a = !1;
                    return (
                      e.SCRTCredentials.SetRuntimeLicenseKeyW(r),
                      (a = e.SCRTCredentials.RequiresValidation()),
                      (o =
                        e.SCRTCredentials.GetLicenseType() ===
                        e.SCRTLicenseType.LICENSE_TYPE_TRIAL_EXPIRED),
                      (0, i.updateLicenseDisplay)(
                        (0, i.getLicenseInfo)(e),
                        t,
                        !1,
                        !0
                      ),
                      { requiresValidation: a, trialExpired: o }
                    );
                  },
                  updateLicenseDisplay3D: () =>
                    (0, i.updateLicenseDisplay)(
                      (0, i.getLicenseInfo)(e),
                      t,
                      !1,
                      !0
                    ),
                }))(e, t)
              ),
              (0, i.applyLicense)(e, t))
            : (0, i.updateLicenseDisplay)((0, i.getLicenseInfo)(e), t, !1, !1),
            r || (o = !1);
        };
      },
      49975: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnnotationHoverModifier = void 0);
        const i = r(84736),
          o = r(89955),
          a = r(78615);
        class s extends a.PointerEventsMediatorModifier {
          constructor(e) {
            super(e),
              (this.type = o.EChart2DModifierType.AnnotationHover),
              (this.enableHoverProperty = !0);
          }
          getAllTargets() {
            const e = this.parentSurface.annotations
                .asArray()
                .filter((e) => !e.isHidden),
              t = e.filter((e) => e.isDomAnnotation),
              r = t.filter((e) => e.isSvgAnnotation),
              o = t.filter((e) => !e.isSvgAnnotation),
              a = e.filter((e) => !e.isSvgAnnotation),
              s = o.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.Background
              ),
              n = o.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.BelowChart
              ),
              l = o.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.AboveChart
              ),
              d = r.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.Background
              ),
              h = r.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.BelowChart
              ),
              u = r.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.AboveChart
              );
            return [
              ...s,
              ...d,
              ...a.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.Background
              ),
              ...a.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.BelowChart
              ),
              ...a.filter(
                (e) => e.annotationLayer === i.EAnnotationLayer.AboveChart
              ),
              ...h,
              ...n,
              ...u,
              ...l,
            ];
          }
        }
        t.AnnotationHoverModifier = s;
      },
      13063: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChartModifierBase = void 0);
        const i = r(55023),
          o = r(32616),
          a = r(6859),
          s = r(66405),
          n = r(19145),
          l = r(73538),
          d = r(22486);
        class h extends i.DeletableEntity {
          constructor(e) {
            var t;
            super(),
              (this.isEnabledProperty = !0),
              (this.executeConditionProperty = {}),
              (this.activePointerEvents = new Map()),
              (this.id =
                null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                  ? t
                  : (0, l.generateGuid)()),
              (this.executeConditionProperty =
                null == e ? void 0 : e.executeCondition),
              (this.secondaryExecuteConditionProperty =
                null == e ? void 0 : e.secondaryExecuteCondition);
          }
          applyTheme(e) {}
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          get isEnabled() {
            return this.isEnabledProperty;
          }
          set isEnabled(e) {
            (this.isEnabledProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.IS_ENABLED);
          }
          get isAttached() {
            return this.isAttachedProperty;
          }
          get receiveHandledEvents() {
            return this.receiveHandledEventsProperty;
          }
          set receiveHandledEvents(e) {
            (this.receiveHandledEventsProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.RECEIVE_HANDLED_EVENTS);
          }
          get executeCondition() {
            return this.executeConditionProperty;
          }
          set executeCondition(e) {
            (this.executeConditionProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.EXECUTE_CONDITION);
          }
          get secondaryExecuteCondition() {
            return this.secondaryExecuteConditionProperty;
          }
          set secondaryExecuteCondition(e) {
            (this.secondaryExecuteConditionProperty = e),
              this.notifyPropertyChanged(
                d.PROPERTY.SECONDARY_EXECUTE_CONDITION
              );
          }
          get canReceiveMouseEvents() {
            return (
              this.isEnabled &&
              this.isAttached &&
              void 0 !== this.parentSurfaceProperty
            );
          }
          onAttach() {}
          onDetach() {}
          onAttachSeries(e) {}
          onDetachSeries(e) {}
          onAttachSubSurface(e) {}
          onDetachSubSurface(e) {}
          onParentSurfaceRendered() {}
          modifierMouseDown(e) {
            var t;
            (null === (t = this.executeCondition) || void 0 === t
              ? void 0
              : t.button) === a.EExecuteOn.MouseMiddleButton &&
              e.nativeEvent.preventDefault(),
              ("touch" === e.pointerType || "pen" === e.pointerType) &&
                this.activePointerEvents.set(e.pointerId, e);
          }
          modifierMouseMove(e) {
            this.updatePointerInfo(e);
          }
          modifierMouseUp(e) {
            ("touch" === e.pointerType || "pen" === e.pointerType) &&
              this.activePointerEvents.delete(e.pointerId);
          }
          modifierMouseWheel(e) {}
          modifierDoubleClick(e) {}
          modifierMouseEnter(e) {}
          modifierMouseLeave(e) {
            this.activePointerEvents.delete(e.pointerId);
          }
          modifierDrop(e) {}
          modifierPointerCancel(e) {
            this.activePointerEvents.delete(e.pointerId);
          }
          setParentSurface(e) {
            if (e) {
              if (
                e.surfaceType === n.ESurfaceType.SciChartSurfaceType &&
                this.modifierType !== s.EModifierType.Chart2DModifier
              )
                throw new Error(
                  `Only 2D Chart Modifiers can be attached to a 2D SciChartSurface. Please check ${this.constructor.name}.modifierType property to match SciChartSurface.surfaceType`
                );
              if (
                e.surfaceType === n.ESurfaceType.SciChartPolarSurfaceType &&
                this.modifierType !== s.EModifierType.Chart2DPolarModifier
              )
                throw new Error(
                  `Only 2D Polar Chart Modifiers can be attached to a 2D SciChartPolarSurface. Please check ${this.constructor.name}.modifierType property to match SciChartSurface.surfaceType`
                );
              if (
                e.surfaceType === n.ESurfaceType.SciChart3DSurfaceType &&
                this.modifierType !== s.EModifierType.Chart3DModifier
              )
                throw new Error(
                  `Only 3D Chart Modifiers can be attached to a 3D SciChartSurface. Please check ${this.constructor.name}.modifierType property to match SciChartSurface.surfaceType`
                );
              this.parentSurfaceProperty = e;
            } else this.parentSurfaceProperty = void 0;
            (this.isAttachedProperty = void 0 !== this.parentSurfaceProperty),
              this.notifyPropertyChanged(d.PROPERTY.PARENT_SURFACE);
          }
          checkExecuteCondition(e, t) {
            if (t) {
              if (void 0 !== t.button && t.button !== e.button) return !1;
              if (void 0 !== t.key)
                if (t.key === o.EModifierMouseArgKey.Ctrl) {
                  if (!e.ctrlKey) return !1;
                } else if (t.key === o.EModifierMouseArgKey.Alt) {
                  if (!e.altKey) return !1;
                } else if (t.key === o.EModifierMouseArgKey.Shift) {
                  if (!e.shiftKey) return !1;
                } else if (
                  t.key === o.EModifierMouseArgKey.None &&
                  (e.ctrlKey || e.altKey || e.shiftKey)
                )
                  return !1;
              return !0;
            }
          }
          checkExecuteConditions(e) {
            return {
              isPrimary: this.checkExecuteCondition(e, this.executeCondition),
              isSecondary: this.checkExecuteCondition(
                e,
                this.secondaryExecuteCondition
              ),
            };
          }
          delete() {}
          notifyPropertyChanged(e) {
            this.invalidateParentCallback && this.invalidateParentCallback();
          }
          updatePointerInfo(e) {
            var t;
            (0 !== this.activePointerEvents.size &&
              this.activePointerEvents.keys().next().value !== e.pointerId) ||
              (this.mousePoint = e.mousePoint),
              (this.previousPoint =
                null === (t = this.activePointerEvents.get(e.pointerId)) ||
                void 0 === t
                  ? void 0
                  : t.mousePoint),
              this.activePointerEvents.has(e.pointerId) &&
                this.activePointerEvents.set(e.pointerId, e);
          }
          getIsActionAllowed(e) {
            return !0;
          }
        }
        t.ChartModifierBase = h;
      },
      89046: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getActiveAxes = t.testIsOverAxes = t.ChartModifierBase2D = void 0);
        const i = r(66405),
          o = r(86699),
          a = r(21670),
          s = r(13063),
          n = r(22486),
          l = r(77354),
          d = r(16819);
        class h extends s.ChartModifierBase {
          constructor(e) {
            var t, r, i, a, s, n, d, h, u, c, p, g, y, f, v, m;
            if (
              (super(e),
              (this.xyDirection = o.EXyDirection.XyDirection),
              (this.includedSeries = new l.IncludedItems()),
              (this.includedXAxes = new l.IncludedItems()),
              (this.includedYAxes = new l.IncludedItems()),
              (this.changedPropertiesList = []),
              (this.typeMap = new Map()),
              (this.xyDirection =
                null !== (t = null == e ? void 0 : e.xyDirection) &&
                void 0 !== t
                  ? t
                  : this.xyDirection),
              (this.modifierGroup =
                null !== (r = null == e ? void 0 : e.modifierGroup) &&
                void 0 !== r
                  ? r
                  : this.modifierGroup),
              (this.xAxisIdProperty =
                null !== (i = null == e ? void 0 : e.xAxisId) && void 0 !== i
                  ? i
                  : this.xAxisIdProperty),
              (this.yAxisIdProperty =
                null !== (a = null == e ? void 0 : e.yAxisId) && void 0 !== a
                  ? a
                  : this.yAxisIdProperty),
              (null === (s = null == e ? void 0 : e.includedSeriesIds) ||
              void 0 === s
                ? void 0
                : s.length) > 0 &&
                (null === (n = null == e ? void 0 : e.excludedSeriesIds) ||
                void 0 === n
                  ? void 0
                  : n.length) > 0)
            )
              throw new Error(
                "You either should use includedSeriesIds or excludedSeriesIds"
              );
            if (
              (null === (d = null == e ? void 0 : e.includedXAxisIds) ||
              void 0 === d
                ? void 0
                : d.length) > 0 &&
              (null === (h = null == e ? void 0 : e.excludedXAxisIds) ||
              void 0 === h
                ? void 0
                : h.length) > 0
            )
              throw new Error(
                "You either should use includedXAxisIds or excludedXAxisIds"
              );
            if (
              (null === (u = null == e ? void 0 : e.includedYAxisIds) ||
              void 0 === u
                ? void 0
                : u.length) > 0 &&
              (null === (c = null == e ? void 0 : e.excludedYAxisIds) ||
              void 0 === c
                ? void 0
                : c.length) > 0
            )
              throw new Error(
                "You either should use includedYAxisIds or excludedYAxisIds"
              );
            (null === (p = null == e ? void 0 : e.includedSeriesIds) ||
            void 0 === p
              ? void 0
              : p.length) > 0 &&
              this.includedSeries.includeList(e.includedSeriesIds),
              (null === (g = null == e ? void 0 : e.excludedSeriesIds) ||
              void 0 === g
                ? void 0
                : g.length) > 0 &&
                this.includedSeries.excludeList(e.excludedSeriesIds),
              (null === (y = null == e ? void 0 : e.includedXAxisIds) ||
              void 0 === y
                ? void 0
                : y.length) > 0 &&
                this.includedXAxes.includeList(e.includedXAxisIds),
              (null === (f = null == e ? void 0 : e.excludedXAxisIds) ||
              void 0 === f
                ? void 0
                : f.length) > 0 &&
                this.includedXAxes.excludeList(e.excludedXAxisIds),
              (null === (v = null == e ? void 0 : e.includedYAxisIds) ||
              void 0 === v
                ? void 0
                : v.length) > 0 &&
                this.includedYAxes.includeList(e.includedYAxisIds),
              (null === (m = null == e ? void 0 : e.excludedYAxisIds) ||
              void 0 === m
                ? void 0
                : m.length) > 0 &&
                this.includedYAxes.excludeList(e.excludedYAxisIds);
          }
          get modifierType() {
            return i.EModifierType.Chart2DModifier;
          }
          onAttach() {
            super.onAttach(), this.linkAxes();
          }
          get xAxisId() {
            return this.xAxisIdProperty;
          }
          set xAxisId(e) {
            e !== this.xAxisIdProperty &&
              ((this.xAxisIdProperty = e),
              (this.xAxisProperty = void 0),
              this.notifyPropertyChanged(n.PROPERTY.X_AXIS_ID));
          }
          get yAxisId() {
            return this.yAxisIdProperty;
          }
          set yAxisId(e) {
            e !== this.yAxisIdProperty &&
              ((this.yAxisIdProperty = e),
              (this.yAxisProperty = void 0),
              this.notifyPropertyChanged(n.PROPERTY.Y_AXIS_ID));
          }
          get xAxis() {
            return this.xAxisProperty;
          }
          get yAxis() {
            return this.yAxisProperty;
          }
          getAllSeries() {
            return this.parentSurface.renderableSeries.asArray();
          }
          getIncludedXAxis() {
            return this.includedXAxes.getIncludedItems(
              this.parentSurface.xAxes.asArray()
            );
          }
          getIncludedYAxis() {
            return this.includedYAxes.getIncludedItems(
              this.parentSurface.yAxes.asArray()
            );
          }
          includeXAxis(e, t) {
            t
              ? this.includedXAxes.include(e.id)
              : this.includedXAxes.exclude(e.id);
          }
          includeYAxis(e, t) {
            t
              ? this.includedYAxes.include(e.id)
              : this.includedYAxes.exclude(e.id);
          }
          includeAllAxes() {
            this.includedXAxes.includeAll(), this.includedYAxes.includeAll();
          }
          testIsIncludedSeries(e) {
            return this.includedSeries.testIsIncluded(e.id);
          }
          includeSeries(e, t) {
            return t
              ? this.includedSeries.include(e.id)
              : this.includedSeries.exclude(e.id);
          }
          getIncludedRenderableSeries() {
            const e = this.getAllSeries().filter(
                (e) =>
                  !e.isStacked && e.isVisible && this.testIsIncludedSeries(e)
              ),
              t = this.getAllSeries().filter((e) => e.isStacked),
              r = e;
            return (
              t.forEach((e) => {
                e.getVisibleSeries().forEach((e) => {
                  this.testIsIncludedSeries(e) && r.push(e);
                });
              }),
              r
            );
          }
          toJSON() {
            const e = {
              id: this.id,
              modifierGroup: this.modifierGroup,
              executeCondition: this.executeCondition,
              secondaryExecuteCondition: this.secondaryExecuteCondition,
              xyDirection: this.xyDirection,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
              includedXAxisIds: this.includedXAxes.getIncludedItemIds(),
              excludedXAxisIds: this.includedXAxes.getExcludedItemIds(),
              includedYAxisIds: this.includedYAxes.getIncludedItemIds(),
              excludedYAxisIds: this.includedYAxes.getExcludedItemIds(),
              includedSeriesIds: this.includedSeries.getIncludedItemIds(),
              excludedSeriesIds: this.includedSeries.getExcludedItemIds(),
            };
            return { type: this.type, options: e };
          }
          linkAxes() {
            if (((0, d.updateAxisIds)(this), this.parentSurface)) {
              if (!this.xAxisProperty && this.xAxisId) {
                const e = this.parentSurface.getXAxisById(this.xAxisId);
                e
                  ? (this.xAxisProperty = e)
                  : (console.warn(
                      `ChartModifier looked for xAxis Id "${this.xAxisId}" but did not find. Default xAxis will be used`
                    ),
                    (this.xAxisProperty =
                      this.parentSurface.getDefaultXAxis()));
              }
              if (!this.yAxisProperty && this.yAxisId) {
                const e = this.parentSurface.getYAxisById(this.yAxisId);
                e
                  ? (this.yAxisProperty = e)
                  : (console.warn(
                      `ChartModifier looked for yAxis Id "${this.yAxisId}" but did not find. Default yAxis will be used`
                    ),
                    (this.yAxisProperty =
                      this.parentSurface.getDefaultYAxis()));
              }
            }
          }
          testPropertyChanged(e) {
            return this.changedPropertiesList.includes(e);
          }
          notifyPropertyChanged(e) {
            this.changedPropertiesList.includes(e) ||
              this.changedPropertiesList.push(e),
              super.notifyPropertyChanged(e);
          }
          growBy(e, t, r) {
            const {
                isHorizontalAxis: i,
                isAxisFlipped: o,
                viewRect: a,
                flippedCoordinates: s,
              } = t,
              { seriesViewRect: n } = this.parentSurface;
            let l = i ? a.width : a.height;
            t.isStackedAxis &&
              this.parentSurface &&
              (l = i ? n.width : n.height);
            const d = i ? e.x : e.y,
              h = (d / l) * r,
              u = (1 - d / l) * r;
            (o && !s) || (!o && s) ? t.zoomBy(u, h) : t.zoomBy(h, u);
          }
        }
        (t.ChartModifierBase2D = h),
          (t.testIsOverAxes = (e, t) => {
            let r = !1;
            return (
              e.forEach((e) => {
                if (e.viewRect) {
                  const { left: i, right: o, top: s, bottom: n } = e.viewRect;
                  (0, a.testIsInBounds)(t.x, t.y, i, n, o, s) && (r = !0);
                }
              }),
              r
            );
          }),
          (t.getActiveAxes = (e, t) => {
            const r = [];
            return (
              e.forEach((e) => {
                if (e.viewRect) {
                  const { left: i, right: o, top: s, bottom: n } = e.viewRect;
                  (0, a.testIsInBounds)(t.x, t.y, i, n, o, s) && r.push(e);
                }
              }),
              r
            );
          });
      },
      62773: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.adjustTooltipPosition =
            t.calcTooltipSize =
            t.defaultCursorTooltipSvgTemplate =
            t.CursorModifier =
              void 0);
        const i = r(45921),
          o = r(56744),
          a = r(11043),
          s = r(89955),
          n = r(57935),
          l = r(48008),
          d = r(32873),
          h = r(31306),
          u = r(26520),
          c = r(64584),
          p = r(28677),
          g = r(14184),
          y = r(89046),
          f = r(22486);
        class v extends y.ChartModifierBase2D {
          constructor(e) {
            var r,
              o,
              l,
              d,
              h,
              u,
              c,
              p,
              y,
              f,
              v,
              m,
              S,
              P,
              C,
              b,
              x,
              A,
              T,
              E,
              R,
              D,
              w;
            super(e),
              (this.type = s.EChart2DModifierType.Cursor),
              (this.tooltipSvgTemplate = t.defaultCursorTooltipSvgTemplate),
              (this.crosshairStrokeThickness = 2),
              (this.crosshairStrokeDashArray = []),
              (this.tooltipContainerBackground = "#228B22"),
              (this.tooltipTextStroke = "#fff"),
              (this.showTooltip = !1),
              (this.axisLabelStroke = "#fff"),
              (this.axisLabelFill = "#228B22"),
              (this.xAxisLabelStroke = void 0),
              (this.xAxisLabelFill = void 0),
              (this.yAxisLabelStroke = void 0),
              (this.yAxisLabelFill = void 0),
              (this.tooltipLegendOffsetX = 0),
              (this.tooltipLegendOffsetY = 0),
              (this.hitTestRadius = 0),
              (this.mousePosition = n.EMousePosition.OutOfCanvas),
              (this.crosshairStrokeProperty =
                g.SciChartSurfaceBase.DEFAULT_THEME.cursorLineBrush),
              (this.tooltipShadowProperty =
                g.SciChartSurfaceBase.DEFAULT_THEME.shadowEffectColor),
              (this.showXLineProperty = !0),
              (this.showYLineProperty = !0),
              (this.showAxisLabelsProperty = !0),
              (null == e ? void 0 : e.tooltipSvgTemplate) &&
                "string" == typeof e.tooltipSvgTemplate &&
                (this.typeMap.set("tooltipSvgTemplate", e.tooltipSvgTemplate),
                (e.tooltipSvgTemplate = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.tooltipSvgTemplate
                ))),
              (this.tooltipSvgTemplate =
                null !== (r = null == e ? void 0 : e.tooltipSvgTemplate) &&
                void 0 !== r
                  ? r
                  : this.tooltipSvgTemplate),
              (this.crosshairStrokeThickness =
                null !==
                  (o = null == e ? void 0 : e.crosshairStrokeThickness) &&
                void 0 !== o
                  ? o
                  : this.crosshairStrokeThickness),
              (this.crosshairStrokeDashArray =
                null !==
                  (l = null == e ? void 0 : e.crosshairStrokeDashArray) &&
                void 0 !== l
                  ? l
                  : this.crosshairStrokeDashArray),
              (this.crosshairStroke =
                null !== (d = null == e ? void 0 : e.crosshairStroke) &&
                void 0 !== d
                  ? d
                  : this.crosshairStroke),
              (this.tooltipContainerBackground =
                null !==
                  (h = null == e ? void 0 : e.tooltipContainerBackground) &&
                void 0 !== h
                  ? h
                  : this.tooltipContainerBackground),
              (this.tooltipTextStroke =
                null !== (u = null == e ? void 0 : e.tooltipTextStroke) &&
                void 0 !== u
                  ? u
                  : this.tooltipTextStroke),
              (this.tooltipShadow =
                null !== (c = null == e ? void 0 : e.tooltipShadow) &&
                void 0 !== c
                  ? c
                  : this.tooltipShadowProperty),
              (this.showTooltip =
                null !== (p = null == e ? void 0 : e.showTooltip) &&
                void 0 !== p
                  ? p
                  : this.showTooltip),
              (this.showAxisLabels =
                null !== (y = null == e ? void 0 : e.showAxisLabels) &&
                void 0 !== y
                  ? y
                  : this.showAxisLabels),
              (this.axisLabelFill =
                null !== (f = null == e ? void 0 : e.axisLabelFill) &&
                void 0 !== f
                  ? f
                  : this.axisLabelFill),
              (this.axisLabelStroke =
                null !== (v = null == e ? void 0 : e.axisLabelStroke) &&
                void 0 !== v
                  ? v
                  : this.axisLabelStroke),
              (this.xAxisLabelStroke =
                null !== (m = null == e ? void 0 : e.xAxisLabelStroke) &&
                void 0 !== m
                  ? m
                  : this.xAxisLabelStroke),
              (this.xAxisLabelFill =
                null !== (S = null == e ? void 0 : e.xAxisLabelFill) &&
                void 0 !== S
                  ? S
                  : this.xAxisLabelFill),
              (this.yAxisLabelStroke =
                null !== (P = null == e ? void 0 : e.yAxisLabelStroke) &&
                void 0 !== P
                  ? P
                  : this.yAxisLabelStroke),
              (this.yAxisLabelFill =
                null !== (C = null == e ? void 0 : e.yAxisLabelFill) &&
                void 0 !== C
                  ? C
                  : this.yAxisLabelFill),
              (this.placementDivIdProperty =
                null !== (b = null == e ? void 0 : e.placementDivId) &&
                void 0 !== b
                  ? b
                  : this.placementDivIdProperty),
              (null == e ? void 0 : e.tooltipLegendTemplate) &&
                "string" == typeof e.tooltipLegendTemplate &&
                (this.typeMap.set(
                  "tooltipLegendTemplate",
                  e.tooltipLegendTemplate
                ),
                (e.tooltipLegendTemplate = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.tooltipLegendTemplate
                ))),
              (this.tooltipLegendTemplate =
                null !== (x = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== x
                  ? x
                  : this.tooltipLegendTemplate),
              (this.tooltipLegendOffsetX =
                null !== (A = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== A
                  ? A
                  : this.tooltipLegendOffsetX),
              (this.tooltipLegendOffsetY =
                null !== (T = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== T
                  ? T
                  : this.tooltipLegendOffsetY),
              (null == e ? void 0 : e.tooltipDataTemplate) &&
                "string" == typeof e.tooltipDataTemplate &&
                (this.typeMap.set("tooltipDataTemplate", e.tooltipDataTemplate),
                (e.tooltipDataTemplate = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.tooltipDataTemplate
                ))),
              (this.tooltipDataTemplateProperty =
                null !== (E = null == e ? void 0 : e.tooltipDataTemplate) &&
                void 0 !== E
                  ? E
                  : this.tooltipDataTemplateProperty),
              (this.showXLine =
                null !== (R = null == e ? void 0 : e.showXLine) && void 0 !== R
                  ? R
                  : this.showXLine),
              (this.showYLine =
                null !== (D = null == e ? void 0 : e.showYLine) && void 0 !== D
                  ? D
                  : this.showYLine),
              (this.hitTestRadius =
                null !== (w = null == e ? void 0 : e.hitTestRadius) &&
                void 0 !== w
                  ? w
                  : this.hitTestRadius);
          }
          applyTheme(e) {
            this.testPropertyChanged(f.PROPERTY.CROSSHAIR_STROKE) ||
              (this.crosshairStroke = e.cursorLineBrush),
              this.testPropertyChanged(f.PROPERTY.TOOLTIP_SHADOW) ||
                (this.tooltipShadow = e.shadowEffectColor);
          }
          onAttach() {
            var e;
            super.onAttach();
            const r = this.xAxisLabelFill
                ? this.xAxisLabelFill
                : this.axisLabelFill,
              i = this.yAxisLabelFill
                ? this.yAxisLabelFill
                : this.axisLabelFill,
              o = this.xAxisLabelStroke
                ? this.xAxisLabelStroke
                : this.axisLabelStroke,
              a = this.yAxisLabelStroke
                ? this.yAxisLabelStroke
                : this.axisLabelStroke;
            this.showXLine &&
              ((this.xLineAnnotation = this.newLineAnnotation(r, o)),
              this.parentSurface.modifierAnnotations.add(this.xLineAnnotation)),
              this.showYLine &&
                ((this.yLineAnnotation = this.newLineAnnotation(i, a)),
                this.parentSurface.modifierAnnotations.add(
                  this.yLineAnnotation
                )),
              (this.tooltipAnnotation = new c.CursorTooltipSvgAnnotation({
                cursorModifier: this,
                xCoordinateMode: h.ECoordinateMode.Pixel,
                yCoordinateMode: h.ECoordinateMode.Pixel,
                tooltipSvgTemplate:
                  null !== (e = this.tooltipSvgTemplate) && void 0 !== e
                    ? e
                    : t.defaultCursorTooltipSvgTemplate,
                containerBackground: this.tooltipContainerBackground,
                textStroke: this.tooltipTextStroke,
                tooltipLegendTemplate: this.tooltipLegendTemplate,
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
                placementDivId: this.placementDivId,
                clipping: u.EAnnotationClippingMode.Chart,
              })),
              this.parentSurface.modifierAnnotations.add(
                this.tooltipAnnotation
              );
          }
          onDetach() {
            super.onDetach(),
              this.xLineAnnotation &&
                this.parentSurface.modifierAnnotations.remove(
                  this.xLineAnnotation,
                  !0
                ),
              this.yLineAnnotation &&
                this.parentSurface.modifierAnnotations.remove(
                  this.yLineAnnotation,
                  !0
                ),
              this.parentSurface.modifierAnnotations.remove(
                this.tooltipAnnotation,
                !0
              );
          }
          onAttachSeries(e) {
            this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
          }
          onDetachSeries(e) {
            this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
          }
          modifierMouseMove(e) {
            if (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent)
              return;
            let t;
            this.activePointerEvents.set(e.pointerId, e),
              super.modifierMouseMove(e),
              this.mousePoint
                ? ((t = (0, d.translateFromCanvasToSeriesViewRect)(
                    this.mousePoint,
                    this.parentSurface.seriesViewRect
                  )),
                  (this.mousePosition = t
                    ? n.EMousePosition.SeriesArea
                    : n.EMousePosition.AxisArea))
                : (this.mousePosition = n.EMousePosition.OutOfCanvas),
              this.getIsActionAllowed(e) && this.update();
          }
          modifierMouseLeave(e) {
            super.modifierMouseLeave(e),
              (this.mousePosition = n.EMousePosition.OutOfCanvas),
              this.update();
          }
          onParentSurfaceRendered() {
            this.update();
          }
          get crosshairStroke() {
            return this.crosshairStrokeProperty;
          }
          set crosshairStroke(e) {
            this.crosshairStrokeProperty !== e &&
              ((this.crosshairStrokeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.CROSSHAIR_STROKE));
          }
          get tooltipShadow() {
            return this.tooltipShadowProperty;
          }
          set tooltipShadow(e) {
            this.tooltipShadowProperty !== e &&
              ((this.tooltipShadowProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.TOOLTIP_SHADOW));
          }
          get showXLine() {
            return this.showXLineProperty;
          }
          set showXLine(e) {
            if (this.showXLineProperty !== e) {
              if (
                ((this.showXLineProperty = e),
                this.showXLineProperty && !this.xLineAnnotation)
              ) {
                const e = this.xAxisLabelFill
                    ? this.xAxisLabelFill
                    : this.axisLabelFill,
                  t = this.xAxisLabelStroke
                    ? this.xAxisLabelStroke
                    : this.axisLabelStroke;
                (this.xLineAnnotation = this.newLineAnnotation(e, t)),
                  this.parentSurface.modifierAnnotations.add(
                    this.xLineAnnotation
                  );
              } else
                !this.showXLineProperty &&
                  this.xLineAnnotation &&
                  (this.parentSurface.modifierAnnotations.remove(
                    this.xLineAnnotation
                  ),
                  (this.xLineAnnotation = (0, o.deleteSafe)(
                    this.xLineAnnotation
                  )));
              this.notifyPropertyChanged(f.PROPERTY.X_LINE);
            }
          }
          get showYLine() {
            return this.showYLineProperty;
          }
          set showYLine(e) {
            if (this.showYLineProperty !== e) {
              if (
                ((this.showYLineProperty = e),
                this.showYLineProperty && !this.yLineAnnotation)
              ) {
                const e = this.yAxisLabelFill
                    ? this.yAxisLabelFill
                    : this.axisLabelFill,
                  t = this.yAxisLabelStroke
                    ? this.yAxisLabelStroke
                    : this.axisLabelStroke;
                (this.yLineAnnotation = this.newLineAnnotation(e, t)),
                  this.parentSurface.modifierAnnotations.add(
                    this.yLineAnnotation
                  );
              } else
                !this.showYLineProperty &&
                  this.yLineAnnotation &&
                  (this.parentSurface.modifierAnnotations.remove(
                    this.yLineAnnotation
                  ),
                  (this.yLineAnnotation = (0, o.deleteSafe)(
                    this.yLineAnnotation
                  )));
              this.notifyPropertyChanged(f.PROPERTY.Y_LINE);
            }
          }
          get showAxisLabels() {
            return this.showAxisLabelsProperty;
          }
          set showAxisLabels(e) {
            this.showAxisLabelsProperty !== e &&
              ((this.showAxisLabelsProperty = e),
              this.xLineAnnotation &&
                (this.xLineAnnotation.showLabel = this.showAxisLabelsProperty),
              this.yLineAnnotation &&
                (this.yLineAnnotation.showLabel = this.showAxisLabelsProperty),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_LABELS));
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.PLACEMENT_DIV_ID));
          }
          includeSeries(e, t) {
            return (
              !!super.includeSeries(e, t) &&
              (this.isAttached &&
                (this.tooltipAnnotation.seriesInfos = this.getSeriesInfos()),
              !0)
            );
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.TOOLTIP_DATA_TEMPLATE);
          }
          hitTestRenderableSeries(e, t) {
            if (t)
              return this.hitTestRadius <= 0
                ? e.hitTestProvider.hitTestXSlice(t.x, t.y)
                : e.hitTestProvider.hitTestDataPoint(
                    t.x,
                    t.y,
                    this.hitTestRadius
                  );
          }
          getMousePosition() {
            return this.mousePosition;
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                axisLabelFill: this.axisLabelFill,
                axisLabelStroke: this.axisLabelStroke,
                xAxisLabelFill: this.xAxisLabelFill,
                xAxisLabelStroke: this.xAxisLabelStroke,
                yAxisLabelFill: this.yAxisLabelFill,
                yAxisLabelStroke: this.yAxisLabelStroke,
                crosshairStroke: this.crosshairStroke,
                crosshairStrokeDashArray: this.crosshairStrokeDashArray,
                crosshairStrokeThickness: this.crosshairStrokeThickness,
                hitTestRadius: this.hitTestRadius,
                placementDivId: this.placementDivId,
                showAxisLabels: this.showAxisLabels,
                showTooltip: this.showTooltip,
                showXLine: this.showXLine,
                showYLine: this.showYLine,
                tooltipContainerBackground: this.tooltipContainerBackground,
                tooltipDataTemplate: this.typeMap.get("tooltipDataTemplate"),
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                tooltipLegendTemplate: this.typeMap.get(
                  "tooltipLegendTemplate"
                ),
                tooltipSvgTemplate: this.typeMap.get("tooltipSvgTemplate"),
                tooltipTextStroke: this.tooltipTextStroke,
                tooltipShadow: this.tooltipShadow,
              };
            return Object.assign(e.options, t), e;
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              e === f.PROPERTY.X_AXIS_ID &&
                (this.tooltipAnnotation &&
                  (this.tooltipAnnotation.xAxisId = this.xAxisId),
                this.xLineAnnotation &&
                  (this.xLineAnnotation.xAxisId = this.xAxisId),
                this.yLineAnnotation &&
                  (this.yLineAnnotation.xAxisId = this.xAxisId)),
              e === f.PROPERTY.Y_AXIS_ID &&
                (this.tooltipAnnotation &&
                  (this.tooltipAnnotation.yAxisId = this.yAxisId),
                this.xLineAnnotation &&
                  (this.xLineAnnotation.yAxisId = this.yAxisId),
                this.yLineAnnotation &&
                  (this.yLineAnnotation.yAxisId = this.yAxisId));
          }
          getSeriesInfos() {
            return this.getIncludedRenderableSeries()
              .map((e) => {
                const t = this.hitTestRenderableSeries(e, this.mousePoint);
                if (t) return e.getSeriesInfo(t);
              })
              .filter((e) => void 0 !== e);
          }
          update() {
            if (this.mousePosition !== n.EMousePosition.SeriesArea)
              return (
                this.xLineAnnotation && (this.xLineAnnotation.isHidden = !0),
                this.yLineAnnotation && (this.yLineAnnotation.isHidden = !0),
                (this.tooltipAnnotation.isHidden = !0),
                (this.tooltipAnnotation.seriesInfos = []),
                void (this.placementDivId && this.tooltipAnnotation.delete())
              );
            const e = (0, d.translateFromCanvasToSeriesViewRect)(
              this.mousePoint,
              this.parentSurface.seriesViewRect
            );
            if (
              (this.xLineAnnotation && (this.xLineAnnotation.isHidden = !1),
              this.yLineAnnotation && (this.yLineAnnotation.isHidden = !1),
              (this.tooltipAnnotation.isHidden = !1),
              (this.tooltipAnnotation.showTooltip = this.showTooltip),
              e)
            ) {
              const t = (0, d.translateToNotScaled)(e.x),
                r = (0, d.translateToNotScaled)(e.y);
              if (
                (this.xLineAnnotation && (this.xLineAnnotation.y1 = 0),
                this.yLineAnnotation && (this.yLineAnnotation.x1 = 0),
                this.parentSurface.isPolar)
              ) {
                const e = this.yAxis,
                  i = e.reverseTransform(t, r);
                this.xLineAnnotation &&
                  ((this.xLineAnnotation.x1 = 0),
                  (this.xLineAnnotation.x2 = i.y),
                  (this.xLineAnnotation.y2 = e.getAxisSize()));
              } else
                this.isVerticalChart()
                  ? (this.xLineAnnotation &&
                      ((this.xLineAnnotation.y2 = (0, d.translateToNotScaled)(
                        this.parentSurface.seriesViewRect.right
                      )),
                      (this.xLineAnnotation.x1 = r),
                      (this.xLineAnnotation.x2 = r)),
                    this.yLineAnnotation &&
                      ((this.yLineAnnotation.x2 = (0, d.translateToNotScaled)(
                        this.parentSurface.seriesViewRect.bottom
                      )),
                      (this.yLineAnnotation.y1 = t),
                      (this.yLineAnnotation.y2 = t)))
                  : (this.xLineAnnotation &&
                      ((this.xLineAnnotation.y2 = (0, d.translateToNotScaled)(
                        this.parentSurface.seriesViewRect.bottom
                      )),
                      (this.xLineAnnotation.x1 = t),
                      (this.xLineAnnotation.x2 = t)),
                    this.yLineAnnotation &&
                      ((this.yLineAnnotation.x2 = (0, d.translateToNotScaled)(
                        this.parentSurface.seriesViewRect.right
                      )),
                      (this.yLineAnnotation.y1 = r),
                      (this.yLineAnnotation.y2 = r)));
              this.showTooltip &&
                ((this.tooltipAnnotation.x1 = t),
                (this.tooltipAnnotation.y1 = r)),
                (this.showTooltip || this.tooltipLegendTemplate) &&
                  (this.tooltipAnnotation.seriesInfos = this.getSeriesInfos());
            }
          }
          newLineAnnotation(e, t) {
            return new p.LineAnnotation({
              xCoordinateMode: h.ECoordinateMode.Pixel,
              yCoordinateMode: h.ECoordinateMode.Pixel,
              strokeThickness: this.crosshairStrokeThickness,
              strokeDashArray: this.crosshairStrokeDashArray,
              stroke: this.crosshairStroke,
              isHidden: !0,
              showLabel: this.showAxisLabels,
              axisLabelFill: e,
              axisLabelStroke: t,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
            });
          }
          isVerticalChart() {
            var e, t;
            return (
              null !==
                (t =
                  null === (e = this.xAxis) || void 0 === e
                    ? void 0
                    : e.isVerticalChart) &&
              void 0 !== t &&
              t
            );
          }
        }
        t.CursorModifier = v;
        const m = (e, t) => {
          const r = [];
          return (
            t && r.push(t),
            e.forEach((e, t) => {
              var i;
              if (e.isHit) {
                const o =
                  null !== (i = e.seriesName) && void 0 !== i
                    ? i
                    : `Series #${t + 1}`;
                r.push(...e.getValuesWithLabels(o, "X", "Y", !1));
              }
            }),
            r
          );
        };
        (t.defaultCursorTooltipSvgTemplate = (e, r) => {
          var i;
          const o = `id_${Date.now()}`,
            a = (
              null !== (i = r.cursorModifier.tooltipDataTemplate) &&
                void 0 !== i
                ? i
                : m
            )(e, r.title);
          if (0 === a.length) return "<svg></svg>";
          const { width: s, height: n } = (0, t.calcTooltipSize)(a, 13);
          (0, t.adjustTooltipPosition)(s, n, r);
          let h = "";
          a.forEach((e, t) => {
            h += `<tspan x="8" dy="1.2em">${e}</tspan>`;
          });
          let u = "95%";
          r.yCoordShift < 0 &&
            n >
              (0, d.translateToNotScaled)(
                r.parentSurface.seriesViewRect.height
              ) -
                r.y1 &&
            (u = (n - 5).toFixed(0));
          const c = r.containerBackground,
            p = r.textStroke,
            g = r.cursorModifier.tooltipShadow;
          let y =
            '<feGaussianBlur result="blurOut" in="offOut" stdDeviation="3" />';
          if (void 0 !== g) {
            const e = (0, l.parseColorToTArgb)(g);
            y = `<feColorMatrix result="matrixOut" in="offOut" type="matrix"\n        values="0 0 0 0 ${
              e.red / 255
            }\n                0 0 0 0 ${
              e.green / 255
            }\n                0 0 0 0 ${e.blue / 255}\n                0 0 0 ${
              e.opacity / 255
            } 0" />\n        <feGaussianBlur result="blurOut" in="matrixOut" stdDeviation="3" />`;
          }
          return `<svg class="scichart__cursor-tooltip" width="${s}" height="${n}">\n        <defs>\n            <filter id="${o}" x="0" y="0" width="200%" height="200%">\n                <feOffset result="offOut" in="SourceAlpha" dx="3" dy="3" />\n                ${y}\n                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />\n            </filter>\n        </defs>\n        <rect rx="4" ry="4" width="95%" height="${u}" fill="${c}" filter="url(#${o})" />\n        <svg width="100%">\n            <text x="8" y="3" font-size="13" font-family="Verdana" dy="0" fill="${p}">${h}</text>\n        </svg>\n    </svg>`;
        }),
          (t.calcTooltipSize = (e, t = 13) => ({
            width:
              8 * e.reduce((e, t) => (t.length > e ? t.length : e), 0) + 20,
            height: 1.2 * t * e.length + 16,
          })),
          (t.adjustTooltipPosition = (e, t, r) => {
            const { seriesViewRect: i } = r.parentSurface,
              o = r.x1,
              a = r.y1,
              s = (0, d.translateToNotScaled)(i.width) - o < e ? -e : 5,
              n = (0, d.translateToNotScaled)(i.height) - a < t ? -t : 5;
            (r.xCoordShift = s), (r.yCoordShift = n);
          });
      },
      42639: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomChartModifier2D = void 0);
        const i = r(89955),
          o = r(89046);
        class a extends o.ChartModifierBase2D {
          constructor(e) {
            super(e), (this.type = i.EChart2DModifierType.Custom);
          }
        }
        t.CustomChartModifier2D = a;
      },
      36534: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataPointInfo = void 0),
          (t.DataPointInfo = class {
            constructor(e, t, r) {
              (this.renderableSeriesProperty = e),
                (this.indexProperty = r),
                (this.metadataProperty = t);
            }
            get metadata() {
              return this.metadataProperty;
            }
            set metadata(e) {
              this.metadataProperty = e;
            }
            get index() {
              return this.indexProperty;
            }
            get xValue() {
              return this.dataSeries.getNativeXValues().get(this.index);
            }
            get yValue() {
              return this.dataSeries.getNativeYValues().get(this.index);
            }
            get renderableSeries() {
              return this.renderableSeriesProperty;
            }
            get dataSeries() {
              return this.renderableSeries.dataSeries;
            }
            get seriesName() {
              return this.renderableSeries.seriesName;
            }
          });
      },
      897: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataPointSelectionChangedArgs = void 0),
          (t.DataPointSelectionChangedArgs = class {
            constructor(e, t) {
              (this.source = e), (this.selectedDataPoints = t);
            }
          });
      },
      71575: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataPointSelectionModifier = t.ESelectionMode = void 0);
        const i = r(45921),
          o = r(56744),
          a = r(3214),
          s = r(87459),
          n = r(11043),
          l = r(6859),
          d = r(89955),
          h = r(21670),
          u = r(32873),
          c = r(51885),
          p = r(33906),
          g = r(7541),
          y = r(90182),
          f = r(89046),
          v = r(22486),
          m = r(36534),
          S = r(897),
          P = r(18809);
        var C;
        !(function (e) {
          (e.Union = "Union"), (e.Inverse = "Inverse"), (e.Replace = "Replace");
        })((C = t.ESelectionMode || (t.ESelectionMode = {})));
        class b extends f.ChartModifierBase2D {
          constructor(e) {
            var t, r, o, s;
            super(e),
              (this.type = d.EChart2DModifierType.DataPointSelection),
              (this.selectionChanged = new a.EventHandler()),
              (this.selectedDataPointsMap = new Map()),
              (this.selectionHasChanged = !1),
              (this.allowClickSelect =
                null === (t = null == e ? void 0 : e.allowClickSelect) ||
                void 0 === t ||
                t),
              (this.allowDragSelect =
                null === (r = null == e ? void 0 : e.allowDragSelect) ||
                void 0 === r ||
                r),
              (this.executeCondition =
                null !== (o = null == e ? void 0 : e.executeCondition) &&
                void 0 !== o
                  ? o
                  : { button: l.EExecuteOn.MouseLeftButton }),
              (null == e ? void 0 : e.selectionStroke) &&
                (this.selectionStroke = e.selectionStroke),
              (null == e ? void 0 : e.selectionFill) &&
                (this.selectionFill = null == e ? void 0 : e.selectionFill),
              (this.selectionStrokeThicknessProperty =
                null !==
                  (s = null == e ? void 0 : e.selectionStrokeThickness) &&
                void 0 !== s
                  ? s
                  : 1),
              (null == e ? void 0 : e.onSelectionChanged) &&
                ("string" == typeof e.onSelectionChanged
                  ? (this.typeMap.set(
                      "onSelectionChanged",
                      e.onSelectionChanged
                    ),
                    this.selectionChanged.subscribe(
                      (0, i.getFunction)(
                        n.EBaseType.OptionFunction,
                        e.onSelectionChanged
                      )
                    ))
                  : this.selectionChanged.subscribe(e.onSelectionChanged)),
              (null == e ? void 0 : e.getSelectionMode) &&
                ("string" == typeof e.getSelectionMode
                  ? (this.typeMap.set("getSelectionMode", e.getSelectionMode),
                    (this.getSelectionMode = (0, i.getFunction)(
                      n.EBaseType.OptionFunction,
                      e.getSelectionMode
                    )))
                  : (this.getSelectionMode = e.getSelectionMode));
          }
          applyTheme(e) {
            this.testPropertyChanged(v.PROPERTY.SELECTION_FILL) ||
              (this.selectionFill = e.rubberBandFillBrush),
              this.testPropertyChanged(v.PROPERTY.SELECTION_STROKE) ||
                (this.selectionStroke = e.rubberBandStrokeBrush);
          }
          onAttach() {
            var e, t;
            super.onAttach(),
              (this.selectionRect = new y.RubberBandSvgRect(
                null === (e = this.parentSurface) || void 0 === e
                  ? void 0
                  : e.domSvgContainer,
                this.selectionFill,
                this.selectionStroke,
                this.selectionStrokeThickness
              )),
              this.clearSelectedDataPoints(),
              null === (t = this.getAllSeries()) ||
                void 0 === t ||
                t.forEach((e) => this.onAttachSeries(e));
          }
          onDetach() {
            var e;
            super.onDetach(),
              (this.selectionRect = (0, o.deleteSafe)(this.selectionRect)),
              this.clearSelectedDataPoints(),
              null === (e = this.getAllSeries()) ||
                void 0 === e ||
                e.forEach((e) => this.onDetachSeries(e));
          }
          get selectedDataPoints() {
            return Array.from(this.selectedDataPointsMap.values());
          }
          onAttachSeries(e) {
            if (
              (super.onAttachSeries(e),
              !e.dataSeries ||
                e.dataSeries.type === c.EDataSeriesType.HeatmapUniform)
            )
              return;
            const t = e.dataSeries;
            t.hasMetadataGenerator() ||
              t.setMetadataGenerator(
                new p.TemplateMetadataGenerator({ isSelected: !1 })
              );
            for (let r = 0; r < t.getMetadataLength(); r++) {
              const i = t.getMetadataAt(r);
              if (null == i ? void 0 : i.isSelected) {
                const t = new m.DataPointInfo(e, i, r);
                this.addSelectedDataPoint(e, r, t);
              }
            }
            this.raiseSelectionChanged(!1);
          }
          onDetachSeries(e) {
            super.onDetachSeries(e),
              e.dataSeries &&
                (this.removeSelectedDataPointsForSeries(e),
                this.raiseSelectionChanged(!1));
          }
          modifierMouseDown(e) {
            if (
              (super.modifierMouseDown(e),
              !this.checkExecuteConditions(e).isPrimary)
            )
              return;
            if (!this.isAttached)
              throw new Error(
                "Should not call DataPointSelectionModifier.modifierMouseDown if not attached"
              );
            const t = (0, u.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect
            );
            t &&
              ((this.startPoint = t), (this.isClicked = !0), (e.handled = !0));
          }
          modifierMouseMove(e) {
            super.modifierMouseMove(e);
            const { seriesViewRect: t } = this.parentSurface;
            if (this.isClicked) {
              this.endPoint = (0, u.translateFromCanvasToSeriesViewRect)(
                s.Rect.clipPointToRect(e.mousePoint, t),
                t
              );
              const {
                x: r,
                right: i,
                y: o,
                bottom: a,
              } = (0, P.getRubberBandRect)(
                this.startPoint,
                this.endPoint,
                this.xyDirection,
                this.parentSurface.seriesViewRect
              );
              (this.selectionRect.isHidden = !this.allowDragSelect),
                (this.selectionRect.x1 = (0, u.translateToNotScaled)(r)),
                (this.selectionRect.x2 = (0, u.translateToNotScaled)(i)),
                (this.selectionRect.y1 = (0, u.translateToNotScaled)(o)),
                (this.selectionRect.y2 = (0, u.translateToNotScaled)(a));
            }
          }
          modifierMouseUp(e) {
            if (
              (super.modifierMouseUp(e),
              this.checkExecuteConditions(e).isPrimary)
            ) {
              if (!this.isAttached)
                throw new Error(
                  "Should not call DataPointSelectionModifier.modifierMouseUp if not attached"
                );
              if (this.isClicked) {
                const { seriesViewRect: t } = this.parentSurface;
                this.endPoint = (0, u.translateFromCanvasToSeriesViewRect)(
                  s.Rect.clipPointToRect(e.mousePoint, t),
                  t
                );
                const r = (0, P.getRubberBandRect)(
                    this.startPoint,
                    this.endPoint,
                    this.xyDirection,
                    this.parentSurface.seriesViewRect
                  ),
                  i = r.width >= 3 && r.height >= 3 && this.allowDragSelect,
                  o = this.getSelectionMode(e, i);
                i && this.allowDragSelect
                  ? this.selectManyPoints(r, o)
                  : this.allowClickSelect &&
                    this.selectSinglePoint(e.mousePoint, o),
                  (this.isClicked = !1),
                  (this.selectionRect.isHidden = !0);
              }
            }
          }
          get selectionStrokeThickness() {
            return this.selectionStrokeThicknessProperty;
          }
          set selectionStrokeThickness(e) {
            (this.selectionStrokeThicknessProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.SELECTION_STROKE_THICKNESS);
          }
          get selectionStroke() {
            return this.selectionStrokeProperty;
          }
          set selectionStroke(e) {
            (this.selectionStrokeProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.SELECTION_STROKE);
          }
          get selectionFill() {
            return this.selectionFillProperty;
          }
          set selectionFill(e) {
            (this.selectionFillProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.SELECTION_FILL);
          }
          getSelectionMode(e, t) {
            return e.ctrlKey ? C.Union : e.shiftKey ? C.Inverse : C.Replace;
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                allowClickSelect: this.allowClickSelect,
                allowDragSelect: this.allowDragSelect,
                getSelectionMode: this.typeMap.get("getSelectionMode"),
                onSelectionChanged: this.typeMap.get("onSelectionChanged"),
                selectionFill: this.selectionFill,
                selectionStroke: this.selectionStroke,
                selectionStrokeThickness: this.selectionStrokeThickness,
              };
            return Object.assign(e.options, t), e;
          }
          delete() {
            this.selectionChanged.unsubscribeAll(),
              (this.selectionRect = (0, o.deleteSafe)(this.selectionRect)),
              super.delete();
          }
          selectManyPoints(e, t) {
            this.parentSurface &&
              (t !== C.Replace || this.deselectAllPoints(!1),
              this.getIncludedRenderableSeries()
                .filter((e) => e.isVisible && e.dataSeries)
                .forEach((r, i) => {
                  const o = r.xAxis.getCurrentCoordinateCalculator(),
                    a = r.yAxis.getCurrentCoordinateCalculator();
                  let s, n, l, d;
                  if (
                    (o.getDataValue(e.left) <= o.getDataValue(e.right)
                      ? ((s = o.getDataValue(e.left)),
                        (n = o.getDataValue(e.right)))
                      : ((s = o.getDataValue(e.right)),
                        (n = o.getDataValue(e.left))),
                    a.getDataValue(e.top) <= a.getDataValue(e.bottom)
                      ? ((l = a.getDataValue(e.top)),
                        (d = a.getDataValue(e.bottom)))
                      : ((l = a.getDataValue(e.bottom)),
                        (d = a.getDataValue(e.top))),
                    r.dataSeries.type === c.EDataSeriesType.HeatmapUniform)
                  );
                  else {
                    const e = r.dataSeries;
                    for (let i = 0; i < e.count(); i++) {
                      const o = e.getNativeXValues().get(i),
                        a = e.getNativeYValues().get(i);
                      if ((0, h.testIsInBounds)(o, a, s, d, n, l)) {
                        const o = e.getMetadataAt(i);
                        t !== C.Inverse
                          ? ((o.isSelected = !0),
                            this.addSelectedDataPoint(
                              r,
                              i,
                              new m.DataPointInfo(r, o, i)
                            ))
                          : o.isSelected
                          ? ((o.isSelected = !1),
                            this.removeSelectedDataPoint(r, i))
                          : ((o.isSelected = !0),
                            this.addSelectedDataPoint(
                              r,
                              i,
                              new m.DataPointInfo(r, o, i)
                            ));
                      }
                    }
                  }
                }),
              this.raiseSelectionChanged(!0));
          }
          selectSinglePoint(e, t) {
            if (this.parentSurface) {
              const r = this.getIncludedRenderableSeries()
                .filter((e) => e.isVisible && e.dataSeries)
                .map((t) => ({
                  renderableSeries: t,
                  hitTestInfo:
                    t.hitTestProvider.hitTestForDataPointSelectionModifier(
                      e.x,
                      e.y,
                      g.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
                    ),
                }));
              t !== C.Replace || this.deselectAllPoints(!1),
                r.forEach((e) => {
                  const r = e.hitTestInfo,
                    i = e.renderableSeries;
                  if (r.isHit)
                    if (r.metadata)
                      if (t === C.Union) {
                        r.metadata.isSelected = !0;
                        const e = new m.DataPointInfo(
                          r.associatedSeries,
                          r.metadata,
                          r.dataSeriesIndex
                        );
                        this.addSelectedDataPoint(
                          r.associatedSeries,
                          r.dataSeriesIndex,
                          e
                        );
                      } else
                        (r.metadata.isSelected = !r.metadata.isSelected),
                          r.metadata.isSelected
                            ? this.addSelectedDataPoint(
                                i,
                                r.dataSeriesIndex,
                                new m.DataPointInfo(
                                  r.associatedSeries,
                                  r.metadata,
                                  r.dataSeriesIndex
                                )
                              )
                            : this.removeSelectedDataPoint(
                                i,
                                r.dataSeriesIndex
                              );
                    else
                      console.warn(
                        `Cannot select datapoint for series ${r.seriesName} as it does not have metadata. To solve this either:\nConfigure metadata when you create the series or when you add data eg renderableSeries.dataSeries = new XyDataSeries(wasmContext, { metadata: { isSelected: false }}), or:\nAdd the DataPointSelectionModifier after all series have had their dataSeries set.`
                      );
                }),
                this.raiseSelectionChanged(!0);
            }
          }
          deselectAllPoints(e = !0) {
            this.selectedDataPoints.forEach((e) => {
              e.renderableSeries && e.metadata && (e.metadata.isSelected = !1);
            }),
              this.clearSelectedDataPoints(),
              e && this.raiseSelectionChanged(!0);
          }
          addSelectedDataPoint(e, t, r) {
            this.selectedDataPointsMap.set(x(e, t), r),
              (this.selectionHasChanged = !0);
          }
          removeSelectedDataPoint(e, t) {
            this.selectedDataPointsMap.delete(x(e, t)),
              (this.selectionHasChanged = !0);
          }
          clearSelectedDataPoints() {
            this.selectedDataPointsMap.size > 0 &&
              (this.selectionHasChanged = !0),
              this.selectedDataPointsMap.clear();
          }
          removeSelectedDataPointsForSeries(e) {
            this.selectedDataPointsMap.forEach((t, r) => {
              t.renderableSeries === e &&
                (this.selectedDataPointsMap.delete(r),
                (this.selectionHasChanged = !0));
            });
          }
          raiseSelectionChanged(e) {
            var t;
            this.selectionHasChanged &&
              (this.selectionChanged.raiseEvent(
                new S.DataPointSelectionChangedArgs(
                  this,
                  this.selectedDataPoints
                )
              ),
              (this.selectionHasChanged = !1),
              e &&
                (null === (t = this.parentSurface) ||
                  void 0 === t ||
                  t.invalidateElement()));
          }
        }
        t.DataPointSelectionModifier = b;
        const x = (e, t) => `${e.id}_${t}`;
      },
      9656: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LegendModifier = void 0);
        const i = r(3214),
          o = r(89955),
          a = r(96260),
          s = r(89046);
        class n extends s.ChartModifierBase2D {
          constructor(e) {
            var t, r, s;
            super(e),
              (this.type = o.EChart2DModifierType.Legend),
              (this.isCheckedChanged = new i.EventHandler()),
              (this.legendItemCheckedChanged =
                this.legendItemCheckedChanged.bind(this)),
              (this.sciChartLegend =
                null !== (t = null == e ? void 0 : e.legend) && void 0 !== t
                  ? t
                  : new a.SciChartLegend(e)),
              (this.sciChartLegend.showCheckboxes =
                null !== (r = null == e ? void 0 : e.showCheckboxes) &&
                void 0 !== r
                  ? r
                  : this.sciChartLegend.showCheckboxes),
              (this.sciChartLegend.showSeriesMarkers =
                null !== (s = null == e ? void 0 : e.showSeriesMarkers) &&
                void 0 !== s
                  ? s
                  : this.sciChartLegend.showSeriesMarkers),
              (this.sciChartLegend.legendItemCheckedChangedCallback =
                this.legendItemCheckedChanged),
              (null == e ? void 0 : e.isCheckedChangedCallback) &&
                this.isCheckedChanged.subscribe((t) =>
                  e.isCheckedChangedCallback(t.series, t.isChecked)
                );
          }
          applyTheme(e) {
            super.applyTheme(e), this.sciChartLegend.applyTheme();
          }
          onAttachSeries(e) {
            super.onAttachSeries(e),
              this.sciChartLegend.setRenderableSeriesArray(
                this.getIncludedRenderableSeries()
              ),
              this.sciChartLegend.setInvalidateParentSurface(
                this.parentSurface.invalidateElement
              );
          }
          onDetachSeries(e) {
            super.onDetachSeries(e),
              this.sciChartLegend.setRenderableSeriesArray(
                this.getIncludedRenderableSeries()
              );
          }
          onParentSurfaceRendered() {
            super.onParentSurfaceRendered();
          }
          onAttach() {
            super.onAttach(),
              this.sciChartLegend.attachTo(this.parentSurface),
              this.sciChartLegend.setRenderableSeriesArray(
                this.getIncludedRenderableSeries()
              );
          }
          onDetach() {
            var e, t;
            super.onDetach(),
              null === (e = this.sciChartLegend) ||
                void 0 === e ||
                e.setRenderableSeriesArray([]),
              null === (t = this.sciChartLegend) || void 0 === t || t.detach(),
              (this.sciChartLegend = void 0);
          }
          includeSeries(e, t) {
            var r;
            return (
              !!super.includeSeries(e, t) &&
              (this.isAttached &&
                this.sciChartLegend.setRenderableSeriesArray(
                  this.getIncludedRenderableSeries()
                ),
              null === (r = this.parentSurface) ||
                void 0 === r ||
                r.invalidateElement(),
              !0)
            );
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                margin: this.sciChartLegend.margin,
                orientation: this.sciChartLegend.orientation,
                placement: this.sciChartLegend.placement,
                showCheckboxes: this.sciChartLegend.showCheckboxes,
                showLegend: this.sciChartLegend.showLegend,
                showSeriesMarkers: this.sciChartLegend.showSeriesMarkers,
              };
            return Object.assign(e.options, t), e;
          }
          delete() {
            super.delete(), this.onDetach();
          }
          legendItemCheckedChanged(e, t) {
            var r;
            null === (r = this.isCheckedChanged) ||
              void 0 === r ||
              r.raiseEvent({ series: e, isChecked: t });
          }
        }
        t.LegendModifier = n;
      },
      14290: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ModifierArgsBase = void 0),
          (t.ModifierArgsBase = class {
            constructor() {
              this.handled = !1;
            }
          });
      },
      39299: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ModifierMouseArgs = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(86127),
          s = r(14290);
        class n extends s.ModifierArgsBase {
          constructor(e, t) {
            var r;
            super(),
              (this.isActiveSubChartEvent = !0),
              (this.mousePoint = e),
              (this.button = null == t ? void 0 : t.button),
              (this.mouseWheelDelta =
                null !== (r = null == t ? void 0 : t.mouseWheelDelta) &&
                void 0 !== r
                  ? r
                  : 0),
              (this.pointerId = null == t ? void 0 : t.pointerId),
              (this.pointerType = null == t ? void 0 : t.pointerType),
              (this.target = null == t ? void 0 : t.target),
              (this.isMaster = null == t ? void 0 : t.isMaster),
              (this.modifierGroup = null == t ? void 0 : t.modifierGroup),
              (this.shiftKey = null == t ? void 0 : t.shiftKey),
              (this.altKey = null == t ? void 0 : t.altKey),
              (this.ctrlKey = null == t ? void 0 : t.ctrlKey),
              (this.nativeEvent = null == t ? void 0 : t.nativeEvent);
          }
          static fromMouseEvent(e) {
            i.Guard.notNull(e, "mouseEvent");
            const t = new o.Point(
                e.offsetX * a.DpiHelper.PIXEL_RATIO,
                e.offsetY * a.DpiHelper.PIXEL_RATIO
              ),
              r = {
                target: e.target,
                isMaster: !0,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                nativeEvent: e,
              };
            return new n(t, r);
          }
          static fromWheelEvent(e) {
            i.Guard.notNull(e, "wheelEvent");
            const t = new o.Point(
                e.offsetX * a.DpiHelper.PIXEL_RATIO,
                e.offsetY * a.DpiHelper.PIXEL_RATIO
              ),
              r = {
                mouseWheelDelta: e.deltaY,
                target: e.target,
                isMaster: !0,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                nativeEvent: e,
              };
            return new n(t, r);
          }
          static fromPointerEvent(e) {
            i.Guard.notNull(e, "pointerEvent");
            const t = new o.Point(
                e.offsetX * a.DpiHelper.PIXEL_RATIO,
                e.offsetY * a.DpiHelper.PIXEL_RATIO
              ),
              r = {
                button: e.button,
                pointerId: e.pointerId,
                pointerType: e.pointerType,
                target: e.target,
                isMaster: !0,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                nativeEvent: e,
              };
            return new n(t, r);
          }
          static copy(e, t, r, i, a) {
            let s = e.mousePoint;
            if (r && i) {
              const t = e.mousePoint.x - r.x,
                a = e.mousePoint.y - r.y,
                n = i.width / r.width,
                l = i.height / r.height;
              s = new o.Point(i.x + t * n, i.y + a * l);
            }
            return Object.assign(Object.assign({}, e), {
              isMaster: !1,
              masterData: a,
              handled: !1,
              modifierGroup: t,
              mousePoint: s,
            });
          }
          static copyForSubChart(e, t, r, i, a) {
            let s = e.mousePoint;
            if (r && i) {
              const t = i.width / r.width,
                a = i.height / r.height;
              s = new o.Point(
                (e.mousePoint.x - r.x) * t + i.x,
                (e.mousePoint.y - r.y) * a + i.y
              );
            }
            return Object.assign(Object.assign({}, e), {
              isMaster: !1,
              masterData: a,
              handled: !1,
              modifierGroup: t,
              mousePoint: s,
            });
          }
        }
        t.ModifierMouseArgs = n;
      },
      56985: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MouseWheelZoomModifier = t.EActionType = void 0);
        const i = r(32616),
          o = r(89955),
          a = r(86699),
          s = r(14379),
          n = r(32873),
          l = r(57397),
          d = r(89046);
        var h;
        !(function (e) {
          (e.Zoom = "Zoom"), (e.Pan = "Pan");
        })((h = t.EActionType || (t.EActionType = {})));
        class u extends d.ChartModifierBase2D {
          constructor(e) {
            var t, r, s, n, l;
            super(e),
              (this.type = o.EChart2DModifierType.MouseWheelZoom),
              (this.growFactor = 0.001),
              (this.actionType = h.Zoom),
              (this.applyToSeriesViewRect = !0),
              (this.applyToAxes = !0),
              (this.growFactor =
                null !== (t = null == e ? void 0 : e.growFactor) && void 0 !== t
                  ? t
                  : this.growFactor),
              (this.actionType =
                null !== (r = null == e ? void 0 : e.actionType) && void 0 !== r
                  ? r
                  : this.actionType),
              (this.applyToSeriesViewRect =
                null !== (s = null == e ? void 0 : e.applyToSeriesViewRect) &&
                void 0 !== s
                  ? s
                  : this.applyToSeriesViewRect),
              (this.applyToAxes =
                null !== (n = null == e ? void 0 : e.applyToAxes) &&
                void 0 !== n
                  ? n
                  : this.applyToAxes),
              this.actionType === h.Pan &&
                this.xyDirection === a.EXyDirection.XyDirection &&
                (console.warn(
                  "SciChart MouseWheelZoomModifier: actionType=Pan and xyDirection=Xy conflict. Auto setting XyDirection to X"
                ),
                (this.xyDirection = a.EXyDirection.XDirection)),
              (this.executeCondition =
                null !== (l = null == e ? void 0 : e.executeCondition) &&
                void 0 !== l
                  ? l
                  : { button: void 0, key: i.EModifierMouseArgKey.None });
          }
          modifierMouseWheel(e) {
            if (!this.checkExecuteConditions(e).isPrimary) return;
            super.modifierMouseWheel(e);
            const t = (0, n.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect
            );
            if (t && this.applyToSeriesViewRect)
              this.actionType === h.Zoom
                ? (e.handled = this.performZoom(t, e.mouseWheelDelta))
                : this.actionType === h.Pan &&
                  (e.handled = this.performPan(e.mouseWheelDelta));
            else if (this.applyToAxes) {
              const t = [];
              [a.EXyDirection.XDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) && t.push(...this.getIncludedXAxis()),
                [
                  a.EXyDirection.YDirection,
                  a.EXyDirection.XyDirection,
                ].includes(this.xyDirection) &&
                  t.push(...this.getIncludedYAxis());
              const r = (0, d.getActiveAxes)(t, e.mousePoint);
              if (r.length > 0)
                if (((e.handled = !0), this.actionType === h.Zoom)) {
                  const t = this.growFactor * e.mouseWheelDelta,
                    i = (0, n.translateFromCanvasToSeriesViewRect)(
                      e.mousePoint,
                      this.parentSurface.seriesViewRect,
                      !0
                    );
                  r.forEach((e) => {
                    this.growBy(i, e, t);
                  });
                } else
                  this.actionType === h.Pan &&
                    r.forEach((t) => {
                      const r = this.getAxisSize(t),
                        i = e.mouseWheelDelta * this.growFactor * r;
                      t.scroll(i, l.EClipMode.None);
                    });
            }
            e.handled &&
              this.parentSurface.setZoomState(s.EZoomState.UserZooming);
          }
          performZoom(e, t) {
            const r = this.growFactor * t;
            let i = !1;
            return (
              [a.EXyDirection.XDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedXAxis().forEach((t) => {
                  this.growBy(e, t, r), (i = !0);
                }),
              [a.EXyDirection.YDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedYAxis().forEach((t) => {
                  this.growBy(e, t, r), (i = !0);
                }),
              i
            );
          }
          performPan(e) {
            let t = !1;
            return (
              [a.EXyDirection.XDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedXAxis().forEach((r) => {
                  const i = this.getAxisSize(r),
                    o = e * this.growFactor * i;
                  r.scroll(o, l.EClipMode.None), (t = !0);
                }),
              [a.EXyDirection.YDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedYAxis().forEach((r) => {
                  const i = this.getAxisSize(r),
                    o = e * this.growFactor * i;
                  r.scroll(o, l.EClipMode.None), (t = !0);
                }),
              t
            );
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                actionType: this.actionType,
                growFactor: this.growFactor,
                applyToSeriesViewRect: this.applyToSeriesViewRect,
                applyToAxes: this.applyToAxes,
              };
            return Object.assign(e.options, t), e;
          }
          getAxisSize(e) {
            let t = e.isHorizontalAxis ? e.viewRect.width : e.viewRect.height;
            return (
              Math.abs(t) < 1e-8 &&
                this.parentSurface &&
                (t = e.isHorizontalAxis
                  ? this.parentSurface.seriesViewRect.width
                  : this.parentSurface.seriesViewRect.height),
              t
            );
          }
        }
        t.MouseWheelZoomModifier = u;
      },
      55526: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OverviewRangeSelectionModifier = void 0);
        const i = r(31194),
          o = r(56744),
          a = r(98140),
          s = r(87459),
          n = r(6859),
          l = r(89955),
          d = r(86699),
          h = r(32873),
          u = r(31306),
          c = r(12021),
          p = r(89046);
        class g extends p.ChartModifierBase2D {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type = l.EChart2DModifierType.OverviewRangeSelection),
              (this.animationDuration = 1e3),
              (this.animate = !0),
              (this.isClicked = !1),
              (this.onSelectedAreaChanged =
                null == e ? void 0 : e.onSelectedAreaChanged),
              (this.xAxisId =
                null !== (t = null == e ? void 0 : e.xAxisId) && void 0 !== t
                  ? t
                  : this.xAxisId),
              (this.yAxisId =
                null !== (r = null == e ? void 0 : e.yAxisId) && void 0 !== r
                  ? r
                  : this.yAxisId),
              (this.executeCondition =
                null !== (i = null == e ? void 0 : e.executeCondition) &&
                void 0 !== i
                  ? i
                  : { button: n.EExecuteOn.MouseLeftButton });
          }
          onAttach() {
            super.onAttach(), this.updateSelectionAnnotation();
          }
          modifierMouseDown(e) {
            if (
              (super.modifierMouseDown(e),
              this.checkExecuteConditions(e).isPrimary)
            ) {
              if (!this.isAttached)
                throw new Error(
                  "Should not call OverviewRangeSelectionModifier.modifierMouseDown if not attached"
                );
              (0, h.translateFromCanvasToSeriesViewRect)(
                e.mousePoint,
                this.parentSurface.seriesViewRect
              ) && (this.isClicked = !0);
            }
          }
          modifierMouseUp(e) {
            var t;
            if (
              (super.modifierMouseUp(e),
              this.checkExecuteConditions(e).isPrimary)
            ) {
              if (!this.isAttached)
                throw new Error(
                  "Should not call OverviewRangeSelectionModifier.modifierMouseUp if not attached"
                );
              if (this.isClicked) {
                (e.handled = !0),
                  null === (t = this.overviewPositionAnimation) ||
                    void 0 === t ||
                    t.cancel();
                const { seriesViewRect: r } = this.parentSurface;
                (this.pointTo = (0, h.translateFromCanvasToSeriesViewRect)(
                  s.Rect.clipPointToRect(e.mousePoint, r),
                  r
                )),
                  (this.isClicked = !1);
                const o =
                    this.xAxis
                      .getCurrentCoordinateCalculator()
                      .getDataValue(
                        this.xAxis.isHorizontalAxis
                          ? this.pointTo.x
                          : this.pointTo.y
                      ) -
                    (this.rangeSelectionAnnotation.x1 +
                      this.rangeSelectionAnnotation.x2) /
                      2,
                  n = new a.NumberRange(
                    this.rangeSelectionAnnotation.x1,
                    this.rangeSelectionAnnotation.x2
                  ),
                  l = new a.NumberRange(
                    this.rangeSelectionAnnotation.x1 + o,
                    this.rangeSelectionAnnotation.x2 + o
                  ),
                  d = (e) => {
                    var t, r, i;
                    null === (t = this.rangeSelectionAnnotation) ||
                      void 0 === t ||
                      t.setCoordinates({ x1: e.min, x2: e.max }),
                      (this.annotationBeforeSelectedAreaProperty.x2 =
                        null === (r = this.rangeSelectionAnnotation) ||
                        void 0 === r
                          ? void 0
                          : r.x1),
                      (this.annotationAfterSelectedAreaProperty.x1 =
                        null === (i = this.rangeSelectionAnnotation) ||
                        void 0 === i
                          ? void 0
                          : i.x2),
                      this.onSelectedAreaChanged(
                        new a.NumberRange(
                          this.rangeSelectionAnnotation.x1,
                          this.rangeSelectionAnnotation.x2
                        )
                      );
                  };
                this.animate
                  ? ((this.overviewPositionAnimation =
                      i.NumberRangeAnimator.animate(
                        n,
                        l,
                        this.animationDuration,
                        d,
                        null
                      )),
                    this.parentSurface.addAnimation(
                      this.overviewPositionAnimation
                    ))
                  : d(l);
              }
            }
          }
          get rangeSelectionAnnotation() {
            return this.rangeSelectionAnnotationProperty;
          }
          get unselectedsvgString() {
            return this.annotationBeforeSelectedAreaProperty.svgString;
          }
          set unselectedsvgString(e) {
            (this.annotationBeforeSelectedAreaProperty.svgString = e),
              (this.annotationAfterSelectedAreaProperty.svgString = e);
          }
          get selectedArea() {
            return this.selectedAreaProperty;
          }
          set selectedArea(e) {
            var t, r, i, o, a;
            this.selectedAreaProperty = e;
            const s = this.xAxis;
            s &&
              (null === (t = this.rangeSelectionAnnotation) ||
                void 0 === t ||
                t.setCoordinates({ x1: e.min, x2: e.max }),
              null === (r = this.annotationBeforeSelectedAreaProperty) ||
                void 0 === r ||
                r.setCoordinates({
                  x1: s.visibleRange.min,
                  x2:
                    null === (i = this.rangeSelectionAnnotation) || void 0 === i
                      ? void 0
                      : i.x1,
                }),
              null === (o = this.annotationAfterSelectedAreaProperty) ||
                void 0 === o ||
                o.setCoordinates({
                  x1:
                    null === (a = this.rangeSelectionAnnotation) || void 0 === a
                      ? void 0
                      : a.x2,
                  x2: s.visibleRange.max,
                }));
          }
          createAnnotation(e) {
            return new c.OverviewCustomResizableAnnotation(e);
          }
          updateSelectionAnnotation() {
            if (this.parentSurface) {
              const e = () => {
                  var e;
                  null === (e = this.overviewPositionAnimation) ||
                    void 0 === e ||
                    e.cancel();
                  const t = new a.NumberRange(
                    this.rangeSelectionAnnotation.x1,
                    this.rangeSelectionAnnotation.x2
                  );
                  (this.selectedAreaProperty = t),
                    (this.annotationBeforeSelectedAreaProperty.x2 =
                      this.rangeSelectionAnnotation.x1),
                    (this.annotationAfterSelectedAreaProperty.x1 =
                      this.rangeSelectionAnnotation.x2),
                    this.onSelectedAreaChanged(t);
                },
                t = this.xAxis,
                r = {
                  xAxisId: this.xAxisId,
                  yAxisId: this.yAxisId,
                  opacity: 0.5,
                  y1: 0,
                  y2: 1,
                  xCoordinateMode: u.ECoordinateMode.DataValue,
                  yCoordinateMode: u.ECoordinateMode.Relative,
                  resizeDirections: d.EXyDirection.XDirection,
                },
                i = this.createAnnotation(
                  Object.assign(Object.assign({}, r), {
                    x1: this.selectedArea.min,
                    x2: this.selectedArea.max,
                    isEditable: !0,
                    svgString: v,
                    onDrag: e,
                  })
                ),
                s = this.createAnnotation(
                  Object.assign(Object.assign({}, r), {
                    x1: t.visibleRange.min,
                    x2: this.selectedArea.min,
                    svgString: m,
                  })
                ),
                n = this.createAnnotation(
                  Object.assign(Object.assign({}, r), {
                    x1: this.selectedArea.max,
                    x2: t.visibleRange.max,
                    svgString: m,
                  })
                );
              t.isHorizontalAxis
                ? ((i.adornerSvgStringTemplate = y),
                  (s.minWidth = 0),
                  (n.minWidth = 0))
                : ((i.adornerSvgStringTemplate = f),
                  (s.minHeight = 0),
                  (n.minHeight = 0)),
                (this.rangeSelectionAnnotationProperty = (0, o.deleteSafe)(
                  this.rangeSelectionAnnotation
                )),
                (this.annotationBeforeSelectedAreaProperty = (0, o.deleteSafe)(
                  this.annotationBeforeSelectedAreaProperty
                )),
                (this.annotationAfterSelectedAreaProperty = (0, o.deleteSafe)(
                  this.annotationAfterSelectedAreaProperty
                )),
                this.parentSurface.modifierAnnotations.remove(
                  this.rangeSelectionAnnotation
                ),
                this.parentSurface.modifierAnnotations.remove(
                  this.annotationBeforeSelectedAreaProperty
                ),
                this.parentSurface.modifierAnnotations.remove(
                  this.annotationAfterSelectedAreaProperty
                ),
                this.parentSurface.modifierAnnotations.add(i),
                this.parentSurface.modifierAnnotations.add(s),
                this.parentSurface.modifierAnnotations.add(n),
                (this.rangeSelectionAnnotationProperty = i),
                (this.annotationBeforeSelectedAreaProperty = s),
                (this.annotationAfterSelectedAreaProperty = n);
            }
          }
        }
        t.OverviewRangeSelectionModifier = g;
        const y = (e, t, r, i) => {
            const o = "black",
              a = "#2e2e2e",
              s = r - e,
              n = i - t;
            return `<svg x="${e}" y="${t}" width="${s}px" height="${n}px" viewBox="0 0 ${s} ${n}" overflow="visible" xmlns="http://www.w3.org/2000/svg">\n        <line x1="0" y1="0" x2="${s}" y2="0" stroke="${o}" stroke-width="1" />\n        <line x1="0" y1="${n}" x2="${s}" y2="${n}" stroke="${o}" stroke-width="1" />\n        <line x1="0" y1="0" x2="0" y2="${n}" stroke="${o}" stroke-width="1" />\n        <line x1="${s}" y1="0" x2="${s}" y2="${n}" stroke="${o}" stroke-width="1" />\n        <rect x="-3" y="30%" width="7" height="40%" fill="${a}" rx="5" stroke="${o}" />\n        <rect x="${
              s - 3
            }" y="30%" width="7" height="40%" fill="${a}" rx="5" stroke="${o}" />\n        </svg>`;
          },
          f = (e, t, r, i) => {
            const o = "black",
              a = "#2e2e2e",
              s = r - e,
              n = i - t;
            return `<svg x="${e}" y="${t}" width="${s}px" height="${n}px" viewBox="0 0 ${s} ${n}" overflow="visible" xmlns="http://www.w3.org/2000/svg">\n        <line x1="0" y1="0" x2="${s}" y2="0" stroke="${o}" stroke-width="1" />\n        <line x1="0" y1="${n}" x2="${s}" y2="${n}" stroke="${o}" stroke-width="1" />\n        <line x1="0" y1="0" x2="0" y2="${n}" stroke="${o}" stroke-width="1" />\n        <line x1="${s}" y1="0" x2="${s}" y2="${n}" stroke="${o}" stroke-width="1" />\n        <rect x="30%" y="-3" width="40%" height="7" fill="${a}" rx="5" stroke="${o}" />\n        <rect x="30%" y="${
              n - 3
            }" width="40%" height="7" fill="${a}" rx="5" stroke="${o}" />\n        </svg>`;
          },
          v =
            '<svg width="50" height="50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n    <rect width="100%" height="100%" style="fill:transparent">\n    </rect>\n</svg>',
          m =
            '<svg width="50" height="50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n        <rect width="100%" height="100%" style="fill:black">\n        </rect>\n    </svg>';
      },
      21562: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PinchZoomModifier = void 0);
        const i = r(75772),
          o = r(89955),
          a = r(86699),
          s = r(14379),
          n = r(32873),
          l = r(89046);
        class d extends l.ChartModifierBase2D {
          constructor(e) {
            var t, r;
            super(e),
              (this.horizontalGrowFactor = 0.005),
              (this.verticalGrowFactor = 0.005),
              (this.getMiddlePoint = (e, t) =>
                new i.Point((e.x + t.x) / 2, (e.y + t.y) / 2)),
              (this.type = o.EChart2DModifierType.PinchZoom),
              (this.horizontalGrowFactor =
                null !== (t = null == e ? void 0 : e.horizontalGrowFactor) &&
                void 0 !== t
                  ? t
                  : this.horizontalGrowFactor),
              (this.verticalGrowFactor =
                null !== (r = null == e ? void 0 : e.verticalGrowFactor) &&
                void 0 !== r
                  ? r
                  : this.verticalGrowFactor);
          }
          modifierMouseDown(e) {
            if ((super.modifierMouseDown(e), !this.isAttached))
              throw new Error(
                "Should not call PinchZoomModifier.modifierMouseDown if not attached"
              );
            (0, n.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect
            ) &&
              ("touch" === e.pointerType || "pen" === e.pointerType) &&
              this.activePointerEvents.set(e.pointerId, e);
          }
          modifierMouseMove(e) {
            super.modifierMouseMove(e),
              this.getIsActionAllowed(e) &&
                (this.parentSurface.setZoomState(s.EZoomState.UserZooming),
                this.performModifierAction(e));
          }
          modifierMouseUp(e) {
            super.modifierMouseUp(e), this.removeFromActiveTouchEvents(e);
          }
          modifierPointerCancel(e) {
            super.modifierPointerCancel(e), this.removeFromActiveTouchEvents(e);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                horizontalGrowFactor: this.horizontalGrowFactor,
                verticalGrowFactor: this.verticalGrowFactor,
              };
            return Object.assign(e.options, t), e;
          }
          performZoom(e, t, r, i, o) {
            const s = i * t,
              n = o * r;
            [a.EXyDirection.XDirection, a.EXyDirection.XyDirection].includes(
              this.xyDirection
            ) &&
              this.getIncludedXAxis().forEach((t) => {
                this.growBy(e, t, s);
              }),
              [a.EXyDirection.YDirection, a.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedYAxis().forEach((t) => {
                  this.growBy(e, t, n);
                });
          }
          removeFromActiveTouchEvents(e) {
            this.activePointerEvents.delete(e.pointerId),
              this.activePointerEvents.size < 2 &&
                ((this.previousHorizontalTouchPointsDistance = void 0),
                (this.previousVerticalTouchPointsDistance = void 0));
          }
          performModifierAction(e) {
            const [{ mousePoint: t }, { mousePoint: r }] = Array.from(
                this.activePointerEvents.values()
              ),
              i = Math.abs(t.x - r.x),
              o = Math.abs(t.y - r.y),
              a = this.getMiddlePoint(t, r),
              s = (0, n.translateFromCanvasToSeriesViewRect)(
                a,
                this.parentSurface.seriesViewRect
              );
            if (
              s &&
              void 0 !== this.previousHorizontalTouchPointsDistance &&
              void 0 !== this.previousVerticalTouchPointsDistance
            ) {
              const e = this.previousHorizontalTouchPointsDistance - i,
                t = this.previousVerticalTouchPointsDistance - o;
              this.performZoom(
                s,
                e,
                t,
                this.horizontalGrowFactor,
                this.verticalGrowFactor
              );
            }
            (this.previousHorizontalTouchPointsDistance = i),
              (this.previousVerticalTouchPointsDistance = o);
          }
          getIsActionAllowed(e) {
            return (
              ("touch" === e.pointerType || "pen" === e.pointerType) &&
              this.activePointerEvents.size >= 2
            );
          }
        }
        t.PinchZoomModifier = d;
      },
      78615: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PointerEventsMediatorModifier = void 0);
        const i = r(45921),
          o = r(89046),
          a = r(3214),
          s = r(11043),
          n = r(10581),
          l = r(57935),
          d = r(32873);
        class h extends o.ChartModifierBase2D {
          constructor(e) {
            var t, r, o, d;
            if (
              (super(e),
              (this.notifyOutEvent = !0),
              (this.notifyPositionUpdate = !1),
              (this.hoverChanged = new a.EventHandler()),
              (this.previousHoveredEntities = []),
              (this.mousePosition = l.EMousePosition.OutOfCanvas),
              (this.enableHoverProperty = !1),
              (this.hoverModeProperty = n.EHoverMode.AbsoluteTopmost),
              (this.enableHoverProperty =
                null !== (t = null == e ? void 0 : e.enableHover) &&
                void 0 !== t
                  ? t
                  : this.enableHoverProperty),
              (this.hoverModeProperty =
                null !== (r = null == e ? void 0 : e.hoverMode) && void 0 !== r
                  ? r
                  : this.hoverModeProperty),
              (this.notifyOutEvent =
                null !== (o = null == e ? void 0 : e.notifyOutEvent) &&
                void 0 !== o
                  ? o
                  : this.notifyOutEvent),
              (this.notifyPositionUpdate =
                null !== (d = null == e ? void 0 : e.notifyPositionUpdate) &&
                void 0 !== d
                  ? d
                  : this.notifyPositionUpdate),
              (null == e ? void 0 : e.onHover) &&
                ("string" == typeof e.onHover &&
                  (this.typeMap.set("onHover", e.onHover),
                  (e.onHover = (0, i.getFunction)(
                    s.EBaseType.OptionFunction,
                    e.onHover
                  ))),
                this.hoverChanged.subscribe(null == e ? void 0 : e.onHover)),
              null == e ? void 0 : e.targets)
            )
              if (Array.isArray(e.targets) && "string" != typeof e.targets[0])
                this.targets = e.targets;
              else if (
                Array.isArray(e.targets) &&
                "string" == typeof e.targets[0]
              ) {
                const t = e.targets;
                (this.includeList = new Map(t.map((e) => [e, !0]))),
                  (this.targetsSelector = () =>
                    this.getAllTargets().filter((e) =>
                      this.includeList.get(e.id)
                    ));
              } else
                "string" == typeof e.targets
                  ? (this.typeMap.set("targetsSelector", e.targets),
                    (e.targets = (0, i.getFunction)(
                      s.EBaseType.OptionFunction,
                      e.targets
                    )),
                    (this.targetsSelector = e.targets))
                  : (this.targetsSelector = e.targets);
          }
          get hoverMode() {
            return this.hoverModeProperty;
          }
          set hoverMode(e) {
            this.hoverModeProperty = e;
          }
          toJSON() {
            var e;
            const t = super.toJSON().options,
              r = {
                hoverMode: this.hoverMode,
                enableHover: this.enableHoverProperty,
                notifyOutEvent: this.notifyOutEvent,
                notifyPositionUpdate: this.notifyPositionUpdate,
                onHover: this.typeMap.get("onHover"),
                targets: this.includeList
                  ? Array.from(this.includeList)
                      .filter(([e, t]) => t)
                      .map(([e]) => e)
                  : this.typeMap.get("targetsSelector") ||
                    (null === (e = this.targets) || void 0 === e
                      ? void 0
                      : e.map(({ id: e }) => e)),
              };
            return {
              type: this.type,
              options: Object.assign(Object.assign({}, t), r),
            };
          }
          modifierMouseMove(e) {
            if (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent)
              return;
            let t;
            this.activePointerEvents.set(e.pointerId, e),
              super.modifierMouseMove(e),
              this.mousePoint
                ? ((t = (0, d.translateFromCanvasToSeriesViewRect)(
                    this.mousePoint,
                    this.parentSurface.seriesViewRect
                  )),
                  (this.mousePosition = t
                    ? l.EMousePosition.SeriesArea
                    : l.EMousePosition.AxisArea),
                  this.getIsActionAllowed(e) &&
                    this.enableHoverProperty &&
                    this.performHoverAction(e))
                : (this.mousePosition = l.EMousePosition.OutOfCanvas);
          }
          modifierMouseLeave(e) {
            if (
              (super.modifierMouseLeave(e),
              (this.mousePosition = l.EMousePosition.OutOfCanvas),
              this.enableHoverProperty)
            ) {
              const t = this.getIncludedTargets();
              let r = null,
                i = !1;
              for (let o = t.length - 1; o > -1; --o)
                (r = t[o]), this.performHoverOnEntity(r, e, i);
              this.previousHoveredEntities.length > 0 &&
                this.hoverChanged.raiseEvent({
                  sender: this,
                  mouseArgs: e,
                  hoveredEntities: [],
                  includedEntities: t,
                  unhoveredEntities: this.previousHoveredEntities,
                  previousHoveredEntities: this.previousHoveredEntities,
                }),
                (this.previousHoveredEntities = []);
            }
          }
          modifierPointerCancel(e) {
            this.modifierMouseLeave(e);
          }
          getIncludedTargets() {
            var e, t, r;
            return null !==
              (r =
                null !== (e = this.targets) && void 0 !== e
                  ? e
                  : null === (t = this.targetsSelector) || void 0 === t
                  ? void 0
                  : t.call(this, this)) && void 0 !== r
              ? r
              : this.getAllTargets();
          }
          performHoverAction(e) {
            const t = this.getIncludedTargets(),
              r = [],
              i = [];
            if (this.hoverMode === n.EHoverMode.TopmostIncluded) {
              for (let i = t.length - 1; i > -1; --i) {
                const o = t[i],
                  a = o.checkIsWithinBounds(e);
                if (a) {
                  r.push(o), this.performHoverOnEntity(o, e, a);
                  break;
                }
              }
              this.previousHoveredEntities.forEach((t) => {
                t !== r[0] && (i.push(t), this.performHoverOnEntity(t, e, !1));
              });
            } else if (this.hoverMode === n.EHoverMode.AbsoluteTopmost) {
              const o = this.getAllTargets();
              for (let i = o.length - 1; i > -1; --i) {
                const a = o[i],
                  s = a.checkIsWithinBounds(e);
                if (s) {
                  t.find((e) => e === a) &&
                    (r.push(a), this.performHoverOnEntity(a, e, s));
                  break;
                }
              }
              this.previousHoveredEntities.forEach((t) => {
                t !== r[0] && (i.push(t), this.performHoverOnEntity(t, e, !1));
              });
            } else if (this.hoverMode === n.EHoverMode.Multi)
              for (let o = t.length - 1; o > -1; --o) {
                const a = t[o],
                  s = a.checkIsWithinBounds(e),
                  n = a.isHovered;
                s
                  ? (r.push(a), this.performHoverOnEntity(a, e, s))
                  : n && (i.push(a), this.performHoverOnEntity(a, e, s));
              }
            const o =
                r.length > this.previousHoveredEntities.length ||
                (i.length && r.length === this.previousHoveredEntities.length),
              a = this.notifyOutEvent && i.length,
              s = this.notifyPositionUpdate && r.length;
            (o || s || a) &&
              this.hoverChanged.raiseEvent({
                sender: this,
                mouseArgs: e,
                hoveredEntities: r,
                previousHoveredEntities: this.previousHoveredEntities,
                includedEntities: t,
                unhoveredEntities: i,
              }),
              (this.previousHoveredEntities = r);
          }
          performHoverOnEntity(e, t, r) {
            e.hover({
              args: t,
              isHovered: r,
              notifyOutEvent: this.notifyOutEvent,
              notifyPositionUpdate: this.notifyPositionUpdate,
            });
          }
        }
        t.PointerEventsMediatorModifier = h;
      },
      95648: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarArcZoomModifier = void 0);
        const i = r(33485),
          o = r(10276),
          a = r(70162),
          s = r(56744),
          n = r(98140),
          l = r(75772),
          d = r(6859),
          h = r(89955),
          u = r(66405),
          c = r(86699),
          p = r(14379),
          g = r(32873),
          y = r(11396),
          f = r(89046),
          v = r(22486),
          m = r(18809);
        class S extends f.ChartModifierBase2D {
          constructor(e) {
            var t, r, i, a, s, n, l;
            super(e),
              (this.type = h.EChart2DModifierType.PolarArcZoom),
              (this.isAnimated = !0),
              (this.animationDuration = 1e3),
              (this.easingFunction = o.easing.outCubic),
              (this.isClicked = !1),
              (this.fillProperty = "#42b64933"),
              (this.strokeProperty = "#42b64977"),
              (this.strokeThicknessProperty = 2),
              (this.fill =
                null !== (t = null == e ? void 0 : e.fill) && void 0 !== t
                  ? t
                  : this.fillProperty),
              (this.stroke =
                null !== (r = null == e ? void 0 : e.stroke) && void 0 !== r
                  ? r
                  : this.strokeProperty),
              (this.strokeThickness =
                null !== (i = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== i
                  ? i
                  : this.strokeThicknessProperty),
              (this.isAnimated =
                null !== (a = null == e ? void 0 : e.isAnimated) && void 0 !== a
                  ? a
                  : this.isAnimated),
              (this.animationDuration =
                null !== (s = null == e ? void 0 : e.animationDuration) &&
                void 0 !== s
                  ? s
                  : this.animationDuration),
              (null == e ? void 0 : e.easingFunction) &&
                "string" == typeof e.easingFunction &&
                (e.easingFunction = o.easing[e.easingFunction]),
              (this.easingFunction =
                null !== (n = null == e ? void 0 : e.easingFunction) &&
                void 0 !== n
                  ? n
                  : this.easingFunction),
              (this.executeCondition =
                null !== (l = null == e ? void 0 : e.executeCondition) &&
                void 0 !== l
                  ? l
                  : { button: d.EExecuteOn.MouseLeftButton });
          }
          get modifierType() {
            return u.EModifierType.Chart2DPolarModifier;
          }
          applyTheme(e) {
            this.testPropertyChanged(v.PROPERTY.FILL) ||
              (this.fill = e.rubberBandFillBrush),
              this.testPropertyChanged(v.PROPERTY.STROKE) ||
                (this.stroke = e.rubberBandStrokeBrush);
          }
          onAttach() {
            super.onAttach(), this.handleAddArcAnnotation();
          }
          onDetach() {
            super.onDetach(), this.handleRemoveArcAnnotation();
          }
          modifierMouseDown(e) {
            if (
              (super.modifierMouseDown(e),
              !this.checkExecuteConditions(e).isPrimary)
            )
              return;
            if (!this.isAttached)
              throw new Error(
                "Should not call PolarArcZoomModifier.modifierMouseDown if not attached"
              );
            this.parentSurface.setZoomState(p.EZoomState.UserZooming);
            const t = (0, g.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect
            );
            if (t) {
              const e = this.xAxis,
                r = this.yAxis.maxRadius,
                i = e.reverseTransform(t.x, t.y);
              i.y <= r &&
                ((this.pointFrom = t),
                (this.polarPointFrom = i),
                (this.isClicked = !0));
            }
          }
          getArcParams() {
            const e = this.xAxis,
              t = this.yAxis,
              r = e.getCurrentCoordinateCalculator(),
              i = t.getCurrentCoordinateCalculator(),
              o = this.polarPointFrom,
              a = this.polarPointTo;
            let s = Math.min(r.getDataValue(o.x), r.getDataValue(a.x)),
              n = Math.max(r.getDataValue(o.x), r.getDataValue(a.x)),
              l = Math.min(i.getDataValue(o.y), i.getDataValue(a.y)),
              d = Math.max(i.getDataValue(o.y), i.getDataValue(a.y));
            return (
              this.xyDirection === c.EXyDirection.XDirection
                ? ((l = t.visibleRange.min), (d = t.visibleRange.max))
                : this.xyDirection === c.EXyDirection.YDirection &&
                  ((s = e.visibleRange.min), (n = e.visibleRange.max)),
              { angleStart: s, angleEnd: n, radiusInner: l, radiusOuter: d }
            );
          }
          updateArcAnnotation(e) {
            const { seriesViewRect: t } = this.parentSurface,
              r = (0, g.translateFromCanvasToSeriesViewRect)(e, t);
            if (r) {
              this.pointTo = r;
              const e = this.xAxis,
                t = this.yAxis.maxRadius,
                i = e.reverseTransform(r.x, r.y);
              this.polarPointTo = new l.Point(i.x, Math.min(i.y, t));
              const o = this.getArcParams();
              return (
                (this.arcAnnotation.isHidden = !1),
                (this.arcAnnotation.x1 = o.angleStart),
                (this.arcAnnotation.x2 = o.angleEnd),
                (this.arcAnnotation.y1 = o.radiusOuter),
                (this.arcAnnotation.y2 = o.radiusInner),
                o
              );
            }
            return this.getArcParams();
          }
          modifierMouseMove(e) {
            super.modifierMouseMove(e),
              this.isClicked && this.updateArcAnnotation(e.mousePoint);
          }
          clear() {
            (this.pointFrom = void 0),
              (this.polarPointFrom = void 0),
              (this.pointTo = void 0),
              (this.polarPointTo = void 0),
              (this.isClicked = !1);
          }
          modifierMouseUp(e) {
            if (
              (super.modifierMouseUp(e),
              this.checkExecuteConditions(e).isPrimary && this.isClicked)
            ) {
              const t = this.updateArcAnnotation(e.mousePoint);
              this.arcAnnotation.isHidden = !0;
              const r = this.calculateDraggedDistance();
              this.clear(),
                t &&
                  r > m.RubberBandXyZoomModifier.MIN_DRAG_SENSITIVITY &&
                  this.performZoom(t);
            }
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.STROKE_THICKNESS);
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.STROKE);
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(v.PROPERTY.FILL);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                animationDuration: this.animationDuration,
                easingFunction: this.easingFunction.name,
                fill: this.fill,
                isAnimated: this.isAnimated,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
              };
            return Object.assign(e.options, t), e;
          }
          delete() {
            (this.parentSurfaceProperty = void 0),
              this.handleRemoveArcAnnotation(),
              super.delete();
          }
          performZoom(e) {
            const t = this.parentSurface;
            if (t) {
              const {
                  angleStart: r,
                  angleEnd: o,
                  radiusInner: s,
                  radiusOuter: l,
                } = e,
                d = this.xAxis,
                h = this.yAxis,
                { min: u, max: c } = d.visibleRange,
                { min: p, max: g } = h.visibleRange,
                y = d.startAngle,
                f = d.totalAngle,
                v = d.flippedCoordinates;
              if (this.isAnimated && this.animationDuration > 0) {
                const e = new a.GenericAnimation({
                  from: { x1: u, x2: c, y1: p, y2: g },
                  to: { x1: r, x2: o, y1: s, y2: l },
                  duration: this.animationDuration,
                  ease: this.easingFunction,
                  onAnimate: (e, t, r) => {
                    const o = i.DoubleAnimator.interpolate(e.x1, t.x1, r),
                      a = i.DoubleAnimator.interpolate(e.x2, t.x2, r),
                      s = i.DoubleAnimator.interpolate(e.y1, t.y1, r),
                      l = i.DoubleAnimator.interpolate(e.y2, t.y2, r);
                    (d.visibleRange = new n.NumberRange(o, a)),
                      (h.visibleRange = new n.NumberRange(s, l));
                    const p = v
                      ? y - (f * (a - c)) / (c - u)
                      : y + (f * (o - u)) / (c - u);
                    (d.startAngle = p),
                      (h.startAngle = p),
                      (d.totalAngle = (f * (a - o)) / (c - u)),
                      (h.innerRadius = s / l);
                  },
                });
                t.addAnimation(e);
              } else {
                (d.visibleRange = new n.NumberRange(r, o)),
                  (h.visibleRange = new n.NumberRange(s, l));
                const e = v
                  ? y - (f * (o - c)) / (c - u)
                  : y + (f * (r - u)) / (c - u);
                (d.startAngle = e),
                  (h.startAngle = e),
                  (d.totalAngle = (f * (o - r)) / (c - u)),
                  (h.innerRadius = s / l);
              }
            }
          }
          calculateDraggedDistance() {
            const e = Math.pow(this.pointFrom.x - this.pointTo.x, 2),
              t = Math.pow(this.pointFrom.y - this.pointTo.y, 2);
            return Math.sqrt(e + t);
          }
          handleAddArcAnnotation() {
            (this.arcAnnotation = new y.PolarArcAnnotation({
              isHidden: !0,
              x1: 0,
              x2: 1,
              y2: 0,
              y1: 1,
              stroke: this.stroke,
              strokeThickness: this.strokeThickness,
              fill: this.fill,
              opacity: 1,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
            })),
              this.parentSurface.modifierAnnotations.add(this.arcAnnotation);
          }
          handleRemoveArcAnnotation() {
            var e;
            null === (e = this.parentSurface) ||
              void 0 === e ||
              e.modifierAnnotations.remove(this.arcAnnotation, !0),
              (this.arcAnnotation = (0, s.deleteSafe)(this.arcAnnotation));
          }
        }
        (t.PolarArcZoomModifier = S), (S.MIN_DRAG_SENSITIVITY = 5);
      },
      94118: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarCursorModifier = void 0);
        const i = r(45921),
          o = r(87108),
          a = r(60986),
          s = r(11043),
          n = r(89955),
          l = r(11805),
          d = r(66405),
          h = r(57935),
          u = r(32873),
          c = r(31306),
          p = r(26520),
          g = r(64584),
          y = r(84736),
          f = r(28677),
          v = r(74370),
          m = r(11396),
          S = r(10572),
          P = r(14184),
          C = r(86127),
          b = r(89046),
          x = r(22486),
          A = r(62773);
        class T extends b.ChartModifierBase2D {
          constructor(e) {
            var t,
              r,
              o,
              a,
              d,
              u,
              c,
              p,
              g,
              y,
              f,
              v,
              m,
              S,
              C,
              b,
              x,
              T,
              E,
              R,
              D,
              w,
              M,
              L,
              O;
            super(e),
              (this.type = n.EChart2DModifierType.PolarCursor),
              (this.tooltipSvgTemplate = A.defaultCursorTooltipSvgTemplate),
              (this.lineThickness = 2),
              (this.lineDashArray = []),
              (this.tooltipContainerBackground = "#228B22"),
              (this.tooltipTextStroke = "#fff"),
              (this.showTooltip = !1),
              (this.axisLabelStroke = "#fff"),
              (this.axisLabelFill = "#228B22"),
              (this.xAxisLabelStroke = void 0),
              (this.xAxisLabelFill = void 0),
              (this.yAxisLabelStroke = void 0),
              (this.yAxisLabelFill = void 0),
              (this.tooltipLegendOffsetX = 0),
              (this.tooltipLegendOffsetY = 0),
              (this.hitTestRadius = 0),
              (this.mousePosition = h.EMousePosition.OutOfCanvas),
              (this.lineColorProperty =
                P.SciChartSurfaceBase.DEFAULT_THEME.cursorLineBrush),
              (this.tooltipShadowProperty =
                P.SciChartSurfaceBase.DEFAULT_THEME.shadowEffectColor),
              (this.showRadialLineProperty = !0),
              (this.showCircularLineProperty = !0),
              (this.showAxisLabelsProperty = !0),
              (this.angularAxisLabelPlacementProperty =
                l.EAngularAxisLabelPlacement.Outer),
              (this.radialAxisLabelPlacementProperty =
                l.ERadialAxisLabelPlacement.Bottom),
              (null == e ? void 0 : e.tooltipSvgTemplate) &&
                "string" == typeof e.tooltipSvgTemplate &&
                (this.typeMap.set("tooltipSvgTemplate", e.tooltipSvgTemplate),
                (e.tooltipSvgTemplate = (0, i.getFunction)(
                  s.EBaseType.OptionFunction,
                  e.tooltipSvgTemplate
                ))),
              (this.tooltipSvgTemplate =
                null !== (t = null == e ? void 0 : e.tooltipSvgTemplate) &&
                void 0 !== t
                  ? t
                  : this.tooltipSvgTemplate),
              (this.lineThickness =
                null !== (r = null == e ? void 0 : e.lineThickness) &&
                void 0 !== r
                  ? r
                  : this.lineThickness),
              (this.lineDashArray =
                null !== (o = null == e ? void 0 : e.lineDashArray) &&
                void 0 !== o
                  ? o
                  : this.lineDashArray),
              (this.lineColor =
                null !== (a = null == e ? void 0 : e.lineColor) && void 0 !== a
                  ? a
                  : this.lineColor),
              (this.tooltipContainerBackground =
                null !==
                  (d = null == e ? void 0 : e.tooltipContainerBackground) &&
                void 0 !== d
                  ? d
                  : this.tooltipContainerBackground),
              (this.tooltipTextStroke =
                null !== (u = null == e ? void 0 : e.tooltipTextStroke) &&
                void 0 !== u
                  ? u
                  : this.tooltipTextStroke),
              (this.tooltipShadow =
                null !== (c = null == e ? void 0 : e.tooltipShadow) &&
                void 0 !== c
                  ? c
                  : this.tooltipShadowProperty),
              (this.showTooltip =
                null !== (p = null == e ? void 0 : e.showTooltip) &&
                void 0 !== p
                  ? p
                  : this.showTooltip),
              (this.showAxisLabels =
                null !== (g = null == e ? void 0 : e.showAxisLabels) &&
                void 0 !== g
                  ? g
                  : this.showAxisLabels),
              (this.axisLabelFill =
                null !== (y = null == e ? void 0 : e.axisLabelFill) &&
                void 0 !== y
                  ? y
                  : this.axisLabelFill),
              (this.axisLabelStroke =
                null !== (f = null == e ? void 0 : e.axisLabelStroke) &&
                void 0 !== f
                  ? f
                  : this.axisLabelStroke),
              (this.angularAxisLabelPlacement =
                null !==
                  (v = null == e ? void 0 : e.angularAxisLabelPlacement) &&
                void 0 !== v
                  ? v
                  : this.angularAxisLabelPlacementProperty),
              (this.radialAxisLabelPlacement =
                null !==
                  (m = null == e ? void 0 : e.radialAxisLabelPlacement) &&
                void 0 !== m
                  ? m
                  : this.radialAxisLabelPlacementProperty),
              (this.xAxisLabelStroke =
                null !== (S = null == e ? void 0 : e.xAxisLabelStroke) &&
                void 0 !== S
                  ? S
                  : this.xAxisLabelStroke),
              (this.xAxisLabelFill =
                null !== (C = null == e ? void 0 : e.xAxisLabelFill) &&
                void 0 !== C
                  ? C
                  : this.xAxisLabelFill),
              (this.yAxisLabelStroke =
                null !== (b = null == e ? void 0 : e.yAxisLabelStroke) &&
                void 0 !== b
                  ? b
                  : this.yAxisLabelStroke),
              (this.yAxisLabelFill =
                null !== (x = null == e ? void 0 : e.yAxisLabelFill) &&
                void 0 !== x
                  ? x
                  : this.yAxisLabelFill),
              (this.placementDivIdProperty =
                null !== (T = null == e ? void 0 : e.placementDivId) &&
                void 0 !== T
                  ? T
                  : this.placementDivIdProperty),
              (null == e ? void 0 : e.tooltipLegendTemplate) &&
                "string" == typeof e.tooltipLegendTemplate &&
                (this.typeMap.set(
                  "tooltipLegendTemplate",
                  e.tooltipLegendTemplate
                ),
                (e.tooltipLegendTemplate = (0, i.getFunction)(
                  s.EBaseType.OptionFunction,
                  e.tooltipLegendTemplate
                ))),
              (this.tooltipLegendTemplate =
                null !== (E = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== E
                  ? E
                  : this.tooltipLegendTemplate),
              (this.tooltipLegendOffsetX =
                null !== (R = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== R
                  ? R
                  : this.tooltipLegendOffsetX),
              (this.tooltipLegendOffsetY =
                null !== (D = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== D
                  ? D
                  : this.tooltipLegendOffsetY),
              (null == e ? void 0 : e.tooltipDataTemplate) &&
                "string" == typeof e.tooltipDataTemplate &&
                (this.typeMap.set("tooltipDataTemplate", e.tooltipDataTemplate),
                (e.tooltipDataTemplate = (0, i.getFunction)(
                  s.EBaseType.OptionFunction,
                  e.tooltipDataTemplate
                ))),
              (this.tooltipDataTemplateProperty =
                null !== (w = null == e ? void 0 : e.tooltipDataTemplate) &&
                void 0 !== w
                  ? w
                  : this.tooltipDataTemplateProperty),
              (this.showRadialLine =
                null !== (M = null == e ? void 0 : e.showRadialLine) &&
                void 0 !== M
                  ? M
                  : this.showRadialLine),
              (this.showCircularLine =
                null !== (L = null == e ? void 0 : e.showCircularLine) &&
                void 0 !== L
                  ? L
                  : this.showCircularLine),
              (this.hitTestRadius =
                null !== (O = null == e ? void 0 : e.hitTestRadius) &&
                void 0 !== O
                  ? O
                  : this.hitTestRadius);
          }
          get modifierType() {
            return d.EModifierType.Chart2DPolarModifier;
          }
          applyTheme(e) {
            this.testPropertyChanged(x.PROPERTY.CROSSHAIR_STROKE) ||
              (this.lineColor = e.cursorLineBrush),
              this.testPropertyChanged(x.PROPERTY.TOOLTIP_SHADOW) ||
                (this.tooltipShadow = e.shadowEffectColor);
          }
          onAttach() {
            var e;
            super.onAttach(),
              this.showRadialLine && this.handleAddRadialLine(),
              this.showCircularLine && this.handleAddCircularLine(),
              (this.tooltipAnnotation = new g.CursorTooltipSvgAnnotation({
                cursorModifier: this,
                xCoordinateMode: c.ECoordinateMode.Pixel,
                yCoordinateMode: c.ECoordinateMode.Pixel,
                tooltipSvgTemplate:
                  null !== (e = this.tooltipSvgTemplate) && void 0 !== e
                    ? e
                    : A.defaultCursorTooltipSvgTemplate,
                containerBackground: this.tooltipContainerBackground,
                textStroke: this.tooltipTextStroke,
                tooltipLegendTemplate: this.tooltipLegendTemplate,
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
                placementDivId: this.placementDivId,
              })),
              this.parentSurface.modifierAnnotations.add(
                this.tooltipAnnotation
              );
          }
          onDetach() {
            super.onDetach(),
              this.radialAnnotation && this.handleRemoveRadialLine(),
              this.circularAnnotation && this.handleRemoveCircularLine(),
              this.parentSurface.modifierAnnotations.remove(
                this.tooltipAnnotation,
                !0
              );
          }
          onAttachSeries(e) {
            this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
          }
          onDetachSeries(e) {
            this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
          }
          modifierMouseMove(e) {
            if (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent)
              return;
            let t;
            this.activePointerEvents.set(e.pointerId, e),
              super.modifierMouseMove(e),
              this.mousePoint
                ? ((t = (0, u.translateFromCanvasToSeriesViewRect)(
                    this.mousePoint,
                    this.parentSurface.seriesViewRect
                  )),
                  (this.mousePosition = t
                    ? h.EMousePosition.SeriesArea
                    : h.EMousePosition.AxisArea))
                : (this.mousePosition = h.EMousePosition.OutOfCanvas),
              this.getIsActionAllowed(e) && this.update();
          }
          modifierMouseLeave(e) {
            super.modifierMouseLeave(e),
              (this.mousePosition = h.EMousePosition.OutOfCanvas),
              this.update();
          }
          onParentSurfaceRendered() {
            this.update();
          }
          get lineColor() {
            return this.lineColorProperty;
          }
          set lineColor(e) {
            this.lineColorProperty !== e &&
              ((this.lineColorProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.CROSSHAIR_STROKE));
          }
          get tooltipShadow() {
            return this.tooltipShadowProperty;
          }
          set tooltipShadow(e) {
            this.tooltipShadowProperty !== e &&
              ((this.tooltipShadowProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.TOOLTIP_SHADOW));
          }
          get showRadialLine() {
            return this.showRadialLineProperty;
          }
          set showRadialLine(e) {
            this.showRadialLineProperty !== e &&
              ((this.showRadialLineProperty = e),
              this.showRadialLineProperty && !this.radialAnnotation
                ? this.handleAddRadialLine()
                : !this.showRadialLineProperty &&
                  this.radialAnnotation &&
                  this.handleRemoveRadialLine(),
              this.notifyPropertyChanged(x.PROPERTY.X_LINE));
          }
          get showCircularLine() {
            return this.showCircularLineProperty;
          }
          set showCircularLine(e) {
            this.showCircularLineProperty !== e &&
              ((this.showCircularLineProperty = e),
              this.showCircularLineProperty && !this.circularAnnotation
                ? this.handleAddCircularLine()
                : !this.showCircularLineProperty &&
                  this.circularAnnotation &&
                  this.handleRemoveCircularLine(),
              this.notifyPropertyChanged(x.PROPERTY.Y_LINE));
          }
          get showAxisLabels() {
            return this.showAxisLabelsProperty;
          }
          set showAxisLabels(e) {
            this.showAxisLabelsProperty !== e &&
              ((this.showAxisLabelsProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.AXIS_LABELS));
          }
          get angularAxisLabelPlacement() {
            return this.angularAxisLabelPlacementProperty;
          }
          set angularAxisLabelPlacement(e) {
            this.angularAxisLabelPlacementProperty !== e &&
              ((this.angularAxisLabelPlacementProperty = e),
              this.notifyPropertyChanged(
                x.PROPERTY.ANGULAR_AXIS_LABELS_PLACEMENT
              ));
          }
          get radialAxisLabelPlacement() {
            return this.radialAxisLabelPlacementProperty;
          }
          set radialAxisLabelPlacement(e) {
            this.radialAxisLabelPlacementProperty !== e &&
              ((this.radialAxisLabelPlacementProperty = e),
              this.notifyPropertyChanged(
                x.PROPERTY.RADIAL_AXIS_LABELS_PLACEMENT
              ));
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.PLACEMENT_DIV_ID));
          }
          includeSeries(e, t) {
            return (
              !!super.includeSeries(e, t) &&
              ((this.tooltipAnnotation.seriesInfos = this.getSeriesInfos()), !0)
            );
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.TOOLTIP_DATA_TEMPLATE);
          }
          hitTestRenderableSeries(e, t) {
            if (t)
              return e.hitTestProvider.hitTestDataPoint(
                t.x,
                t.y,
                this.hitTestRadius
              );
          }
          getMousePosition() {
            return this.mousePosition;
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                axisLabelFill: this.axisLabelFill,
                axisLabelStroke: this.axisLabelStroke,
                angularAxisLabelPlacement: this.angularAxisLabelPlacement,
                radialAxisLabelPlacement: this.radialAxisLabelPlacement,
                xAxisLabelFill: this.xAxisLabelFill,
                xAxisLabelStroke: this.xAxisLabelStroke,
                yAxisLabelFill: this.yAxisLabelFill,
                yAxisLabelStroke: this.yAxisLabelStroke,
                lineColor: this.lineColor,
                lineDashArray: this.lineDashArray,
                lineThickness: this.lineThickness,
                hitTestRadius: this.hitTestRadius,
                placementDivId: this.placementDivId,
                showAxisLabels: this.showAxisLabels,
                showTooltip: this.showTooltip,
                showRadialLine: this.showRadialLine,
                showCircularLine: this.showCircularLine,
                tooltipContainerBackground: this.tooltipContainerBackground,
                tooltipDataTemplate: this.typeMap.get("tooltipDataTemplate"),
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                tooltipLegendTemplate: this.typeMap.get(
                  "tooltipLegendTemplate"
                ),
                tooltipSvgTemplate: this.typeMap.get("tooltipSvgTemplate"),
                tooltipTextStroke: this.tooltipTextStroke,
                tooltipShadow: this.tooltipShadow,
              };
            return Object.assign(e.options, t), e;
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              e === x.PROPERTY.X_AXIS_ID &&
                (this.tooltipAnnotation &&
                  (this.tooltipAnnotation.xAxisId = this.xAxisId),
                this.radialAnnotation &&
                  ((this.radialAnnotation.xAxisId = this.xAxisId),
                  (this.angularAxisLabelAnnotation.xAxisId = this.xAxisId)),
                this.circularAnnotation &&
                  ((this.circularAnnotation.xAxisId = this.xAxisId),
                  (this.radialAxisLabelAnnotation.xAxisId = this.xAxisId))),
              e === x.PROPERTY.Y_AXIS_ID &&
                (this.tooltipAnnotation &&
                  (this.tooltipAnnotation.yAxisId = this.yAxisId),
                this.radialAnnotation &&
                  ((this.radialAnnotation.yAxisId = this.yAxisId),
                  (this.angularAxisLabelAnnotation.yAxisId = this.yAxisId)),
                this.circularAnnotation &&
                  ((this.circularAnnotation.yAxisId = this.yAxisId),
                  (this.radialAxisLabelAnnotation.yAxisId = this.yAxisId)));
          }
          getSeriesInfos() {
            return this.getIncludedRenderableSeries()
              .map((e) => {
                const t = this.hitTestRenderableSeries(e, this.mousePoint);
                if (t) return e.getSeriesInfo(t);
              })
              .filter((e) => void 0 !== e);
          }
          update() {
            if (this.mousePosition !== h.EMousePosition.SeriesArea)
              return (
                this.radialAnnotation &&
                  ((this.radialAnnotation.isHidden = !0),
                  (this.angularAxisLabelAnnotation.isHidden = !0)),
                this.circularAnnotation &&
                  ((this.circularAnnotation.isHidden = !0),
                  (this.radialAxisLabelAnnotation.isHidden = !0)),
                void (
                  this.tooltipAnnotation &&
                  ((this.tooltipAnnotation.isHidden = !0),
                  (this.tooltipAnnotation.seriesInfos = []),
                  this.placementDivId && this.tooltipAnnotation.delete())
                )
              );
            const e = (0, u.translateFromCanvasToSeriesViewRect)(
              this.mousePoint,
              this.parentSurface.seriesViewRect
            );
            if (e) {
              const t = e.x,
                r = e.y,
                i = this.xAxis,
                o = this.yAxis,
                s = i.reverseTransform(t, r);
              if (s.x > i.totalAngle)
                return (
                  (this.radialAnnotation.isHidden = !0),
                  (this.angularAxisLabelAnnotation.isHidden = !0),
                  (this.circularAnnotation.isHidden = !0),
                  (this.radialAxisLabelAnnotation.isHidden = !0),
                  void (this.tooltipAnnotation.isHidden = !0)
                );
              this.radialAnnotation &&
                ((this.radialAnnotation.isHidden = !1),
                (this.angularAxisLabelAnnotation.isHidden =
                  !this.showAxisLabels)),
                this.circularAnnotation &&
                  ((this.circularAnnotation.isHidden = !1),
                  (this.radialAxisLabelAnnotation.isHidden =
                    !this.showAxisLabels)),
                this.showTooltip && (this.tooltipAnnotation.isHidden = !1);
              const n = o.getAxisSize(),
                l = i.getCurrentCoordinateCalculator(),
                d = o.getCurrentCoordinateCalculator();
              if (this.radialAnnotation) {
                const e = l.getDataValue(s.x);
                (this.radialAnnotation.x1 = 0),
                  (this.radialAnnotation.y1 = 0),
                  (this.radialAnnotation.x2 = s.x),
                  (this.radialAnnotation.y2 = n / C.DpiHelper.PIXEL_RATIO),
                  (this.angularAxisLabelAnnotation.x1 = s.x),
                  (this.angularAxisLabelAnnotation.y1 =
                    n / C.DpiHelper.PIXEL_RATIO),
                  (this.angularAxisLabelAnnotation.text = e.toFixed(3));
                const {
                  resultAngle: t,
                  horizontalAnchorPoint: r,
                  verticalAnchorPoint: o,
                } = S.labelHelper.getLabelRotationAndPlacementForAngularAxis(
                  s.x + i.startAngle,
                  i.polarLabelMode,
                  this.angularAxisLabelPlacement
                );
                (this.angularAxisLabelAnnotation.verticalAnchorPoint = o),
                  (this.angularAxisLabelAnnotation.horizontalAnchorPoint = r),
                  (this.angularAxisLabelAnnotation.rotation = t);
              }
              if (this.circularAnnotation) {
                const e = Math.min(s.y, n),
                  t = d.getDataValue(e),
                  r = this.circularAnnotation,
                  h = l.isFlipped;
                (r.y1 = d.getDataValue(e)),
                  (r.x1 = h
                    ? l.getDataValue(i.totalAngle - 0.001)
                    : l.getDataValue(0)),
                  (r.x2 = h
                    ? l.getDataValue(0)
                    : l.getDataValue(i.totalAngle - 0.001)),
                  (this.radialAxisLabelAnnotation.x1 =
                    o.startAngle - i.startAngle),
                  (this.radialAxisLabelAnnotation.y1 =
                    e / C.DpiHelper.PIXEL_RATIO),
                  (this.radialAxisLabelAnnotation.text = t.toFixed(3)),
                  (this.radialAxisLabelAnnotation.verticalAnchorPoint =
                    S.labelHelper.getLabelPlacementForRadialAxis(
                      this.radialAxisLabelPlacement
                    )),
                  (this.radialAxisLabelAnnotation.horizontalAnchorPoint =
                    a.EHorizontalAnchorPoint.Center),
                  (this.radialAxisLabelAnnotation.rotation = 0);
              }
              this.showTooltip &&
                ((this.tooltipAnnotation.x1 = (0, u.translateToNotScaled)(e.x)),
                (this.tooltipAnnotation.y1 = (0, u.translateToNotScaled)(e.y))),
                (this.showTooltip || this.tooltipLegendTemplate) &&
                  (this.tooltipAnnotation.seriesInfos = this.getSeriesInfos());
            }
          }
          newLineAnnotation(e, t) {
            return new f.LineAnnotation({
              xCoordinateMode: c.ECoordinateMode.Pixel,
              yCoordinateMode: c.ECoordinateMode.Pixel,
              strokeThickness: this.lineThickness,
              strokeDashArray: this.lineDashArray,
              stroke: this.lineColor,
              isHidden: !0,
              showLabel: this.showAxisLabels,
              axisLabelFill: e,
              axisLabelStroke: t,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
            });
          }
          newNativeTextAnnotation(e, t) {
            return new v.NativeTextAnnotation({
              isHidden: !0,
              xCoordinateMode: c.ECoordinateMode.Pixel,
              yCoordinateMode: c.ECoordinateMode.Pixel,
              fontSize: 18,
              textColor: t,
              background: e,
              padding: o.Thickness.fromNumber(4),
              isEditable: !1,
              annotationLayer: y.EAnnotationLayer.AboveChart,
              clipping: p.EAnnotationClippingMode.Chart,
            });
          }
          newArcAnnotation(e, t) {
            return new m.PolarArcAnnotation({
              isHidden: !0,
              y2: 0,
              stroke: this.lineColor,
              strokeThickness: this.lineThickness,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
              isLineMode: !0,
            });
          }
          isVerticalChart() {
            var e, t;
            return (
              null !==
                (t =
                  null === (e = this.xAxis) || void 0 === e
                    ? void 0
                    : e.isVerticalChart) &&
              void 0 !== t &&
              t
            );
          }
          handleAddRadialLine() {
            const e = this.xAxisLabelFill
                ? this.xAxisLabelFill
                : this.axisLabelFill,
              t = this.xAxisLabelStroke
                ? this.xAxisLabelStroke
                : this.axisLabelStroke;
            (this.radialAnnotation = this.newLineAnnotation(e, t)),
              this.parentSurface.modifierAnnotations.add(this.radialAnnotation),
              (this.angularAxisLabelAnnotation = this.newNativeTextAnnotation(
                e,
                t
              )),
              this.parentSurface.modifierAnnotations.add(
                this.angularAxisLabelAnnotation
              );
          }
          handleRemoveRadialLine() {
            this.parentSurface.modifierAnnotations.remove(
              this.radialAnnotation,
              !0
            ),
              this.parentSurface.modifierAnnotations.remove(
                this.angularAxisLabelAnnotation,
                !0
              );
          }
          handleAddCircularLine() {
            const e = this.yAxisLabelFill
                ? this.yAxisLabelFill
                : this.axisLabelFill,
              t = this.yAxisLabelStroke
                ? this.yAxisLabelStroke
                : this.axisLabelStroke;
            (this.circularAnnotation = this.newArcAnnotation(e, t)),
              this.parentSurface.modifierAnnotations.add(
                this.circularAnnotation
              ),
              (this.radialAxisLabelAnnotation = this.newNativeTextAnnotation(
                e,
                t
              )),
              this.parentSurface.modifierAnnotations.add(
                this.radialAxisLabelAnnotation
              );
          }
          handleRemoveCircularLine() {
            this.parentSurface.modifierAnnotations.remove(
              this.circularAnnotation,
              !0
            ),
              this.parentSurface.modifierAnnotations.remove(
                this.radialAxisLabelAnnotation,
                !0
              );
          }
        }
        t.PolarCursorModifier = T;
      },
      37221: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarDataPointSelectionModifier = void 0);
        const i = r(89955),
          o = r(66405),
          a = r(71575);
        class s extends a.DataPointSelectionModifier {
          constructor(e) {
            super(e),
              (this.type = i.EChart2DModifierType.PolarDataPointSelection);
          }
          get modifierType() {
            return o.EModifierType.Chart2DPolarModifier;
          }
        }
        t.PolarDataPointSelectionModifier = s;
      },
      99389: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarLegendModifier = void 0);
        const i = r(89955),
          o = r(66405),
          a = r(9656);
        class s extends a.LegendModifier {
          constructor(e) {
            super(e), (this.type = i.EChart2DModifierType.PolarLegend);
          }
          get modifierType() {
            return o.EModifierType.Chart2DPolarModifier;
          }
        }
        t.PolarLegendModifier = s;
      },
      30580: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__rest) ||
          function (e, t) {
            var r = {};
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) &&
                t.indexOf(i) < 0 &&
                (r[i] = e[i]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (i = Object.getOwnPropertySymbols(e); o < i.length; o++)
                t.indexOf(i[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, i[o]) &&
                  (r[i[o]] = e[i[o]]);
            }
            return r;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarMouseWheelZoomModifier = void 0);
        const o = r(89955),
          a = r(66405),
          s = r(86699),
          n = r(32616),
          l = r(56985),
          d = r(98140);
        class h extends l.MouseWheelZoomModifier {
          constructor(e) {
            var t, r, a, s;
            const d = null != e ? e : {},
              { executeCondition: h, secondaryExecuteCondition: u } = d;
            super(i(d, ["executeCondition", "secondaryExecuteCondition"])),
              (this.type = o.EChart2DModifierType.PolarMouseWheelZoom),
              (this.defaultActionType = l.EActionType.Pan),
              (this.zoomSize = !0),
              (this.defaultActionType =
                null !== (t = null == e ? void 0 : e.defaultActionType) &&
                void 0 !== t
                  ? t
                  : this.defaultActionType),
              (this.executeCondition =
                null !== (r = null == e ? void 0 : e.executeCondition) &&
                void 0 !== r
                  ? r
                  : { key: n.EModifierMouseArgKey.None }),
              (this.secondaryExecuteCondition =
                null !==
                  (a = null == e ? void 0 : e.secondaryExecuteCondition) &&
                void 0 !== a
                  ? a
                  : { key: n.EModifierMouseArgKey.Ctrl }),
              (this.zoomSize =
                null !== (s = null == e ? void 0 : e.zoomSize) && void 0 !== s
                  ? s
                  : this.zoomSize);
          }
          get modifierType() {
            return a.EModifierType.Chart2DPolarModifier;
          }
          modifierMouseWheel(e) {
            const { isPrimary: t, isSecondary: r } =
              this.checkExecuteConditions(e);
            (this.actionType = t
              ? this.defaultActionType
              : r
              ? this.defaultActionType === l.EActionType.Pan
                ? l.EActionType.Zoom
                : l.EActionType.Pan
              : void 0),
              (this.xyDirection = s.EXyDirection.XyDirection),
              super.modifierMouseWheel(e);
          }
          performPan(e) {
            let t = !1;
            return (
              [s.EXyDirection.XDirection, s.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedXAxis().forEach((r) => {
                  const i = Math.PI,
                    o = e * this.growFactor * i;
                  (r.startAngle += o), (t = !0);
                }),
              [s.EXyDirection.YDirection, s.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedYAxis().forEach((r) => {
                  const i = Math.PI,
                    o = e * this.growFactor * i;
                  (r.startAngle += o), (t = !0);
                }),
              t
            );
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                zoomSize: this.zoomSize,
                defaultActionType: this.defaultActionType,
              };
            return Object.assign(e.options, t), e;
          }
          growBy(e, t, r) {
            const i = t;
            if (!i.isAngular)
              if (this.zoomSize) i.lengthScale -= r;
              else {
                const { min: e, max: t } = i.visibleRange,
                  o = t * (1 + r);
                i.visibleRange = new d.NumberRange(e, o);
              }
          }
        }
        t.PolarMouseWheelZoomModifier = h;
      },
      27524: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarPanModifier = t.EPolarPanModifierPanMode = void 0);
        const i = r(98140),
          o = r(6859),
          a = r(32616),
          s = r(89955),
          n = r(66405),
          l = r(86699),
          d = r(14379),
          h = r(32873),
          u = r(21562);
        var c;
        !(function (e) {
          (e.PolarStartAngle = "PolarStartAngle"),
            (e.PolarVisibleRange = "PolarVisibleRange"),
            (e.Cartesian = "Cartesian");
        })(
          (c = t.EPolarPanModifierPanMode || (t.EPolarPanModifierPanMode = {}))
        );
        class p extends u.PinchZoomModifier {
          constructor(e) {
            var t, r, i, n, l, d;
            super(e),
              (this.primaryPanMode = c.PolarStartAngle),
              (this.secondaryPanMode = c.Cartesian),
              (this.growFactor = 1),
              (this.zoomSize = !0),
              (this.type = s.EChart2DModifierType.PolarPan),
              (this.primaryPanMode =
                null !== (t = null == e ? void 0 : e.primaryPanMode) &&
                void 0 !== t
                  ? t
                  : this.primaryPanMode),
              (this.secondaryPanMode =
                null !== (r = null == e ? void 0 : e.secondaryPanMode) &&
                void 0 !== r
                  ? r
                  : this.secondaryPanMode),
              (this.growFactor =
                null !== (i = null == e ? void 0 : e.growFactor) && void 0 !== i
                  ? i
                  : this.growFactor),
              (this.executeCondition =
                null !== (n = null == e ? void 0 : e.executeCondition) &&
                void 0 !== n
                  ? n
                  : {
                      button: o.EExecuteOn.MouseLeftButton,
                      key: a.EModifierMouseArgKey.None,
                    }),
              (this.secondaryExecuteCondition =
                null !==
                  (l = null == e ? void 0 : e.secondaryExecuteCondition) &&
                void 0 !== l
                  ? l
                  : {
                      button: o.EExecuteOn.MouseRightButton,
                      key: a.EModifierMouseArgKey.None,
                    }),
              (this.zoomSize =
                null !== (d = null == e ? void 0 : e.zoomSize) && void 0 !== d
                  ? d
                  : this.zoomSize);
          }
          get modifierType() {
            return n.EModifierType.Chart2DPolarModifier;
          }
          modifierMouseDown(e) {
            e.nativeEvent.preventDefault();
            const { isPrimary: t, isSecondary: r } =
              this.checkExecuteConditions(e);
            if (
              ((this.panMode = t
                ? this.primaryPanMode
                : r
                ? this.secondaryPanMode
                : void 0),
              this.panMode)
            ) {
              if (!this.isAttached)
                throw new Error(
                  "Should not call PolarPanModifier.modifierMouseDown if not attached"
                );
              (0, h.translateFromCanvasToSeriesViewRect)(
                e.mousePoint,
                this.parentSurface.seriesViewRect
              ) &&
                (this.activePointerEvents.set(e.pointerId, e),
                this.parentSurface.setZoomState(d.EZoomState.UserZooming));
            }
          }
          modifierMouseMove(e) {
            (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent) ||
              (this.updatePointerInfo(e),
              this.previousPoint &&
                this.getIsActionAllowed(e) &&
                (this.panMode === c.Cartesian
                  ? this.performCartesianPan(e)
                  : this.panMode === c.PolarStartAngle
                  ? this.performPolarPan(!0, this.zoomSize)
                  : this.panMode === c.PolarVisibleRange &&
                    this.performPolarPan(!1, this.zoomSize)));
          }
          modifierPointerCancel(e) {
            super.modifierPointerCancel(e), this.activePointerEvents.clear();
          }
          modifierMouseUp(e) {
            super.modifierMouseUp(e), (this.panMode = void 0);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                primaryPanMode: this.primaryPanMode,
                secondaryPanMode: this.secondaryPanMode,
                growFactor: this.growFactor,
                zoomSize: this.zoomSize,
              };
            return Object.assign(e.options, t), e;
          }
          getIsActionAllowed(e) {
            return (
              this.activePointerEvents.values().next().value.pointerId ===
              e.pointerId
            );
          }
          performCartesianPan(e) {
            const t = e.mousePoint;
            let r = t.x - this.previousPoint.x,
              i = this.previousPoint.y - t.y;
            this.xyDirection === l.EXyDirection.XDirection && (i = 0),
              this.xyDirection === l.EXyDirection.YDirection && (r = 0),
              this.getIncludedXAxis().forEach((e) => {
                if (e.isPolarAxis) {
                  const t = e;
                  t.isAngular &&
                    ((t.xCenterOffset += r), (t.yCenterOffset -= i));
                }
              }),
              this.getIncludedYAxis().forEach((e) => {
                if (e.isPolarAxis) {
                  const t = e;
                  t.isAngular &&
                    ((t.xCenterOffset += r), (t.yCenterOffset -= i));
                }
              });
          }
          performPolarPan(e, t) {
            const { seriesViewRect: r } = this.parentSurface,
              o = (0, h.translateFromCanvasToSeriesViewRect)(
                this.previousPoint,
                r
              ),
              a = (0, h.translateFromCanvasToSeriesViewRect)(
                this.mousePoint,
                r
              );
            o &&
              a &&
              this.getIncludedXAxis().forEach((r) => {
                if (r.isPolarAxis) {
                  const s = r,
                    n = s.otherAxis;
                  if (s.isAngular) {
                    const r = s.reverseTransform(o.x, o.y),
                      d = s.reverseTransform(a.x, a.y),
                      h = d.x - r.x,
                      u = s.startAngle;
                    if (this.xyDirection !== l.EXyDirection.YDirection)
                      if (e) {
                        const e = u + h * this.growFactor;
                        (s.startAngle = e), (n.startAngle = e);
                      } else {
                        const { visibleRange: e, totalAngle: t } = s,
                          r = (h * this.growFactor * (e.max - e.min)) / t;
                        s.visibleRange = new i.NumberRange(
                          e.min - r,
                          e.max - r
                        );
                      }
                    if (this.xyDirection !== l.EXyDirection.XDirection)
                      if (t)
                        n.lengthScale =
                          n.lengthScale +
                          n.lengthScale * (d.y / r.y - 1) * this.growFactor;
                      else {
                        const { min: e, max: t } = n.visibleRange,
                          o = t + ((t * r.y) / d.y - t) * this.growFactor;
                        n.visibleRange = new i.NumberRange(e, o);
                      }
                  } else {
                    const r = s.reverseTransform(o.x, o.y),
                      d = s.reverseTransform(a.x, a.y),
                      h = d.y - r.y,
                      u = s.startAngle;
                    if (this.xyDirection !== l.EXyDirection.XDirection)
                      if (e) {
                        const e = u + h * this.growFactor;
                        (s.startAngle = e), (n.startAngle = e);
                      } else {
                        const { visibleRange: e, totalAngle: t } = n,
                          r = (h * this.growFactor * (e.max - e.min)) / t;
                        n.visibleRange = new i.NumberRange(
                          e.min - r,
                          e.max - r
                        );
                      }
                    if (this.xyDirection !== l.EXyDirection.YDirection)
                      if (t)
                        s.lengthScale =
                          s.lengthScale +
                          s.lengthScale * (d.x / r.x - 1) * this.growFactor;
                      else {
                        const { min: e, max: t } = s.visibleRange,
                          o = t + ((t * r.x) / d.x - t) * this.growFactor;
                        s.visibleRange = new i.NumberRange(e, o);
                      }
                  }
                }
              });
          }
        }
        t.PolarPanModifier = p;
      },
      36463: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarZoomExtentsModifier = void 0);
        const i = r(33485),
          o = r(10276),
          a = r(70162),
          s = r(75772),
          n = r(89955),
          l = r(66405),
          d = r(86699),
          h = r(14379),
          u = r(63407);
        class c extends u.ZoomExtentsModifier {
          constructor(e) {
            var t, r, i, a, s, l;
            super(e),
              (this.type = n.EChart2DModifierType.PolarZoomExtents),
              (this.resetRanges = !0),
              (this.resetStartAngles = !0),
              (this.resetTotalAngle = !0),
              (this.resetLengthScale = !0),
              (this.resetCenterPoint = !0),
              (this.resetInnerRadius = !0),
              (this.xStartAngle = null == e ? void 0 : e.xStartAngle),
              (this.yStartAngle = null == e ? void 0 : e.yStartAngle),
              (this.totalAngle = null == e ? void 0 : e.totalAngle),
              (this.lengthScale = null == e ? void 0 : e.lengthScale),
              (this.centerPoint = null == e ? void 0 : e.centerPoint),
              (this.innerRadius = null == e ? void 0 : e.innerRadius),
              (this.resetRanges =
                null !== (t = null == e ? void 0 : e.resetRanges) &&
                void 0 !== t
                  ? t
                  : this.resetRanges),
              (this.resetStartAngles =
                null !== (r = null == e ? void 0 : e.resetStartAngles) &&
                void 0 !== r
                  ? r
                  : this.resetStartAngles),
              (this.resetTotalAngle =
                null !== (i = null == e ? void 0 : e.resetTotalAngle) &&
                void 0 !== i
                  ? i
                  : this.resetTotalAngle),
              (this.resetLengthScale =
                null !== (a = null == e ? void 0 : e.resetLengthScale) &&
                void 0 !== a
                  ? a
                  : this.resetLengthScale),
              (this.resetCenterPoint =
                null !== (s = null == e ? void 0 : e.resetCenterPoint) &&
                void 0 !== s
                  ? s
                  : this.resetCenterPoint),
              (this.resetInnerRadius =
                null !== (l = null == e ? void 0 : e.resetInnerRadius) &&
                void 0 !== l
                  ? l
                  : this.resetInnerRadius),
              (null == e ? void 0 : e.easingFunction) ||
                (this.easingFunction = o.easing.outCubic);
          }
          get modifierType() {
            return l.EModifierType.Chart2DPolarModifier;
          }
          getAngularAxis() {
            const e = this.xAxis;
            return e.isAngular ? e : this.yAxis;
          }
          getRadialAxis() {
            const e = this.yAxis;
            return e.isAngular ? this.xAxis : e;
          }
          onAttach() {
            super.onAttach();
            const e = this.xAxis,
              t = this.yAxis;
            void 0 === this.xStartAngle && (this.xStartAngle = e.startAngle),
              void 0 === this.yStartAngle && (this.yStartAngle = t.startAngle),
              void 0 === this.totalAngle &&
                (this.totalAngle = this.getAngularAxis().totalAngle),
              void 0 === this.lengthScale &&
                (this.lengthScale = this.getRadialAxis().lengthScale),
              void 0 === this.centerPoint &&
                (this.centerPoint = new s.Point(
                  e.xCenterOffset,
                  e.yCenterOffset
                )),
              void 0 === this.innerRadius &&
                (this.innerRadius = this.getRadialAxis().innerRadius);
          }
          modifierDoubleClick(e) {
            const t = this.parentSurface;
            if (!t) return;
            const r = this.xAxis,
              o = this.yAxis;
            if (
              this.resetRanges &&
              (!this.onZoomExtents || this.onZoomExtents(t))
            )
              switch (this.xyDirection) {
                case d.EXyDirection.XyDirection:
                  t.zoomExtents(
                    this.animationDuration,
                    this.easingFunction,
                    () => t.setZoomState(h.EZoomState.AtExtents)
                  );
                  break;
                case d.EXyDirection.XDirection:
                  t.zoomExtentsX(this.animationDuration, this.easingFunction);
                  break;
                case d.EXyDirection.YDirection:
                  t.zoomExtentsY(this.animationDuration, this.easingFunction);
              }
            const s = r.startAngle,
              n = o.startAngle,
              l = this.getAngularAxis().totalAngle,
              u = this.resetStartAngles ? this.xStartAngle : s,
              c = this.resetStartAngles ? this.yStartAngle : n,
              p = this.resetTotalAngle ? this.totalAngle : l,
              g = this.getRadialAxis().lengthScale,
              y = this.resetLengthScale ? this.lengthScale : g,
              f = r.xCenterOffset,
              v = r.yCenterOffset,
              m = this.resetCenterPoint ? this.centerPoint.x : f,
              S = this.resetCenterPoint ? this.centerPoint.y : v,
              P = this.getRadialAxis().innerRadius,
              C = this.resetInnerRadius ? this.innerRadius : P,
              b = this.isAnimated ? this.animationDuration : 0,
              x = this.easingFunction;
            e.handled = !0;
            const A = new a.GenericAnimation({
              from: {
                xStartAngle: s,
                yStartAngle: n,
                totalAngle: l,
                lengthScale: g,
                xAxisXCenterOffset: f,
                xAxisYCenterOffset: v,
                innerRadius: P,
              },
              to: {
                xStartAngle: u,
                yStartAngle: c,
                totalAngle: p,
                lengthScale: y,
                xAxisXCenterOffset: m,
                xAxisYCenterOffset: S,
                innerRadius: C,
              },
              duration: b,
              ease: x,
              onAnimate: (e, t, a) => {
                const s = i.DoubleAnimator.interpolate(
                    e.xStartAngle,
                    t.xStartAngle,
                    a
                  ),
                  n = i.DoubleAnimator.interpolate(
                    e.yStartAngle,
                    t.yStartAngle,
                    a
                  ),
                  l = i.DoubleAnimator.interpolate(
                    e.totalAngle,
                    t.totalAngle,
                    a
                  ),
                  d = i.DoubleAnimator.interpolate(
                    e.lengthScale,
                    t.lengthScale,
                    a
                  );
                (r.startAngle = s),
                  (o.startAngle = n),
                  (this.getAngularAxis().totalAngle = l),
                  (this.getRadialAxis().lengthScale = d);
                const h = i.DoubleAnimator.interpolate(
                    e.xAxisXCenterOffset,
                    t.xAxisXCenterOffset,
                    a
                  ),
                  u = i.DoubleAnimator.interpolate(
                    e.xAxisYCenterOffset,
                    t.xAxisYCenterOffset,
                    a
                  ),
                  c = i.DoubleAnimator.interpolate(
                    e.innerRadius,
                    t.innerRadius,
                    a
                  );
                (r.xCenterOffset = h),
                  (r.yCenterOffset = u),
                  (o.xCenterOffset = h),
                  (o.yCenterOffset = u),
                  (this.getRadialAxis().innerRadius = c);
              },
            });
            t.addAnimation(A);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                centerPoint: this.centerPoint,
                innerRadius: this.innerRadius,
                lengthScale: this.lengthScale,
                resetCenterPoint: this.resetCenterPoint,
                resetInnerRadius: this.resetInnerRadius,
                resetLengthScale: this.resetLengthScale,
                resetRanges: this.resetRanges,
                resetStartAngles: this.resetStartAngles,
                resetTotalAngle: this.resetTotalAngle,
                totalAngle: this.totalAngle,
                xStartAngle: this.xStartAngle,
                yStartAngle: this.yStartAngle,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.PolarZoomExtentsModifier = c;
      },
      63903: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.updateRolloverModifierProps =
            t.splitIntoClusters =
            t.calcTooltipPositions =
            t.calcTooltipProps =
            t.RolloverModifier =
            t.TOOLTIP_SPACING =
              void 0);
        const i = r(45921),
          o = r(11043),
          a = r(89955),
          s = r(57935),
          n = r(5337),
          l = r(58345),
          d = r(32873),
          h = r(84392),
          u = r(31306),
          c = r(28677),
          p = r(69302),
          g = r(66443),
          y = r(60915),
          f = r(14184),
          v = r(86127),
          m = r(89046),
          S = r(22486);
        t.TOOLTIP_SPACING = 4;
        class P extends m.ChartModifierBase2D {
          constructor(e) {
            var t, r, n, l, d, h, u, c, g, y;
            super(e),
              (this.type = a.EChart2DModifierType.Rollover),
              (this.tooltipLegendOffsetX = 0),
              (this.tooltipLegendOffsetY = 0),
              (this.snapToDataPoint = !1),
              (this.hitTestRadius = 0),
              (this.showRolloverLineProperty = !0),
              (this.showTooltipProperty = !0),
              (this.absoluteXCoord = 0),
              (this.mousePosition = s.EMousePosition.OutOfCanvas),
              (this.allowTooltipOverlappingProperty = !1),
              (this.hitTestRenderableSeries =
                this.hitTestRenderableSeries.bind(this)),
              (this.placementDivIdProperty =
                null !== (t = null == e ? void 0 : e.placementDivId) &&
                void 0 !== t
                  ? t
                  : this.placementDivIdProperty),
              (this.rolloverLineAnnotation = this.createLine(e)),
              (null == e ? void 0 : e.tooltipLegendTemplate) &&
                "string" == typeof e.tooltipLegendTemplate &&
                (this.typeMap.set(
                  "tooltipLegendTemplate",
                  e.tooltipLegendTemplate
                ),
                (e.tooltipLegendTemplate = (0, i.getFunction)(
                  o.EBaseType.OptionFunction,
                  e.tooltipLegendTemplate
                ))),
              (this.tooltipLegendTemplate =
                null !== (r = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== r
                  ? r
                  : this.tooltipLegendTemplate),
              (this.tooltipLegendOffsetX =
                null !== (n = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== n
                  ? n
                  : this.tooltipLegendOffsetX),
              (this.tooltipLegendOffsetY =
                null !== (l = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== l
                  ? l
                  : this.tooltipLegendOffsetY),
              (null == e ? void 0 : e.tooltipDataTemplate) &&
                "string" == typeof e.tooltipDataTemplate &&
                (this.typeMap.set("tooltipDataTemplate", e.tooltipDataTemplate),
                (e.tooltipDataTemplate = (0, i.getFunction)(
                  o.EBaseType.OptionFunction,
                  e.tooltipDataTemplate
                ))),
              (this.tooltipDataTemplateProperty =
                null !== (d = null == e ? void 0 : e.tooltipDataTemplate) &&
                void 0 !== d
                  ? d
                  : this.tooltipDataTemplateProperty),
              (this.showRolloverLineProperty =
                null !== (h = null == e ? void 0 : e.showRolloverLine) &&
                void 0 !== h
                  ? h
                  : this.showRolloverLineProperty),
              (this.showTooltipProperty =
                null !== (u = null == e ? void 0 : e.showTooltip) &&
                void 0 !== u
                  ? u
                  : this.showTooltipProperty),
              (this.legendAnnotation = new p.RolloverLegendSvgAnnotation({
                tooltipLegendTemplate: this.tooltipLegendTemplate,
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
              })),
              (this.allowTooltipOverlappingProperty =
                null !== (c = null == e ? void 0 : e.allowTooltipOverlapping) &&
                void 0 !== c
                  ? c
                  : this.allowTooltipOverlappingProperty),
              (this.snapToDataPoint =
                null !== (g = null == e ? void 0 : e.snapToDataPoint) &&
                void 0 !== g
                  ? g
                  : this.snapToDataPoint),
              (this.hitTestRadius =
                null !== (y = null == e ? void 0 : e.hitTestRadius) &&
                void 0 !== y
                  ? y
                  : this.hitTestRadius);
          }
          createLine(e) {
            var t, r, i;
            return new c.LineAnnotation({
              xCoordinateMode: u.ECoordinateMode.Pixel,
              yCoordinateMode: u.ECoordinateMode.Pixel,
              strokeDashArray:
                null == e ? void 0 : e.rolloverLineStrokeDashArray,
              strokeThickness:
                null !==
                  (t = null == e ? void 0 : e.rolloverLineStrokeThickness) &&
                void 0 !== t
                  ? t
                  : 2,
              stroke:
                null !== (r = null == e ? void 0 : e.rolloverLineStroke) &&
                void 0 !== r
                  ? r
                  : f.SciChartSurfaceBase.DEFAULT_THEME.cursorLineBrush,
              xAxisId: this.xAxisId,
              yAxisId: this.yAxisId,
              showLabel:
                null !== (i = null == e ? void 0 : e.showAxisLabel) &&
                void 0 !== i &&
                i,
            });
          }
          applyTheme(e) {
            if (this.parentSurface) {
              const t = this.parentSurface.previousThemeProvider;
              this.rolloverLineAnnotation.stroke === t.cursorLineBrush &&
                (this.rolloverLineAnnotation.stroke = e.cursorLineBrush);
            }
          }
          get rolloverLineStroke() {
            return this.rolloverLineAnnotation.stroke;
          }
          set rolloverLineStroke(e) {
            (this.rolloverLineAnnotation.stroke = e),
              this.notifyPropertyChanged(S.PROPERTY.STROKE);
          }
          get rolloverLineStrokeThickness() {
            return this.rolloverLineAnnotation.strokeThickness;
          }
          set rolloverLineStrokeThickness(e) {
            (this.rolloverLineAnnotation.strokeThickness = e),
              this.notifyPropertyChanged(S.PROPERTY.STROKE_THICKNESS);
          }
          get rolloverLineStrokeDashArray() {
            return this.rolloverLineAnnotation.strokeDashArray;
          }
          set rolloverLineStrokeDashArray(e) {
            (this.rolloverLineAnnotation.strokeDashArray = e),
              this.notifyPropertyChanged(S.PROPERTY.STROKE_DASH_ARRAY);
          }
          get showRolloverLine() {
            return this.showRolloverLineProperty;
          }
          set showRolloverLine(e) {
            (this.showRolloverLineProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.SHOW_ROLLOVER_LINE);
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.TOOLTIP_DATA_TEMPLATE);
          }
          get showTooltip() {
            return this.showTooltipProperty;
          }
          set showTooltip(e) {
            (this.showTooltipProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.SHOW_TOOLTIP);
          }
          get allowTooltipOverlapping() {
            return this.allowTooltipOverlappingProperty;
          }
          set allowTooltipOverlapping(e) {
            (this.allowTooltipOverlappingProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.ALLOW_TOOLTIP_OVERLAPPING);
          }
          onAttach() {
            super.onAttach(),
              this.addLineAnnotationToSurface(),
              this.parentSurface.modifierAnnotations.add(this.legendAnnotation),
              this.getIncludedRenderableSeries().forEach((e) =>
                this.addSeriesAnnotationsToParentSurface(e)
              );
          }
          addLineAnnotationToSurface() {
            this.parentSurface.modifierAnnotations.add(
              this.rolloverLineAnnotation
            );
          }
          onDetach() {
            super.onDetach(),
              this.parentSurface.modifierAnnotations.remove(
                this.rolloverLineAnnotation,
                !0
              ),
              this.parentSurface.modifierAnnotations.remove(
                this.legendAnnotation
              ),
              this.getIncludedRenderableSeries().forEach((e) =>
                this.removeSeriesAnnotationsFromParentSurface(e)
              );
          }
          onAttachSeries(e) {
            super.onAttachSeries(e),
              this.getIncludedRenderableSeries().includes(e) &&
                (this.addSeriesAnnotationsToParentSurface(e),
                (this.legendAnnotation.seriesInfos = this.getSeriesInfos()));
          }
          onDetachSeries(e) {
            super.onDetachSeries(e),
              this.removeSeriesAnnotationsFromParentSurface(e);
          }
          modifierMouseMove(e) {
            if (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent)
              return;
            let t;
            this.activePointerEvents.set(e.pointerId, e),
              super.modifierMouseMove(e),
              this.mousePoint
                ? ((t = (0, d.translateFromCanvasToSeriesViewRect)(
                    this.mousePoint,
                    this.parentSurface.seriesViewRect
                  )),
                  (this.mousePosition = t
                    ? s.EMousePosition.SeriesArea
                    : s.EMousePosition.AxisArea))
                : (this.mousePosition = s.EMousePosition.OutOfCanvas),
              this.getIsActionAllowed(e) && this.update();
          }
          modifierMouseLeave(e) {
            super.modifierMouseLeave(e),
              (this.mousePosition = s.EMousePosition.OutOfCanvas),
              this.update();
          }
          onParentSurfaceRendered() {
            this.update();
          }
          includeSeries(e, t) {
            var r, i;
            return (
              !!super.includeSeries(e, t) &&
              (this.isAttached &&
                (!0 === t && this.addSeriesAnnotationsToParentSurface(e),
                !1 === t && this.removeSeriesAnnotationsFromParentSurface(e),
                this.parentSurface &&
                  (this.legendAnnotation.seriesInfos = this.getSeriesInfos()),
                null === (r = this.parentSurface) ||
                  void 0 === r ||
                  r.invalidateElement()),
              null === (i = this.parentSurface) ||
                void 0 === i ||
                i.invalidateElement(),
              !0)
            );
          }
          getIncludedRenderableSeries() {
            const e = this.parentSurface.renderableSeries
                .asArray()
                .filter(
                  (e) =>
                    !e.isStacked &&
                    e.isVisible &&
                    e.rolloverModifierProps.showRollover &&
                    this.testIsIncludedSeries(e)
                ),
              t = this.parentSurface.renderableSeries
                .asArray()
                .filter((e) => e.isStacked),
              r = e;
            return (
              t.forEach((e) => {
                e.getVisibleSeries().forEach((e) => {
                  e.rolloverModifierProps.showRollover &&
                    this.testIsIncludedSeries(e) &&
                    r.push(e);
                });
              }),
              r
            );
          }
          hitTestRenderableSeries(e, t) {
            if (t)
              return this.hitTestRadius <= 0
                ? e.hitTestProvider.hitTestXSlice(t.x, t.y)
                : e.hitTestProvider.hitTestDataPoint(
                    t.x,
                    t.y,
                    this.hitTestRadius
                  );
          }
          getMousePosition() {
            return this.mousePosition;
          }
          toJSON() {
            var e, t;
            const r = super.toJSON(),
              i = {
                snapToDataPoint: this.snapToDataPoint,
                placementDivId: this.placementDivId,
                hitTestRadius: this.hitTestRadius,
                allowTooltipOverlapping: this.allowTooltipOverlapping,
                rolloverLineStrokeDashArray: this.rolloverLineStrokeDashArray,
                rolloverLineStroke: this.rolloverLineStroke,
                rolloverLineStrokeThickness: this.rolloverLineStrokeThickness,
                showRolloverLine: this.showRolloverLine,
                showTooltip: this.showTooltip,
                showAxisLabel:
                  null !==
                    (t =
                      null === (e = this.rolloverLineAnnotation) || void 0 === e
                        ? void 0
                        : e.showLabel) &&
                  void 0 !== t &&
                  t,
                tooltipDataTemplate: this.typeMap.get("tooltipDataTemplate"),
                tooltipLegendOffsetX: this.tooltipLegendOffsetX,
                tooltipLegendOffsetY: this.tooltipLegendOffsetY,
                tooltipLegendTemplate: this.typeMap.get(
                  "tooltipLegendTemplate"
                ),
              };
            return Object.assign(r.options, i), r;
          }
          CalculateTooltipPositions(e, r, i, o, a, s = !1) {
            return (0, t.calcTooltipPositions)(e, r, i, o, a, s);
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              e === S.PROPERTY.X_AXIS_ID &&
                ((this.rolloverLineAnnotation.xAxisId = this.xAxisId),
                (this.legendAnnotation.xAxisId = this.xAxisId)),
              e === S.PROPERTY.Y_AXIS_ID &&
                ((this.rolloverLineAnnotation.yAxisId = this.yAxisId),
                (this.legendAnnotation.yAxisId = this.yAxisId));
          }
          isVerticalChart() {
            var e, t;
            return (
              null !==
                (t =
                  null === (e = this.xAxis) || void 0 === e
                    ? void 0
                    : e.isVerticalChart) &&
              void 0 !== t &&
              t
            );
          }
          removeSeriesAnnotationsFromParentSurface(e) {
            this.parentSurface &&
              (e.isStacked
                ? e.asArray().forEach((e) => {
                    this.parentSurface.modifierAnnotations.remove(
                      this.getRolloverProps(e).marker
                    ),
                      this.parentSurface.modifierAnnotations.remove(
                        this.getRolloverProps(e).tooltip
                      ),
                      this.getRolloverProps(e).delete();
                  })
                : (this.parentSurface.modifierAnnotations.remove(
                    this.getRolloverProps(e).marker
                  ),
                  this.parentSurface.modifierAnnotations.remove(
                    this.getRolloverProps(e).tooltip
                  ),
                  this.getRolloverProps(e).delete(),
                  e.type === n.ESeriesType.BandSeries &&
                    (this.parentSurface.modifierAnnotations.remove(
                      this.getRolloverProps1(e).marker
                    ),
                    this.parentSurface.modifierAnnotations.remove(
                      this.getRolloverProps1(e).tooltip
                    ),
                    this.getRolloverProps1(e).delete())));
          }
          addSeriesAnnotationsToParentSurface(e) {
            if (
              !this.parentSurface ||
              e.type === n.ESeriesType.StackedMountainCollection ||
              e.type === n.ESeriesType.StackedColumnCollection
            )
              return;
            (this.getRolloverProps(e).rolloverModifier = this),
              C(
                e,
                this.getRolloverProps(e),
                this.getRolloverProps1(e),
                this.placementDivIdProperty
              );
            const t = this.getRolloverProps(e).marker;
            this.parentSurface.modifierAnnotations.contains(t) ||
              (this.parentSurface.modifierAnnotations.add(
                this.getRolloverProps(e).marker
              ),
              this.parentSurface.modifierAnnotations.add(
                this.getRolloverProps(e).tooltip
              ),
              e.type === n.ESeriesType.BandSeries &&
                ((this.getRolloverProps1(e).rolloverModifier = this),
                this.parentSurface.modifierAnnotations.add(
                  this.getRolloverProps1(e).marker
                ),
                this.parentSurface.modifierAnnotations.add(
                  this.getRolloverProps1(e).tooltip
                )));
          }
          getRolloverProps(e) {
            return e.rolloverModifierProps;
          }
          getRolloverProps1(e) {
            return e.rolloverModifierProps1;
          }
          update() {
            this.updateLine(),
              this.updateSeriesAnnotations(),
              this.tooltipLegendTemplate &&
                (this.legendAnnotation.seriesInfos = this.getSeriesInfos());
          }
          updateLine() {
            if (this.mousePosition === s.EMousePosition.SeriesArea)
              if (this.showRolloverLineProperty)
                if (this.snapToDataPoint) {
                  const e = this.getIncludedRenderableSeries()[0];
                  if (e) {
                    const t = this.hitTestRenderableSeries(e, this.mousePoint);
                    if (t && t.isWithinDataBounds) {
                      this.rolloverLineAnnotation.isHidden = !1;
                      const e = (0, d.translateToNotScaled)(t.xCoord);
                      (this.rolloverLineAnnotation.x1 = e),
                        (this.rolloverLineAnnotation.x2 = e),
                        (this.rolloverLineAnnotation.y1 = 0),
                        (this.rolloverLineAnnotation.y2 = this.isVerticalChart()
                          ? (0, d.translateToNotScaled)(
                              this.parentSurface.seriesViewRect.right
                            )
                          : (0, d.translateToNotScaled)(
                              this.parentSurface.seriesViewRect.bottom
                            ));
                    } else this.rolloverLineAnnotation.isHidden = !0;
                  } else this.rolloverLineAnnotation.isHidden = !0;
                } else {
                  this.rolloverLineAnnotation.isHidden = !1;
                  const e = (0, d.translateFromCanvasToSeriesViewRect)(
                    this.mousePoint,
                    this.parentSurface.seriesViewRect
                  );
                  if (e) {
                    const t = (0, d.translateToNotScaled)(e.x),
                      r = (0, d.translateToNotScaled)(e.y);
                    if (this.parentSurface.isPolar) {
                      const e = this.yAxis,
                        i = e.reverseTransform(t, r);
                      (this.rolloverLineAnnotation.x1 = 0),
                        (this.rolloverLineAnnotation.x2 = i.y),
                        (this.rolloverLineAnnotation.y1 = 0),
                        (this.rolloverLineAnnotation.y2 = e.getAxisSize());
                    } else
                      this.isVerticalChart()
                        ? ((this.rolloverLineAnnotation.x1 = r),
                          (this.rolloverLineAnnotation.x2 = r),
                          (this.rolloverLineAnnotation.y1 = 0),
                          (this.rolloverLineAnnotation.y2 = (0,
                          d.translateToNotScaled)(
                            this.parentSurface.seriesViewRect.right
                          )))
                        : ((this.rolloverLineAnnotation.x1 = t),
                          (this.rolloverLineAnnotation.x2 = t),
                          (this.rolloverLineAnnotation.y1 = 0),
                          (this.rolloverLineAnnotation.y2 = (0,
                          d.translateToNotScaled)(
                            this.parentSurface.seriesViewRect.bottom
                          )));
                  }
                }
              else this.rolloverLineAnnotation.isHidden = !0;
            else this.rolloverLineAnnotation.isHidden = !0;
          }
          updateSeriesAnnotations() {
            const e = this.getIncludedRenderableSeries();
            if (
              (e.forEach((e) => {
                const t = this.getRolloverProps(e);
                t.marker || this.addSeriesAnnotationsToParentSurface(e),
                  t.marker.suspendInvalidate(),
                  t.tooltip.suspendInvalidate(),
                  (t.marker.isHidden = !0),
                  (t.tooltip.isHidden = !0),
                  (t.tooltip.x1 = void 0),
                  (t.tooltip.y1 = void 0),
                  e.type === n.ESeriesType.BandSeries &&
                    (t.marker.suspendInvalidate(),
                    t.tooltip.suspendInvalidate(),
                    (t.marker.isHidden = !0),
                    (t.tooltip.isHidden = !0),
                    (t.tooltip.x1 = void 0),
                    (t.tooltip.y1 = void 0));
              }),
              this.mousePosition !== s.EMousePosition.SeriesArea)
            )
              return void e.forEach((e) => {
                const t = this.getRolloverProps(e);
                t.marker.resumeInvalidate(),
                  t.tooltip.resumeInvalidate(),
                  e.type === n.ESeriesType.BandSeries &&
                    (this.getRolloverProps1(e).marker.resumeInvalidate(),
                    this.getRolloverProps1(e).tooltip.resumeInvalidate());
              });
            const r = [],
              i = this.isVerticalChart()
                ? this.parentSurface.seriesViewRect.width
                : this.parentSurface.seriesViewRect.height;
            let o;
            e.forEach((e, o) => {
              const a = this.hitTestRenderableSeries(e, this.mousePoint);
              if (a) {
                if (
                  ((e.type !== n.ESeriesType.StackedColumnSeries &&
                    0 === this.hitTestRadius) ||
                    a.isHit) &&
                  0 <= a.yCoord &&
                  a.yCoord <= i
                ) {
                  this.absoluteXCoord = this.isVerticalChart()
                    ? a.yCoord
                    : a.xCoord;
                  const i = this.isVerticalChart() ? a.xCoord : a.yCoord,
                    s = (0, t.calcTooltipProps)(
                      o,
                      e,
                      this.getRolloverProps(e),
                      this.parentSurface.seriesViewRect,
                      a.xValue,
                      a.yValue,
                      this.absoluteXCoord,
                      i,
                      a,
                      v.DpiHelper.PIXEL_RATIO,
                      !1,
                      this.isVerticalChart()
                    );
                  s && r.push(s);
                }
                if (
                  e.type === n.ESeriesType.BandSeries &&
                  0 <= a.y1Coord &&
                  a.y1Coord <= i
                ) {
                  const i = this.isVerticalChart() ? a.y1Coord : a.xCoord,
                    s = this.isVerticalChart() ? a.xCoord : a.y1Coord,
                    n = (0, t.calcTooltipProps)(
                      o,
                      e,
                      this.getRolloverProps1(e),
                      this.parentSurface.seriesViewRect,
                      a.xValue,
                      a.y1Value,
                      i,
                      s,
                      a,
                      v.DpiHelper.PIXEL_RATIO,
                      !0,
                      this.isVerticalChart()
                    );
                  n && r.push(n);
                }
              }
            }),
              (o = this.isVerticalChart()
                ? r.sort((e, t) =>
                    e.xCoord > t.xCoord ? 1 : t.xCoord > e.xCoord ? -1 : 0
                  )
                : r.sort((e, t) =>
                    e.yCoord > t.yCoord ? 1 : t.yCoord > e.yCoord ? -1 : 0
                  )),
              this.CalculateTooltipPositions(
                o,
                this.allowTooltipOverlapping,
                t.TOOLTIP_SPACING * v.DpiHelper.PIXEL_RATIO,
                this.parentSurface.seriesViewRect,
                v.DpiHelper.PIXEL_RATIO,
                this.isVerticalChart()
              ).forEach((r) => {
                const i = e[r.index],
                  o = this.showTooltip && r.seriesInfo.isHit,
                  a = r.seriesInfo.isHit;
                r.isY1
                  ? (0, t.updateRolloverModifierProps)(
                      this.getRolloverProps1(i),
                      i,
                      r,
                      o,
                      a,
                      this.placementDivId
                    )
                  : (0, t.updateRolloverModifierProps)(
                      this.getRolloverProps(i),
                      i,
                      r,
                      o,
                      a,
                      this.placementDivId
                    );
              }),
              e.forEach((e) => {
                this.getRolloverProps(e).marker.resumeInvalidate(),
                  this.getRolloverProps(e).tooltip.resumeInvalidate(),
                  e.type === n.ESeriesType.BandSeries &&
                    (this.getRolloverProps1(e).marker.resumeInvalidate(),
                    this.getRolloverProps1(e).tooltip.resumeInvalidate());
              });
          }
          getSeriesInfos() {
            return this.getIncludedRenderableSeries()
              .map((e) => {
                const t = this.hitTestRenderableSeries(e, this.mousePoint);
                if (t) return e.getSeriesInfo(t);
              })
              .filter((e) => void 0 !== e);
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            var t;
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              null === (t = this.parentSurface) ||
                void 0 === t ||
                t.renderableSeries.asArray().forEach((e) => {
                  (this.getRolloverProps(e).tooltip.placementDivId =
                    this.placementDivIdProperty),
                    (this.getRolloverProps1(e).tooltip.placementDivId =
                      this.placementDivIdProperty);
                }));
          }
        }
        (t.RolloverModifier = P),
          (t.calcTooltipProps = (
            e,
            t,
            r,
            i,
            o,
            a,
            s,
            n,
            l,
            d,
            h = !1,
            u = !1
          ) => {
            const c = t.getSeriesInfo(l),
              p = r.tooltip.width,
              g = p * d,
              y = r.tooltip.height,
              f = y * d,
              v = n,
              m = i.height - n,
              S = 5 * d,
              P = i.width - s < g ? -p : 5;
            let C = u ? S : -y / 2;
            return (
              u
                ? m < f + S && (C = ((f + S) / d) * -1)
                : v < f / 2
                ? (C = -v / d)
                : m < f / 2 && (C = -(f - m) / d),
              {
                index: e,
                isY1: h,
                xValue: o,
                yValue: a,
                xCoord: s,
                yCoord: n,
                hitTestPointValues: l.hitTestPointValues,
                isCategoryAxis: l.isCategoryAxis,
                xCoordShift: P,
                yCoordShift: C,
                height: f,
                width: g,
                seriesInfo: c,
              }
            );
          }),
          (t.calcTooltipPositions = (e, r, i, o, a, s = !1) => {
            const n = (0, l.getTooltipPositionProperties)(s);
            s &&
              e.forEach((e) => {
                const t = e.width / 2 / a;
                e.xCoord > t && (e[n.shiftPropertyName] = -e.width / 2 / a);
              });
            const d = (0, l.checkHasOverlap)(e, i, a, n),
              h = e.length;
            return (
              !r &&
                h >= 2 &&
                d &&
                (0, t.splitIntoClusters)(e, i, a, n).forEach((e) => {
                  if (e.length >= 2) {
                    const t = (0, l.spreadTooltips)(e, a, n, i, o);
                    e.forEach((e) => {
                      e[n.shiftPropertyName] = t.get(e.index);
                    });
                  }
                }),
              e
            );
          }),
          (t.splitIntoClusters = (e, t, r, i) => {
            const o = [...e].sort(
                (e, t) => e[i.coordPropertyName] - t[i.coordPropertyName]
              ),
              a = [];
            let s = [];
            for (const e of o)
              if (0 === s.length) s.push(e);
              else {
                const o = (0, l.getStartPoint)(
                    e[i.coordPropertyName],
                    e[i.shiftPropertyName],
                    r
                  ),
                  n = s[s.length - 1];
                o <
                (0, l.getEndPoint)(
                  n[i.coordPropertyName],
                  n[i.shiftPropertyName],
                  r,
                  n[i.sizePropertyName]
                ) +
                  t / r
                  ? s.push(e)
                  : (a.push(s), (s = [e]));
              }
            return s.length > 0 && a.push(s), a;
          });
        const C = (e, t, r, i) => {
          var o, a, s, l;
          if (
            (t.marker ||
              ((t.marker = new g.RolloverMarkerSvgAnnotation(t)),
              (t.marker.xAxisId = e.xAxisId),
              (t.marker.yAxisId = e.yAxisId)),
            t.tooltip ||
              ((t.tooltipTitle =
                null !==
                  (a =
                    null !== (o = t.tooltipTitle) && void 0 !== o
                      ? o
                      : e.seriesName) && void 0 !== a
                  ? a
                  : ""),
              (t.tooltipColor = t.tooltipColor),
              (t.shadowColor = e.parentSurface.themeProvider.shadowEffectColor),
              (t.tooltip = new y.RolloverTooltipSvgAnnotation(t, {
                seriesType: e.type,
                placementDivId: i,
              })),
              (t.tooltip.xAxisId = e.xAxisId),
              (t.tooltip.yAxisId = e.yAxisId)),
            e.type === n.ESeriesType.BandSeries)
          ) {
            const t = e;
            r.marker ||
              ((r.marker = new g.RolloverMarkerSvgAnnotation(r)),
              (r.marker.xAxisId = t.xAxisId),
              (r.marker.yAxisId = t.yAxisId)),
              r.tooltip ||
                ((r.tooltipTitle =
                  null !==
                    (l =
                      null !== (s = r.tooltipTitle) && void 0 !== s
                        ? s
                        : t.seriesName) && void 0 !== l
                    ? l
                    : ""),
                (r.tooltipColor = r.tooltipColor),
                (r.tooltip = new y.RolloverTooltipSvgAnnotation(r, {
                  placementDivId: i,
                })),
                (r.tooltip.xAxisId = t.xAxisId),
                (r.tooltip.yAxisId = t.yAxisId));
          }
        };
        t.updateRolloverModifierProps = (e, t, r, i, o, a) => {
          (e.tooltip.seriesInfo = r.seriesInfo),
            r.isY1 && (e.tooltip.seriesInfo.isFirstSeries = !1),
            o &&
              ((e.marker.isHidden = !1),
              (e.marker.x1 = r.xValue),
              (e.marker.y1 = r.yValue),
              e.markerColor.startsWith(h.AUTO_COLOR) &&
                (e.markerColor = r.isY1 ? t.strokeY1 : t.stroke)),
            i
              ? ((e.tooltip.isHidden = !1),
                (e.tooltip.x1 = r.xValue),
                (e.tooltip.y1 = r.yValue),
                (e.tooltip.xCoordShift = r.xCoordShift),
                (e.tooltip.yCoordShift = r.yCoordShift),
                e.tooltipColor.startsWith(h.AUTO_COLOR) &&
                  (e.tooltipColor = r.isY1 ? t.strokeY1 : t.stroke))
              : a && e.tooltip.delete();
        };
      },
      18809: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getRubberBandRect = t.RubberBandXyZoomModifier = void 0);
        const i = r(10276),
          o = r(56744),
          a = r(75772),
          s = r(87459),
          n = r(6859),
          l = r(89955),
          d = r(86699),
          h = r(14379),
          u = r(32873),
          c = r(90182),
          p = r(89046),
          g = r(22486);
        class y extends p.ChartModifierBase2D {
          constructor(e) {
            var t, r, o, a, s, d, h;
            super(e),
              (this.type = l.EChart2DModifierType.RubberBandXYZoom),
              (this.isAnimated = !0),
              (this.animationDuration = 400),
              (this.easingFunction = i.easing.outExpo),
              (this.isClicked = !1),
              (this.fillProperty = "#42b64933"),
              (this.strokeProperty = "#42b64977"),
              (this.strokeThicknessProperty = 2),
              (this.fill =
                null !== (t = null == e ? void 0 : e.fill) && void 0 !== t
                  ? t
                  : this.fillProperty),
              (this.stroke =
                null !== (r = null == e ? void 0 : e.stroke) && void 0 !== r
                  ? r
                  : this.strokeProperty),
              (this.strokeThickness =
                null !== (o = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== o
                  ? o
                  : this.strokeThicknessProperty),
              (this.isAnimated =
                null === (a = null == e ? void 0 : e.isAnimated) ||
                void 0 === a ||
                a),
              (this.animationDuration =
                null !== (s = null == e ? void 0 : e.animationDuration) &&
                void 0 !== s
                  ? s
                  : 400),
              (null == e ? void 0 : e.easingFunction) &&
                "string" == typeof e.easingFunction &&
                (e.easingFunction = i.easing[e.easingFunction]),
              (this.easingFunction =
                null !== (d = null == e ? void 0 : e.easingFunction) &&
                void 0 !== d
                  ? d
                  : i.easing.outExpo),
              (this.executeCondition =
                null !== (h = null == e ? void 0 : e.executeCondition) &&
                void 0 !== h
                  ? h
                  : { button: n.EExecuteOn.MouseLeftButton });
          }
          applyTheme(e) {
            this.testPropertyChanged(g.PROPERTY.FILL) ||
              (this.fill = e.rubberBandFillBrush),
              this.testPropertyChanged(g.PROPERTY.STROKE) ||
                (this.stroke = e.rubberBandStrokeBrush);
          }
          onDetach() {
            super.onDetach(),
              (this.rubberBandRect = (0, o.deleteSafe)(this.rubberBandRect));
          }
          modifierMouseDown(e) {
            if (
              (super.modifierMouseDown(e),
              !this.checkExecuteConditions(e).isPrimary)
            )
              return;
            if (!this.isAttached)
              throw new Error(
                "Should not call RubberBandXyZoomModifier.modifierMouseDown if not attached"
              );
            this.parentSurface.setZoomState(h.EZoomState.UserZooming);
            const t = (0, u.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect
            );
            t && ((this.pointFrom = t), (this.isClicked = !0));
          }
          modifierMouseMove(e) {
            super.modifierMouseMove(e);
            const { seriesViewRect: t } = this.parentSurface;
            if (this.isClicked) {
              this.pointTo = (0, u.translateFromCanvasToSeriesViewRect)(
                s.Rect.clipPointToRect(e.mousePoint, t),
                t
              );
              const r = this.parentSurface.getCoordSvgTranslation(),
                {
                  x: i,
                  right: o,
                  y: a,
                  bottom: n,
                } = f(
                  this.pointFrom,
                  this.pointTo,
                  this.xyDirection,
                  this.parentSurface.seriesViewRect
                );
              (this.rubberBandRect.isHidden = !1),
                (this.rubberBandRect.x1 = (0, u.translateToNotScaled)(i + r.x)),
                (this.rubberBandRect.x2 = (0, u.translateToNotScaled)(o + r.x)),
                (this.rubberBandRect.y1 = (0, u.translateToNotScaled)(a + r.y)),
                (this.rubberBandRect.y2 = (0, u.translateToNotScaled)(n + r.y));
            }
          }
          modifierMouseUp(e) {
            if (
              (super.modifierMouseUp(e),
              this.checkExecuteConditions(e).isPrimary && this.isClicked)
            ) {
              const { seriesViewRect: t } = this.parentSurface;
              this.pointTo = (0, u.translateFromCanvasToSeriesViewRect)(
                s.Rect.clipPointToRect(e.mousePoint, t),
                t
              );
              const {
                x: r,
                right: i,
                y: o,
                bottom: n,
              } = f(
                this.pointFrom,
                this.pointTo,
                this.xyDirection,
                this.parentSurface.seriesViewRect
              );
              (this.isClicked = !1),
                (this.rubberBandRect.isHidden = !0),
                this.calculateDraggedDistance() > y.MIN_DRAG_SENSITIVITY &&
                  this.performZoom(new a.Point(r, o), new a.Point(i, n));
            }
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE_THICKNESS);
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE);
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.FILL);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                animationDuration: this.animationDuration,
                easingFunction: this.easingFunction.name,
                fill: this.fill,
                isAnimated: this.isAnimated,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
              };
            return Object.assign(e.options, t), e;
          }
          delete() {
            (this.parentSurfaceProperty = void 0),
              (this.rubberBandRect = (0, o.deleteSafe)(this.rubberBandRect)),
              super.delete();
          }
          performZoom(e, t) {
            const r = [
                d.EXyDirection.XDirection,
                d.EXyDirection.XyDirection,
              ].includes(this.xyDirection),
              i = [
                d.EXyDirection.YDirection,
                d.EXyDirection.XyDirection,
              ].includes(this.xyDirection);
            this.parentSurface.xAxes.asArray().forEach((o) => {
              ((!o.isVerticalChart && r) || (o.isVerticalChart && i)) &&
                this.performZoomOnAxis(
                  o,
                  o.isVerticalChart ? e.y : e.x,
                  o.isVerticalChart ? t.y : t.x
                );
            }),
              this.parentSurface.yAxes.asArray().forEach((o) => {
                ((!o.isVerticalChart && i) || (o.isVerticalChart && r)) &&
                  this.performZoomOnAxis(
                    o,
                    o.isVerticalChart ? e.x : e.y,
                    o.isVerticalChart ? t.x : t.y
                  );
              });
          }
          performZoomOnAxis(e, t, r) {
            e.zoom(
              t,
              r,
              this.isAnimated ? this.animationDuration : 0,
              this.easingFunction
            );
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e), this.updateRubberBandRect();
          }
          calculateDraggedDistance() {
            const e = Math.pow(this.pointFrom.x - this.pointTo.x, 2),
              t = Math.pow(this.pointFrom.y - this.pointTo.y, 2);
            return Math.sqrt(e + t);
          }
          updateRubberBandRect() {
            this.parentSurface &&
              ((this.rubberBandRect = (0, o.deleteSafe)(this.rubberBandRect)),
              (this.rubberBandRect = new c.RubberBandSvgRect(
                this.parentSurface.domSvgContainer,
                this.fill,
                this.stroke,
                this.strokeThickness
              )));
          }
        }
        function f(e, t, r, i) {
          let o = t.x <= e.x ? t.x : e.x,
            n = t.x <= e.x ? e.x : t.x,
            l = t.y <= e.y ? t.y : e.y,
            h = t.y <= e.y ? e.y : t.y;
          return (
            r === d.EXyDirection.XDirection && ((l = 0), (h = i.height)),
            r === d.EXyDirection.YDirection && ((o = 0), (n = i.width)),
            s.Rect.createWithPoints(new a.Point(o, l), new a.Point(n, h))
          );
        }
        (t.RubberBandXyZoomModifier = y),
          (y.MIN_DRAG_SENSITIVITY = 5),
          (t.getRubberBandRect = f);
      },
      32545: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesSelectionModifier = void 0);
        const i = r(45921),
          o = r(3214),
          a = r(11043),
          s = r(6859),
          n = r(89955),
          l = r(45215),
          d = r(7541),
          h = r(69570),
          u = r(9150),
          c = r(89046),
          p = r(22486);
        class g extends c.ChartModifierBase2D {
          constructor(e) {
            var t, r, l;
            if (
              (super(e),
              (this.type = n.EChart2DModifierType.SeriesSelection),
              (this.selectedSeries = []),
              (this.hoveredSeries = []),
              (this.selectionChanged = new o.EventHandler()),
              (this.hoverChanged = new o.EventHandler()),
              (this.hitTestRadiusProperty =
                (null == e ? void 0 : e.hitTestRadius) ||
                d.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS),
              (this.enableSelection =
                null === (t = null == e ? void 0 : e.enableSelection) ||
                void 0 === t ||
                t),
              (this.enableHover =
                null !== (r = null == e ? void 0 : e.enableHover) &&
                void 0 !== r &&
                r),
              (this.executeCondition =
                null !== (l = null == e ? void 0 : e.executeCondition) &&
                void 0 !== l
                  ? l
                  : { button: s.EExecuteOn.MouseLeftButton }),
              null == e ? void 0 : e.onSelectionChanged)
            )
              if ("string" == typeof e.onSelectionChanged) {
                this.typeMap.set("onSelectionChanged", e.onSelectionChanged);
                const t = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.onSelectionChanged
                );
                this.selectionChanged.subscribe(t);
              } else this.selectionChanged.subscribe(e.onSelectionChanged);
            if (null == e ? void 0 : e.onHoverChanged)
              if ("string" == typeof e.onHoverChanged) {
                this.typeMap.set("onHoverChanged", e.onHoverChanged);
                const t = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.onHoverChanged
                );
                this.hoverChanged.subscribe(t);
              } else this.hoverChanged.subscribe(e.onHoverChanged);
            (this.updateSeriesSelected = this.updateSeriesSelected.bind(this)),
              (this.updateSeriesHovered = this.updateSeriesHovered.bind(this)),
              (this.getAllSeries = this.getAllSeries.bind(this));
          }
          get hitTestRadius() {
            return this.hitTestRadiusProperty;
          }
          set hitTestRadius(e) {
            (this.hitTestRadiusProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.HIT_TEST_RADIUS);
          }
          onAttach() {
            var e;
            super.onAttach(),
              (this.selectedSeries = []),
              null === (e = this.getAllSeries()) ||
                void 0 === e ||
                e.forEach((e) => this.onAttachSeries(e));
          }
          onDetach() {
            var e;
            super.onDetach(),
              (this.selectedSeries = []),
              null === (e = this.getAllSeries()) ||
                void 0 === e ||
                e.forEach((e) => this.onDetachSeries(e));
          }
          onAttachSeries(e) {
            super.onAttachSeries(e),
              e.isSelected && this.selectedSeries.push(e),
              e.selected.subscribe(this.updateSeriesSelected),
              e.isHovered && this.hoveredSeries.push(e),
              e.hovered.subscribe(this.updateSeriesHovered);
          }
          onDetachSeries(e) {
            super.onDetachSeries(e),
              (this.selectedSeries = (0, l.arrayRemove)(
                this.selectedSeries,
                e
              )),
              e.selected.unsubscribe(this.updateSeriesSelected),
              (this.hoveredSeries = (0, l.arrayRemove)(this.hoveredSeries, e)),
              e.hovered.unsubscribe(this.updateSeriesHovered);
          }
          modifierMouseDown(e) {
            if (
              (super.modifierMouseDown(e),
              this.checkExecuteConditions(e).isPrimary && !this.isAttached)
            )
              throw new Error(
                "Should not call SeriesSelectionModifier.modifierMouseDown if not attached"
              );
          }
          modifierMouseMove(e) {
            var t;
            if ((super.modifierMouseMove(e), !this.enableHover)) return;
            const r = this.getAllSeries(),
              i = r.map((t) =>
                t.hitTestProvider.hitTest(
                  e.mousePoint.x,
                  e.mousePoint.y,
                  this.hitTestRadius
                )
              );
            try {
              this.preventReentrancy = !0;
              const e = [...this.hoveredSeries];
              let o;
              (this.hoveredSeries = []),
                (null == i ? void 0 : i.length) > 0
                  ? ((o = i
                      .filter((e) => e.isHit)
                      .sort(
                        (e, t) =>
                          e.getEuclideanDistance() - t.getEuclideanDistance()
                      )[0]),
                    o
                      ? ((o.associatedSeries.isHovered = !0),
                        this.hoveredSeries.push(o.associatedSeries))
                      : r.forEach((e) => (e.isHovered = !1)),
                    i
                      .filter((e) => e !== o)
                      .forEach((e) => {
                        (null == e ? void 0 : e.associatedSeries) &&
                          (e.associatedSeries.isHovered = !1);
                      }))
                  : r.forEach((e) => (e.isHovered = !1)),
                (e.length !== this.hoveredSeries.length ||
                  e.some((e) => !this.hoveredSeries.includes(e))) &&
                  (null === (t = this.hoverChanged) ||
                    void 0 === t ||
                    t.raiseEvent(
                      new h.HoveredChangedArgs(this, this.hoveredSeries, r, o)
                    ));
            } finally {
              this.preventReentrancy = !1;
            }
          }
          modifierMouseLeave(e) {
            var t;
            this.preventReentrancy = !0;
            const r = this.getAllSeries();
            [...this.hoveredSeries].length > 0 &&
              (r.forEach((e) => (e.isHovered = !1)),
              null === (t = this.hoverChanged) ||
                void 0 === t ||
                t.raiseEvent(
                  new h.HoveredChangedArgs(this, this.hoveredSeries, r, void 0)
                )),
              (this.preventReentrancy = !1);
          }
          modifierPointerCancel(e) {
            this.modifierMouseLeave(e);
          }
          modifierMouseUp(e) {
            var t;
            if (
              (super.modifierMouseUp(e),
              !this.checkExecuteConditions(e).isPrimary)
            )
              return;
            if (!this.enableSelection) return;
            if (!this.isAttached)
              throw new Error(
                "Should not call SeriesSelectionModifier.modifierMouseUp if not attached"
              );
            const r = this.getAllSeries(),
              i = r.map((t) =>
                t.hitTestProvider.hitTest(
                  e.mousePoint.x,
                  e.mousePoint.y,
                  this.hitTestRadius
                )
              );
            try {
              let e;
              (this.preventReentrancy = !0),
                (this.selectedSeries = []),
                r.forEach((e) => (e.isSelected = !1)),
                (null == i ? void 0 : i.length) > 0 &&
                  ((e = i.sort(
                    (e, t) =>
                      e.getEuclideanDistance() - t.getEuclideanDistance()
                  )[0]),
                  e.isHit &&
                    ((e.associatedSeries.isSelected = !0),
                    this.selectedSeries.push(e.associatedSeries))),
                null === (t = this.selectionChanged) ||
                  void 0 === t ||
                  t.raiseEvent(
                    new u.SelectionChangedArgs(this, this.selectedSeries, r, e)
                  );
            } finally {
              this.preventReentrancy = !1;
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                enableHover: this.enableHover,
                enableSelection: this.enableSelection,
                hitTestRadius: this.hitTestRadius,
                onHoverChanged: this.typeMap.get("onHoverChanged"),
                onSelectionChanged: this.typeMap.get("onSelectionChanged"),
              };
            return Object.assign(e.options, t), e;
          }
          getAllSeries() {
            return super.getAllSeries().filter((e) => e.isVisible);
          }
          updateSeriesSelected(e) {
            var t, r;
            this.preventReentrancy ||
              (e.isSelected
                ? (this.selectedSeries.push(e.sourceSeries),
                  null === (t = this.selectionChanged) ||
                    void 0 === t ||
                    t.raiseEvent(
                      new u.SelectionChangedArgs(
                        this,
                        this.selectedSeries,
                        this.getAllSeries(),
                        void 0
                      )
                    ))
                : ((this.selectedSeries = (0, l.arrayRemove)(
                    this.selectedSeries,
                    e.sourceSeries
                  )),
                  null === (r = this.selectionChanged) ||
                    void 0 === r ||
                    r.raiseEvent(
                      new u.SelectionChangedArgs(
                        this,
                        this.selectedSeries,
                        this.getAllSeries(),
                        void 0
                      )
                    )));
          }
          updateSeriesHovered(e) {
            var t, r;
            this.preventReentrancy ||
              (e.hovered
                ? (this.hoveredSeries.push(e.sourceSeries),
                  null === (t = this.hoverChanged) ||
                    void 0 === t ||
                    t.raiseEvent(
                      new h.HoveredChangedArgs(
                        this,
                        this.hoveredSeries,
                        this.getAllSeries(),
                        void 0
                      )
                    ))
                : ((this.hoveredSeries = (0, l.arrayRemove)(
                    this.hoveredSeries,
                    e.sourceSeries
                  )),
                  null === (r = this.hoverChanged) ||
                    void 0 === r ||
                    r.raiseEvent(
                      new h.HoveredChangedArgs(
                        this,
                        this.hoveredSeries,
                        this.getAllSeries(),
                        void 0
                      )
                    )));
          }
        }
        t.SeriesSelectionModifier = g;
      },
      96408: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VerticalSliceModifier = void 0);
        const i = r(63903),
          o = r(32873),
          a = r(75772),
          s = r(57935),
          n = r(54962),
          l = r(31306),
          d = r(5337),
          h = r(22486),
          u = r(89955);
        class c extends i.RolloverModifier {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.xCoordinateModeProperty = l.ECoordinateMode.Pixel),
              (this.isDraggableProperty = !1),
              (this.rmrsProps = new Map()),
              (this.rmrsProps1 = new Map()),
              (this.type = u.EChart2DModifierType.VerticalSlice),
              (this.x1Property = null !== (t = e.x1) && void 0 !== t ? t : 0),
              (this.mousePosition = s.EMousePosition.SeriesArea),
              (this.xCoordinateModeProperty =
                null !== (r = e.xCoordinateMode) && void 0 !== r
                  ? r
                  : this.xCoordinateModeProperty),
              (this.isDraggableProperty =
                null !== (i = e.isDraggable) && void 0 !== i
                  ? i
                  : this.isDraggableProperty),
              (this.lineSelectionColorProperty = e.lineSelectionColor),
              (this.rolloverLineAnnotation.isEditable =
                this.isDraggableProperty),
              (this.rolloverLineAnnotation.selectionBoxStroke =
                this.lineSelectionColor);
          }
          get x1() {
            return this.x1Property;
          }
          set x1(e) {
            e !== this.x1Property &&
              ((this.x1Property = e),
              this.notifyPropertyChanged(h.PROPERTY.X1));
          }
          get xCoordinateMode() {
            return this.xCoordinateModeProperty;
          }
          set xCoordinateMode(e) {
            e !== this.xCoordinateModeProperty &&
              ((this.xCoordinateModeProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.X_COORDINATE_MODE));
          }
          get verticalLine() {
            return this.rolloverLineAnnotation;
          }
          get isDraggable() {
            return this.isDraggableProperty;
          }
          set isDraggable(e) {
            e != this.isDraggableProperty &&
              ((this.isDraggableProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.IS_DRAGGABLE));
          }
          get lineSelectionColor() {
            return this.lineSelectionColorProperty;
          }
          set lineSelectionColor(e) {
            e !== this.lineSelectionColorProperty &&
              ((this.lineSelectionColorProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.LINE_SELECTION_COLOR));
          }
          modifierMouseMove(e) {
            if (this.rolloverLineAnnotation.isDraggingStarted) {
              this.mousePoint = new a.Point(e.mousePoint.x, e.mousePoint.y);
              const t = this.isVerticalChart()
                  ? e.mousePoint.y
                  : e.mousePoint.x,
                r = this.xAxis,
                i = r.getCurrentCoordinateCalculator();
              if (this.xCoordinateMode === l.ECoordinateMode.Pixel)
                this.x1 = Math.min(
                  Math.max(r.viewRect.left, (0, o.translateToNotScaled)(t)),
                  r.viewRect.right
                );
              else if (this.xCoordinateMode === l.ECoordinateMode.Relative) {
                const e =
                  (t -
                    (this.isVerticalChart()
                      ? r.viewRect.top
                      : r.viewRect.left)) /
                  i.viewportDimension;
                this.x1 = Math.min(Math.max(0, e), 1);
              } else {
                const e = this.isVerticalChart()
                    ? (0, o.translateFromCanvasToSeriesViewRectY)(
                        t,
                        this.parentSurface.seriesViewRect
                      )
                    : (0, o.translateFromCanvasToSeriesViewRectX)(
                        t,
                        this.parentSurface.seriesViewRect
                      ),
                  r = i.getDataValue(e);
                isNaN(r) || (this.x1 = r);
              }
              this.update();
            }
          }
          modifierMouseLeave(e) {}
          toJSON() {
            const e = super.toJSON(),
              t = {
                x1: this.x1,
                xCoordinateMode: this.xCoordinateMode,
                isDraggable: this.isDraggable,
                lineSelectionColor: this.lineSelectionColor,
              };
            return Object.assign(e.options, t), e;
          }
          getRolloverProps(e) {
            return this.rmrsProps.get(e);
          }
          getRolloverProps1(e) {
            return this.rmrsProps.get(e);
          }
          removeSeriesAnnotationsFromParentSurface(e) {
            super.removeSeriesAnnotationsFromParentSurface(e),
              this.rmrsProps.get(e).delete(),
              this.rmrsProps.delete(e),
              e.type === d.ESeriesType.BandSeries &&
                (this.rmrsProps1.get(e).delete(), this.rmrsProps1.delete(e));
          }
          addSeriesAnnotationsToParentSurface(e) {
            const t = new n.RolloverModifierRenderableSeriesProps(e, !1);
            if (
              (n.RolloverModifierRenderableSeriesProps.copy(
                e.rolloverModifierProps,
                t
              ),
              this.rmrsProps.set(e, t),
              e.type === d.ESeriesType.BandSeries)
            ) {
              const t = new n.RolloverModifierRenderableSeriesProps(e, !1);
              n.RolloverModifierRenderableSeriesProps.copy(
                e.rolloverModifierProps1,
                t
              ),
                this.rmrsProps1.set(e, t);
            }
            super.addSeriesAnnotationsToParentSurface(e);
          }
          createLine(e) {
            const t = super.createLine(e);
            return (t.annotationsGripsRadius = 0), t;
          }
          update() {
            this.calculateXPosition(),
              this.updateLine(),
              this.updateSeriesAnnotations(),
              Array.from(this.rmrsProps.values()).forEach((e) => {
                (e.renderableSeries.isVisible && e.showRollover) ||
                  ((e.tooltip.isHidden = !0), (e.marker.isHidden = !0));
              }),
              this.tooltipLegendTemplate &&
                (this.legendAnnotation.seriesInfos = this.getSeriesInfos());
          }
          notifyPropertyChanged(e) {
            switch ((super.notifyPropertyChanged(e), e)) {
              case h.PROPERTY.X1:
              case h.PROPERTY.X_COORDINATE_MODE:
                this.calculateXPosition();
                break;
              case h.PROPERTY.IS_DRAGGABLE:
                this.rolloverLineAnnotation.isEditable =
                  this.isDraggableProperty;
            }
          }
          calculateXPosition() {
            const e = this.xAxis,
              t = this.isVerticalChart();
            if (e) {
              const r = e.getCurrentCoordinateCalculator();
              let i = this.rolloverLineAnnotation.getCoordinate(
                this.x1Property,
                r,
                this.xCoordinateModeProperty
              );
              (this.xCoordinateMode !== l.ECoordinateMode.Relative &&
                this.xCoordinateMode !== l.ECoordinateMode.DataValue) ||
                (i += t ? e.viewRect.top : e.viewRect.left);
              const o = t
                ? this.parentSurface.seriesViewRect.width / 2
                : this.parentSurface.seriesViewRect.height / 2;
              this.mousePoint = t ? new a.Point(o, i) : new a.Point(i, o);
            }
          }
        }
        t.VerticalSliceModifier = c;
      },
      9809: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XAxisDragModifier = void 0);
        const i = r(14278),
          o = r(7980),
          a = r(32873),
          s = r(57397),
          n = r(89046),
          l = r(89955);
        class d extends n.ChartModifierBase2D {
          constructor(e) {
            var t;
            super(e),
              (this.type = l.EChart2DModifierType.XAxisDrag),
              (this.dragMode = o.EDragMode.Scaling),
              (this.isClickedOverXAxis = !1),
              (this.isVerticalChart = !1),
              (this.cursorStyle = i.ECursorStyle.Defalut),
              (this.dragMode =
                null !== (t = null == e ? void 0 : e.dragMode) && void 0 !== t
                  ? t
                  : this.dragMode);
          }
          includeYAxis(e, t) {
            throw Error(
              "method includeYAxis() is not supported for XAxisDragModifier, use includeXAxis() instead"
            );
          }
          getIncludedYAxis() {
            throw Error(
              "method getIncludedYAxis() is not supported for XAxisDragModifier, use getIncludedXAxis() instead"
            );
          }
          modifierMouseDown(e) {
            if ((super.modifierMouseDown(e), !this.isAttached))
              throw new Error(
                "Should not call XAxisDragModifier.modifierMouseDown if not attached"
              );
            (0, n.testIsOverAxes)(this.getHorizontalXAxes(), e.mousePoint)
              ? ((this.isVerticalChart = !1),
                this.startDragging(this.getHorizontalXAxes(), e))
              : (0, n.testIsOverAxes)(this.getVerticalXAxes(), e.mousePoint) &&
                ((this.isVerticalChart = !0),
                this.startDragging(this.getVerticalXAxes(), e));
          }
          modifierMouseMove(e) {
            if (this.isClickedOverXAxis) {
              if ((super.modifierMouseMove(e), void 0 === this.pointFrom))
                return;
              this.dragMode === o.EDragMode.Panning
                ? this.doPanning(e.mousePoint)
                : this.dragMode === o.EDragMode.Scaling &&
                  this.doScaling(e.mousePoint);
            } else this.updateCursor(e.mousePoint);
          }
          modifierMouseUp(e) {
            super.modifierMouseUp(e),
              this.updateCursor(e.mousePoint),
              (this.pointFrom = void 0),
              (this.isClickedOverXAxis = !1);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { dragMode: this.dragMode };
            return Object.assign(e.options, t), e;
          }
          updateCursor(e) {
            const t = this.parentSurface.getMainCanvas();
            (0, n.testIsOverAxes)(this.getHorizontalXAxes(), e)
              ? this.cursorStyle !== i.ECursorStyle.EW &&
                ((t.style.cursor = i.ECursorStyle.EW),
                (this.cursorStyle = i.ECursorStyle.EW))
              : (0, n.testIsOverAxes)(this.getVerticalXAxes(), e)
              ? this.cursorStyle !== i.ECursorStyle.NS &&
                ((t.style.cursor = i.ECursorStyle.NS),
                (this.cursorStyle = i.ECursorStyle.NS))
              : this.cursorStyle !== i.ECursorStyle.Defalut &&
                ((t.style.cursor = i.ECursorStyle.Defalut),
                (this.cursorStyle = i.ECursorStyle.Defalut));
          }
          doPanning(e) {
            const t = e;
            if (this.isVerticalChart) {
              const e = t.y - this.pointFrom.y;
              this.activeAxes.forEach((t) => {
                const r = t.flippedCoordinates ? -e : e;
                t.scroll(r, s.EClipMode.None);
              });
            } else {
              const e = t.x - this.pointFrom.x;
              this.activeAxes.forEach((t) => {
                const r = t.flippedCoordinates ? -e : e;
                t.scroll(r, s.EClipMode.None);
              });
            }
            this.pointFrom = t;
          }
          doScaling(e) {
            this.isVerticalChart
              ? this.activeAxes.forEach((t, r) => {
                  const i = t.viewRect,
                    o =
                      (0, a.translateFromCanvasToSeriesViewRectY)(
                        this.pointFrom.y,
                        i
                      ) >=
                      i.height / 2,
                    s = (e.y - this.pointFrom.y) / i.height;
                  t.scale(this.initialVisibleRanges[r], s, o);
                })
              : this.activeAxes.forEach((t, r) => {
                  const i = t.viewRect,
                    o =
                      (0, a.translateFromCanvasToSeriesViewRectX)(
                        this.pointFrom.x,
                        i
                      ) >=
                      i.width / 2,
                    s = (e.x - this.pointFrom.x) / i.width;
                  t.scale(this.initialVisibleRanges[r], s, o);
                });
          }
          getHorizontalXAxes() {
            return this.getIncludedXAxis().filter((e) => e.isHorizontalAxis);
          }
          getVerticalXAxes() {
            return this.getIncludedXAxis().filter((e) => !e.isHorizontalAxis);
          }
          startDragging(e, t) {
            this.isClickedOverXAxis = !0;
            const r = (0, n.getActiveAxes)(e, t.mousePoint),
              i = [];
            r.forEach((e) => {
              i.push(e.visibleRange);
            }),
              (this.activeAxes = r),
              (this.initialVisibleRanges = i),
              (this.pointFrom = t.mousePoint),
              (t.handled = !0);
          }
        }
        t.XAxisDragModifier = d;
      },
      3397: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.YAxisDragModifier = void 0);
        const i = r(89955),
          o = r(14278),
          a = r(7980),
          s = r(32873),
          n = r(57397),
          l = r(89046);
        class d extends l.ChartModifierBase2D {
          constructor(e) {
            var t;
            super(e),
              (this.type = i.EChart2DModifierType.YAxisDrag),
              (this.dragMode = a.EDragMode.Scaling),
              (this.isClickedOverYAxis = !1),
              (this.isVerticalChart = !1),
              (this.cursorStyle = o.ECursorStyle.Defalut),
              (this.dragMode =
                null !== (t = null == e ? void 0 : e.dragMode) && void 0 !== t
                  ? t
                  : this.dragMode);
          }
          includeXAxis(e, t) {
            throw Error(
              "method includeXAxis() is not supported for YAxisDragModifier, use includeYAxis() instead"
            );
          }
          getIncludedXAxis() {
            throw Error(
              "method getIncludedXAxis() is not supported for YAxisDragModifier, use getIncludedXAxis() instead"
            );
          }
          modifierMouseDown(e) {
            if ((super.modifierMouseDown(e), !this.isAttached))
              throw new Error(
                "Should not call YAxisDragModifier.modifierMouseDown if not attached"
              );
            (0, l.testIsOverAxes)(this.getVerticalYAxes(), e.mousePoint)
              ? ((this.isVerticalChart = !1),
                this.startDragging(this.getVerticalYAxes(), e))
              : (0, l.testIsOverAxes)(
                  this.getHorizontalYAxes(),
                  e.mousePoint
                ) &&
                ((this.isVerticalChart = !0),
                this.startDragging(this.getHorizontalYAxes(), e));
          }
          modifierMouseMove(e) {
            if (this.isClickedOverYAxis) {
              if ((super.modifierMouseMove(e), void 0 === this.pointFrom))
                return;
              this.dragMode === a.EDragMode.Panning
                ? this.doPanning(e.mousePoint)
                : this.dragMode === a.EDragMode.Scaling &&
                  this.doScaling(e.mousePoint);
            } else this.updateCursor(e.mousePoint);
          }
          modifierMouseUp(e) {
            super.modifierMouseUp(e),
              this.updateCursor(e.mousePoint),
              (this.pointFrom = void 0),
              (this.isClickedOverYAxis = !1);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { dragMode: this.dragMode };
            return Object.assign(e.options, t), e;
          }
          updateCursor(e) {
            const t = this.parentSurface.getMainCanvas();
            (0, l.testIsOverAxes)(this.getVerticalYAxes(), e)
              ? this.cursorStyle !== o.ECursorStyle.NS &&
                ((t.style.cursor = o.ECursorStyle.NS),
                (this.cursorStyle = o.ECursorStyle.NS))
              : (0, l.testIsOverAxes)(this.getHorizontalYAxes(), e)
              ? this.cursorStyle !== o.ECursorStyle.EW &&
                ((t.style.cursor = o.ECursorStyle.EW),
                (this.cursorStyle = o.ECursorStyle.EW))
              : this.cursorStyle !== o.ECursorStyle.Defalut &&
                ((t.style.cursor = o.ECursorStyle.Defalut),
                (this.cursorStyle = o.ECursorStyle.Defalut));
          }
          doPanning(e) {
            const t = e;
            if (this.isVerticalChart) {
              const e = t.x - this.pointFrom.x;
              this.activeAxes.forEach((t) => {
                const r = t.flippedCoordinates ? e : -e;
                t.scroll(r, n.EClipMode.None);
              });
            } else {
              const e = t.y - this.pointFrom.y;
              this.activeAxes.forEach((t) => {
                const r = t.flippedCoordinates ? e : -e;
                t.scroll(r, n.EClipMode.None);
              });
            }
            this.pointFrom = t;
          }
          doScaling(e) {
            this.isVerticalChart
              ? this.activeAxes.forEach((t, r) => {
                  const i = t.viewRect,
                    o =
                      (0, s.translateFromCanvasToSeriesViewRectX)(
                        this.pointFrom.x,
                        i
                      ) <=
                      i.width / 2,
                    a = -(e.x - this.pointFrom.x) / i.width;
                  t.scale(this.initialVisibleRanges[r], a, o);
                })
              : this.activeAxes.forEach((t, r) => {
                  const i = t.viewRect,
                    o =
                      (0, s.translateFromCanvasToSeriesViewRectY)(
                        this.pointFrom.y,
                        i
                      ) <=
                      i.height / 2,
                    a = -(e.y - this.pointFrom.y) / i.height;
                  t.scale(this.initialVisibleRanges[r], a, o);
                });
          }
          getVerticalYAxes() {
            return this.getIncludedYAxis().filter((e) => !e.isHorizontalAxis);
          }
          getHorizontalYAxes() {
            return this.getIncludedYAxis().filter((e) => e.isHorizontalAxis);
          }
          startDragging(e, t) {
            this.isClickedOverYAxis = !0;
            const r = (0, l.getActiveAxes)(e, t.mousePoint),
              i = [];
            r.forEach((e) => {
              i.push(e.visibleRange);
            }),
              (this.activeAxes = r),
              (this.initialVisibleRanges = i),
              (this.pointFrom = t.mousePoint),
              (t.handled = !0);
          }
        }
        t.YAxisDragModifier = d;
      },
      63407: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ZoomExtentsModifier = void 0);
        const i = r(45921),
          o = r(10276),
          a = r(11043),
          s = r(32616),
          n = r(89955),
          l = r(86699),
          d = r(14379),
          h = r(32873),
          u = r(89046);
        class c extends u.ChartModifierBase2D {
          constructor(e) {
            var t, r, l, d, h, u;
            super(e),
              (this.type = n.EChart2DModifierType.ZoomExtents),
              (this.isAnimated = !0),
              (this.animationDuration = 400),
              (this.easingFunction = o.easing.outExpo),
              (this.applyToSeriesViewRect = !0),
              (this.applyToAxes = !0),
              (this.isAnimated =
                null !== (t = null == e ? void 0 : e.isAnimated) && void 0 !== t
                  ? t
                  : this.isAnimated),
              (this.animationDuration =
                null !== (r = null == e ? void 0 : e.animationDuration) &&
                void 0 !== r
                  ? r
                  : this.animationDuration),
              (this.applyToSeriesViewRect =
                null !== (l = null == e ? void 0 : e.applyToSeriesViewRect) &&
                void 0 !== l
                  ? l
                  : this.applyToSeriesViewRect),
              (this.applyToAxes =
                null !== (d = null == e ? void 0 : e.applyToAxes) &&
                void 0 !== d
                  ? d
                  : this.applyToAxes),
              (null == e ? void 0 : e.easingFunction) &&
                "string" == typeof e.easingFunction &&
                (e.easingFunction = o.easing[e.easingFunction]),
              (this.easingFunction =
                null !== (h = null == e ? void 0 : e.easingFunction) &&
                void 0 !== h
                  ? h
                  : o.easing.outExpo),
              (null == e ? void 0 : e.onZoomExtents) &&
                "string" == typeof e.onZoomExtents &&
                (this.typeMap.set("onZoomExtents", e.onZoomExtents),
                (e.onZoomExtents = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.onZoomExtents
                ))),
              (this.onZoomExtents = null == e ? void 0 : e.onZoomExtents),
              (this.executeCondition =
                null !== (u = null == e ? void 0 : e.executeCondition) &&
                void 0 !== u
                  ? u
                  : { button: void 0, key: s.EModifierMouseArgKey.None });
          }
          modifierDoubleClick(e) {
            if (!this.checkExecuteConditions(e).isPrimary) return;
            const t = this.parentSurface,
              r = this.isAnimated ? this.animationDuration : 0;
            if (void 0 !== t)
              if (
                (0, h.translateFromCanvasToSeriesViewRect)(
                  e.mousePoint,
                  this.parentSurface.seriesViewRect
                ) &&
                this.applyToSeriesViewRect
              ) {
                if (!this.onZoomExtents || this.onZoomExtents(t)) {
                  switch (this.xyDirection) {
                    case l.EXyDirection.XyDirection:
                      t.zoomExtents(
                        r,
                        this.easingFunction,
                        () => t.setZoomState(d.EZoomState.AtExtents),
                        (e) => this.includedXAxes.testIsIncluded(e.id),
                        (e) => this.includedYAxes.testIsIncluded(e.id)
                      );
                      break;
                    case l.EXyDirection.XDirection:
                      t.zoomExtentsX(r, this.easingFunction, (e) =>
                        this.includedXAxes.testIsIncluded(e.id)
                      );
                      break;
                    case l.EXyDirection.YDirection:
                      t.zoomExtentsY(r, this.easingFunction, (e) =>
                        this.includedYAxes.testIsIncluded(e.id)
                      );
                  }
                  e.handled = !0;
                }
              } else if (this.applyToAxes) {
                const t = [];
                [
                  l.EXyDirection.XDirection,
                  l.EXyDirection.XyDirection,
                ].includes(this.xyDirection) &&
                  t.push(...this.getIncludedXAxis()),
                  [
                    l.EXyDirection.YDirection,
                    l.EXyDirection.XyDirection,
                  ].includes(this.xyDirection) &&
                    t.push(...this.getIncludedYAxis());
                const i = (0, u.getActiveAxes)(t, e.mousePoint);
                i.length > 0 &&
                  ((e.handled = !0),
                  i.forEach((e) => {
                    if (e.isXAxis) {
                      const t = e.getMaximumRange();
                      e.animateVisibleRange(t, r, this.easingFunction);
                    } else {
                      const t = e.getWindowedYRange(void 0);
                      e.animateVisibleRange(t, r, this.easingFunction);
                    }
                  }));
              }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                animationDuration: this.animationDuration,
                easingFunction: this.easingFunction.name,
                isAnimated: this.isAnimated,
                applyToSeriesViewRect: this.applyToSeriesViewRect,
                applyToAxes: this.applyToAxes,
                onZoomExtents: this.typeMap.get("onZoomExtents"),
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.ZoomExtentsModifier = c;
      },
      64171: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ZoomPanModifier = void 0);
        const i = r(6859),
          o = r(32616),
          a = r(89955),
          s = r(86699),
          n = r(14379),
          l = r(32873),
          d = r(57397),
          h = r(21562);
        class u extends h.PinchZoomModifier {
          constructor(e) {
            var t, r;
            super(e),
              (this.enableZoom = !0),
              (this.type = a.EChart2DModifierType.ZoomPan),
              (this.enableZoom =
                null !== (t = null == e ? void 0 : e.enableZoom) && void 0 !== t
                  ? t
                  : this.enableZoom),
              (this.executeCondition =
                null !== (r = null == e ? void 0 : e.executeCondition) &&
                void 0 !== r
                  ? r
                  : {
                      button: i.EExecuteOn.MouseLeftButton,
                      key: o.EModifierMouseArgKey.None,
                    });
          }
          modifierMouseDown(e) {
            if (
              (e.nativeEvent.preventDefault(),
              this.checkExecuteConditions(e).isPrimary)
            ) {
              if (!this.isAttached)
                throw new Error(
                  "Should not call ZoomPanModifier.modifierMouseDown if not attached"
                );
              super.modifierMouseDown(e),
                (0, l.translateFromCanvasToSeriesViewRect)(
                  e.mousePoint,
                  this.parentSurface.seriesViewRect
                ) &&
                  (this.activePointerEvents.set(e.pointerId, e),
                  this.parentSurface.setZoomState(n.EZoomState.UserZooming));
            }
          }
          modifierMouseMove(e) {
            (this.parentSurface.isSubSurface && !e.isActiveSubChartEvent) ||
              (this.updatePointerInfo(e),
              this.previousPoint &&
                (this.enableZoom &&
                  super.getIsActionAllowed(e) &&
                  super.performModifierAction(e),
                this.getIsActionAllowed(e) && this.performModifierAction(e)));
          }
          modifierMouseUp(e) {
            if ((super.modifierMouseUp(e), this.activePointerEvents.size > 0)) {
              const t = this.activePointerEvents.values().next().value;
              e.target.setPointerCapture(t.pointerId);
            }
          }
          modifierPointerCancel(e) {
            super.modifierPointerCancel(e), this.activePointerEvents.clear();
          }
          toJSON() {
            const e = super.toJSON(),
              t = { enableZoom: this.enableZoom };
            return Object.assign(e.options, t), e;
          }
          performModifierAction(e) {
            const t = e.mousePoint,
              r = t.x - this.previousPoint.x,
              i = this.previousPoint.y - t.y;
            this.performPan(r, i);
          }
          getIsActionAllowed(e) {
            return (
              this.activePointerEvents.values().next().value.pointerId ===
              e.pointerId
            );
          }
          performPan(e, t) {
            [s.EXyDirection.XDirection, s.EXyDirection.XyDirection].includes(
              this.xyDirection
            ) &&
              this.getIncludedXAxis().forEach((r) => {
                const i = r.isHorizontalAxis ? e : -t;
                r.scroll(r.flippedCoordinates ? -i : i, d.EClipMode.None);
              }),
              [s.EXyDirection.YDirection, s.EXyDirection.XyDirection].includes(
                this.xyDirection
              ) &&
                this.getIncludedYAxis().forEach((r) => {
                  const i = r.isHorizontalAxis ? -e : t;
                  r.scroll(r.flippedCoordinates ? -i : i, d.EClipMode.None);
                });
          }
        }
        t.ZoomPanModifier = u;
      },
      22486: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).ALLOWS_MULTI_SELECTION =
            "ALLOWS_MULTI_SELECTION"),
          (r.ALLOW_TOOLTIP_OVERLAPPING = "ALLOW_TOOLTIP_OVERLAPPING"),
          (r.CROSSHAIR_STROKE = "CROSSHAIR_STROKE"),
          (r.EXECUTE_CONDITION = "EXECUTE_CONDITION"),
          (r.FILL = "FILL"),
          (r.HIT_TEST_RADIUS = "HIT_TEST_RADIUS"),
          (r.IS_ATTACHED = "IS_ATTACHED"),
          (r.IS_ENABLED = "IS_ENABLED"),
          (r.PARENT_SURFACE = "PARENT_SURFACE"),
          (r.RECEIVE_HANDLED_EVENTS = "RECEIVE_HANDLED_EVENTS"),
          (r.SHOW_ROLLOVER_LINE = "SHOW_ROLLOVER_LINE"),
          (r.SHOW_TOOLTIP = "SHOW_TOOLTIP"),
          (r.SECONDARY_EXECUTE_CONDITION = "SECONDARY_EXECUTE_CONDITION"),
          (r.SELECTED_AREA = "SELECTED_AREA"),
          (r.SELECTION_FILL = "SELECTION_FILL"),
          (r.SELECTION_STROKE = "SELECTION_STROKE"),
          (r.SELECTION_STROKE_THICKNESS = "SELECTION_STROKE_THICKNESS"),
          (r.STROKE = "STROKE"),
          (r.STROKE_THICKNESS = "STROKE_THICKNESS"),
          (r.STROKE_DASH_ARRAY = "STROKE_DASH_ARRAY"),
          (r.TOOLTIP_DATA_TEMPLATE = "TOOLTIP_DATA_TEMPLATE"),
          (r.X_AXIS_ID = "X_AXIS_ID"),
          (r.Y_AXIS_ID = "Y_AXIS_ID"),
          (r.PLACEMENT_DIV_ID = "PLACEMENT_DIV_ID"),
          (r.X_LINE = "X_LINE"),
          (r.Y_LINE = "Y_LINE"),
          (r.AXIS_LABELS = "AXIS_LABELS"),
          (r.ANGULAR_AXIS_LABELS_PLACEMENT = "ANGULAR_AXIS_LABELS_PLACEMENT"),
          (r.RADIAL_AXIS_LABELS_PLACEMENT = "RADIAL_AXIS_LABELS_PLACEMENT"),
          (r.X1 = "X1"),
          (r.X_COORDINATE_MODE = "X_COORDINATE_MODE"),
          (r.IS_DRAGGABLE = "IS_DRAGGABLE"),
          (r.LINE_ANNOTATIONS_OPTIONS = "LINE_ANNOTATIONS_OPTIONS"),
          (r.LINE_SELECTION_COLOR = "LINE_SELECTION_COLOR"),
          (r.TOOLTIP_SHADOW = "TOOLTIP_SHADOW");
      },
      63915: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseCache = void 0);
        const i = r(55023),
          o = r(56744),
          a = (r(27307), r(16185));
        class s extends i.DeletableEntity {
          constructor(e) {
            super(),
              (this.webAssemblyContext = e),
              e && a.WebGlRenderContext2D.webGlResourcesRefs.add(this);
          }
          get value() {
            return this.cachedEntity;
          }
          invalidateCache() {
            this.cachedEntity = (0, o.deleteSafe)(this.cachedEntity);
          }
          resetCache() {
            this.invalidateCache();
          }
          delete() {
            (this.cachedEntity = (0, o.deleteSafe)(this.cachedEntity)),
              a.WebGlRenderContext2D.webGlResourcesRefs.delete(this),
              (this.webAssemblyContext = void 0);
          }
        }
        t.BaseCache = s;
      },
      93113: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BatchRenderContext = void 0);
        const i = r(16185);
        class o extends i.WebGlRenderContext2D {
          constructor() {
            super(...arguments), (this.doDraw = !1);
          }
          drawLayers() {
            this.doDraw && super.drawLayers();
          }
          endFonts(e = !1) {
            (this.doDraw || e) && super.endFonts();
          }
        }
        t.BatchRenderContext = o;
      },
      51269: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createBrushInCache =
            t.getScrtBrushFromCache =
            t.getWebGlBrushFromCache =
            t.BrushCache =
              void 0);
        const i = r(56744),
          o = r(23866),
          a = r(33841),
          s = r(35992),
          n = r(63915),
          l = r(33512),
          d = 256;
        class h extends n.BaseCache {
          get value() {
            return (
              !this.cachedEntity &&
                (this.fill ||
                  this.fillLinearGradient ||
                  this.customTextureOptions) &&
                (this.cachedEntity = this.create(
                  this.fill,
                  this.opacity,
                  this.textureHeightRatio,
                  this.textureWidthRatio,
                  this.fillLinearGradient,
                  this.customTextureOptions
                )),
              this.cachedEntity
            );
          }
          defaultCustomEquals(e, t) {
            return e === t;
          }
          create(e, t, r, i, o, a) {
            var s, n, d, h;
            (r =
              null !== (s = null == a ? void 0 : a.textureHeight) &&
              void 0 !== s
                ? s
                : r),
              (i =
                null !== (n = null == a ? void 0 : a.textureWidth) &&
                void 0 !== n
                  ? n
                  : i);
            const u =
              null !== (d = null == a ? void 0 : a.areEqual) && void 0 !== d
                ? d
                : this.defaultCustomEquals;
            if (
              this.cachedEntity &&
              e === this.fill &&
              t === this.opacity &&
              r === this.textureHeightRatio &&
              i === this.textureWidthRatio &&
              o === this.fillLinearGradient &&
              a === this.customTextureOptions &&
              u(
                null === (h = this.customTextureOptions) || void 0 === h
                  ? void 0
                  : h.options,
                null == a ? void 0 : a.options
              )
            )
              return this.cachedEntity;
            let c;
            return (
              this.invalidateCache(),
              (this.fill = e),
              (this.opacity = t),
              (this.textureHeightRatio = r),
              (this.textureWidthRatio = i),
              (this.fillLinearGradient = o),
              (this.customTextureOptions = a),
              (c = a
                ? this.createCustomBrush()
                : o
                ? this.createGradientBrush()
                : this.createSolidBrush(e, t)),
              (this.cachedEntity = new l.WebGlBrush(c))
            );
          }
          createCustomBrush() {
            var e;
            (this.canvasTexture = new s.CanvasTexture(
              this.webAssemblyContext,
              this.textureWidthRatio,
              this.textureHeightRatio
            )),
              this.canvasTexture.clear();
            const t = this.canvasTexture.getContext();
            this.customTextureOptions.createTexture(
              t,
              Object.assign(
                { fill: this.fill, opacity: this.opacity },
                this.customTextureOptions.options
              )
            ),
              this.canvasTexture.copyTexture();
            const r = this.canvasTexture.getTexture(),
              i = new this.webAssemblyContext.SCRTTextureBrush(
                r,
                null !== (e = this.customTextureOptions.isPerPrimitive) &&
                void 0 !== e &&
                e
                  ? this.webAssemblyContext.eSCRTBrushMappingMode.PerPrimitive
                  : this.webAssemblyContext.eSCRTBrushMappingMode.PerScreen,
                1
              );
            return (
              this.customTextureOptions.repeat &&
                (i.SetSamplerMode(
                  this.webAssemblyContext.SCRTTextureBrushSamplerMode.Wrap
                ),
                i.SetMappingMode(
                  this.webAssemblyContext.eSCRTBrushMappingMode.PerScreen
                )),
              i
            );
          }
          invalidateCache() {
            super.invalidateCache(),
              (this.canvasTexture = (0, i.deleteSafe)(this.canvasTexture));
          }
          reset() {
            this.invalidateCache(),
              (this.fill = void 0),
              (this.opacity = void 0),
              (this.fillLinearGradient = void 0);
          }
          delete() {
            this.invalidateCache();
          }
          createSolidBrush(e, t) {
            return (0, a.createSolidBrush)(this.webAssemblyContext, e, t);
          }
          createGradientBrush() {
            const e = this.createGradientTexture().getTexture();
            return new this.webAssemblyContext.SCRTTextureBrush(
              e,
              this.webAssemblyContext.eSCRTBrushMappingMode.PerPrimitive,
              1
            );
          }
          createGradientTexture() {
            o.Guard.notNull(this.fillLinearGradient, "fillLinearGradient");
            const {
              startPoint: e,
              endPoint: t,
              gradientStops: r,
            } = this.fillLinearGradient;
            (this.canvasTexture = new s.CanvasTexture(
              this.webAssemblyContext,
              d,
              d
            )),
              this.canvasTexture.clear();
            const i = this.canvasTexture.getContext(),
              a = u(e.x, d * this.textureWidthRatio),
              n = u(e.y, d * this.textureHeightRatio),
              l = u(t.x, d * this.textureWidthRatio),
              h = u(t.y, d * this.textureHeightRatio),
              c = i.createLinearGradient(a, n, l, h);
            return (
              r.forEach((e) => {
                c.addColorStop(e.offset, e.color);
              }),
              (i.fillStyle = c),
              i.fillRect(0, 0, d, d),
              this.canvasTexture.copyTexture(),
              this.canvasTexture
            );
          }
        }
        (t.BrushCache = h),
          (t.getWebGlBrushFromCache = (e) => (
            o.Guard.notNull(e, "cache"), e.value
          )),
          (t.getScrtBrushFromCache = (e) => {
            const r = (0, t.getWebGlBrushFromCache)(e);
            return null == r ? void 0 : r.scrtBrush;
          }),
          (t.createBrushInCache = (e, t, r, i, a, s, n) => (
            o.Guard.notNull(e, "brushCache"),
            e.create(t, r, i, a, s, n).scrtBrush
          ));
        const u = (e, t) => e * t;
      },
      59348: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PaletteCache = void 0);
        const i = r(56744),
          o = r(63915);
        class a extends o.BaseCache {
          get value() {
            return (
              !this.cachedEntity &&
                this.fillColors &&
                (this.cachedEntity = this.create(this.fillColors)),
              this.cachedEntity
            );
          }
          create(e) {
            return this.cachedEntity && e === this.fillColors
              ? this.cachedEntity
              : ((0, i.deleteSafe)(this.cachedEntity),
                (this.fillColors = e),
                (this.cachedEntity =
                  new this.webAssemblyContext.SCRTCreatePalette(e)));
          }
          reset() {
            this.invalidateCache(), (this.fillColors = void 0);
          }
        }
        t.PaletteCache = a;
      },
      21915: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createPenInCache =
            t.getScrtPenFromCache =
            t.getWebGlPenFromCache =
            t.Pen2DCache =
              void 0);
        const i = r(56744),
          o = r(23866),
          a = r(45215),
          s = r(48008),
          n = r(47376),
          l = r(86127),
          d = r(63915),
          h = r(55444);
        class u extends d.BaseCache {
          get value() {
            if (!this.cachedEntity && this.stroke) {
              const {
                stroke: e,
                strokeThickness: t,
                strokeDashArray: r,
                antiAliased: i,
                opacity: o,
              } = this;
              this.cachedEntity = this.create({
                stroke: e,
                strokeThickness: t,
                strokeDashArray: r,
                antiAliased: i,
                opacity: o,
              });
            }
            return this.cachedEntity;
          }
          create(e) {
            const {
                stroke: t,
                strokeThickness: r = 1,
                strokeDashArray: o,
                antiAliased: d = !0,
                opacity: u = 1,
              } = e,
              { strokeThickness: c, strokeDashArray: p } =
                l.DpiHelper.adjustStrokeSize({
                  strokeThickness: r,
                  strokeDashArray: o,
                });
            if (
              this.cachedEntity &&
              t === this.stroke &&
              c === this.adjustedStrokeThickness &&
              d === this.antiAliased &&
              (0, a.areArraysEqual)(p, this.adjustedStrokeDashArray)
            )
              return (
                u !== this.opacity &&
                  ((this.opacity = u), this.cachedEntity.setOpacity(u)),
                (this.strokeThickness = r),
                (this.strokeDashArray = o),
                this.cachedEntity
              );
            (0, i.deleteSafe)(this.cachedEntity),
              (this.stroke = t),
              (this.opacity = u),
              (this.antiAliased = d),
              (this.strokeThickness = r),
              (this.adjustedStrokeThickness = c),
              (this.strokeDashArray = o),
              (this.adjustedStrokeDashArray = p);
            const g = (0, n.createSCRTPen)(
              this.webAssemblyContext,
              t,
              c,
              u,
              p,
              d
            );
            return (this.cachedEntity = new h.WebGlPen(
              g,
              t ? (0, s.parseColorToUIntArgb)(t) : void 0
            ));
          }
        }
        (t.Pen2DCache = u),
          (t.getWebGlPenFromCache = (e) => (
            o.Guard.notNull(e, "penCache"), e.value
          )),
          (t.getScrtPenFromCache = (e) => {
            const r = (0, t.getWebGlPenFromCache)(e);
            return null == r ? void 0 : r.scrtPen;
          }),
          (t.createPenInCache = (e, t, r, i, a, s) => (
            o.Guard.notNull(e, "penCache"),
            e.create({
              stroke: t,
              strokeThickness: r,
              opacity: i,
              strokeDashArray: a,
              antiAliased: s,
            }).scrtPen
          ));
      },
      53831: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderContext2D = void 0),
          (t.RenderContext2D = class {
            constructor(e) {
              (this.canvas2D = e), (this.ctx2D = e.getContext("2d"));
            }
            drawRect(e, t, r, i, o = "rgba(211,211,211,0.5)") {
              this.clear(),
                (this.ctx2D.fillStyle = o),
                this.ctx2D.fillRect(e, t, r, i);
            }
            drawCircle(e, t, r, i) {
              const o = i;
              this.clear(),
                this.ctx2D.beginPath(),
                this.ctx2D.arc(e, t, r, 0, 2 * Math.PI, !1),
                (this.ctx2D.fillStyle = i),
                this.ctx2D.fill(),
                (this.ctx2D.lineWidth = 0),
                (this.ctx2D.strokeStyle = o),
                this.ctx2D.stroke();
            }
            clear() {
              this.ctx2D.clearRect(
                0,
                0,
                this.canvas2D.width,
                this.canvas2D.height
              );
            }
          });
      },
      77186: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderSurface = void 0);
        const i = r(84745),
          o = r(62049),
          a = r(16185);
        t.RenderSurface = class {
          constructor(e, t, r) {
            (this.webAssemblyContext = e),
              (this.viewportSize = t),
              (this.canvasId = r);
          }
          getRenderContext() {
            return (
              this.renderContextProperty ||
                (this.renderContextProperty = new a.WebGlRenderContext2D(
                  this.webAssemblyContext,
                  this.viewportSize,
                  this.canvasId
                )),
              this.renderContextProperty
            );
          }
          invalidateElement(e) {
            var t;
            i.IS_TEST_ENV ||
              (null ===
                (t = o.WebGlHelper.getContext(
                  this.webAssemblyContext.canvas
                )) || void 0 === t
                ? void 0
                : t.isContextLost()) ||
              this.webAssemblyContext.TSRRequestCanvasDraw(e);
          }
          onRenderTimeElapsed() {
            this.handleDraw(), (this.renderContextProperty = void 0);
          }
        };
      },
      78623: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SolidBrushCache = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(48008);
        class s extends i.DeletableEntity {
          constructor(e) {
            super(), (this.webAssemblyContext = e);
          }
          newBrush(e, t = !1) {
            return (
              (this.brush && e === this.color && t === this.transparent) ||
                (this.brush && this.brush.delete(),
                (this.color = e),
                (this.transparent = t),
                (this.brush = new this.webAssemblyContext.SCRTSolidBrush(
                  (0, a.parseColorToUIntArgb)(e),
                  t
                ))),
              this.brush
            );
          }
          delete() {
            (this.brush = (0, o.deleteSafe)(this.brush)),
              (this.webAssemblyContext = void 0);
          }
        }
        t.SolidBrushCache = s;
      },
      80445: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TextureCache = void 0);
        const i = r(56744),
          o = r(63915);
        class a extends o.BaseCache {
          constructor(e) {
            super(e), (this.wasmContext = e);
          }
          get value() {
            return (
              !this.cachedEntity &&
                this.textureFormat &&
                (this.cachedEntity = this.create(
                  this.width,
                  this.height,
                  this.textureFormat
                )),
              this.cachedEntity
            );
          }
          create(e, t, r) {
            return (
              (this.cachedEntity &&
                e === this.width &&
                t === this.height &&
                r === this.textureFormat) ||
                ((this.cachedEntity = (0, i.deleteSafe)(this.cachedEntity)),
                (this.width = e),
                (this.height = t),
                (this.textureFormat = r),
                (this.cachedEntity = this.wasmContext.SCRTCreateBitmapTexture(
                  this.width,
                  this.height,
                  r
                ))),
              this.cachedEntity
            );
          }
          resetCache() {
            this.invalidateCache(),
              (this.width = void 0),
              (this.height = void 0),
              (this.textureFormat = void 0);
          }
        }
        t.TextureCache = a;
      },
      33512: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebGlBrush = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(78249);
        class s extends i.DeletableEntity {
          constructor(e) {
            super(), (this.scrtBrushProperty = e);
          }
          get scrtBrush() {
            return this.scrtBrushProperty;
          }
          delete() {
            this.scrtBrushProperty = (0, o.deleteSafe)(this.scrtBrushProperty);
          }
          getBrushType() {
            return a.EDrawingTypes.WasmBrush;
          }
          setOpacity(e) {
            var t;
            null === (t = this.scrtBrushProperty) ||
              void 0 === t ||
              t.SetOpacity(e);
          }
        }
        t.WebGlBrush = s;
      },
      55444: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebGlPen = void 0);
        const i = r(84745),
          o = r(55023),
          a = r(56744),
          s = r(22950),
          n = r(78249);
        class l extends o.DeletableEntity {
          constructor(e, t) {
            super(),
              (this.scrtPenProperty = e),
              (this.originalColor =
                null != t ? t : null == e ? void 0 : e.m_uiColor);
          }
          get scrtPen() {
            return this.scrtPenProperty;
          }
          delete() {
            this.scrtPenProperty = (0, a.deleteSafe)(this.scrtPenProperty);
          }
          getPenType() {
            return n.EDrawingTypes.WasmPen;
          }
          setOpacity(e) {
            i.IS_TEST_ENV ||
              (this.scrtPen.m_uiColor = (0, s.uintArgbColorMultiplyOpacity)(
                this.originalColor,
                e
              ));
          }
        }
        t.WebGlPen = l;
      },
      16185: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebGlRenderContext2D =
            t.ELineDrawMode =
            t.calculateAbsoluteRenderLayer =
              void 0);
        const i = r(84745),
          o = r(23866),
          a = r(87459),
          s = r(63458),
          n = r(98353),
          l = r(55023),
          d = r(16602),
          h = r(75772),
          u = r(60986),
          c = r(36420),
          p = r(22950),
          g = r(48008);
        var y;
        (t.calculateAbsoluteRenderLayer = (e, t, r) => 1e3 * e + r * t),
          (function (e) {
            (e.PolyLine = "PolyLine"),
              (e.DiscontinuousLine = "DiscontinuousLine");
          })((y = t.ELineDrawMode || (t.ELineDrawMode = {})));
        class f extends l.DeletableEntity {
          constructor(e, t, r) {
            super(),
              (this.layers = new Map()),
              (this.effects = []),
              (this.webAssemblyContext = e),
              (this.viewportSize = t),
              (this.canvasId = r);
          }
          getNativeContext() {
            return (
              this.nativeContext ||
                (this.nativeContext =
                  this.webAssemblyContext.SCRTGetMainRenderContext2D()),
              this.nativeContext
            );
          }
          drawLinesNative(e, t, r, i, o = 0, a = 0) {
            const s = r === y.PolyLine,
              n = this.getNativeContext();
            n.PushMatrix(),
              n.PushState(),
              n.Translate(o, a),
              n.SetClipRect(i.x, i.y, i.width, i.height),
              n.DrawLinesBatchVec(s, e, t),
              n.PopMatrix(),
              n.PopState();
          }
          drawRects(e, t, r, i = 0, o = 0) {
            const a = (0, n.getVector4)(this.webAssemblyContext, 0, 0, 0, 0),
              s = this.getNativeContext();
            s.PushMatrix(),
              s.PushState(),
              s.Translate(i, o),
              s.SetClipRect(r.x, r.y, r.width, r.height),
              s.DrawRectsBatchVec(e, t, a),
              s.PopMatrix(),
              s.PopState();
          }
          drawEllipses(e, t, r = 0, i = 0) {
            const o = this.getNativeContext();
            o.PushMatrix(),
              o.Translate(r, i),
              o.DrawEllipseRectsBatchVec(e, e.size(), t),
              o.PopMatrix();
          }
          drawArcs(e, t, r, i, o, a, s, n = 0, l = 0) {
            const d = this.getNativeContext();
            d.PushMatrix(), d.PushState();
            let h = 0,
              u = 0;
            if (0 !== i) {
              const e = Math.sqrt(t * t + r * r),
                o = Math.atan2(r, t);
              (h = t - e * Math.cos(o + i)), (u = r - e * Math.sin(o + i));
            }
            d.Translate(h + n, u - l),
              d.SetClipRect(o.x, o.y, o.width, o.height),
              0 !== i && d.Rotate((180 * i) / Math.PI),
              s ? d.DrawFilledArcBatchVec(e, s, a) : d.DrawArcBatchVec(e, a),
              d.PopMatrix(),
              d.PopState();
          }
          enqueueLayeredDraw(e, t) {
            this.layers.has(t) || this.layers.set(t, []),
              this.layers.get(t).push(e);
          }
          drawLayers() {
            const e = Array.from(this.layers.keys()).sort((e, t) => e - t);
            for (const t of e) for (const e of this.layers.get(t)) e();
          }
          pushShaderEffect(e) {
            e &&
              (this.effects.push(e),
              i.IS_TEST_ENV ||
                this.getNativeContext().AddSeriesEffect(e.getNativeEffect()));
          }
          popShaderEffect() {
            const e = this.effects.pop();
            e &&
              !i.IS_TEST_ENV &&
              this.getNativeContext().RemoveSeriesEffect(e.getNativeEffect());
          }
          createPen(e, t, r = [], i = !0) {
            throw new Error("Use Pen2DCache for creating pens instead!");
          }
          createSolidBrush(e, t) {
            throw new Error("Use BrushCache for creating brushes instead!");
          }
          delete() {}
          drawLine(e, t, r, i, a, s, l) {
            if (!(e || t || r || i)) return;
            o.Guard.notNull(a, "pen"),
              o.Guard.isTrue(
                "WasmPen" === a.getPenType(),
                "pen must be an instance of WasmPen to be used with the WasmRenderContext"
              );
            const d = a.scrtPen;
            o.Guard.notNull(d, "WasmPen.scrtPen");
            const h = this.getNativeContext(),
              u = (0, n.getVectorColorVertex)(this.webAssemblyContext),
              c = (0, n.getVertex)(this.webAssemblyContext, e, t);
            u.push_back(c);
            const p = (0, n.getVertex)(this.webAssemblyContext, r, i);
            u.push_back(p),
              h.PushMatrix(),
              h.PushState(),
              h.Translate(s.x, s.y),
              h.SetClipRect(l.x, l.y, l.width, l.height),
              h.DrawLinesBatchVec(!0, u, d),
              h.PopMatrix(),
              h.PopState();
          }
          drawLines(e, t, r, i, a = y.PolyLine) {
            o.Guard.notNull(t, "pen"),
              o.Guard.notNull(e, "xyValues"),
              o.Guard.isTrue(
                "WasmPen" === t.getPenType(),
                "pen must be an instance of WasmPen to be used with the WasmRenderContext"
              ),
              o.Guard.isTrue(
                e.length > 0 && e.length % 2 == 0,
                "xyValues length must be a multiple of 2, values arranged as x0y0 x1y1 x2y2..."
              );
            const s = t.scrtPen;
            o.Guard.notNull(s, "WebGlPen.scrtPen");
            const l = a === y.PolyLine,
              d = this.getNativeContext(),
              h = (0, n.getVectorColorVertex)(this.webAssemblyContext);
            for (let t = 0; t < e.length; t += 2) {
              const r = (0, n.getVertex)(
                this.webAssemblyContext,
                e[t],
                e[t + 1]
              );
              (r.m_vPosition.z = 0), h.push_back(r);
            }
            d.PushMatrix(),
              d.PushState(),
              d.Translate(r.x, r.y),
              d.SetClipRect(i.x, i.y, i.width, i.height),
              d.DrawLinesBatchVec(l, h, s),
              d.PopMatrix(),
              d.PopState();
          }
          drawTriangleStrip(e, t, r, i, a) {
            if (a) {
              o.Guard.arraysSameLength(e, "xValues", t, "yValues");
              const s = this.getNativeContext(),
                l = a.scrtBrush;
              o.Guard.notNull(l, "WebGlBrush.scrtBrush");
              const d = (0, n.getVectorColorTextureVertex)(
                  this.webAssemblyContext
                ),
                h = e.length;
              for (let r = 0; r < h; r++) {
                const i = e[r],
                  o = t[r],
                  a = (0, n.getTextureVertex)(this.webAssemblyContext, i, o);
                d.push_back(a);
              }
              s.PushMatrix(),
                s.PushState(),
                s.Translate(r.x, r.y),
                s.SetClipRect(i.x, i.y, i.width, i.height),
                s.DrawTrianglesStripVec(d, 0, h, l),
                s.PopMatrix(),
                s.PopState();
            }
          }
          drawRect(e, t, r, i, a, l, d) {
            if (a) {
              const i = this.getNativeContext(),
                l = a.scrtBrush;
              o.Guard.notNull(l, "WebGlBrush.scrtBrush");
              const d = (0, n.getVectorRectVertex)(this.webAssemblyContext),
                h = (0, n.getVector4)(this.webAssemblyContext, 0, 0, 0, 0),
                u = (0, s.createNativeRect)(
                  this.webAssemblyContext,
                  e.x,
                  e.y,
                  e.right,
                  e.bottom
                );
              d.push_back(u),
                i.PushMatrix(),
                i.PushState(),
                i.Translate(t.x, t.y),
                i.SetClipRect(r.x, r.y, r.width, r.height),
                i.DrawRectsBatchVec(d, l, h),
                i.PopMatrix(),
                i.PopState();
            }
            if (i)
              if (l)
                this.drawLines(
                  [
                    e.right,
                    e.top,
                    e.right,
                    e.bottom,
                    e.left,
                    e.bottom,
                    e.left,
                    e.top,
                    e.right,
                    e.top,
                    e.right,
                    e.bottom,
                  ],
                  i,
                  t,
                  r,
                  y.PolyLine
                );
              else {
                const o = Math.round(d / 2) - 1;
                this.drawLines(
                  [
                    e.right,
                    e.top - o,
                    e.right,
                    e.bottom + o,
                    e.right,
                    e.bottom,
                    e.left,
                    e.bottom,
                    e.left,
                    e.bottom + o,
                    e.left,
                    e.top - o,
                    e.left,
                    e.top,
                    e.right,
                    e.top,
                  ],
                  i,
                  t,
                  r,
                  y.DiscontinuousLine
                );
              }
          }
          drawTextBackground(e, t, r, i, o, s, n, l, d) {
            const c = this.getNativeContext();
            let p, g, y, f;
            switch ((c.PushMatrix(), c.Translate(i.x, i.y), c.Rotate(r), s)) {
              case u.EVerticalAnchorPoint.Bottom:
                (p = t + l.top + l.bottom), (g = 0);
                break;
              case u.EVerticalAnchorPoint.Top:
                (p = 0), (g = t + l.bottom + l.top);
                break;
              default:
                (p = t / 2 + l.top), (g = t / 2 + l.bottom);
            }
            switch (n) {
              case u.EHorizontalAnchorPoint.Right:
                (y = e + l.left + l.right), (f = 0);
                break;
              case u.EHorizontalAnchorPoint.Left:
                (y = 0), (f = e + l.right + l.left);
                break;
              default:
                (y = e / 2 + l.left), (f = e / 2 + l.right);
            }
            const v = a.Rect.createWithPoints(
              new h.Point(-y, -p),
              new h.Point(f, g)
            );
            this.drawRect(v, o, o, void 0, d), c.PopMatrix();
          }
          drawNativeText(
            e,
            t,
            r,
            i,
            o,
            a,
            s,
            l,
            d,
            y,
            f,
            v,
            m,
            S,
            P = !1,
            C = 1
          ) {
            const b = (0, g.parseColorToUIntArgb)(l),
              x = (0, p.uintArgbColorOverrideOpacity)(b, d),
              A = { fontFamily: a, fontSize: s },
              T = this.getFont(A, !1, !1),
              E = (0, n.getTextBounds)(this.webAssemblyContext);
            T.CalculateStringBounds(null != m ? m : "", E, 3);
            const R = t + i.x,
              D = r + i.y;
            let w = t,
              M = r;
            v === u.EHorizontalAnchorPoint.Center
              ? (w -= E.m_fWidth / 2)
              : v === u.EHorizontalAnchorPoint.Right
              ? (w -= E.m_fWidth + S.right)
              : v === u.EHorizontalAnchorPoint.Left && (w += S.left),
              f === u.EVerticalAnchorPoint.Center
                ? (M -= E.m_fHeight / 2 - E.GetLineBounds(0).m_fHeight)
                : f === u.EVerticalAnchorPoint.Top
                ? (M += E.GetLineBounds(0).m_fHeight + S.top)
                : f === u.EVerticalAnchorPoint.Bottom && (M -= S.bottom);
            const L = E.m_fWidth,
              O = E.m_fHeight,
              I = (0, c.convertMultiLineAlignment)(
                c.EMultiLineAlignment.Center,
                this.webAssemblyContext
              );
            let k = T.GetScale(),
              _ = !1;
            k !== C && (T.SetScale(C), (_ = !0));
            const V = w + i.x,
              N = M + i.y;
            y &&
              this.drawTextBackground(
                L,
                O,
                (-180 * e) / Math.PI,
                new h.Point(R, D),
                o,
                f,
                v,
                S,
                y
              );
            const B = (0, n.getVector4)(this.webAssemblyContext, R, D, e, 0);
            T.DrawStringAdvanced(m, x, Math.round(V), Math.round(N), B, I, 3),
              _ && T.SetScale(k),
              P && T.End();
          }
          printBlendMode() {
            switch (this.getNativeContext().GetBlendMode()) {
              case this.webAssemblyContext.eSCRTBlendMode.BlendDefault:
                console.log("BlendDefault");
                break;
              case this.webAssemblyContext.eSCRTBlendMode.BlendAdditiveOneAlpha:
                console.log("BlendAdditiveOneAlpha");
                break;
              case this.webAssemblyContext.eSCRTBlendMode.BlendAdditiveColor:
                console.log("BlendAdditiveColor");
                break;
              case this.webAssemblyContext.eSCRTBlendMode.BlendAdditiveAlpha:
                console.log("BlendAdditiveAlpha");
                break;
              case this.webAssemblyContext.eSCRTBlendMode.BlendDisabled:
                console.log("BlendDisabled");
                break;
              default:
                throw new Error("Unhandled blendmode ");
            }
          }
          getFont(e, t = !1, r = !1) {
            const i = (0, n.getFontKey)(this.webAssemblyContext, e, t, r),
              o = this.getNativeContext().AquireFont(i);
            if (!o) throw new Error("Could not create font " + i.m_strName);
            o.m_isDrawing || o.Begin();
            const a = o.GetFaceName();
            return (
              "SCRT_Loading" === a
                ? setTimeout(() => {
                    var e;
                    d.PerformanceDebugHelper.mark(
                      d.EPerformanceMarkType.Invalidate,
                      { parentContextId: this.canvasId }
                    ),
                      this.webAssemblyContext.TSRRequestCanvasDraw(
                        null !== (e = this.canvasId) && void 0 !== e
                          ? e
                          : "undefinedCanvasId"
                      );
                  }, 100)
                : a !== i.m_strName &&
                  (i.warned ||
                    (console.warn(
                      `Font ${i.m_strName} could not be found on the server and has not been registered. Falling back to default font.\n                Use await scichartSurface.registerFont if you need to load the font from a remote url`
                    ),
                    (i.warned = !0))),
              o
            );
          }
          endFonts(e = !1) {
            var t;
            const r = d.PerformanceDebugHelper.mark(
                d.EPerformanceMarkType.DrawNativeTextStart,
                {
                  contextId: this.canvasId,
                  level: d.EPerformanceDebugLevel.Verbose,
                }
              ),
              i = this.getNativeContext(),
              o = (0, n.getAllFontKeys)(this.webAssemblyContext);
            for (const e of o) {
              const t = i.AquireFont(e);
              t && t.m_isDrawing && t.End();
            }
            d.PerformanceDebugHelper.mark(
              d.EPerformanceMarkType.DrawNativeTextEnd,
              {
                contextId: this.canvasId,
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                level: d.EPerformanceDebugLevel.Verbose,
              }
            );
          }
        }
        (t.WebGlRenderContext2D = f), (f.webGlResourcesRefs = new Set());
      },
      78249: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDrawingTypes = void 0),
          ((r = t.EDrawingTypes || (t.EDrawingTypes = {})).WasmBrush =
            "WasmBrush"),
          (r.WasmPen = "WasmPen");
      },
      5100: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.testLayoutManager =
            t.getCoordinateWithCoordinateMode =
            t.getValueWithCoordinateMode =
            t.updateTopAndBottomChartLayoutState =
            t.updateLeftAndRightChartLayoutState =
            t.getVerticalAxisRequiredSize =
            t.getHorizontalAxisRequiredSize =
            t.layoutAxisPartsBottomStrategy =
            t.layoutAxisPartsTopStrategy =
            t.layoutAxisPartsRightStrategy =
            t.layoutAxisPartsLeftStrategy =
            t.layoutAxisParts =
            t.updateAxisLayoutState =
              void 0);
        const i = r(23866),
          o = r(87459),
          a = r(41344);
        function s(e) {
          const {
            axisRenderer: t,
            axisTitleRenderer: r,
            axisLayoutState: i,
            isHorizontalAxis: o,
            axisBorder: a,
          } = e;
          i.clear(),
            (i.axisSize = o
              ? t.desiredHeight + r.desiredHeight
              : t.desiredWidth + r.desiredWidth),
            (i.additionalBottomSize = a.borderBottom),
            (i.additionalTopSize = a.borderTop),
            (i.additionalRightSize = a.borderRight),
            (i.additionalLeftSize = a.borderLeft);
        }
        function n(e, t, r, i, a) {
          return {
            axisTitleRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top,
              a.left + r,
              a.bottom
            ),
            axisRendererViewRect: o.Rect.createWithCoords(
              a.left + r,
              a.top,
              a.right,
              a.bottom
            ),
          };
        }
        function l(e, t, r, i, a) {
          return {
            axisRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top,
              a.left + e,
              a.bottom
            ),
            axisTitleRendererViewRect: o.Rect.createWithCoords(
              a.left + e,
              a.top,
              a.right,
              a.bottom
            ),
          };
        }
        function d(e, t, r, i, a) {
          return {
            axisTitleRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top,
              a.right,
              a.top + i
            ),
            axisRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top + i,
              a.right,
              a.bottom
            ),
          };
        }
        function h(e, t, r, i, a) {
          return {
            axisRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top,
              a.right,
              a.top + t
            ),
            axisTitleRendererViewRect: o.Rect.createWithCoords(
              a.left,
              a.top + t,
              a.right,
              a.bottom
            ),
          };
        }
        (t.updateAxisLayoutState = s),
          (t.layoutAxisParts = function (e, t) {
            const {
                isHorizontalAxis: r,
                viewRect: i,
                axisRenderer: o,
                axisTitleRenderer: a,
                axisBorder: s,
              } = e,
              n = r ? i.width : o.desiredWidth,
              l = r ? o.desiredHeight : i.height,
              d = a.desiredWidth,
              h = a.desiredHeight,
              { axisRendererViewRect: u, axisTitleRendererViewRect: c } = t(
                n,
                l,
                d,
                h,
                i,
                s
              );
            o.layout(u), a.layout(c);
          }),
          (t.layoutAxisPartsLeftStrategy = n),
          (t.layoutAxisPartsRightStrategy = l),
          (t.layoutAxisPartsTopStrategy = d),
          (t.layoutAxisPartsBottomStrategy = h),
          (t.getHorizontalAxisRequiredSize = function (e) {
            return e.axisSize + e.additionalTopSize + e.additionalBottomSize;
          }),
          (t.getVerticalAxisRequiredSize = function (e) {
            return e.axisSize + e.additionalLeftSize + e.additionalRightSize;
          }),
          (t.updateLeftAndRightChartLayoutState = function (e, t = 0, r = 0) {
            (e.leftOuterAreaSize =
              e.leftOuterAreaSize < 0
                ? e.leftOuterAreaSize + t
                : Math.max(e.leftOuterAreaSize, t)),
              (e.rightOuterAreaSize =
                e.rightOuterAreaSize < 0
                  ? e.rightOuterAreaSize + r
                  : Math.max(e.rightOuterAreaSize, r));
          }),
          (t.updateTopAndBottomChartLayoutState = function (e, t = 0, r = 0) {
            (e.topOuterAreaSize =
              e.topOuterAreaSize < 0
                ? e.topOuterAreaSize + t
                : Math.max(e.topOuterAreaSize, t)),
              (e.bottomOuterAreaSize =
                e.bottomOuterAreaSize < 0
                  ? e.bottomOuterAreaSize + r
                  : Math.max(e.bottomOuterAreaSize, r));
          }),
          (t.getValueWithCoordinateMode = (e, t, r) => {
            switch (r) {
              case a.EInnerAxisPlacementCoordinateMode.Pixel:
                return t.getDataValue(e);
              case a.EInnerAxisPlacementCoordinateMode.DataValue:
                return e;
              case a.EInnerAxisPlacementCoordinateMode.Relative:
                return (t.visibleMax - t.visibleMin) * e + t.visibleMin;
              default:
                throw new Error(`CoordinateMode ${r} is not supported`);
            }
          }),
          (t.getCoordinateWithCoordinateMode = (e, t, r) => {
            switch (
              (i.Guard.notNull(r, "coordinateMode"),
              i.Guard.notNull(t, "calculator"),
              r)
            ) {
              case a.EInnerAxisPlacementCoordinateMode.Pixel:
                return e;
              case a.EInnerAxisPlacementCoordinateMode.DataValue:
                return t.getCoordinate(e);
              case a.EInnerAxisPlacementCoordinateMode.Relative:
                return e * t.viewportDimension;
              default:
                throw new Error(`CoordinateMode ${r} is not supported`);
            }
          }),
          (t.testLayoutManager = {
            updateAxisLayoutState: s,
            layoutAxisPartsLeftStrategy: n,
            layoutAxisPartsRightStrategy: l,
            layoutAxisPartsTopStrategy: d,
            layoutAxisPartsBottomStrategy: h,
          });
      },
      21843: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(5100);
        t.BaseAxisLayoutStrategy = class {
          constructor() {
            this.isStacked = !1;
          }
          toJSON() {
            return { type: this.type };
          }
          updateAxisLayoutState(e) {
            (0, o.updateAxisLayoutState)(e);
          }
          updateLeftAndRightChartLayoutState(e, t, r) {
            (0, o.updateLeftAndRightChartLayoutState)(e, t, r);
          }
          updateTopAndBottomChartLayoutState(e, t, r) {
            (0, o.updateTopAndBottomChartLayoutState)(e, t, r);
          }
          layoutAxesFromBottomToTop(e, t, r, a, s) {
            let n = a;
            s.forEach((t) => {
              const {
                  axisLayoutState: {
                    axisSize: a,
                    additionalTopSize: s,
                    additionalBottomSize: l,
                  },
                } = t,
                d = n - a - l - s;
              (t.viewRect = i.Rect.createWithCoords(e, d + s, r, n - l)),
                (n = d),
                (0, o.layoutAxisParts)(t, this.layoutAxisPartsStrategy);
            });
          }
          layoutAxesFromTopToBottom(e, t, r, a, s) {
            let n = t;
            s.forEach((t) => {
              const {
                  axisLayoutState: {
                    axisSize: a,
                    additionalTopSize: s,
                    additionalBottomSize: l,
                  },
                } = t,
                d = n + a + l + s;
              (t.viewRect = i.Rect.createWithCoords(e, n + s, r, d - l)),
                (n = d),
                (0, o.layoutAxisParts)(t, this.layoutAxisPartsStrategy);
            });
          }
          layoutAxesFromLeftToRight(e, t, r, a, s) {
            let n = e;
            s.forEach((e) => {
              const {
                  axisLayoutState: {
                    axisSize: r,
                    additionalLeftSize: s,
                    additionalRightSize: l,
                  },
                } = e,
                d = n + r + s + l;
              (e.viewRect = i.Rect.createWithCoords(n + s, t, d - l, a)),
                (n = d),
                (0, o.layoutAxisParts)(e, this.layoutAxisPartsStrategy);
            });
          }
          layoutAxesFromRightToLeft(e, t, r, a, s) {
            let n = r;
            s.forEach((e) => {
              const {
                  axisLayoutState: {
                    axisSize: r,
                    additionalLeftSize: s,
                    additionalRightSize: l,
                  },
                } = e,
                d = n - r - s - l;
              (e.viewRect = i.Rect.createWithCoords(d + s, t, n - l, a)),
                (n = d),
                (0, o.layoutAxisParts)(e, this.layoutAxisPartsStrategy);
            });
          }
          calculateTotalAxisHeight(e, t) {
            return (
              a(e.stackedAxisLength, t) +
              e.axisLayoutState.additionalBottomSize +
              e.axisLayoutState.additionalTopSize
            );
          }
          calculateTotalAxisWidth(e, t) {
            return (
              a(e.stackedAxisLength, t) +
              e.axisLayoutState.additionalRightSize +
              e.axisLayoutState.additionalLeftSize
            );
          }
        };
        const a = (e, t) => {
            if ("number" == typeof e) {
              if (e < 0)
                throw new Error("stackedAxisLength must be a positive value!");
              return e;
            }
            if (e.includes("%")) return s(e, t);
            const r = parseFloat(e);
            if (!isNaN(r)) return r;
            throw new Error(
              "stackedAxisLength must be a number or a percentage"
            );
          },
          s = (e, t) => {
            const r = parseFloat(e);
            if (r < 0 || r > 100)
              throw new Error(
                "stackedAxisLength percentage must be from 0 to 100"
              );
            return Math.round((t * r) / 10) / 10;
          };
      },
      93326: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseCenteredAxisLayoutStrategy = void 0);
        const i = r(21843),
          o = r(73105),
          a = r(41344);
        class s extends i.BaseAxisLayoutStrategy {
          constructor(e) {
            var t, r, i;
            super(),
              (this.coordinateModeProperty =
                a.EInnerAxisPlacementCoordinateMode.DataValue),
              (this.orthogonalAxisIdProperty =
                null !== (t = null == e ? void 0 : e.orthogonalAxisId) &&
                void 0 !== t
                  ? t
                  : this.orthogonalAxisIdProperty),
              (this.coordinateModeProperty =
                null !== (r = null == e ? void 0 : e.coordinateMode) &&
                void 0 !== r
                  ? r
                  : this.coordinateModeProperty),
              (this.axisPositionProperty =
                null !== (i = null == e ? void 0 : e.axisPosition) &&
                void 0 !== i
                  ? i
                  : this.axisPositionProperty);
          }
          get orthogonalAxisId() {
            return this.orthogonalAxisIdProperty;
          }
          set orthogonalAxisId(e) {
            this.orthogonalAxisId !== e &&
              ((this.orthogonalAxisIdProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.VERTICAL_AXIS_ID));
          }
          get coordinateMode() {
            return this.coordinateModeProperty;
          }
          set coordinateMode(e) {
            this.coordinateModeProperty !== e &&
              ((this.coordinateModeProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.COORDINATE_MODE));
          }
          get axisPosition() {
            return this.axisPositionProperty;
          }
          set axisPosition(e) {
            this.axisPositionProperty !== e &&
              ((this.axisPositionProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.AXIS_POSITION_COORDINATE));
          }
          toJSON() {
            const e = {
              axisPosition: this.axisPosition,
              coordinateMode: this.coordinateMode,
              orthogonalAxisId: this.orthogonalAxisId,
            };
            return { type: this.type, options: e };
          }
          notifyPropertyChanged(e) {
            var t;
            (null === (t = this.sciChartSurface) || void 0 === t
              ? void 0
              : t.invalidateElement) &&
              this.sciChartSurface.invalidateElement();
          }
        }
        t.BaseCenteredAxisLayoutStrategy = s;
      },
      60872: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BottomAlignedInnerAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(93326);
        class s extends a.BaseCenteredAxisLayoutStrategy {
          constructor(e) {
            super(e),
              (this.type = i.ELayoutStrategyType.BottomInner),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsTopStrategy);
          }
          measureAxes(e, t, r) {
            this.sciChartSurface = e;
            let i = 0;
            return (
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (i += (0, o.getHorizontalAxisRequiredSize)(
                    e.axisLayoutState
                  ));
              }),
              i
            );
          }
          updateAreaSize(e, t) {
            e.bottomInnerAreaSize = t;
          }
          layoutAxes(e, t, r, i, a) {
            var s;
            if (
              (a.forEach((e) => {
                (e.axisLength = void 0), (e.offset = 0);
              }),
              0 === a.length)
            )
              return;
            let n = i;
            if (void 0 !== this.axisPosition) {
              const e =
                null !==
                  (s = this.sciChartSurface.getYAxisById(
                    this.orthogonalAxisId
                  )) && void 0 !== s
                  ? s
                  : this.sciChartSurface.getDefaultYAxis();
              if (!e || e.isHorizontalAxis)
                throw new Error(
                  "orthogonalAxisId should be a valid id of vertical axis on the surface!"
                );
              const t = e.getCurrentCoordinateCalculator();
              n =
                (0, o.getCoordinateWithCoordinateMode)(
                  this.axisPosition,
                  t,
                  this.coordinateMode
                ) + e.viewRect.top;
            }
            this.layoutAxesFromBottomToTop(e, t, r, n, a);
          }
        }
        t.BottomAlignedInnerAxisLayoutStrategy = s;
      },
      53521: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BottomAlignedOuterAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(21843);
        class s extends a.BaseAxisLayoutStrategy {
          constructor() {
            super(),
              (this.type = i.ELayoutStrategyType.BottomOuter),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsBottomStrategy);
          }
          measureAxes(e, t, r) {
            var i, a;
            let s =
              null !==
                (a =
                  null === (i = e.adjustedPadding) || void 0 === i
                    ? void 0
                    : i.bottom) && void 0 !== a
                ? a
                : 0;
            return (
              (s += e.bottomViewportBorder + e.bottomCanvasBorder),
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (s += (0, o.getHorizontalAxisRequiredSize)(
                    e.axisLayoutState
                  )),
                  this.updateLeftAndRightChartLayoutState(
                    t,
                    e.axisLayoutState.additionalLeftSize,
                    e.axisLayoutState.additionalRightSize
                  );
              }),
              s
            );
          }
          updateAreaSize(e, t) {
            e.bottomOuterAreaSize = t;
          }
          layoutAxes(e, t, r, i, o) {
            o.forEach((e) => {
              (e.axisLength = void 0), (e.offset = 0);
            }),
              this.layoutAxesFromTopToBottom(e, t, r, i, o);
          }
        }
        t.BottomAlignedOuterAxisLayoutStrategy = s;
      },
      57384: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(73785),
          a = r(5100),
          s = r(53521);
        class n extends s.BottomAlignedOuterAxisLayoutStrategy {
          constructor() {
            super(...arguments),
              (this.type = o.ELayoutStrategyType.BottomStacked),
              (this.isStacked = !0);
          }
          measureAxes(e, t, r) {
            var i;
            let o = 0;
            r.forEach((e) => {
              e.measure(), this.updateAxisLayoutState(e);
              const t = (0, a.getHorizontalAxisRequiredSize)(e.axisLayoutState);
              o = t > o ? t : o;
            });
            const [s] = r,
              n = r[r.length - 1];
            this.updateLeftAndRightChartLayoutState(
              t,
              null == s ? void 0 : s.axisLayoutState.additionalLeftSize,
              null == n ? void 0 : n.axisLayoutState.additionalRightSize
            );
            const {
              bottomViewportBorder: l,
              bottomCanvasBorder: d,
              adjustedPadding: h,
            } = e;
            return (
              (o +=
                l +
                d +
                (null !== (i = null == h ? void 0 : h.bottom) && void 0 !== i
                  ? i
                  : 0)),
              o
            );
          }
          layoutAxes(e, t, r, o, s) {
            const n = r - e,
              [l] = s,
              d = s[s.length - 1],
              h = s.filter((e) => e.stackedAxisLength),
              u = s.reduce(
                (e, t) =>
                  e -
                  t.axisLayoutState.additionalBottomSize -
                  t.axisLayoutState.additionalTopSize,
                n +
                  (null == l ? void 0 : l.axisLayoutState.additionalLeftSize) +
                  (null == d ? void 0 : d.axisLayoutState.additionalRightSize)
              ),
              c = h.reduce((e, t) => e + this.calculateTotalAxisWidth(t, u), 0),
              p =
                n +
                (null == l ? void 0 : l.axisLayoutState.additionalLeftSize) +
                (null == d ? void 0 : d.axisLayoutState.additionalRightSize) -
                c;
            if (p < 0)
              throw new Error(
                `Bottom stacked axes with defined size total ${c} pixels which is ${-p} more than the space available`
              );
            const g = p / (s.length - h.length);
            let y =
              e - (null == l ? void 0 : l.axisLayoutState.additionalLeftSize);
            s.forEach((r) => {
              const {
                  axisSize: o,
                  additionalLeftSize: s,
                  additionalRightSize: n,
                  additionalTopSize: l,
                } = r.axisLayoutState,
                d = t + l,
                h = d + o,
                c = r.stackedAxisLength
                  ? this.calculateTotalAxisWidth(r, u)
                  : g,
                p = y + c - n;
              (y += s),
                (r.offset = y - e),
                (r.axisLength = p - y),
                (r.isPrimaryAxis = !0),
                (r.viewRect = i.Rect.createWithCoords(y, d, p, h)),
                (y = p + n),
                (0, a.layoutAxisParts)(r, this.layoutAxisPartsStrategy);
            });
          }
        }
        t.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy = n;
      },
      70397: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CentralAxesLayoutManager = void 0);
        const i = r(38215),
          o = r(883),
          a = r(60872),
          s = r(73105),
          n = r(41344),
          l = r(45481),
          d = r(83638),
          h = r(24478),
          u = r(27194);
        class c extends l.LayoutManager {
          constructor(e) {
            var t, r, i, s;
            super(e),
              (this.type = o.ELayoutManagerType.CentralAxes),
              (this.horizontalAxisPositionCoordinateModeProperty =
                n.EInnerAxisPlacementCoordinateMode.Relative),
              (this.verticalAxisPositionCoordinateModeProperty =
                n.EInnerAxisPlacementCoordinateMode.Relative),
              (this.horizontalAxisPositionProperty = 0.5),
              (this.verticalAxisPositionProperty = 0.5),
              (this.verticalAxisPositionProperty =
                null !== (t = null == e ? void 0 : e.verticalAxisPosition) &&
                void 0 !== t
                  ? t
                  : this.verticalAxisPositionProperty),
              (this.verticalAxisPositionCoordinateModeProperty =
                null !==
                  (r =
                    null == e
                      ? void 0
                      : e.verticalAxisPositionCoordinateMode) && void 0 !== r
                  ? r
                  : this.verticalAxisPositionCoordinateModeProperty),
              (this.horizontalAxisPositionProperty =
                null !== (i = null == e ? void 0 : e.horizontalAxisPosition) &&
                void 0 !== i
                  ? i
                  : this.horizontalAxisPositionProperty),
              (this.horizontalAxisPositionCoordinateModeProperty =
                null !==
                  (s =
                    null == e
                      ? void 0
                      : e.horizontalAxisPositionCoordinateMode) && void 0 !== s
                  ? s
                  : this.horizontalAxisPositionCoordinateModeProperty),
              (this.leftInnerAxesLayoutStrategy =
                new d.LeftAlignedInnerAxisLayoutStrategy({
                  axisPosition: this.verticalAxisPositionProperty,
                  coordinateMode:
                    this.verticalAxisPositionCoordinateModeProperty,
                })),
              (this.rightInnerAxesLayoutStrategy =
                new h.RightAlignedInnerAxisLayoutStrategy({
                  axisPosition: this.verticalAxisPositionProperty,
                  coordinateMode:
                    this.verticalAxisPositionCoordinateModeProperty,
                })),
              (this.topInnerAxesLayoutStrategy =
                new u.TopAlignedInnerAxisLayoutStrategy({
                  axisPosition: this.horizontalAxisPositionProperty,
                  coordinateMode:
                    this.horizontalAxisPositionCoordinateModeProperty,
                })),
              (this.bottomInnerAxesLayoutStrategy =
                new a.BottomAlignedInnerAxisLayoutStrategy({
                  axisPosition: this.horizontalAxisPositionProperty,
                  coordinateMode:
                    this.horizontalAxisPositionCoordinateModeProperty,
                }));
          }
          get horizontalAxisPositionCoordinateMode() {
            return this.horizontalAxisPositionCoordinateModeProperty;
          }
          set horizontalAxisPositionCoordinateMode(e) {
            (this.horizontalAxisPositionCoordinateModeProperty = e),
              (this.topInnerAxesLayoutStrategy.coordinateMode = e),
              (this.bottomInnerAxesLayoutStrategy.coordinateMode = e),
              this.notifyPropertyChanged(s.PROPERTY.COORDINATE_MODE);
          }
          get verticalAxisPositionCoordinateMode() {
            return this.verticalAxisPositionCoordinateModeProperty;
          }
          set verticalAxisPositionCoordinateMode(e) {
            (this.verticalAxisPositionCoordinateModeProperty = e),
              (this.rightInnerAxesLayoutStrategy.coordinateMode = e),
              (this.leftInnerAxesLayoutStrategy.coordinateMode = e),
              this.notifyPropertyChanged(s.PROPERTY.COORDINATE_MODE);
          }
          get horizontalAxisPosition() {
            return this.horizontalAxisPositionProperty;
          }
          set horizontalAxisPosition(e) {
            (this.horizontalAxisPositionProperty = e),
              (this.topInnerAxesLayoutStrategy.axisPosition = e),
              (this.bottomInnerAxesLayoutStrategy.axisPosition = e),
              this.notifyPropertyChanged(s.PROPERTY.AXIS_POSITION_COORDINATE);
          }
          get verticalAxisPosition() {
            return this.verticalAxisPositionProperty;
          }
          set verticalAxisPosition(e) {
            (this.verticalAxisPositionProperty = e),
              (this.rightInnerAxesLayoutStrategy.axisPosition = e),
              (this.leftInnerAxesLayoutStrategy.axisPosition = e),
              this.notifyPropertyChanged(s.PROPERTY.AXIS_POSITION_COORDINATE);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                horizontalAxisPosition: this.horizontalAxisPosition,
                horizontalAxisPositionCoordinateMode:
                  this.horizontalAxisPositionCoordinateMode,
                verticalAxisPosition: this.verticalAxisPosition,
                verticalAxisPositionCoordinateMode:
                  this.verticalAxisPositionCoordinateMode,
              };
            return Object.assign(e, t), e;
          }
          notifyPropertyChanged(e) {
            var t;
            (null === (t = this.sciChartSurface) || void 0 === t
              ? void 0
              : t.invalidateElement) &&
              this.sciChartSurface.invalidateElement();
          }
          groupAxesByLayoutStrategy() {
            this.axesGroupedByLayoutStrategy.clear();
            const {
                topInnerAxes: e,
                bottomInnerAxes: t,
                leftInnerAxes: r,
                rightInnerAxes: o,
              } = this.axesGroupedByLayoutStrategy,
              a = (a) => {
                a.forEach((a) => {
                  const { axisAlignment: s } = a;
                  switch (((a.isInnerAxis = !0), s)) {
                    case i.EAxisAlignment.Top:
                      e.push(a);
                      break;
                    case i.EAxisAlignment.Bottom:
                      t.push(a);
                      break;
                    case i.EAxisAlignment.Left:
                      r.push(a);
                      break;
                    case i.EAxisAlignment.Right:
                      o.push(a);
                  }
                });
              };
            a(this.sciChartSurface.xAxes.asArray()),
              a(this.sciChartSurface.yAxes.asArray());
          }
        }
        t.CentralAxesLayoutManager = c;
      },
      2310: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChartLayoutState = void 0);
        class r {
          constructor() {
            (this.leftInnerAreaSize = r.DEFAULT_SIZE),
              (this.topInnerAreaSize = r.DEFAULT_SIZE),
              (this.bottomInnerAreaSize = r.DEFAULT_SIZE),
              (this.rightInnerAreaSize = r.DEFAULT_SIZE),
              (this.leftOuterAreaSize = r.DEFAULT_SIZE),
              (this.topOuterAreaSize = r.DEFAULT_SIZE),
              (this.bottomOuterAreaSize = r.DEFAULT_SIZE),
              (this.rightOuterAreaSize = r.DEFAULT_SIZE);
          }
          clear() {
            (this.leftInnerAreaSize = r.DEFAULT_SIZE),
              (this.topInnerAreaSize = r.DEFAULT_SIZE),
              (this.bottomInnerAreaSize = r.DEFAULT_SIZE),
              (this.rightInnerAreaSize = r.DEFAULT_SIZE),
              (this.leftOuterAreaSize = r.DEFAULT_SIZE),
              (this.topOuterAreaSize = r.DEFAULT_SIZE),
              (this.bottomOuterAreaSize = r.DEFAULT_SIZE),
              (this.rightOuterAreaSize = r.DEFAULT_SIZE);
          }
        }
        (t.ChartLayoutState = r), (r.DEFAULT_SIZE = 0);
      },
      41344: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EInnerAxisPlacementCoordinateMode = void 0),
          ((r =
            t.EInnerAxisPlacementCoordinateMode ||
            (t.EInnerAxisPlacementCoordinateMode = {}))[(r.DataValue = 0)] =
            "DataValue"),
          (r[(r.Pixel = 1)] = "Pixel"),
          (r[(r.Relative = 2)] = "Relative");
      },
      45481: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LayoutManager = void 0);
        const i = r(45921),
          o = r(87459),
          a = r(38215),
          s = r(11043),
          n = r(883),
          l = r(73785),
          d = r(60872),
          h = r(53521),
          u = r(2310),
          c = r(20639),
          p = r(83638),
          g = r(6153),
          y = r(24478),
          f = r(27282),
          v = r(27194),
          m = r(73145);
        t.LayoutManager = class {
          constructor(e) {
            (this.type = n.ELayoutManagerType.Default),
              (this.leftOuterAxesLayoutStrategyProperty =
                new g.LeftAlignedOuterAxisLayoutStrategy()),
              (this.rightOuterAxesLayoutStrategyProperty =
                new f.RightAlignedOuterAxisLayoutStrategy()),
              (this.topOuterAxesLayoutStrategyProperty =
                new m.TopAlignedOuterAxisLayoutStrategy()),
              (this.bottomOuterAxesLayoutStrategyProperty =
                new h.BottomAlignedOuterAxisLayoutStrategy()),
              (this.leftInnerAxesLayoutStrategy =
                new p.LeftAlignedInnerAxisLayoutStrategy()),
              (this.rightInnerAxesLayoutStrategy =
                new y.RightAlignedInnerAxisLayoutStrategy()),
              (this.topInnerAxesLayoutStrategy =
                new v.TopAlignedInnerAxisLayoutStrategy()),
              (this.bottomInnerAxesLayoutStrategy =
                new d.BottomAlignedInnerAxisLayoutStrategy()),
              (this.chartLayoutState = new u.ChartLayoutState()),
              (this.axesGroupedByLayoutStrategy = new c.LayoutStrategyAxes()),
              (this.leftOuterAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.LeftOuter,
                this.leftOuterAxesLayoutStrategy
              )),
              (this.rightOuterAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.RightOuter,
                this.rightOuterAxesLayoutStrategy
              )),
              (this.topOuterAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.TopOuter,
                this.topOuterAxesLayoutStrategy
              )),
              (this.bottomOuterAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.BottomOuter,
                this.bottomOuterAxesLayoutStrategy
              )),
              (this.leftInnerAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.LeftInner,
                this.leftInnerAxesLayoutStrategy
              )),
              (this.rightInnerAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.RightInner,
                this.rightInnerAxesLayoutStrategy
              )),
              (this.topInnerAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.TopInner,
                this.topInnerAxesLayoutStrategy
              )),
              (this.bottomInnerAxesLayoutStrategy = this.createStrategy(
                null == e ? void 0 : e.BottomInner,
                this.bottomInnerAxesLayoutStrategy
              ));
          }
          get leftOuterAxesLayoutStrategy() {
            return this.leftOuterAxesLayoutStrategyProperty;
          }
          set leftOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.leftOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.leftOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(this.axesGroupedByLayoutStrategy.leftOuterAxes)),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get rightOuterAxesLayoutStrategy() {
            return this.rightOuterAxesLayoutStrategyProperty;
          }
          set rightOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.rightOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.rightOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(
                  this.axesGroupedByLayoutStrategy.rightOuterAxes
                )),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get topOuterAxesLayoutStrategy() {
            return this.topOuterAxesLayoutStrategyProperty;
          }
          set topOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.topOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.topOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(this.axesGroupedByLayoutStrategy.topOuterAxes)),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get bottomOuterAxesLayoutStrategy() {
            return this.bottomOuterAxesLayoutStrategyProperty;
          }
          set bottomOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.bottomOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.bottomOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(
                  this.axesGroupedByLayoutStrategy.bottomOuterAxes
                )),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          getAxisLayoutStrategy(e) {
            const { axisAlignment: t, isInnerAxis: r } = e;
            switch (t) {
              case a.EAxisAlignment.Left:
                return r
                  ? this.leftInnerAxesLayoutStrategy
                  : this.leftOuterAxesLayoutStrategy;
              case a.EAxisAlignment.Right:
                return r
                  ? this.rightInnerAxesLayoutStrategy
                  : this.rightOuterAxesLayoutStrategy;
              case a.EAxisAlignment.Top:
                return r
                  ? this.topInnerAxesLayoutStrategy
                  : this.topOuterAxesLayoutStrategy;
              case a.EAxisAlignment.Bottom:
                return r
                  ? this.bottomInnerAxesLayoutStrategy
                  : this.bottomOuterAxesLayoutStrategy;
              default:
                return (0, a.handleInvalidAxisAlignment)(t);
            }
          }
          layoutChart(e, t) {
            var r, i, o, a;
            this.groupAxesByLayoutStrategy();
            const s =
                null !== (r = null == t ? void 0 : t.right) && void 0 !== r
                  ? r
                  : 0,
              n =
                null !== (i = null == t ? void 0 : t.left) && void 0 !== i
                  ? i
                  : 0,
              l =
                null !== (o = null == t ? void 0 : t.top) && void 0 !== o
                  ? o
                  : 0,
              d =
                null !== (a = null == t ? void 0 : t.bottom) && void 0 !== a
                  ? a
                  : 0,
              h = e.width - n - s,
              u = e.height - l - d;
            try {
              this.measureTopOuterAxes(),
                this.measureBottomOuterAxes(),
                this.measureLeftOuterAxes(),
                this.measureRightOuterAxes(),
                this.measureTopInnerAxes(),
                this.measureBottomInnerAxes(),
                this.measureLeftInnerAxes(),
                this.measureRightInnerAxes();
              const e =
                  h -
                  this.chartLayoutState.leftOuterAreaSize -
                  this.chartLayoutState.rightOuterAreaSize,
                t =
                  u -
                  this.chartLayoutState.topOuterAreaSize -
                  this.chartLayoutState.bottomOuterAreaSize,
                r = n,
                i = r + this.chartLayoutState.leftOuterAreaSize,
                o = i + (e < 10 ? 10 : e),
                a = o + this.chartLayoutState.rightOuterAreaSize,
                s = l,
                d = s + this.chartLayoutState.topOuterAreaSize,
                c = d + (t < 10 ? 10 : t),
                p = c + this.chartLayoutState.bottomOuterAreaSize;
              this.sciChartSurface.drawSeriesBehindAxis
                ? this.layoutChartCenter(r, s, a, p)
                : this.layoutChartCenter(i, d, o, c),
                this.leftOuterAxesLayoutStrategy.layoutAxes(
                  r,
                  d,
                  i - this.sciChartSurface.leftViewportBorder,
                  c,
                  this.axesGroupedByLayoutStrategy.leftOuterAxes
                ),
                this.rightOuterAxesLayoutStrategy.layoutAxes(
                  o + this.sciChartSurface.rightViewportBorder,
                  d,
                  a,
                  c,
                  this.axesGroupedByLayoutStrategy.rightOuterAxes
                ),
                this.topOuterAxesLayoutStrategy.layoutAxes(
                  i,
                  s,
                  o,
                  d - this.sciChartSurface.topViewportBorder,
                  this.axesGroupedByLayoutStrategy.topOuterAxes
                ),
                this.bottomOuterAxesLayoutStrategy.layoutAxes(
                  i,
                  c + this.sciChartSurface.bottomViewportBorder,
                  o,
                  p,
                  this.axesGroupedByLayoutStrategy.bottomOuterAxes
                );
              const g = i + this.chartLayoutState.leftInnerAreaSize,
                y = o - this.chartLayoutState.rightInnerAreaSize,
                f = d + this.chartLayoutState.topInnerAreaSize,
                v = c - this.chartLayoutState.bottomInnerAreaSize;
              return (
                this.leftInnerAxesLayoutStrategy.layoutAxes(
                  i,
                  d,
                  g,
                  c,
                  this.axesGroupedByLayoutStrategy.leftInnerAxes
                ),
                this.rightInnerAxesLayoutStrategy.layoutAxes(
                  y,
                  d,
                  o,
                  c,
                  this.axesGroupedByLayoutStrategy.rightInnerAxes
                ),
                this.topInnerAxesLayoutStrategy.layoutAxes(
                  i,
                  d,
                  o,
                  f,
                  this.axesGroupedByLayoutStrategy.topInnerAxes
                ),
                this.bottomInnerAxesLayoutStrategy.layoutAxes(
                  i,
                  v,
                  o,
                  c,
                  this.axesGroupedByLayoutStrategy.bottomInnerAxes
                ),
                this.sciChartSurface.seriesViewRect
              );
            } finally {
              this.chartLayoutState.clear();
            }
          }
          toJSON() {
            const e = {
              BottomInner: this.bottomInnerAxesLayoutStrategy.toJSON(),
              BottomOuter: this.bottomOuterAxesLayoutStrategy.toJSON(),
              LeftInner: this.leftInnerAxesLayoutStrategy.toJSON(),
              LeftOuter: this.leftOuterAxesLayoutStrategy.toJSON(),
              RightInner: this.rightInnerAxesLayoutStrategy.toJSON(),
              RightOuter: this.rightOuterAxesLayoutStrategy.toJSON(),
              TopInner: this.topInnerAxesLayoutStrategy.toJSON(),
              TopOuter: this.topOuterAxesLayoutStrategy.toJSON(),
            };
            return { type: this.type, options: e };
          }
          measureLeftOuterAxes() {
            const e = this.leftOuterAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.leftOuterAxes
            );
            this.leftOuterAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureRightOuterAxes() {
            const e = this.rightOuterAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.rightOuterAxes
            );
            this.rightOuterAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureTopOuterAxes() {
            const e = this.topOuterAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.topOuterAxes
            );
            this.topOuterAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureBottomOuterAxes() {
            const e = this.bottomOuterAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.bottomOuterAxes
            );
            this.bottomOuterAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureLeftInnerAxes() {
            const e = this.leftInnerAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.leftInnerAxes
            );
            this.leftInnerAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureRightInnerAxes() {
            const e = this.rightInnerAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.rightInnerAxes
            );
            this.rightInnerAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureTopInnerAxes() {
            const e = this.topInnerAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.topInnerAxes
            );
            this.topInnerAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          measureBottomInnerAxes() {
            const e = this.bottomInnerAxesLayoutStrategy.measureAxes(
              this.sciChartSurface,
              this.chartLayoutState,
              this.axesGroupedByLayoutStrategy.bottomInnerAxes
            );
            this.bottomInnerAxesLayoutStrategy.updateAreaSize(
              this.chartLayoutState,
              e
            );
          }
          groupAxesByLayoutStrategy() {
            this.axesGroupedByLayoutStrategy.clear();
            const {
                topInnerAxes: e,
                bottomInnerAxes: t,
                leftInnerAxes: r,
                rightInnerAxes: i,
                topOuterAxes: o,
                bottomOuterAxes: s,
                leftOuterAxes: n,
                rightOuterAxes: l,
              } = this.axesGroupedByLayoutStrategy,
              d = (d) => {
                d.forEach((d) => {
                  const { axisAlignment: h, isInnerAxis: u, isVisible: c } = d;
                  if (u)
                    switch (h) {
                      case a.EAxisAlignment.Top:
                        e.push(d);
                        break;
                      case a.EAxisAlignment.Bottom:
                        t.push(d);
                        break;
                      case a.EAxisAlignment.Left:
                        r.push(d);
                        break;
                      case a.EAxisAlignment.Right:
                        i.push(d);
                    }
                  else
                    switch (h) {
                      case a.EAxisAlignment.Top:
                        o.push(d);
                        break;
                      case a.EAxisAlignment.Bottom:
                        s.push(d);
                        break;
                      case a.EAxisAlignment.Left:
                        n.push(d);
                        break;
                      case a.EAxisAlignment.Right:
                        l.push(d);
                    }
                });
              };
            d(this.sciChartSurface.xAxes.asArray()),
              d(this.sciChartSurface.yAxes.asArray());
          }
          layoutChartCenter(e, t, r, i) {
            this.setSeriesViewRect(e, t, r, i),
              (this.sciChartSurface.annotationUnderlaySurfaceViewRect =
                o.Rect.createWithCoords(e, t, r, i)),
              (this.sciChartSurface.annotationOverlaySurfaceViewRect =
                o.Rect.createWithCoords(e, t, r, i)),
              (this.sciChartSurface.chartModifierSurfaceViewRect =
                o.Rect.createWithCoords(e, t, r, i));
          }
          setSeriesViewRect(e, t, r, i) {
            const { seriesViewRect: a } = this.sciChartSurface,
              s = o.Rect.createWithCoords(e, t, r, i);
            (a && o.Rect.isEqual(a, s)) ||
              this.sciChartSurface.setSeriesViewRect(s);
          }
          createStrategy(e, t) {
            return e && e.type !== t.type
              ? "measureAxes" in e
                ? e
                : e.type === l.ELayoutStrategyType.Custom
                ? (0, i.createType)(
                    s.EBaseType.LayoutStrategy,
                    e.customType,
                    void 0,
                    e.options
                  )
                : (0, i.createType)(
                    s.EBaseType.LayoutStrategy,
                    e.type,
                    void 0,
                    e.options
                  )
              : t;
          }
          resetAxes(e) {
            e.length > 0 && (e[0].isPrimaryAxis = !0);
          }
        };
      },
      20639: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LayoutStrategyAxes = void 0),
          (t.LayoutStrategyAxes = class {
            constructor() {
              (this.topInnerAxes = []),
                (this.bottomInnerAxes = []),
                (this.leftInnerAxes = []),
                (this.rightInnerAxes = []),
                (this.topOuterAxes = []),
                (this.bottomOuterAxes = []),
                (this.leftOuterAxes = []),
                (this.rightOuterAxes = []);
            }
            clear() {
              (this.topInnerAxes = []),
                (this.bottomInnerAxes = []),
                (this.leftInnerAxes = []),
                (this.rightInnerAxes = []),
                (this.topOuterAxes = []),
                (this.bottomOuterAxes = []),
                (this.leftOuterAxes = []),
                (this.rightOuterAxes = []);
            }
          });
      },
      83638: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LeftAlignedInnerAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(93326);
        class s extends a.BaseCenteredAxisLayoutStrategy {
          constructor(e) {
            super(e),
              (this.type = i.ELayoutStrategyType.LeftInner),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsRightStrategy);
          }
          measureAxes(e, t, r) {
            this.sciChartSurface = e;
            let i = 0;
            return (
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (i += (0, o.getVerticalAxisRequiredSize)(e.axisLayoutState));
              }),
              i
            );
          }
          updateAreaSize(e, t) {
            e.leftInnerAreaSize = t;
          }
          layoutAxes(e, t, r, i, a) {
            var s;
            if (
              (a.forEach((e) => {
                (e.axisLength = void 0), (e.offset = 0);
              }),
              0 === a.length)
            )
              return;
            let n = e;
            if (void 0 !== this.axisPosition) {
              const e =
                null !==
                  (s = this.sciChartSurface.getXAxisById(
                    this.orthogonalAxisId
                  )) && void 0 !== s
                  ? s
                  : this.sciChartSurface.getDefaultXAxis();
              if (!e || !e.isHorizontalAxis)
                throw new Error(
                  "orthogonalAxisId should be a valid id of horizontal axis on the surface!"
                );
              const t = e.getCurrentCoordinateCalculator();
              n =
                (0, o.getCoordinateWithCoordinateMode)(
                  this.axisPosition,
                  t,
                  this.coordinateMode
                ) + e.parentSurface.seriesViewRect.left;
            }
            this.layoutAxesFromLeftToRight(n, t, r, i, a);
          }
        }
        t.LeftAlignedInnerAxisLayoutStrategy = s;
      },
      6153: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LeftAlignedOuterAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(21843);
        class s extends a.BaseAxisLayoutStrategy {
          constructor() {
            super(),
              (this.type = i.ELayoutStrategyType.LeftOuter),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsLeftStrategy);
          }
          measureAxes(e, t, r) {
            var i, a;
            let s =
              null !==
                (a =
                  null === (i = e.adjustedPadding) || void 0 === i
                    ? void 0
                    : i.left) && void 0 !== a
                ? a
                : 0;
            return (
              (s += e.leftViewportBorder + e.leftCanvasBorder),
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (s += (0, o.getVerticalAxisRequiredSize)(e.axisLayoutState)),
                  this.updateTopAndBottomChartLayoutState(
                    t,
                    e.axisLayoutState.additionalTopSize,
                    e.axisLayoutState.additionalBottomSize
                  );
              }),
              s
            );
          }
          updateAreaSize(e, t) {
            e.leftOuterAreaSize = t;
          }
          layoutAxes(e, t, r, i, o) {
            o.forEach((e) => {
              (e.axisLength = void 0), (e.offset = 0);
            }),
              this.layoutAxesFromRightToLeft(e, t, r, i, o);
          }
        }
        t.LeftAlignedOuterAxisLayoutStrategy = s;
      },
      55173: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(73785),
          a = r(5100),
          s = r(6153);
        class n extends s.LeftAlignedOuterAxisLayoutStrategy {
          constructor() {
            super(...arguments),
              (this.type = o.ELayoutStrategyType.LeftStacked),
              (this.isStacked = !0);
          }
          measureAxes(e, t, r) {
            var i;
            let o = 0;
            r.forEach((e) => {
              e.measure(), this.updateAxisLayoutState(e);
              const t = (0, a.getVerticalAxisRequiredSize)(e.axisLayoutState);
              o = t > o ? t : o;
            });
            const [s] = r,
              n = r[r.length - 1];
            this.updateTopAndBottomChartLayoutState(
              t,
              null == s ? void 0 : s.axisLayoutState.additionalTopSize,
              null == n ? void 0 : n.axisLayoutState.additionalBottomSize
            );
            const {
              leftViewportBorder: l,
              leftCanvasBorder: d,
              adjustedPadding: h,
            } = e;
            return (
              (o +=
                l +
                d +
                (null !== (i = null == h ? void 0 : h.left) && void 0 !== i
                  ? i
                  : 0)),
              o
            );
          }
          layoutAxes(e, t, r, o, s) {
            const n = o - t,
              [l] = s,
              d = s[s.length - 1],
              h = s.filter((e) => void 0 !== e.stackedAxisLength),
              u = s.reduce(
                (e, t) =>
                  e -
                  t.axisLayoutState.additionalBottomSize -
                  t.axisLayoutState.additionalTopSize,
                n +
                  (null == l ? void 0 : l.axisLayoutState.additionalTopSize) +
                  (null == d ? void 0 : d.axisLayoutState.additionalBottomSize)
              ),
              c = h.reduce(
                (e, t) => e + this.calculateTotalAxisHeight(t, u),
                0
              ),
              p =
                n +
                (null == l ? void 0 : l.axisLayoutState.additionalTopSize) +
                (null == d ? void 0 : d.axisLayoutState.additionalBottomSize) -
                c;
            if (p < 0)
              throw new Error(
                `Left stacked axes with defined size total ${c} pixels which is ${-p} more than the space available`
              );
            const g = p / (s.length - h.length);
            let y =
              t - (null == l ? void 0 : l.axisLayoutState.additionalTopSize);
            s.forEach((e) => {
              const {
                  axisSize: o,
                  additionalRightSize: s,
                  additionalBottomSize: n,
                  additionalTopSize: l,
                } = e.axisLayoutState,
                d = r - s,
                h = d - o,
                c =
                  void 0 !== e.stackedAxisLength
                    ? this.calculateTotalAxisHeight(e, u)
                    : g,
                p = y + c - n;
              (y += l),
                (e.offset = y - t),
                (e.axisLength = p - y),
                (e.isPrimaryAxis = !0),
                (e.viewRect = i.Rect.createWithCoords(h, y, d, p)),
                (y = p + n),
                (0, a.layoutAxisParts)(e, this.layoutAxisPartsStrategy);
            });
          }
        }
        t.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy = n;
      },
      1908: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AngularAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(73785),
          a = r(19238),
          s = r(10572),
          n = 2 * Math.PI,
          l = Math.PI / 2;
        class d extends a.BasePolarAxisLayoutStrategy {
          constructor() {
            super(...arguments), (this.type = o.ELayoutStrategyType.TopOuter);
          }
          measureAxes(e, t, r) {
            if (!r || 0 === r.length) return 0;
            const i = r[0].isXAxis ? e.yAxes.get(0) : e.xAxes.get(0),
              o = r[0].startAngle,
              a = r[0].totalAngle,
              {
                rightScale: s,
                topScale: n,
                leftScale: l,
                bottomScale: d,
              } = this.partialArcLayout(i.innerRadius, o, a);
            return (
              r.forEach((e) => {
                const r = e;
                if (o !== r.startAngle || a !== r.totalAngle)
                  throw new Error(
                    "AngularAxisLayoutStrategy assumes all angular axes have the same startAngle and totalAngle.  To vary this use StackedAngularAxisLayoutStrategy."
                  );
                e.measure();
                const {
                  axisRenderer: i,
                  axisLayoutState: h,
                  axisBorder: u,
                } = r;
                h.clear();
                const c = u.borderBottom + u.borderTop,
                  p = 0 + i.desiredHeight + c;
                h.axisSize = p;
                const g = u.borderLeft + u.borderRight,
                  y = 0 + i.desiredWidth + g;
                (h.leftScale = l),
                  (h.rightScale = s),
                  (h.topScale = n),
                  (h.bottomScale = d),
                  r.isAngular &&
                    ((t.topOuterAreaSize += p),
                    (t.bottomOuterAreaSize += p),
                    (t.leftOuterAreaSize += y),
                    (t.rightOuterAreaSize += y));
              }),
              0
            );
          }
          layoutAxes(e, t, r, o, a) {
            if (!a || 0 === a.length) return;
            const s = a[0],
              {
                leftScale: n,
                rightScale: l,
                topScale: d,
                bottomScale: h,
                axisSize: u,
              } = s.axisLayoutState,
              c = l - n,
              p = c / (d - h),
              g = o - t,
              y = r - e,
              f = y / g,
              v = f > p ? g * p : y,
              m = f > p ? g : y / p;
            let S = v / c;
            const P = e + (y - v) / 2 - (v * n) / (l - n),
              C = t + (g - m) / 2 + m * (1 + h / (d - h));
            a.forEach((e) => {
              (e.axisLength = e.totalAngle), (e.offset = 0);
              const {
                axisLayoutState: { axisSize: t },
                axisRenderer: r,
                xCenterOffset: o,
                yCenterOffset: a,
              } = e;
              (e.viewRect = i.Rect.create(P + o, C + a, S, S + t)),
                r.layout(e.viewRect),
                (S += t);
            });
          }
          partialArcLayout(e, t, r) {
            let i = 1,
              o = 1,
              a = -1,
              d = -1;
            if (r < n) {
              const h = s.labelHelper.normalizeAngle(t),
                u = h + r,
                c = Math.cos(h),
                p = Math.cos(u),
                g = Math.sin(h),
                y = Math.sin(u);
              0 === h || n <= u || (i = Math.max(c, p, c * e, p * e)),
                (h <= Math.PI && Math.PI <= u) ||
                  3 * Math.PI <= u ||
                  (a = Math.min(c, p, c * e, p * e)),
                (h <= l && l <= u) ||
                  n + l <= u ||
                  (o = Math.max(g, y, g * e, y * e)),
                (h <= 3 * l && 3 * l <= u) ||
                  n + 3 * l <= u ||
                  (d = Math.min(g, y, g * e, y * e));
            }
            return { rightScale: i, leftScale: a, topScale: o, bottomScale: d };
          }
        }
        t.AngularAxisLayoutStrategy = d;
      },
      19238: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePolarAxisLayoutStrategy = void 0);
        const i = r(21843);
        class o extends i.BaseAxisLayoutStrategy {
          updateAreaSize(e, t) {}
        }
        t.BasePolarAxisLayoutStrategy = o;
      },
      24696: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarLayoutManager = void 0);
        const i = r(87459),
          o = r(883),
          a = r(1908),
          s = r(45481),
          n = r(57230);
        class l extends s.LayoutManager {
          constructor() {
            super(...arguments),
              (this.type = o.ELayoutManagerType.Polar),
              (this.angularOuterAxesLayoutStrategyProperty =
                new a.AngularAxisLayoutStrategy()),
              (this.angularInnerAxesLayoutStrategyProperty =
                new a.AngularAxisLayoutStrategy()),
              (this.radialOuterAxesLayoutStrategyProperty =
                new n.RadialAxisLayoutStrategy()),
              (this.radialInnerAxesLayoutStrategyProperty =
                new n.RadialAxisLayoutStrategy());
          }
          get angularOuterAxesLayoutStrategy() {
            return this.angularOuterAxesLayoutStrategyProperty;
          }
          set angularOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.angularOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.angularOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(this.axesGroupedByLayoutStrategy.topOuterAxes)),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get angularInnerAxesLayoutStrategy() {
            return this.angularInnerAxesLayoutStrategyProperty;
          }
          set angularInnerAxesLayoutStrategy(e) {
            var t;
            const r = this.angularInnerAxesLayoutStrategyProperty;
            r !== e &&
              ((this.angularInnerAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(this.axesGroupedByLayoutStrategy.topInnerAxes)),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get radialOuterAxesLayoutStrategy() {
            return this.radialOuterAxesLayoutStrategyProperty;
          }
          set radialOuterAxesLayoutStrategy(e) {
            var t;
            const r = this.radialOuterAxesLayoutStrategyProperty;
            r !== e &&
              ((this.radialOuterAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(
                  this.axesGroupedByLayoutStrategy.rightOuterAxes
                )),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          get radialInnerAxesLayoutStrategy() {
            return this.radialInnerAxesLayoutStrategyProperty;
          }
          set radialInnerAxesLayoutStrategy(e) {
            var t;
            const r = this.radialInnerAxesLayoutStrategyProperty;
            r !== e &&
              ((this.radialInnerAxesLayoutStrategyProperty = e),
              r.isStacked &&
                !e.isStacked &&
                (this.groupAxesByLayoutStrategy(),
                this.resetAxes(
                  this.axesGroupedByLayoutStrategy.rightInnerAxes
                )),
              null === (t = this.sciChartSurface) ||
                void 0 === t ||
                t.invalidateElement());
          }
          getAxisLayoutStrategy(e) {
            if (!e.isPolarAxis)
              throw new Error(
                "Cannot get Polar LayoutStrategy for a non-polar axis"
              );
            return e.isAngular
              ? e.isInnerAxis
                ? this.angularInnerAxesLayoutStrategy
                : this.angularOuterAxesLayoutStrategy
              : e.isInnerAxis
              ? this.radialInnerAxesLayoutStrategy
              : this.radialOuterAxesLayoutStrategy;
          }
          layoutChart(e, t) {
            var r, o, a, s, n, l, d, h, u, c, p, g;
            this.groupAxesByLayoutStrategy();
            const y =
                null !== (r = null == t ? void 0 : t.right) && void 0 !== r
                  ? r
                  : 0,
              f =
                null !== (o = null == t ? void 0 : t.left) && void 0 !== o
                  ? o
                  : 0,
              v =
                null !== (a = null == t ? void 0 : t.top) && void 0 !== a
                  ? a
                  : 0,
              m =
                null !== (s = null == t ? void 0 : t.bottom) && void 0 !== s
                  ? s
                  : 0,
              S = e.width - f - y,
              P = e.height - v - m,
              C = this.sciChartSurface.adjustedPadding;
            (this.chartLayoutState.leftOuterAreaSize =
              (null !== (n = null == C ? void 0 : C.left) && void 0 !== n
                ? n
                : 0) +
              this.sciChartSurface.leftViewportBorder +
              this.sciChartSurface.leftCanvasBorder),
              (this.chartLayoutState.rightOuterAreaSize =
                (null !== (l = null == C ? void 0 : C.right) && void 0 !== l
                  ? l
                  : 0) +
                this.sciChartSurface.rightViewportBorder +
                this.sciChartSurface.rightCanvasBorder),
              (this.chartLayoutState.topOuterAreaSize =
                (null !== (d = null == C ? void 0 : C.top) && void 0 !== d
                  ? d
                  : 0) +
                this.sciChartSurface.topViewportBorder +
                this.sciChartSurface.topCanvasBorder),
              (this.chartLayoutState.bottomOuterAreaSize =
                (null !== (h = null == C ? void 0 : C.bottom) && void 0 !== h
                  ? h
                  : 0) +
                this.sciChartSurface.bottomViewportBorder +
                this.sciChartSurface.bottomCanvasBorder),
              this.setSeriesViewRect(
                this.chartLayoutState.leftOuterAreaSize,
                this.chartLayoutState.topOuterAreaSize,
                e.width - this.chartLayoutState.rightOuterAreaSize,
                e.height - this.chartLayoutState.bottomOuterAreaSize
              );
            try {
              this.angularOuterAxesLayoutStrategy.measureAxes(
                this.sciChartSurface,
                this.chartLayoutState,
                this.axesGroupedByLayoutStrategy.topOuterAxes
              ),
                this.angularInnerAxesLayoutStrategy.measureAxes(
                  this.sciChartSurface,
                  this.chartLayoutState,
                  this.axesGroupedByLayoutStrategy.topInnerAxes
                ),
                this.radialOuterAxesLayoutStrategy.measureAxes(
                  this.sciChartSurface,
                  this.chartLayoutState,
                  this.axesGroupedByLayoutStrategy.rightOuterAxes
                ),
                this.radialInnerAxesLayoutStrategy.measureAxes(
                  this.sciChartSurface,
                  this.chartLayoutState,
                  this.axesGroupedByLayoutStrategy.rightInnerAxes
                );
              const e =
                  S -
                  this.chartLayoutState.leftOuterAreaSize -
                  this.chartLayoutState.rightOuterAreaSize,
                t =
                  P -
                  this.chartLayoutState.topOuterAreaSize -
                  this.chartLayoutState.bottomOuterAreaSize,
                r = f,
                o = r + this.chartLayoutState.leftOuterAreaSize,
                a = o + (e < 10 ? 10 : e),
                s = a + this.chartLayoutState.rightOuterAreaSize,
                n = v,
                l = n + this.chartLayoutState.topOuterAreaSize,
                d = l + (t < 10 ? 10 : t),
                h = d + this.chartLayoutState.bottomOuterAreaSize;
              (this.sciChartSurface.annotationUnderlaySurfaceViewRect =
                i.Rect.createWithCoords(r, n, s, h)),
                (this.sciChartSurface.annotationOverlaySurfaceViewRect =
                  i.Rect.createWithCoords(r, n, s, h)),
                (this.sciChartSurface.chartModifierSurfaceViewRect =
                  i.Rect.createWithCoords(r, n, s, h)),
                this.angularOuterAxesLayoutStrategy.layoutAxes(
                  o,
                  l,
                  a,
                  d,
                  this.axesGroupedByLayoutStrategy.topOuterAxes
                );
              const y =
                null !==
                  (g =
                    null !==
                      (c =
                        null ===
                          (u =
                            this.axesGroupedByLayoutStrategy
                              .rightOuterAxes[0]) || void 0 === u
                          ? void 0
                          : u.offset) && void 0 !== c
                      ? c
                      : null ===
                          (p =
                            this.axesGroupedByLayoutStrategy
                              .rightInnerAxes[0]) || void 0 === p
                      ? void 0
                      : p.offset) && void 0 !== g
                  ? g
                  : 0;
              this.angularInnerAxesLayoutStrategy.layoutAxes(
                o + y,
                l + y,
                a - y,
                d - y,
                this.axesGroupedByLayoutStrategy.topInnerAxes
              );
              let m = i.Rect.createZero();
              return (
                this.axesGroupedByLayoutStrategy.topOuterAxes.length > 0
                  ? (m =
                      this.axesGroupedByLayoutStrategy.topOuterAxes[0].viewRect)
                  : this.axesGroupedByLayoutStrategy.topInnerAxes.length > 0 &&
                    (m =
                      this.axesGroupedByLayoutStrategy.topInnerAxes[0]
                        .viewRect),
                this.radialOuterAxesLayoutStrategy.layoutAxes(
                  m.left,
                  m.top,
                  m.width,
                  m.height,
                  this.axesGroupedByLayoutStrategy.rightOuterAxes
                ),
                this.radialInnerAxesLayoutStrategy.layoutAxes(
                  m.left,
                  m.top,
                  m.width,
                  m.height,
                  this.axesGroupedByLayoutStrategy.rightInnerAxes
                ),
                this.sciChartSurface.seriesViewRect
              );
            } finally {
              this.chartLayoutState.clear();
            }
          }
          groupAxesByLayoutStrategy() {
            this.axesGroupedByLayoutStrategy.clear();
            const {
                topOuterAxes: e,
                topInnerAxes: t,
                rightOuterAxes: r,
                rightInnerAxes: i,
              } = this.axesGroupedByLayoutStrategy,
              o = (o) => {
                o.forEach((o) => {
                  if (o.isPolarAxis) {
                    const { isAngular: a } = o;
                    a
                      ? o.isInnerAxis
                        ? t.push(o)
                        : e.push(o)
                      : o.isInnerAxis
                      ? i.push(o)
                      : r.push(o);
                  }
                });
              };
            o(this.sciChartSurface.xAxes.asArray()),
              o(this.sciChartSurface.yAxes.asArray());
          }
        }
        t.PolarLayoutManager = l;
      },
      57230: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RadialAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(19238);
        class a extends o.BasePolarAxisLayoutStrategy {
          measureAxes(e, t, r) {
            return (
              r.forEach((e) => {
                e.measure();
              }),
              0
            );
          }
          layoutAxes(e, t, r, o, a) {
            a.forEach((o) => {
              (o.axisLength = r),
                (o.offset = 0),
                (o.viewRect = i.Rect.create(e, t, r, 1));
            });
          }
        }
        t.RadialAxisLayoutStrategy = a;
      },
      24478: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RightAlignedInnerAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(93326);
        class s extends a.BaseCenteredAxisLayoutStrategy {
          constructor(e) {
            super(e),
              (this.type = i.ELayoutStrategyType.RightInner),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsLeftStrategy);
          }
          measureAxes(e, t, r) {
            this.sciChartSurface = e;
            let i = 0;
            return (
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (i += (0, o.getVerticalAxisRequiredSize)(e.axisLayoutState));
              }),
              i
            );
          }
          updateAreaSize(e, t) {
            e.rightInnerAreaSize = Math.max(e.rightInnerAreaSize, t);
          }
          layoutAxes(e, t, r, i, a) {
            var s;
            if (
              (a.forEach((e) => {
                (e.axisLength = void 0), (e.offset = 0);
              }),
              0 === a.length)
            )
              return;
            let n = r;
            if (void 0 !== this.axisPosition) {
              const e =
                null !==
                  (s = this.sciChartSurface.getXAxisById(
                    this.orthogonalAxisId
                  )) && void 0 !== s
                  ? s
                  : this.sciChartSurface.getDefaultXAxis();
              if (!e || !e.isHorizontalAxis)
                throw new Error(
                  "orthogonalAxisId should be a valid id of horizontal axis on the surface!"
                );
              const t = e.getCurrentCoordinateCalculator();
              n =
                (0, o.getCoordinateWithCoordinateMode)(
                  this.axisPosition,
                  t,
                  this.coordinateMode
                ) + e.parentSurface.seriesViewRect.left;
            }
            this.layoutAxesFromRightToLeft(e, t, n, i, a);
          }
        }
        t.RightAlignedInnerAxisLayoutStrategy = s;
      },
      27282: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RightAlignedOuterAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(21843);
        class s extends a.BaseAxisLayoutStrategy {
          constructor() {
            super(),
              (this.type = i.ELayoutStrategyType.RightOuter),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsRightStrategy);
          }
          measureAxes(e, t, r) {
            var i, a;
            let s =
              null !==
                (a =
                  null === (i = e.adjustedPadding) || void 0 === i
                    ? void 0
                    : i.right) && void 0 !== a
                ? a
                : 0;
            return (
              (s += e.rightViewportBorder + e.rightCanvasBorder),
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (s += (0, o.getVerticalAxisRequiredSize)(e.axisLayoutState)),
                  this.updateTopAndBottomChartLayoutState(
                    t,
                    e.axisLayoutState.additionalTopSize,
                    e.axisLayoutState.additionalBottomSize
                  );
              }),
              s
            );
          }
          updateAreaSize(e, t) {
            e.rightOuterAreaSize = t;
          }
          layoutAxes(e, t, r, i, o) {
            o.forEach((e) => {
              (e.axisLength = void 0), (e.offset = 0);
            }),
              this.layoutAxesFromLeftToRight(e, t, r, i, o);
          }
        }
        t.RightAlignedOuterAxisLayoutStrategy = s;
      },
      12119: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RightAlignedOuterVerticallyStackedAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(73785),
          a = r(5100),
          s = r(27282);
        class n extends s.RightAlignedOuterAxisLayoutStrategy {
          constructor() {
            super(...arguments),
              (this.type = o.ELayoutStrategyType.RightStacked),
              (this.isStacked = !0);
          }
          measureAxes(e, t, r) {
            var i;
            let o = 0;
            r.forEach((e) => {
              e.measure(), this.updateAxisLayoutState(e);
              const t = (0, a.getVerticalAxisRequiredSize)(e.axisLayoutState);
              o = t > o ? t : o;
            });
            const [s] = r,
              n = r[r.length - 1];
            this.updateTopAndBottomChartLayoutState(
              t,
              null == s ? void 0 : s.axisLayoutState.additionalTopSize,
              null == n ? void 0 : n.axisLayoutState.additionalBottomSize
            );
            const {
              rightViewportBorder: l,
              rightCanvasBorder: d,
              adjustedPadding: h,
            } = e;
            return (
              (o +=
                l +
                d +
                (null !== (i = null == h ? void 0 : h.right) && void 0 !== i
                  ? i
                  : 0)),
              o
            );
          }
          layoutAxes(e, t, r, o, s) {
            const n = o - t,
              [l] = s,
              d = s[s.length - 1],
              h = s.filter((e) => e.stackedAxisLength),
              u = s.reduce(
                (e, t) =>
                  e -
                  t.axisLayoutState.additionalBottomSize -
                  t.axisLayoutState.additionalTopSize,
                n +
                  (null == l ? void 0 : l.axisLayoutState.additionalTopSize) +
                  (null == d ? void 0 : d.axisLayoutState.additionalBottomSize)
              ),
              c = h.reduce(
                (e, t) => e + this.calculateTotalAxisHeight(t, u),
                0
              ),
              p =
                n +
                (null == l ? void 0 : l.axisLayoutState.additionalTopSize) +
                (null == d ? void 0 : d.axisLayoutState.additionalBottomSize) -
                c;
            if (p < 0)
              throw new Error(
                `Right stacked axes with defined size total ${c} pixels which is ${-p} more than the space available`
              );
            const g = p / (s.length - h.length);
            let y =
              t - (null == l ? void 0 : l.axisLayoutState.additionalTopSize);
            s.forEach((r) => {
              const {
                  axisSize: o,
                  additionalLeftSize: s,
                  additionalBottomSize: n,
                  additionalTopSize: l,
                } = r.axisLayoutState,
                d = e + s,
                h = d + o,
                c = r.stackedAxisLength
                  ? this.calculateTotalAxisHeight(r, u)
                  : g,
                p = y + c - n;
              (y += l),
                (r.offset = y - t),
                (r.axisLength = p - y),
                (r.isPrimaryAxis = !0),
                (r.viewRect = i.Rect.createWithCoords(d, y, h, p)),
                (y = p + n),
                (0, a.layoutAxisParts)(r, this.layoutAxisPartsStrategy);
            });
          }
        }
        t.RightAlignedOuterVerticallyStackedAxisLayoutStrategy = n;
      },
      66086: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartHorizontalGroup = void 0);
        const i = r(87108),
          o = r(883),
          a = r(45481),
          s = r(8959);
        t.SciChartHorizontalGroup = class {
          constructor() {
            (this.groupTopSize = 0),
              (this.groupBottomSize = 0),
              (this.layoutManagers = []),
              (this.topOuterLayoutSizes = {}),
              (this.bottomOuterLayoutSizes = {});
          }
          addSurfaceToGroup(e) {
            let t = e.layoutManager;
            t.type !== o.ELayoutManagerType.Synchronised
              ? ((t = new s.SynchronizedLayoutManager(void 0, this)),
                (t.bottomInnerAxesLayoutStrategy =
                  e.layoutManager.bottomInnerAxesLayoutStrategy),
                (t.bottomOuterAxesLayoutStrategy =
                  e.layoutManager.bottomOuterAxesLayoutStrategy),
                (t.leftInnerAxesLayoutStrategy =
                  e.layoutManager.leftInnerAxesLayoutStrategy),
                (t.leftOuterAxesLayoutStrategy =
                  e.layoutManager.leftOuterAxesLayoutStrategy),
                (t.rightInnerAxesLayoutStrategy =
                  e.layoutManager.rightInnerAxesLayoutStrategy),
                (t.rightOuterAxesLayoutStrategy =
                  e.layoutManager.rightOuterAxesLayoutStrategy),
                (t.topInnerAxesLayoutStrategy =
                  e.layoutManager.topInnerAxesLayoutStrategy),
                (t.topOuterAxesLayoutStrategy =
                  e.layoutManager.topOuterAxesLayoutStrategy),
                (e.layoutManager = t))
              : (t.horizontalGroup = this),
              this.layoutManagers.push(t),
              e.layoutManager.layoutChart(
                e.renderSurface.viewportSize,
                this.calculateMaxTitleSize()
              ),
              this.synchronizeAxisSizes(),
              e.invalidateElement();
          }
          removeSurface(e) {
            const t = e.layoutManager,
              r = this.layoutManagers.findIndex((e) => e === t);
            if (r < 0)
              throw new Error(`Surface ${e.id} not found in Horizontal Group!`);
            if ((this.layoutManagers.splice(r, 1), t.verticalGroup))
              t.horizontalGroup = void 0;
            else {
              const r = new a.LayoutManager();
              (r.leftInnerAxesLayoutStrategy = t.leftInnerAxesLayoutStrategy),
                (r.leftOuterAxesLayoutStrategy = t.leftOuterAxesLayoutStrategy),
                (r.rightInnerAxesLayoutStrategy =
                  t.rightInnerAxesLayoutStrategy),
                (r.rightOuterAxesLayoutStrategy =
                  t.rightOuterAxesLayoutStrategy),
                (r.bottomInnerAxesLayoutStrategy =
                  t.bottomInnerAxesLayoutStrategy),
                (r.bottomOuterAxesLayoutStrategy =
                  t.bottomOuterAxesLayoutStrategy),
                (r.topInnerAxesLayoutStrategy = t.topInnerAxesLayoutStrategy),
                (r.topOuterAxesLayoutStrategy = t.topOuterAxesLayoutStrategy),
                (e.layoutManager = r);
            }
            e.layoutManager.layoutChart(
              e.renderSurface.viewportSize,
              e.chartTitleRenderer.titleOffset
            ),
              this.onTopSizeChanged(t.id, 0),
              this.onBottomSizeChanged(t.id, 0),
              delete this.topOuterLayoutSizes[t.id],
              delete this.bottomOuterLayoutSizes[t.id],
              this.synchronizeAxisSizes(),
              e.invalidateElement();
          }
          calculateMaxTitleSize() {
            let e = new i.Thickness(0, 0, 0, 0);
            return (
              this.layoutManagers.forEach((t) => {
                const r = t.sciChartSurface.chartTitleRenderer.titleOffset;
                e = i.Thickness.mergeMax(
                  e,
                  new i.Thickness(r.top, 0, r.bottom, 0)
                );
              }),
              e
            );
          }
          synchronizeAxisSizes() {
            this.layoutManagers.forEach((e) => {
              e.trySynchronizeLayouts();
            });
          }
          onTopSizeChanged(e, t) {
            (this.topOuterLayoutSizes[e] = t),
              (this.groupTopSize = n(this.topOuterLayoutSizes));
          }
          onBottomSizeChanged(e, t) {
            (this.bottomOuterLayoutSizes[e] = t),
              (this.groupBottomSize = n(this.bottomOuterLayoutSizes));
          }
        };
        const n = (e) => {
          let t = 0;
          return (
            Object.keys(e).forEach((r) => {
              t = Math.max(t, e[r]);
            }),
            t
          );
        };
      },
      78499: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartVerticalGroup = void 0);
        const i = r(87108),
          o = r(883),
          a = r(45481),
          s = r(8959);
        t.SciChartVerticalGroup = class {
          constructor() {
            (this.groupRightSize = 0),
              (this.groupLeftSize = 0),
              (this.layoutManagers = []),
              (this.leftOuterLayoutSizes = {}),
              (this.rightOuterLayoutSizes = {});
          }
          addSurfaceToGroup(e) {
            let t = e.layoutManager;
            t.type !== o.ELayoutManagerType.Synchronised
              ? ((t = new s.SynchronizedLayoutManager(this)),
                (t.bottomInnerAxesLayoutStrategy =
                  e.layoutManager.bottomInnerAxesLayoutStrategy),
                (t.bottomOuterAxesLayoutStrategy =
                  e.layoutManager.bottomOuterAxesLayoutStrategy),
                (t.leftInnerAxesLayoutStrategy =
                  e.layoutManager.leftInnerAxesLayoutStrategy),
                (t.leftOuterAxesLayoutStrategy =
                  e.layoutManager.leftOuterAxesLayoutStrategy),
                (t.rightInnerAxesLayoutStrategy =
                  e.layoutManager.rightInnerAxesLayoutStrategy),
                (t.rightOuterAxesLayoutStrategy =
                  e.layoutManager.rightOuterAxesLayoutStrategy),
                (t.topInnerAxesLayoutStrategy =
                  e.layoutManager.topInnerAxesLayoutStrategy),
                (t.topOuterAxesLayoutStrategy =
                  e.layoutManager.topOuterAxesLayoutStrategy),
                (e.layoutManager = t))
              : (t.verticalGroup = this),
              this.layoutManagers.push(t),
              e.layoutManager.layoutChart(
                e.renderSurface.viewportSize,
                this.calculateMaxTitleSize()
              ),
              this.synchronizeAxisSizes(),
              e.invalidateElement();
          }
          removeSurface(e) {
            const t = e.layoutManager,
              r = this.layoutManagers.findIndex((e) => e === t);
            if (r < 0)
              throw new Error(`Surface ${e.id} not found in Vertical Group!`);
            if ((this.layoutManagers.splice(r, 1), t.horizontalGroup))
              t.verticalGroup = void 0;
            else {
              const r = new a.LayoutManager();
              (r.bottomInnerAxesLayoutStrategy =
                t.bottomInnerAxesLayoutStrategy),
                (r.bottomOuterAxesLayoutStrategy =
                  t.bottomOuterAxesLayoutStrategy),
                (r.topInnerAxesLayoutStrategy = t.topInnerAxesLayoutStrategy),
                (r.topOuterAxesLayoutStrategy = t.topOuterAxesLayoutStrategy),
                (r.leftInnerAxesLayoutStrategy = t.leftInnerAxesLayoutStrategy),
                (r.leftOuterAxesLayoutStrategy = t.leftOuterAxesLayoutStrategy),
                (r.rightInnerAxesLayoutStrategy =
                  t.rightInnerAxesLayoutStrategy),
                (r.rightOuterAxesLayoutStrategy =
                  t.rightOuterAxesLayoutStrategy),
                (e.layoutManager = r);
            }
            e.layoutManager.layoutChart(
              e.renderSurface.viewportSize,
              e.chartTitleRenderer.titleOffset
            ),
              this.onLeftSizeChanged(t.id, 0),
              this.onRightSizeChanged(t.id, 0),
              delete this.leftOuterLayoutSizes[t.id],
              delete this.rightOuterLayoutSizes[t.id],
              this.synchronizeAxisSizes();
          }
          calculateMaxTitleSize() {
            let e = new i.Thickness(0, 0, 0, 0);
            return (
              this.layoutManagers.forEach((t) => {
                const r = t.sciChartSurface.chartTitleRenderer.titleOffset;
                e = i.Thickness.mergeMax(
                  e,
                  new i.Thickness(0, r.right, 0, r.left)
                );
              }),
              e
            );
          }
          synchronizeAxisSizes() {
            this.layoutManagers.forEach((e) => {
              e.trySynchronizeLayouts();
            });
          }
          onLeftSizeChanged(e, t) {
            (this.leftOuterLayoutSizes[e] = t),
              (this.groupLeftSize = n(this.leftOuterLayoutSizes));
          }
          onRightSizeChanged(e, t) {
            (this.rightOuterLayoutSizes[e] = t),
              (this.groupRightSize = n(this.rightOuterLayoutSizes));
          }
        };
        const n = (e) => {
          let t = 0;
          return (
            Object.keys(e).forEach((r) => {
              t = Math.max(t, e[r]);
            }),
            t
          );
        };
      },
      8959: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SynchronizedLayoutManager = void 0);
        const i = r(883),
          o = r(73538),
          a = r(45481),
          s = r(87108);
        class n extends a.LayoutManager {
          constructor(e, t, r) {
            super(r),
              (this.type = i.ELayoutManagerType.Synchronised),
              (this.id = (0, o.generateGuid)()),
              (this.lastLeftOuterAreaSize = 0),
              (this.lastRightOuterAreaSize = 0),
              (this.lastTopOuterAreaSize = 0),
              (this.lastBottomOuterAreaSize = 0),
              (this.verticalGroup = null != e ? e : void 0),
              (this.horizontalGroup = null != t ? t : void 0);
          }
          layoutChart(e, t) {
            const r = this.sciChartSurface.chartTitleRenderer.titleOffset;
            if (this.verticalGroup && this.horizontalGroup) {
              const i = s.Thickness.mergeMax(
                  this.verticalGroup.calculateMaxTitleSize(),
                  this.horizontalGroup.calculateMaxTitleSize()
                ),
                o = s.Thickness.mergeSubtract(i, r),
                a = s.Thickness.mergeAdd(t, o),
                n = super.layoutChart(e, a);
              return (
                this.verticalGroup.synchronizeAxisSizes(),
                this.horizontalGroup.synchronizeAxisSizes(),
                n
              );
            }
            if (this.verticalGroup) {
              const i = s.Thickness.mergeSubtract(
                  this.verticalGroup.calculateMaxTitleSize(),
                  r
                ),
                o = super.layoutChart(e, s.Thickness.mergeAdd(t, i));
              return this.verticalGroup.synchronizeAxisSizes(), o;
            }
            if (this.horizontalGroup) {
              const i = s.Thickness.mergeSubtract(
                  this.horizontalGroup.calculateMaxTitleSize(),
                  r
                ),
                o = super.layoutChart(e, s.Thickness.mergeAdd(t, i));
              return this.horizontalGroup.synchronizeAxisSizes(), o;
            }
            return super.layoutChart(e, t);
          }
          trySynchronizeLayouts() {
            this.verticalGroup &&
              ((this.lastLeftOuterAreaSize ===
                this.verticalGroup.groupLeftSize &&
                this.lastRightOuterAreaSize ===
                  this.verticalGroup.groupRightSize) ||
                this.sciChartSurface.invalidateElement()),
              this.horizontalGroup &&
                ((this.lastTopOuterAreaSize ===
                  this.horizontalGroup.groupTopSize &&
                  this.lastBottomOuterAreaSize ===
                    this.horizontalGroup.groupBottomSize) ||
                  this.sciChartSurface.invalidateElement());
          }
          measureLeftOuterAxes() {
            if ((super.measureLeftOuterAxes(), !this.verticalGroup))
              return void super.measureLeftOuterAxes();
            this.verticalGroup.onLeftSizeChanged(
              this.id,
              this.chartLayoutState.leftOuterAreaSize
            );
            const e = this.chartLayoutState.leftOuterAreaSize,
              t = this.verticalGroup.groupLeftSize,
              r = Math.abs(e) > Math.abs(t) ? e : t;
            if (this.axesGroupedByLayoutStrategy.leftOuterAxes.length > 0) {
              const e =
                  this.axesGroupedByLayoutStrategy.leftOuterAxes[
                    this.axesGroupedByLayoutStrategy.leftOuterAxes.length - 1
                  ],
                t =
                  this.chartLayoutState.leftOuterAreaSize -
                  e.axisLayoutState.axisSize;
              e.axisLayoutState.axisSize = r - t;
            }
            (this.chartLayoutState.leftOuterAreaSize = r),
              (this.lastLeftOuterAreaSize = r);
          }
          measureRightOuterAxes() {
            if ((super.measureRightOuterAxes(), !this.verticalGroup))
              return void super.measureRightOuterAxes();
            this.verticalGroup.onRightSizeChanged(
              this.id,
              this.chartLayoutState.rightOuterAreaSize
            );
            const e = this.chartLayoutState.rightOuterAreaSize,
              t = this.verticalGroup.groupRightSize,
              r = Math.abs(e) > Math.abs(t) ? e : t;
            if (this.axesGroupedByLayoutStrategy.rightOuterAxes.length > 0) {
              const e =
                  this.axesGroupedByLayoutStrategy.rightOuterAxes[
                    this.axesGroupedByLayoutStrategy.rightOuterAxes.length - 1
                  ],
                t =
                  this.chartLayoutState.rightOuterAreaSize -
                  e.axisLayoutState.axisSize;
              e.axisLayoutState.axisSize = r - t;
            }
            (this.chartLayoutState.rightOuterAreaSize = r),
              (this.lastRightOuterAreaSize = r);
          }
          measureTopOuterAxes() {
            if ((super.measureTopOuterAxes(), !this.horizontalGroup)) return;
            this.horizontalGroup.onTopSizeChanged(
              this.id,
              this.chartLayoutState.topOuterAreaSize
            );
            const e = this.chartLayoutState.topOuterAreaSize,
              t = this.horizontalGroup.groupTopSize,
              r = Math.abs(e) > Math.abs(t) ? e : t;
            if (this.axesGroupedByLayoutStrategy.topOuterAxes.length > 0) {
              const e =
                  this.axesGroupedByLayoutStrategy.topOuterAxes[
                    this.axesGroupedByLayoutStrategy.topOuterAxes.length - 1
                  ],
                t =
                  this.chartLayoutState.topOuterAreaSize -
                  e.axisLayoutState.axisSize;
              e.axisLayoutState.axisSize = r - t;
            }
            (this.chartLayoutState.topOuterAreaSize = r),
              (this.lastTopOuterAreaSize = r);
          }
          measureBottomOuterAxes() {
            if ((super.measureBottomOuterAxes(), !this.horizontalGroup)) return;
            this.horizontalGroup.onBottomSizeChanged(
              this.id,
              this.chartLayoutState.bottomOuterAreaSize
            );
            const e = this.chartLayoutState.bottomOuterAreaSize,
              t = this.horizontalGroup.groupBottomSize,
              r = Math.abs(e) > Math.abs(t) ? e : t;
            if (this.axesGroupedByLayoutStrategy.bottomOuterAxes.length > 0) {
              const e =
                  this.axesGroupedByLayoutStrategy.bottomOuterAxes[
                    this.axesGroupedByLayoutStrategy.bottomOuterAxes.length - 1
                  ],
                t =
                  this.chartLayoutState.bottomOuterAreaSize -
                  e.axisLayoutState.axisSize;
              e.axisLayoutState.axisSize = r - t;
            }
            (this.chartLayoutState.bottomOuterAreaSize = r),
              (this.lastBottomOuterAreaSize = r);
          }
        }
        t.SynchronizedLayoutManager = n;
      },
      27194: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TopAlignedInnerAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(93326);
        class s extends a.BaseCenteredAxisLayoutStrategy {
          constructor(e) {
            super(e),
              (this.type = i.ELayoutStrategyType.TopInner),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsBottomStrategy);
          }
          measureAxes(e, t, r) {
            this.sciChartSurface = e;
            let i = 0;
            return (
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (i += (0, o.getHorizontalAxisRequiredSize)(
                    e.axisLayoutState
                  ));
              }),
              i
            );
          }
          updateAreaSize(e, t) {
            e.topInnerAreaSize = t;
          }
          layoutAxes(e, t, r, i, a) {
            var s;
            if (
              (a.forEach((e) => {
                (e.axisLength = void 0), (e.offset = 0);
              }),
              0 === a.length)
            )
              return;
            let n = t;
            if (void 0 !== this.axisPosition) {
              const e =
                null !==
                  (s = this.sciChartSurface.getYAxisById(
                    this.orthogonalAxisId
                  )) && void 0 !== s
                  ? s
                  : this.sciChartSurface.getDefaultYAxis();
              if (!e || e.isHorizontalAxis)
                throw new Error(
                  "orthogonalAxisId should be a valid id of vertical axis on the surface!"
                );
              const t = e.getCurrentCoordinateCalculator();
              n =
                (0, o.getCoordinateWithCoordinateMode)(
                  this.axisPosition,
                  t,
                  this.coordinateMode
                ) + e.viewRect.top;
            }
            this.layoutAxesFromTopToBottom(e, n, r, i, a);
          }
        }
        t.TopAlignedInnerAxisLayoutStrategy = s;
      },
      73145: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TopAlignedOuterAxisLayoutStrategy = void 0);
        const i = r(73785),
          o = r(5100),
          a = r(21843);
        class s extends a.BaseAxisLayoutStrategy {
          constructor() {
            super(),
              (this.type = i.ELayoutStrategyType.TopOuter),
              (this.layoutAxisPartsStrategy = o.layoutAxisPartsTopStrategy);
          }
          measureAxes(e, t, r) {
            var i, a;
            let s =
              null !==
                (a =
                  null === (i = e.adjustedPadding) || void 0 === i
                    ? void 0
                    : i.top) && void 0 !== a
                ? a
                : 0;
            return (
              (s += e.topViewportBorder + e.topCanvasBorder),
              r.forEach((e) => {
                e.measure(),
                  this.updateAxisLayoutState(e),
                  (s += (0, o.getHorizontalAxisRequiredSize)(
                    e.axisLayoutState
                  )),
                  this.updateLeftAndRightChartLayoutState(
                    t,
                    e.axisLayoutState.additionalLeftSize,
                    e.axisLayoutState.additionalRightSize
                  );
              }),
              s
            );
          }
          updateAreaSize(e, t) {
            e.topOuterAreaSize = t;
          }
          layoutAxes(e, t, r, i, o) {
            o.forEach((e) => {
              (e.axisLength = void 0), (e.offset = 0);
            }),
              this.layoutAxesFromBottomToTop(e, t, r, i, o);
          }
        }
        t.TopAlignedOuterAxisLayoutStrategy = s;
      },
      55696: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy = void 0);
        const i = r(87459),
          o = r(73785),
          a = r(5100),
          s = r(73145);
        class n extends s.TopAlignedOuterAxisLayoutStrategy {
          constructor() {
            super(...arguments),
              (this.type = o.ELayoutStrategyType.TopStacked),
              (this.isStacked = !0);
          }
          measureAxes(e, t, r) {
            var i;
            let o = 0;
            r.forEach((e) => {
              e.measure(), this.updateAxisLayoutState(e);
              const t = (0, a.getHorizontalAxisRequiredSize)(e.axisLayoutState);
              o = t > o ? t : o;
            });
            const [s] = r,
              n = r[r.length - 1];
            this.updateLeftAndRightChartLayoutState(
              t,
              null == s ? void 0 : s.axisLayoutState.additionalLeftSize,
              null == n ? void 0 : n.axisLayoutState.additionalRightSize
            );
            const {
              topViewportBorder: l,
              topCanvasBorder: d,
              adjustedPadding: h,
            } = e;
            return (
              (o +=
                l +
                d +
                (null !== (i = null == h ? void 0 : h.top) && void 0 !== i
                  ? i
                  : 0)),
              o
            );
          }
          layoutAxes(e, t, r, o, s) {
            const n = r - e,
              [l] = s,
              d = s[s.length - 1],
              h = s.filter((e) => e.stackedAxisLength),
              u = s.reduce(
                (e, t) =>
                  e -
                  t.axisLayoutState.additionalBottomSize -
                  t.axisLayoutState.additionalTopSize,
                n +
                  (null == l ? void 0 : l.axisLayoutState.additionalLeftSize) +
                  (null == d ? void 0 : d.axisLayoutState.additionalRightSize)
              ),
              c = h.reduce((e, t) => e + this.calculateTotalAxisWidth(t, u), 0),
              p =
                n +
                (null == l ? void 0 : l.axisLayoutState.additionalLeftSize) +
                (null == d ? void 0 : d.axisLayoutState.additionalRightSize) -
                c;
            if (p < 0)
              throw new Error(
                `Top stacked axes with defined size total ${c} pixels which is ${-p} more than the space available`
              );
            const g = p / (s.length - h.length);
            let y =
              e - (null == l ? void 0 : l.axisLayoutState.additionalLeftSize);
            s.forEach((t) => {
              const {
                  axisSize: r,
                  additionalLeftSize: s,
                  additionalRightSize: n,
                  additionalBottomSize: l,
                } = t.axisLayoutState,
                d = o - l,
                h = d - r,
                c = t.stackedAxisLength
                  ? this.calculateTotalAxisWidth(t, u)
                  : g,
                p = y + c - n;
              (y += s),
                (t.offset = y - e),
                (t.axisLength = p - y),
                (t.isPrimaryAxis = !0),
                (t.viewRect = i.Rect.createWithCoords(y, h, p, d)),
                (y = p + n),
                (0, a.layoutAxisParts)(t, this.layoutAxisPartsStrategy);
            });
          }
        }
        t.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy = n;
      },
      73105: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).AXIS_POSITION_COORDINATE =
            "AXIS_POSITION_COORDINATE"),
          (r.COORDINATE_MODE = "COORDINATE_MODE"),
          (r.VERTICAL_AXIS_ID = "VERTICAL_AXIS_ID");
      },
      24933: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getWindowedYRange = t.getIndicesRange = t.BaseDataSeries = void 0);
        const i = r(45921),
          o = r(55023),
          a = r(56744),
          s = r(3214),
          n = r(23866),
          l = r(98140),
          d = r(11043),
          h = r(65885),
          u = r(26361),
          c = r(54624),
          p = r(9073),
          g = r(45215),
          y = r(27699),
          f = r(46544),
          v = r(73538),
          m = r(72934),
          S = r(4748),
          P = r(16602),
          C = r(33435),
          b = r(84366),
          x = r(51885),
          A = r(33906),
          T = r(33070);
        class E extends o.DeletableEntity {
          constructor(e, t) {
            var r, o, a, l, h, u, p, g, y, f;
            if (
              (super(),
              (this.dataChanged = new s.EventHandler()),
              (this.dataDistributionCalculator =
                new C.DataDistributionCalculator()),
              (this.minXSpacing = 0),
              (this.yInitialAnimationValuesArray = []),
              (this.yFinalAnimationValuesArray = []),
              (this.yValuesArray = []),
              (this.arrayCount = 1),
              (this.doubleVectorProvider = new b.DoubleVectorProvider()),
              (this.isSortedProperty = void 0),
              (this.containsNaNProperty = void 0),
              (this.isEvenlySpacedProperty = !1),
              (this.metadataGeneratorProperty = void 0),
              (this.changeCountProperty = 0),
              (this.fifoCapacityProperty = void 0),
              (this.fifoSweepingProperty = !1),
              (this.fifoSweepingGapProperty = 1),
              (this.webAssemblyContext = e),
              (this.id =
                null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                  ? r
                  : (0, v.generateGuid)()),
              null == t ? void 0 : t.fifoCapacity)
            )
              (this.fifoCapacityProperty = t.fifoCapacity),
                (this.doubleVectorProvider = new b.FIFOVectorProvider(
                  t.fifoCapacity
                ));
            else {
              const e = this.calculateInitialCapacity(t);
              n.Guard.argumentIsRealInteger(e, "initialCapacity"),
                (this.doubleVectorProvider.capacity = e);
            }
            (this.fifoSweepingProperty =
              (null == t ? void 0 : t.fifoSweeping) ||
              this.fifoSweepingProperty),
              (this.fifoSweepingGapProperty =
                (null == t ? void 0 : t.fifoSweepingGap) ||
                this.fifoSweepingGapProperty),
              (this.xValues = this.doubleVectorProvider.getDoubleVector(e)),
              (this.arrayCount =
                null !== (o = null == t ? void 0 : t.arrayCount) && void 0 !== o
                  ? o
                  : this.arrayCount);
            for (let t = 0; t < this.arrayCount; t++)
              this.yValuesArray.push(
                this.doubleVectorProvider.getDoubleVector(e)
              );
            (this.valueNames =
              null !== (a = null == t ? void 0 : t.valueNames) && void 0 !== a
                ? a
                : (0, c.generateValueNamesForDataSeries)(
                    this.yValuesArray.length
                  )),
              (this.indexes = new e.SCRTDoubleVector()),
              (this.dataSeriesNameProperty =
                null !== (l = null == t ? void 0 : t.dataSeriesName) &&
                void 0 !== l
                  ? l
                  : this.dataSeriesNameProperty),
              (this.isSorted =
                null !==
                  (u =
                    null !== (h = null == t ? void 0 : t.dataIsSortedInX) &&
                    void 0 !== h
                      ? h
                      : null == t
                      ? void 0
                      : t.isSorted) && void 0 !== u
                  ? u
                  : this.isSortedProperty),
              (this.containsNaN =
                null !== (p = null == t ? void 0 : t.containsNaN) &&
                void 0 !== p
                  ? p
                  : this.containsNaNProperty),
              (this.isEvenlySpaced =
                null !== (g = null == t ? void 0 : t.dataEvenlySpacedInX) &&
                void 0 !== g
                  ? g
                  : this.isEvenlySpacedProperty),
              (this.includeInYRange =
                null !== (y = null == t ? void 0 : t.includeInYRange) &&
                void 0 !== y
                  ? y
                  : this.valueNames.map((e) => !0)),
              (null == t ? void 0 : t.metadata) &&
                ("type" in t.metadata
                  ? ((this.metadataGeneratorProperty = (0, i.createType)(
                      d.EBaseType.MetadataGenerator,
                      t.metadata.type,
                      e,
                      t.metadata.data
                    )),
                    (t.metadata =
                      null === (f = this.metadataGeneratorProperty) ||
                      void 0 === f
                        ? void 0
                        : f.getMetadata()))
                  : Array.isArray(null == t ? void 0 : t.metadata) ||
                    ((this.metadataGeneratorProperty =
                      new A.TemplateMetadataGenerator(
                        null == t ? void 0 : t.metadata
                      )),
                    (t.metadata = void 0)));
          }
          getYValuesByName(e, t = x.EDataSeriesValueType.Default) {
            const r = this.valueNames.indexOf(e);
            if (r >= 0)
              switch (t) {
                case x.EDataSeriesValueType.FinalAnimationValues:
                  return this.yFinalAnimationValuesArray[r];
                case x.EDataSeriesValueType.InitialAnimationValues:
                  return this.yInitialAnimationValuesArray[r];
                default:
                  return this.yValuesArray[r];
              }
          }
          appendN(e, t, r, i) {
            var o;
            const a = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              const o = this.getNativeXValues();
              this.dataDistributionCalculator.onAppend(
                this.isSorted,
                this.containsNaN,
                o,
                [e],
                [t[0]]
              ),
                this.appendMetadata(r),
                o.push_back(e);
              for (let e = 0; e < this.arrayCount; e++)
                this.yValuesArray[e].push_back(t[e]);
              i && i(),
                this.notifyDataChanged(x.EDataChangeType.Append, null, 1);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (o = null == a ? void 0 : a.detail) || void 0 === o
                    ? void 0
                    : o.relatedId,
                contextId: this.id,
              }
            );
          }
          appendRangeN(e, t, r, i) {
            var o;
            const a = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              n.Guard.isTrue(
                (0, h.isNumberArray)(e) || (0, h.isTypedArray)(e),
                "xValues must be an array of numbers"
              );
              for (let r = 0; r < this.arrayCount; r++) {
                const i = this.valueNames[r];
                if (
                  (n.Guard.isTrue(
                    (0, h.isNumberArray)(t[r]) || (0, h.isTypedArray)(t[r]),
                    `${i}Values must be an array of numbers`
                  ),
                  t[r].length !== e.length)
                )
                  throw new Error(
                    `Arrays xValues and ${i} must have the same length`
                  );
              }
              r &&
                (n.Guard.isTrue(
                  Array.isArray(r),
                  "metadata must be an array of IPointMetadata"
                ),
                n.Guard.arraysSameLength(e, "xValues", r, "metadata"));
              const o = this.getNativeXValues();
              this.dataDistributionCalculator.onAppend(
                this.isSorted,
                this.containsNaN,
                o,
                e,
                t[0]
              ),
                this.appendMetadataRange(r, e.length),
                this.doubleVectorProvider.appendArray(
                  this.webAssemblyContext,
                  o,
                  e
                );
              for (let e = 0; e < this.arrayCount; e++)
                this.doubleVectorProvider.appendArray(
                  this.webAssemblyContext,
                  this.yValuesArray[e],
                  t[e]
                );
              i && i(),
                this.notifyDataChanged(
                  x.EDataChangeType.Append,
                  null,
                  e.length
                );
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (o = null == a ? void 0 : a.detail) || void 0 === o
                    ? void 0
                    : o.relatedId,
                contextId: this.id,
              }
            );
          }
          updateN(e, t, r, i) {
            var o;
            const a = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              this.validateIndex(e),
                this.dataDistributionCalculator.onUpdate(
                  this.isSorted,
                  this.containsNaN,
                  void 0,
                  void 0,
                  [t[0]],
                  e
                );
              for (let r = 0; r < this.arrayCount; r++)
                this.yValuesArray[r].set(e, t[r]);
              i && i(),
                this.setMetadataAt(e, r),
                this.notifyDataChanged(x.EDataChangeType.Update, e, 1);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (o = null == a ? void 0 : a.detail) || void 0 === o
                    ? void 0
                    : o.relatedId,
                contextId: this.id,
              }
            );
          }
          updateXyN(e, t, r, i, o) {
            var a;
            const s = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              this.validateIndex(e);
              const a = this.getNativeXValues();
              this.dataDistributionCalculator.onUpdate(
                this.isSorted,
                this.containsNaN,
                a,
                [t],
                [r[0]],
                e
              ),
                a.set(e, t);
              for (let t = 0; t < this.arrayCount; t++)
                this.yValuesArray[t].set(e, r[t]);
              o && o(),
                this.setMetadataAt(e, i),
                this.notifyDataChanged(x.EDataChangeType.Update, e, 1);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (a = null == s ? void 0 : s.detail) || void 0 === a
                    ? void 0
                    : a.relatedId,
                contextId: this.id,
              }
            );
          }
          insertN(e, t, r, i, o) {
            var a;
            const s = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              this.validateIndex(e, "Start index is out of range"),
                this.throwIfFifo("insert");
              const a = this.getNativeXValues();
              this.getNativeYValues(),
                this.dataDistributionCalculator.onInsert(
                  this.isSorted,
                  this.containsNaN,
                  a,
                  [t],
                  [r[0]],
                  e
                ),
                a.insertAt(e, t);
              for (let t = 0; t < this.arrayCount; t++)
                this.yValuesArray[t].insertAt(e, r[t]);
              o && o(),
                this.insertMetadata(e, i),
                this.notifyDataChanged(x.EDataChangeType.Insert, e, 1);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (a = null == s ? void 0 : s.detail) || void 0 === a
                    ? void 0
                    : a.relatedId,
                contextId: this.id,
              }
            );
          }
          insertRangeN(e, t, r, i, o) {
            var a;
            const s = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              n.Guard.isTrue(
                (0, h.isNumberArray)(t) || (0, h.isTypedArray)(t),
                "xValues must be an array of numbers"
              ),
                this.validateIndex(e, "Start index is out of range");
              for (let e = 0; e < this.arrayCount; e++) {
                const i = this.valueNames[e];
                if (
                  (n.Guard.isTrue(
                    (0, h.isNumberArray)(r[e]) || (0, h.isTypedArray)(r[e]),
                    `${i}Values must be an array of numbers`
                  ),
                  r[e].length !== t.length)
                )
                  throw new Error(
                    `Arrays xValues and ${i} must have the same length`
                  );
              }
              this.throwIfFifo("insertRange"),
                i &&
                  (n.Guard.isTrue(
                    Array.isArray(i),
                    "metadata must be an array of IPointMetadata"
                  ),
                  n.Guard.arraysSameLength(t, "xValues", i, "metadata"));
              const a = this.getNativeXValues();
              this.dataDistributionCalculator.onInsert(
                this.isSorted,
                this.containsNaN,
                a,
                t,
                r[0],
                e
              ),
                (0, y.insertDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  t,
                  this.getNativeXValues(),
                  e
                );
              for (let t = 0; t < this.arrayCount; t++)
                (0, y.insertDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  r[t],
                  this.yValuesArray[t],
                  e
                );
              o && o(),
                this.insertMetadataRange(e, i),
                this.notifyDataChanged(x.EDataChangeType.Insert, e, t.length);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (a = null == s ? void 0 : s.detail) || void 0 === a
                    ? void 0
                    : a.relatedId,
                contextId: this.id,
              }
            );
          }
          removeAt(e) {
            var t;
            const r = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              this.validateIndex(e),
                this.throwIfFifo("removeAt"),
                this.getNativeXValues().removeAt(e);
              for (let t = 0; t < this.arrayCount; t++)
                this.yValuesArray[t].removeAt(e);
              this.removeMetadataAt(e),
                this.notifyDataChanged(x.EDataChangeType.Remove, e, 1);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                contextId: this.id,
              }
            );
          }
          removeRange(e, t) {
            var r;
            const i = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              this.validateIndex(e, "Start index is out of range"),
                this.throwIfFifo("removeRange"),
                this.getNativeXValues().removeRange(e, t);
              for (let r = 0; r < this.arrayCount; r++)
                this.yValuesArray[r].removeRange(e, t);
              this.removeMetadataRange(e, t),
                this.notifyDataChanged(x.EDataChangeType.Remove, e, t);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (r = null == i ? void 0 : i.detail) || void 0 === r
                    ? void 0
                    : r.relatedId,
                contextId: this.id,
              }
            );
          }
          clear() {
            var e, t;
            const r = P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateStart,
              { contextId: this.id }
            );
            if (!this.getIsDeleted()) {
              null === (e = this.indexes) || void 0 === e || e.clear(),
                this.dataDistributionCalculator.clear(
                  this.isSorted,
                  this.containsNaN
                ),
                this.getNativeXValues().clear();
              for (let e = 0; e < this.arrayCount; e++)
                this.yValuesArray[e].clear();
              this.setMetadata(void 0),
                this.notifyDataChanged(x.EDataChangeType.Clear, null, null);
            }
            P.PerformanceDebugHelper.mark(
              P.EPerformanceMarkType.DataUpdateEnd,
              {
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                contextId: this.id,
              }
            );
          }
          get capacity() {
            return this.xValues.capacity();
          }
          set capacity(e) {
            e > this.capacity && this.reserve(e);
          }
          get containsNaN() {
            return this.containsNaNProperty;
          }
          set containsNaN(e) {
            (this.containsNaNProperty = e),
              void 0 !== e && this.dataDistributionCalculator.setContainsNaN(e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "containsNaN"
              );
          }
          get isSorted() {
            return this.isSortedProperty;
          }
          set isSorted(e) {
            (this.isSortedProperty = e),
              void 0 !== e &&
                this.dataDistributionCalculator.setIsSortedAscending(e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "isSorted"
              );
          }
          get isEvenlySpaced() {
            return this.isEvenlySpacedProperty;
          }
          set isEvenlySpaced(e) {
            (this.isEvenlySpacedProperty = e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "isEvenlySpaced"
              );
          }
          get dataSeriesName() {
            return this.dataSeriesNameProperty;
          }
          set dataSeriesName(e) {
            (this.dataSeriesNameProperty = e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "dataSeriesName"
              );
          }
          count() {
            return this.xValues ? this.xValues.size() : 0;
          }
          getIsDeleted() {
            return this.isDeleted;
          }
          get fifoCapacity() {
            return this.fifoCapacityProperty;
          }
          get fifoStartIndex() {
            return this.fifoCapacity > 0 ? this.xValues.getStartIndex() : 0;
          }
          get fifoSweeping() {
            return this.fifoCapacity && this.fifoSweepingProperty;
          }
          set fifoSweeping(e) {
            (this.fifoSweepingProperty = e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "fifoSweeping"
              );
          }
          get fifoSweepingGap() {
            return this.fifoSweepingGapProperty;
          }
          set fifoSweepingGap(e) {
            (this.fifoSweepingGapProperty = e),
              this.notifyDataChanged(
                x.EDataChangeType.Property,
                void 0,
                void 0,
                "fifoSweepingGap"
              );
          }
          getNativeIndexes() {
            if (!this.indexes) return;
            const e = this.count(),
              t = this.indexes.size();
            return (
              t < e
                ? this.webAssemblyContext.SCRTFillVectorSequential(
                    this.indexes,
                    e
                  )
                : t > e && this.indexes.resizeFast(e),
              this.indexes
            );
          }
          getNativeXValues() {
            return this.xValues;
          }
          getNativeYValues(e = 0) {
            return this.yValuesArray[e];
          }
          get yInitialAnimationValues() {
            return this.yInitialAnimationValuesArray[0];
          }
          get yFinalAnimationValues() {
            return this.yFinalAnimationValuesArray[0];
          }
          getNativeValue(e, t) {
            if (e)
              return this.fifoSweeping && e.getRaw ? e.getRaw(t) : e.get(t);
          }
          delete() {
            this.isDeleted ||
              ((this.xValues = (0, a.deleteSafe)(this.xValues)),
              this.yValuesArray.forEach((e) => (0, a.deleteSafe)(e)),
              (this.yValuesArray.length = 0),
              (this.indexes = (0, a.deleteSafe)(this.indexes)),
              (this.xInitialAnimationValues = (0, a.deleteSafe)(
                this.xInitialAnimationValues
              )),
              this.yInitialAnimationValuesArray.forEach((e) =>
                (0, a.deleteSafe)(e)
              ),
              (this.xFinalAnimationValues = (0, a.deleteSafe)(
                this.xFinalAnimationValues
              )),
              this.yFinalAnimationValuesArray.forEach((e) =>
                (0, a.deleteSafe)(e)
              ),
              this.setMetadata(void 0),
              (this.isDeleted = !0));
          }
          notifyDataChanged(e, t, r, i) {
            this.changeCountProperty++,
              this.dataChanged.raiseEvent({
                changeType: e,
                index: t,
                count: r,
              });
          }
          get xRange() {
            return this.getXRange();
          }
          getXRange(e) {
            return this.getXRangeByName(e);
          }
          getXRangeByName(e, t) {
            return (
              this.memoizedgetXRange ||
                (this.memoizedgetXRange = (0, S.memoize)((e, t, r) => {
                  const i = r
                    ? this.getYValuesByName(r, t)
                    : this.getXValues(t);
                  let o;
                  if (1 === this.count()) {
                    const e = i.get(0) - 1,
                      t = i.get(0) + 1;
                    return new l.NumberRange(e, t);
                  }
                  if (this.count() > 1) {
                    let e = i.get(0),
                      t = i.get(this.count() - 1);
                    if (!this.dataDistributionCalculator.isSortedAscending) {
                      let r;
                      try {
                        if (
                          ((r = this.webAssemblyContext.NumberUtil.MinMax(i)),
                          !(0, m.isRealNumber)(r.minD) ||
                            !(0, m.isRealNumber)(r.maxD))
                        )
                          return new l.NumberRange(0, 0);
                        (e = r.minD), (t = r.maxD);
                      } finally {
                        (0, a.deleteSafe)(r);
                      }
                    }
                    return e === t
                      ? new l.NumberRange(e - 1, t + 1)
                      : (e > t && ((o = e), (e = t), (t = o)),
                        new l.NumberRange(e, t));
                  }
                  return new l.NumberRange(0, 0);
                })),
              this.memoizedgetXRange(this.changeCount, e, t)
            );
          }
          getWindowedYRange(
            e,
            r,
            i = !1,
            o = x.EDataSeriesValueType.Default,
            s = p.EYRangeMode.Visible
          ) {
            return (
              this.memoizedGetWindowedYRange ||
                (this.memoizedGetWindowedYRange = (0, S.memoize)(
                  (e) => {
                    const {
                      _xRange: r,
                      _getPositiveRange: i,
                      _isXCategoryAxis: o,
                      _dataSeriesValueType: s,
                      _yRangeMode: n,
                    } = e;
                    let d = Number.MAX_VALUE,
                      h = Number.NEGATIVE_INFINITY;
                    const c =
                        n === p.EYRangeMode.Visible
                          ? u.ESearchMode.RoundUp
                          : u.ESearchMode.RoundDown,
                      g =
                        n === p.EYRangeMode.Visible
                          ? u.ESearchMode.RoundDown
                          : u.ESearchMode.RoundUp;
                    if (1 === this.count()) {
                      for (let e = 0; e < this.arrayCount; e++)
                        if (this.includeInYRange[e]) {
                          const t = this.yValuesArray[e].get(0);
                          (d = Math.min(d, t)), (h = Math.max(h, t));
                        }
                      return new l.NumberRange(d, h);
                    }
                    const y = this.getXValues(s),
                      f = o
                        ? r
                        : (0, t.getIndicesRange)(
                            this.webAssemblyContext,
                            y,
                            r,
                            this.dataDistributionCalculator.isSortedAscending,
                            c,
                            g
                          ),
                      v = Math.max(Math.floor(f.min), 0),
                      S = Math.min(Math.ceil(f.max), this.count() - 1);
                    if (S < v) return;
                    let P;
                    try {
                      for (let e = 0; e < this.arrayCount; e++)
                        if (this.includeInYRange[e]) {
                          if (
                            ((P =
                              this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                                this.getYValues(s, e),
                                v,
                                S - v + 1
                              )),
                            !(0, m.isRealNumber)(P.minD) ||
                              !(0, m.isRealNumber)(P.maxD))
                          )
                            return;
                          (d = Math.min(d, P.minD)), (h = Math.max(h, P.maxD));
                        }
                      return new l.NumberRange(d, h);
                    } finally {
                      (0, a.deleteSafe)(P);
                    }
                  },
                  ([e], [t]) =>
                    e._xRange.equals(t._xRange) &&
                    e._changeCount === t._changeCount &&
                    e._dataSeriesValueType === t._dataSeriesValueType &&
                    e._isXCategoryAxis === t._isXCategoryAxis &&
                    e._yRangeMode === t._yRangeMode
                )),
              this.memoizedGetWindowedYRange({
                _changeCount: this.changeCount,
                _xRange: e,
                _getPositiveRange: r,
                _isXCategoryAxis: i,
                _dataSeriesValueType: o,
                _yRangeMode: s,
              })
            );
          }
          getIndicesRange(
            e,
            r = !1,
            i = u.ESearchMode.RoundDown,
            o = u.ESearchMode.RoundUp
          ) {
            const a = r ? this.getNativeIndexes() : this.xValues;
            return (0, t.getIndicesRange)(
              this.webAssemblyContext,
              a,
              e,
              this.dataDistributionCalculator.isSortedAscending,
              i,
              o
            );
          }
          get hasValues() {
            return this.count() > 0;
          }
          hasMetadataGenerator() {
            return void 0 !== this.metadataGeneratorProperty;
          }
          setMetadataGenerator(e) {
            const t = !this.hasMetadataGenerator();
            if (
              ((this.metadataGeneratorProperty = e),
              t && !this.metadataProperty)
            ) {
              const e = Array(this.xValues.size())
                .fill(1)
                .map((e) => this.metadataGeneratorProperty.getSingleMetadata());
              this.metadataProperty = e;
            }
          }
          getMetadataAt(e, t = !1) {
            if ((this.validateIndex(e), this.metadataProperty)) {
              if (this.fifoCapacity && !t) {
                const t =
                  (this.xValues.getStartIndex() + e) % this.fifoCapacity;
                return this.metadataProperty[t];
              }
              return this.metadataProperty[e];
            }
          }
          getMetadataLength() {
            return this.metadataProperty
              ? this.metadataProperty.length
              : this.count();
          }
          get hasMetadata() {
            return void 0 !== this.metadataProperty;
          }
          createAnimationVectors() {
            (this.xInitialAnimationValues =
              this.doubleVectorProvider.getDoubleVector(
                this.webAssemblyContext
              )),
              (this.xFinalAnimationValues =
                this.doubleVectorProvider.getDoubleVector(
                  this.webAssemblyContext
                ));
            for (let e = 0; e < this.arrayCount; e++)
              this.yInitialAnimationValuesArray.push(
                this.doubleVectorProvider.getDoubleVector(
                  this.webAssemblyContext
                )
              ),
                this.yFinalAnimationValuesArray.push(
                  this.doubleVectorProvider.getDoubleVector(
                    this.webAssemblyContext
                  )
                );
          }
          setInitialAnimationVectors(e) {
            if (!e)
              return (
                this.xInitialAnimationValues.resize(0, 0),
                void this.yInitialAnimationValuesArray.forEach((e) =>
                  e.resize(0, 0)
                )
              );
            (0, f.copyDoubleVector)(
              e.getNativeXValues(),
              this.xInitialAnimationValues,
              this.webAssemblyContext
            ),
              this.yInitialAnimationValuesArray.forEach((t, r) =>
                (0, f.copyDoubleVector)(
                  e.getNativeYValues(r),
                  t,
                  this.webAssemblyContext
                )
              );
          }
          setFinalAnimationVectors(e) {
            if (!e)
              return (
                this.xFinalAnimationValues.resize(0, 0),
                void this.yFinalAnimationValuesArray.forEach((e) =>
                  e.resize(0, 0)
                )
              );
            (0, f.copyDoubleVector)(
              e.getNativeXValues(),
              this.xFinalAnimationValues,
              this.webAssemblyContext
            ),
              this.yFinalAnimationValuesArray.forEach((t, r) =>
                (0, f.copyDoubleVector)(
                  e.getNativeYValues(r),
                  t,
                  this.webAssemblyContext
                )
              );
          }
          revertAnimationVectors(e) {
            (e = null != e ? e : this),
              (0, f.copyDoubleVector)(
                this.xFinalAnimationValues,
                e.getNativeXValues(),
                this.webAssemblyContext
              ),
              (0, f.copyDoubleVector)(
                this.yFinalAnimationValues,
                e.getNativeYValues(),
                this.webAssemblyContext
              );
          }
          validateAnimationVectors() {
            const e = this.xInitialAnimationValues.size();
            if (
              this.yInitialAnimationValuesArray.some((t) => t.size() !== e) ||
              e !== this.xFinalAnimationValues.size() ||
              this.yFinalAnimationValuesArray.some((t) => t.size() !== e)
            )
              throw Error(
                "initialAnimationValues and finalAnimationValues must have the same length"
              );
          }
          updateAnimationProperties(e, t) {
            if (t.isOnStartAnimation)
              this.yFinalAnimationValuesArray.forEach((r, i) =>
                t.calculateAnimationValues(
                  this.webAssemblyContext,
                  r,
                  this.getNativeYValues(i),
                  e
                )
              );
            else if (t.isDataSeriesAnimation) {
              t.calculateDataSeriesAnimationValues(
                this.webAssemblyContext,
                this.xInitialAnimationValues,
                this.xFinalAnimationValues,
                this.getNativeXValues(),
                e
              );
              for (let r = 0; r < this.arrayCount; r++)
                t.calculateDataSeriesAnimationValues(
                  this.webAssemblyContext,
                  this.yInitialAnimationValuesArray[r],
                  this.yFinalAnimationValuesArray[r],
                  this.getNativeYValues(r),
                  e
                );
            }
          }
          isUsedForYRange(e) {
            const t = this.valueNames.indexOf(e);
            return t >= 0 && this.includeInYRange[t];
          }
          setUsedForYRange(e, t) {
            const r = this.valueNames.indexOf(e);
            r >= 0 && (this.includeInYRange[r] = t);
          }
          toJSON(e = !1) {
            const t = this.getOptions(e);
            return { type: this.type, options: t };
          }
          get changeCount() {
            return this.changeCountProperty;
          }
          getOptions(e = !1) {
            const t = Object.assign(
              {
                id: this.id,
                containsNaN: this.containsNaN,
                isSorted: this.isSorted,
                dataIsSortedInX: this.isSorted,
                dataEvenlySpacedInX: this.isEvenlySpaced,
                dataSeriesName: this.dataSeriesName,
                fifoCapacity: this.fifoCapacity,
                fifoSweeping: this.fifoSweeping,
                fifoSweepingGap: this.fifoSweepingGap,
                fifoStartIndex: this.fifoSweeping ? this.fifoStartIndex : 0,
                capacity: this.capacity,
                metadata: void 0,
                arrayCount: this.arrayCount,
                valueNames: this.valueNames,
                includeInYRange: this.includeInYRange,
                xValues: void 0,
                yValues: void 0,
              },
              this.dataIds
            );
            return (t.metadata = e ? void 0 : this.metadataProperty), t;
          }
          toPointSeries(e, t, r) {
            return new T.BasePointSeriesWrapped(this);
          }
          findIndex(e, t = u.ESearchMode.Nearest) {
            var r, i;
            if (0 === this.count()) return -1;
            const o =
                null !==
                  (i =
                    null === (r = this.dataDistributionCalculator) ||
                    void 0 === r
                      ? void 0
                      : r.isSortedAscending) &&
                void 0 !== i &&
                i,
              a = o
                ? (0, u.convertSearchMode)(this.webAssemblyContext, t)
                : this.webAssemblyContext.SCRTFindIndexSearchMode.Exact;
            return this.webAssemblyContext.NumberUtil.FindIndex(
              this.xValues,
              e,
              a,
              o
            );
          }
          validateIndex(e, t) {
            if (Math.round(e) !== e) throw Error("Index must be an integer");
            const r = null != t ? t : "Index is out of range";
            if (e < 0 || e >= this.count()) throw new Error(r);
          }
          setMetadataAt(e, t) {
            if (t)
              if (
                (this.validateIndex(e),
                this.fillMetadataIfUndefined(),
                this.fifoCapacity)
              ) {
                const r =
                  (this.xValues.getStartIndex() + e) % this.fifoCapacity;
                this.metadataProperty[r] = t;
              } else this.metadataProperty[e] = t;
          }
          appendMetadata(e) {
            if (!e) {
              if (!this.metadataGeneratorProperty) return;
              e = this.metadataGeneratorProperty.getSingleMetadata();
            }
            this.fillMetadataIfUndefined(),
              this.fifoCapacity && this.count() === this.fifoCapacity
                ? (this.metadataProperty[this.xValues.getStartIndex()] = e)
                : this.metadataProperty.push(e);
          }
          appendMetadataRange(e, t) {
            if (!e) {
              if (!this.metadataGeneratorProperty) return;
              e = Array(t)
                .fill(1)
                .map((e) => this.metadataGeneratorProperty.getSingleMetadata());
            }
            if ((this.fillMetadataIfUndefined(), this.fifoCapacity))
              (0, g.appendRangeFifo)(
                e,
                this.metadataProperty,
                this.fifoCapacity,
                this.xValues.getStartIndex()
              );
            else {
              const r = this.metadataProperty.length;
              this.metadataProperty.length += t;
              for (let i = 0; i < t; ++i) this.metadataProperty[r + i] = e[i];
            }
          }
          insertMetadata(e, t) {
            if (!t) {
              if (!this.metadataGeneratorProperty) return;
              t = this.metadataGeneratorProperty.getSingleMetadata();
            }
            this.fillMetadataIfUndefined(),
              this.metadataProperty.splice(e, 0, t);
          }
          insertMetadataRange(e, t) {
            if (!t) {
              if (!this.metadataGeneratorProperty) return;
              t = Array(length)
                .fill(1)
                .map((e) => this.metadataGeneratorProperty.getSingleMetadata());
            }
            this.fillMetadataIfUndefined();
            const r = this.metadataProperty.slice(0, e),
              i = this.metadataProperty.slice(e);
            this.metadataProperty = r.concat(t, i);
          }
          removeMetadataAt(e) {
            this.metadataProperty && this.metadataProperty.splice(e, 1);
          }
          removeMetadataRange(e, t) {
            this.metadataProperty && this.metadataProperty.splice(e, t);
          }
          setMetadata(e) {
            this.metadataProperty = e;
          }
          getXValues(e) {
            let t;
            switch (e) {
              case x.EDataSeriesValueType.FinalAnimationValues:
                t = this.xFinalAnimationValues;
                break;
              case x.EDataSeriesValueType.InitialAnimationValues:
                t = this.xInitialAnimationValues;
                break;
              default:
                t = this.xValues;
            }
            return t;
          }
          getYValuesArray(e) {
            let t;
            switch (e) {
              case x.EDataSeriesValueType.FinalAnimationValues:
                t = this.yFinalAnimationValuesArray;
                break;
              case x.EDataSeriesValueType.InitialAnimationValues:
                t = this.yInitialAnimationValuesArray;
                break;
              default:
                t = this.yValuesArray;
            }
            return t;
          }
          throwIfFifo(e) {
            if (this.fifoCapacity)
              throw new Error(`${e} is not supported in fifo mode`);
          }
          reserve(e) {
            if (this.fifoCapacity)
              throw new Error(
                "Resizing a fifo dataSeries is not currently supported."
              );
            n.Guard.argumentIsRealInteger(e, "capacity"),
              this.xValues.reserve(e),
              this.yValuesArray.forEach((t) => t.reserve(e));
          }
          calculateInitialCapacity(e) {
            var t, r, i;
            return Math.max(
              null !== (t = null == e ? void 0 : e.capacity) && void 0 !== t
                ? t
                : 0,
              null !==
                (i =
                  null === (r = null == e ? void 0 : e.xValues) || void 0 === r
                    ? void 0
                    : r.length) && void 0 !== i
                ? i
                : 0
            );
          }
          fillMetadataIfUndefined() {
            if (void 0 === this.metadataProperty) {
              const e = this.count();
              this.metadataProperty = Array(e).fill(void 0);
            }
          }
          getYValues(e, t = 0) {
            let r;
            switch (e) {
              case x.EDataSeriesValueType.FinalAnimationValues:
                r = this.yFinalAnimationValuesArray[t];
                break;
              case x.EDataSeriesValueType.InitialAnimationValues:
                r = this.yInitialAnimationValuesArray[t];
                break;
              default:
                r = this.getNativeYValues(t);
            }
            return r;
          }
        }
        (t.BaseDataSeries = E),
          (t.getIndicesRange = (
            e,
            t,
            r,
            i,
            o = u.ESearchMode.RoundDown,
            a = u.ESearchMode.RoundUp
          ) => {
            const s = t.size();
            let n = new l.NumberRange(0, -1);
            if (s > 0) {
              if (!i) return new l.NumberRange(0, s - 1);
              const d = (t) => {
                  switch (t) {
                    case u.ESearchMode.Exact:
                      return e.SCRTFindIndexSearchMode.Exact;
                    case u.ESearchMode.Nearest:
                      return e.SCRTFindIndexSearchMode.Nearest;
                    case u.ESearchMode.RoundDown:
                      return e.SCRTFindIndexSearchMode.RoundDown;
                    case u.ESearchMode.RoundUp:
                      return e.SCRTFindIndexSearchMode.RoundUp;
                  }
                },
                h = e.NumberUtil.FindIndex(t, r.min, d(o), !0),
                c = e.NumberUtil.FindIndex(t, r.max, d(a), !0);
              n = new l.NumberRange(h, c);
            }
            return n;
          }),
          (t.getWindowedYRange = (
            e,
            r,
            i,
            o,
            s,
            n,
            d,
            h = u.ESearchMode.RoundUp,
            c = u.ESearchMode.RoundDown
          ) => {
            const p = r.size();
            if (1 === p) {
              const e = i.get(0);
              return new l.NumberRange(e, e);
            }
            let g,
              y = 0,
              f = p;
            if (n)
              (y = Math.max(Math.floor(o.min), 0)),
                (f = Math.min(Math.ceil(o.max), p - 1));
            else {
              const i = (0, t.getIndicesRange)(e, r, o, d, h, c);
              (y = Math.max(Math.floor(i.min), 0)),
                (f = Math.min(Math.ceil(i.max), p - 1));
            }
            if (!(f < y))
              try {
                if (
                  ((g = e.NumberUtil.MinMaxWithIndex(i, y, f - y + 1)),
                  !(0, m.isRealNumber)(g.minD) || !(0, m.isRealNumber)(g.maxD))
                )
                  return;
                return new l.NumberRange(g.minD, g.maxD);
              } finally {
                (0, a.deleteSafe)(g);
              }
          });
      },
      16179: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseHeatmapDataSeries = void 0);
        const i = r(45921),
          o = r(56744),
          a = r(3214),
          s = r(23866),
          n = r(98140),
          l = r(11043),
          d = r(27699),
          h = r(73538),
          u = r(72934),
          c = r(51885),
          p = r(33906);
        t.BaseHeatmapDataSeries = class {
          constructor(e, t) {
            var r, o, s, n;
            (this.dataChanged = new a.EventHandler()),
              (this.minXSpacing = 0),
              (this.arrayWidth = 0),
              (this.arrayHeight = 0),
              (this.hasDataChangesProperty = !1),
              (this.hasNaNsProperty = !1),
              (this.lastZMin = -1),
              (this.lastZMax = -1),
              (this.lastFillValuesOutOfRange = void 0),
              (this.metadataGeneratorProperty = void 0),
              (this.changeCountProperty = 0),
              (this.webAssemblyContext = e),
              (this.id =
                null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                  ? r
                  : (0, h.generateGuid)()),
              (this.dataSeriesNameProperty =
                null !== (o = null == t ? void 0 : t.dataSeriesName) &&
                void 0 !== o
                  ? o
                  : this.dataSeriesNameProperty),
              (this.hasNaNsProperty =
                null !== (s = null == t ? void 0 : t.containsNaN) &&
                void 0 !== s
                  ? s
                  : this.hasNaNsProperty),
              (this.normalizedVector =
                new this.webAssemblyContext.SCRTFloatVector()),
              (null == t ? void 0 : t.metadata) &&
                ("type" in t.metadata
                  ? ((this.metadataGeneratorProperty = (0, i.createType)(
                      l.EBaseType.MetadataGenerator,
                      t.metadata.type,
                      e,
                      t.metadata.data
                    )),
                    (t.metadata =
                      null === (n = this.metadataGeneratorProperty) ||
                      void 0 === n
                        ? void 0
                        : n.getMetadata()))
                  : Array.isArray(null == t ? void 0 : t.metadata) ||
                    ((this.metadataGeneratorProperty =
                      new p.TemplateMetadataGenerator(
                        null == t ? void 0 : t.metadata
                      )),
                    (t.metadata = void 0))),
              this.setZValues(
                null == t ? void 0 : t.zValues,
                null == t ? void 0 : t.metadata
              );
          }
          get isSorted() {
            return !0;
          }
          set isSorted(e) {
            throw new Error(
              "setting isSorted on a heatmap series is not supported"
            );
          }
          get isEvenlySpaced() {
            return !0;
          }
          set isEvenlySpaced(e) {
            throw new Error(
              "setting isEvenlySpaced on a heatmap series is not supported"
            );
          }
          get containsNaN() {
            return !1;
          }
          set containsNaN(e) {
            throw new Error(
              "setting containsNaN is not supported on BaseHeatmapDataSeries"
            );
          }
          get dataDistributionCalculator() {
            throw new Error(
              "dataDistributionCalculator is not supported on BaseHeatmapDataSeries"
            );
          }
          getNativeValue(e, t) {
            throw new Error(
              "getNativeValue not supported for HeatmapDataSeries"
            );
          }
          get hasDataChanges() {
            return this.hasDataChangesProperty;
          }
          getZValues() {
            return this.zValuesProperty;
          }
          setZValues(e, t) {
            if (!e || !e[0])
              return (
                (this.zValuesProperty = void 0),
                (this.arrayHeight = 0),
                (this.arrayWidth = 0),
                void (this.size = 0)
              );
            const r = e[0].length;
            e.forEach((e) => {
              if (!e)
                throw new Error(
                  "Each row in zValues must be defined. See how to declare a 2D array in Javascript here https://stackoverflow.com/a/966234/303612"
                );
              if (e.length !== r)
                throw new Error(
                  "Each row in zValues must be the same length, so that the overall 2D array is square"
                );
            }),
              t && g(e, t);
            const i = e[0].length,
              o = e.length;
            (this.arrayWidth = i),
              (this.arrayHeight = o),
              (this.size = i * o),
              (this.zValuesProperty = e),
              this.setMetadata(t),
              this.notifyDataChanged(c.EDataChangeType.Append);
          }
          getZValue(e, t) {
            return this.zValuesProperty[e][t];
          }
          setZValue(e, t, r, i) {
            (this.zValuesProperty[e][t] = r),
              this.setMetadataAt(e, t, i),
              this.notifyDataChanged(c.EDataChangeType.Update, t, e);
          }
          clear() {
            this.getIsDeleted() ||
              (this.setZValues(void 0),
              this.setMetadata(void 0),
              this.notifyDataChanged(c.EDataChangeType.Clear, null, null));
          }
          get xMin() {
            return this.xRange.min;
          }
          get xMax() {
            return this.xRange.max;
          }
          get yMin() {
            return this.yRange.min;
          }
          get yMax() {
            return this.yRange.max;
          }
          get zMin() {
            return this.zRange.min;
          }
          get zMax() {
            return this.zRange.max;
          }
          get xRange() {
            return this.getXRange();
          }
          get yRange() {
            return this.getYRange();
          }
          get zRange() {
            return this.getZRange();
          }
          get dataSeriesName() {
            return this.dataSeriesNameProperty;
          }
          set dataSeriesName(e) {
            (this.dataSeriesNameProperty = e),
              this.notifyDataChanged(
                c.EDataChangeType.Property,
                null,
                null,
                "dataSeriesName"
              );
          }
          get hasValues() {
            return this.arrayWidth > 0 && this.arrayHeight > 0;
          }
          set hasNaNs(e) {
            (this.hasNaNsProperty = e),
              this.notifyDataChanged(
                c.EDataChangeType.Property,
                null,
                null,
                "hasNaNs"
              );
          }
          get hasNaNs() {
            return this.hasNaNsProperty;
          }
          count() {
            return this.arrayWidth * this.arrayHeight;
          }
          setMetadataGenerator(e) {
            const t = void 0 === this.metadataGeneratorProperty;
            (this.metadataGeneratorProperty = e), t && this.setMetadata(null);
          }
          delete() {
            (this.isDeleted = !0),
              (this.normalizedVector = (0, o.deleteSafe)(
                this.normalizedVector
              ));
          }
          getIsDeleted() {
            return this.isDeleted;
          }
          getNativeIndexes() {
            throw new Error(
              "getNativeIndexes is invalid for heatmap type series. Try getting or setting zValues instead"
            );
          }
          getNativeXValues() {
            throw new Error(
              "getNativeXValues is invalid for heatmap type series. Try getting or setting zValues instead"
            );
          }
          getNativeYValues() {
            throw new Error(
              "getNativeYValues is invalid for heatmap type series. Try getting or setting zValues instead"
            );
          }
          getWindowedYRange(e, t, r) {
            return this.yRange;
          }
          notifyDataChanged(e, t, r, i) {
            this.changeCountProperty++,
              (this.hasDataChangesProperty = !0),
              this.dataChanged.raiseEvent({
                changeType: e,
                index: t,
                yIndex: r,
                name: i,
              });
          }
          getNormalizedVector(e, t) {
            s.Guard.notNull(e, "colorMap"),
              s.Guard.argumentIsRealNumber(e.minimum, "colorMap.minimum"),
              s.Guard.argumentIsRealNumber(e.maximum, "colorMap.maximum");
            const r = this.arrayWidth * this.arrayHeight;
            return (
              (this.hasDataChangesProperty ||
                r !== this.normalizedVector.size() ||
                e.minimum !== this.lastZMin ||
                e.maximum !== this.lastZMax ||
                t !== this.lastFillValuesOutOfRange) &&
                (this.recreateNormalizedVector(e.minimum, e.maximum, t),
                (this.lastZMin = e.minimum),
                (this.lastZMax = e.maximum),
                (this.lastFillValuesOutOfRange = t),
                (this.hasDataChangesProperty = !1)),
              this.normalizedVector
            );
          }
          recreateNormalizedVector(e, t, r) {
            const i = this.arrayWidth * this.arrayHeight;
            this.normalizedVector.clear(), this.normalizedVector.resizeFast(i);
            const o = this.hasNaNs ? e - (t - e) / 128 : e;
            if (!(0, u.isRealNumber)(o))
              throw Error(
                "Can not create newZMin for try to use different zMin and zMax values"
              );
            let a = 0;
            const s = 1 / (t - o),
              n = new Float32Array(this.arrayWidth);
            for (let i = 0; i < this.arrayHeight; i++) {
              for (let a = 0; a < this.arrayWidth; a++) {
                const l = this.zValuesProperty[i][a];
                let d = l - o;
                l != l
                  ? (d = 0)
                  : d < e - o
                  ? (d = r ? e - o : 0)
                  : d > t - o && (d = r ? t - o : 0);
                const h = d * s;
                n[a] = h;
              }
              (0, d.memCopyFloat32)(
                this.webAssemblyContext,
                n,
                this.normalizedVector,
                a
              ),
                (a += this.arrayWidth);
            }
          }
          getMetadataAt(e, t) {
            if ((this.validateIndexes(e, t), this.metadataProperty))
              return this.metadataProperty[e][t];
          }
          getMetadataHeight() {
            return this.metadataProperty
              ? this.metadataProperty.length
              : this.arrayHeight;
          }
          getMetadataWidth() {
            return this.metadataProperty
              ? this.metadataProperty[0].length
              : this.arrayWidth;
          }
          toJSON(e = !1) {
            const t = this.getOptions(e);
            return { type: this.type, options: t };
          }
          getIndicesRange(e, t, r, i) {}
          get changeCount() {
            return this.changeCountProperty;
          }
          getOptions(e = !1) {
            return {
              id: this.id,
              containsNaN: this.hasNaNs,
              dataSeriesName: this.dataSeriesName,
              zValues: e ? void 0 : this.zValuesProperty,
              metadata: this.metadataGeneratorProperty
                ? this.metadataGeneratorProperty.toJSON()
                : e
                ? void 0
                : this.metadataProperty,
            };
          }
          getZRange() {
            const e = this.getZValues();
            if (e) {
              let t = Number.MAX_VALUE,
                r = -Number.MAX_VALUE;
              for (let i = 0; i < this.arrayHeight; ++i)
                for (let o = 0; o < this.arrayWidth; o++) {
                  const a = e[i][o];
                  a < t && (t = a), a > r && (r = a);
                }
              return new n.NumberRange(t, r);
            }
          }
          validateIndexes(e, t) {
            if (Math.round(e) !== e) throw Error("yIndex must be an integer");
            if (Math.round(t) !== t) throw Error("xIndex must be an integer");
            if (e < 0 || e >= this.arrayHeight)
              throw new Error("yIndex is out of range");
            if (t < 0 || t >= this.arrayWidth)
              throw new Error("xIndex is out of range");
          }
          setMetadata(e) {
            if (!e && this.metadataGeneratorProperty) {
              e = [];
              for (let t = 0; t < this.arrayHeight; t++) {
                e[t] = [];
                for (let r = 0; r < this.arrayWidth; r++)
                  e[t][r] = this.metadataGeneratorProperty.getSingleMetadata();
              }
            }
            this.metadataProperty = e;
          }
          setMetadataAt(e, t, r) {
            r &&
              (this.validateIndexes(e, t),
              this.fillMetadataIfUndefined(),
              (this.metadataProperty[e][t] = r));
          }
          fillMetadataIfUndefined() {
            if (void 0 === this.metadataProperty) {
              const e = Array(this.arrayHeight).fill(void 0);
              for (let t = 0; t < this.arrayHeight; t++)
                e[t] = Array(this.arrayWidth).fill(void 0);
            }
          }
        };
        const g = (e, t) => {
          s.Guard.arraysSameLengthArr([
            { arg: e, name: "zValues" },
            { arg: t, name: "metadata" },
          ]);
          for (let r = 0; r < e.length; r++)
            s.Guard.arraysSameLengthArr([
              { arg: e[r], name: `zValues[${r}]` },
              { arg: t[r], name: `metadata[${r}]` },
            ]);
        };
      },
      27781: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePaletteProvider = void 0),
          (t.BasePaletteProvider = class {
            onAttached(e) {}
            onDetached() {}
          });
      },
      57835: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxPlotDataSeries = void 0);
        const i = r(98140),
          o = r(26361),
          a = r(54624),
          s = r(9073),
          n = r(24933),
          l = r(51885);
        class d extends n.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 5,
                valueNames: [
                  a.EValueName.BoxPlotMedian,
                  a.EValueName.BoxPlotMax,
                  a.EValueName.BoxPlotUpper,
                  a.EValueName.BoxPlotLower,
                  a.EValueName.BoxPlotMinimum,
                ],
                includeInYRange: [!0, !0, !0, !0, !0],
              })
            ),
              (this.type = l.EDataSeriesType.BoxPlot),
              (null == t ? void 0 : t.xValues) &&
                (this.appendRange(
                  t.xValues,
                  t.maximumValues,
                  t.upperQuartileValues,
                  t.medianValues,
                  t.lowerQuartileValues,
                  t.minimumValues,
                  t.metadata
                ),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.medianValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.maximumValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.upperQuartileValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.lowerQuartileValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.minimumValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get medianValues() {
            return this.getNativeYValues();
          }
          get maximumValues() {
            return this.getNativeMaximumValues();
          }
          get upperQuartileValues() {
            return this.getNativeUpperQuartileValues();
          }
          get lowerQuartileValues() {
            return this.getNativeLowerQuartileValues();
          }
          get minimumValues() {
            return this.getNativeMinimumValues();
          }
          getNativeMaximumValues() {
            return this.getNativeYValues(1);
          }
          getNativeUpperQuartileValues() {
            return this.getNativeYValues(2);
          }
          getNativeMedianValues() {
            return this.getNativeYValues();
          }
          getNativeLowerQuartileValues() {
            return this.getNativeYValues(3);
          }
          getNativeMinimumValues() {
            return this.getNativeYValues(4);
          }
          append(e, t, r, i, o, a, s) {
            super.appendN(e, [i, t, r, o, a], s);
          }
          appendRange(e, t, r, i, o, a, s) {
            super.appendRangeN(e, [i, t, r, o, a], s);
          }
          update(e, t, r, i, o, a, s) {
            super.updateN(e, [t, r, i, o, a], s);
          }
          updateXBoxPlot(e, t, r, i, o, a, s, n) {
            super.updateXyN(e, t, [o, r, i, a, s], n);
          }
          insert(e, t, r, i, o, a, s, n) {
            super.insertN(e, t, [o, r, i, a, s], n);
          }
          insertRange(e, t, r, i, o, a, s, n) {
            super.insertRangeN(e, t, [o, r, i, a, s], n);
          }
          getWindowedYRange(
            e,
            t,
            r = !1,
            a = l.EDataSeriesValueType.Default,
            n = s.EYRangeMode.Visible
          ) {
            const { maximumValues: d, minimumValues: h } =
              this.getBoxPlotValues(a);
            if (1 === this.count())
              return new i.NumberRange(d.get(0), h.get(0));
            const u = r
              ? e
              : this.getIndicesRange(
                  e,
                  !1,
                  n === s.EYRangeMode.Visible
                    ? o.ESearchMode.RoundUp
                    : o.ESearchMode.RoundDown,
                  n === s.EYRangeMode.Visible
                    ? o.ESearchMode.RoundDown
                    : o.ESearchMode.RoundUp
                );
            let c = Number.MAX_VALUE,
              p = Number.NEGATIVE_INFINITY;
            const g = Math.max(u.min, 0),
              y = Math.min(u.max, this.count() - 1);
            if (!(y < g)) {
              for (let e = g; e <= y; e++) {
                const t = d.get(e),
                  r = h.get(e);
                r < c && (c = r), t > p && (p = t);
              }
              return new i.NumberRange(c, p);
            }
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e),
                a = new Array(e),
                s = new Array(e),
                n = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.maximumValues.getRaw(t)),
                    (s[t] = this.yValues.getRaw(t)),
                    (o[t] = this.upperQuartileValues.getRaw(t)),
                    (a[t] = this.medianValues.getRaw(t)),
                    (n[t] = this.minimumValues.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.maximumValues.get(t)),
                    (s[t] = this.lowerQuartileValues.get(t)),
                    (o[t] = this.upperQuartileValues.get(t)),
                    (a[t] = this.medianValues.get(t)),
                    (n[t] = this.minimumValues.get(t));
              const l = {
                xValues: r,
                maximumValues: i,
                upperQuartileValues: o,
                medianValues: a,
                lowerQuartileValues: s,
                minimumValues: n,
              };
              Object.assign(t, l);
            }
            return t;
          }
          getBoxPlotValues(e) {
            let t, r;
            switch (e) {
              case l.EDataSeriesValueType.FinalAnimationValues:
                (t = this.yFinalAnimationValuesArray[1]),
                  (r = this.yFinalAnimationValuesArray[4]);
                break;
              case l.EDataSeriesValueType.InitialAnimationValues:
                (t = this.yInitialAnimationValuesArray[1]),
                  (r = this.yInitialAnimationValuesArray[4]);
                break;
              default:
                (t = this.maximumValues), (r = this.minimumValues);
            }
            return { maximumValues: t, minimumValues: r };
          }
        }
        t.BoxPlotDataSeries = d;
      },
      51185: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxPlotSeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            var r;
            super(e, t),
              5 ===
                (null === (r = t.yValues) || void 0 === r
                  ? void 0
                  : r.length) &&
                ((this.max = t.yValues[0]),
                (this.upper = t.yValues[1]),
                (this.median = t.yValues[2]),
                (this.lower = t.yValues[3]),
                (this.minimum = t.yValues[4]));
          }
          get formattedMaxValue() {
            return this.getYCursorFormattedValue(this.max);
          }
          get formattedUpperValue() {
            return this.getYCursorFormattedValue(this.upper);
          }
          get formattedMedianValue() {
            return this.getYCursorFormattedValue(this.median);
          }
          get formattedLowerValue() {
            return this.getYCursorFormattedValue(this.lower);
          }
          get formattedMinimumValue() {
            return this.getYCursorFormattedValue(this.minimum);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              t && o.push(this.concatValueWithLabel(this.formattedXValue, t)),
              o.push(this.concatValueWithLabel(this.formattedMaxValue, "Max")),
              o.push(
                this.concatValueWithLabel(this.formattedUpperValue, "Upper")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedMedianValue, "Median")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedLowerValue, "Lower")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedMinimumValue, "Minimum")
              ),
              o
            );
          }
        }
        t.BoxPlotSeriesInfo = o;
      },
      14883: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HeatmapSeriesInfo = void 0);
        const i = r(96528),
          o = r(8591),
          a = r(32025);
        class s extends a.SeriesInfo {
          constructor(e, t) {
            super(e, t),
              (this.xIndex = t.heatmapXIndex),
              (this.yIndex = t.heatmapYIndex),
              (this.zValue = t.zValue),
              (this.color = void 0);
          }
          get formattedZValue() {
            const e = this.renderableSeries;
            return e
              ? e.zLabelProvider.formatCursorLabel(this.zValue)
              : (0, o.formatNumber)(this.zValue, i.ENumericFormat.Decimal, 2);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              t && o.push(this.concatValueWithLabel(this.formattedXValue, t)),
              r && o.push(this.concatValueWithLabel(this.formattedYValue, r)),
              null !== this.zValue &&
                void 0 !== this.zValue &&
                o.push(this.concatValueWithLabel(this.formattedZValue, "Z")),
              o
            );
          }
        }
        t.HeatmapSeriesInfo = s;
      },
      84754: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcSeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t),
              (this.highValue = t.highValue),
              (this.lowValue = t.lowValue),
              (this.closeValue = t.closeValue);
          }
          get formattedHighValue() {
            return this.getYCursorFormattedValue(this.highValue);
          }
          get formattedLowValue() {
            return this.getYCursorFormattedValue(this.lowValue);
          }
          get formattedCloseValue() {
            return this.getYCursorFormattedValue(this.closeValue);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              t && o.push(this.concatValueWithLabel(this.formattedXValue, t)),
              o.push(
                this.concatValueWithLabel(this.formattedHighValue, "High")
              ),
              o.push(this.concatValueWithLabel(this.formattedLowValue, "Low")),
              o
            );
          }
        }
        t.HlcSeriesInfo = o;
      },
      97041: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcSeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t),
              (this.openValue = t.openValue),
              (this.highValue = t.highValue),
              (this.lowValue = t.lowValue),
              (this.closeValue = t.closeValue);
          }
          get formattedOpenValue() {
            return this.getYCursorFormattedValue(this.openValue);
          }
          get formattedHighValue() {
            return this.getYCursorFormattedValue(this.highValue);
          }
          get formattedLowValue() {
            return this.getYCursorFormattedValue(this.lowValue);
          }
          get formattedCloseValue() {
            return this.getYCursorFormattedValue(this.closeValue);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              t && o.push(this.concatValueWithLabel(this.formattedXValue, t)),
              o.push(
                this.concatValueWithLabel(this.formattedOpenValue, "Open")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedHighValue, "Highest")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedLowValue, "Lowest")
              ),
              o.push(
                this.concatValueWithLabel(this.formattedCloseValue, "Close")
              ),
              o
            );
          }
        }
        t.OhlcSeriesInfo = o;
      },
      32025: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesInfo = void 0);
        const i = r(5337);
        t.SeriesInfo = class {
          constructor(e, t) {
            (this.renderableSeries = e),
              (this.seriesName = e.seriesName),
              (this.stroke = e.stroke),
              (this.dataSeriesType = t.dataSeriesType),
              (this.dataSeriesIndex = t.dataSeriesIndex),
              (this.isHit = t.isHit),
              (this.isWithinDataBounds = t.isWithinDataBounds),
              (this.hitTestPointValues = t.hitTestPointValues),
              (this.xValue = t.isCategoryAxis ? t.xCategoryValue : t.xValue),
              (this.point2xValue = t.point2xValue),
              (this.yValue = t.yValue),
              (this.point2yValue = t.point2yValue),
              (this.xCoordinate = t.xCoord),
              (this.yCoordinate = t.yCoord),
              (this.point2xCoordinate = t.point2xCoord),
              (this.point2yCoordinate = t.point2yCoord),
              (this.pointMetadata = t.metadata),
              (this.point2metadata = t.point2metadata),
              (this.distance = t.distance),
              (e.type === i.ESeriesType.ColumnSeries ||
                e.type === i.ESeriesType.MountainSeries ||
                e.type === i.ESeriesType.BandSeries) &&
                (this.fill = e.fill);
          }
          get isVisible() {
            return this.renderableSeries.isVisible;
          }
          get formattedYValue() {
            return this.getYCursorFormattedValue(this.yValue);
          }
          get formattedXValue() {
            return this.getXCursorFormattedValue(this.xValue);
          }
          getYCursorFormattedValue(e) {
            return this.renderableSeries.yAxis.labelProvider.formatCursorLabel(
              e
            );
          }
          getXCursorFormattedValue(e) {
            return this.renderableSeries.xAxis.labelProvider.formatCursorLabel(
              e
            );
          }
          equals(e) {
            return (
              e &&
              this.renderableSeries.id === e.renderableSeries.id &&
              this.isHit === e.isHit &&
              (this.xValue === e.xValue ||
                (this.xValue != this.xValue && e.xValue != e.xValue)) &&
              (this.yValue === e.yValue ||
                (this.yValue != this.yValue && e.yValue != e.yValue)) &&
              this.pointMetadata === e.pointMetadata
            );
          }
          getValuesWithLabels(e, t, r, i) {
            const o = [];
            return e && o.push(e), o;
          }
          concatValueWithLabel(e, t) {
            return `${t}: ${e}`;
          }
          concatTwoValuesWithLabels(e, t, r, i) {
            return r
              ? `${r}: ${e} ${null != i ? i : "Y"}: ${t}`
              : `${i ? `${i}: ` : ""}${t}`;
          }
        };
      },
      75662: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedXySeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t),
              (this.yValue = t.y1Value),
              (this.accumulatedValue = t.yValue);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              o.push(
                this.concatTwoValuesWithLabels(
                  this.formattedXValue,
                  this.formattedYValue,
                  t,
                  r
                )
              ),
              o
            );
          }
        }
        t.StackedXySeriesInfo = o;
      },
      43808: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TriangleSeriesInfo = void 0);
        const i = r(95808),
          o = r(32025);
        class a extends o.SeriesInfo {
          constructor(e, t, r, o) {
            var a, s;
            super(e, t),
              (this.drawMode = r),
              (this.vertices = r === i.ETriangleSeriesDrawMode.Polygon ? o : 3),
              (null === (a = t.xValues) || void 0 === a ? void 0 : a.length) ===
                this.vertices &&
                (null === (s = t.yValues) || void 0 === s
                  ? void 0
                  : s.length) === this.vertices &&
                ((this.xValues = [...t.xValues]),
                (this.yValues = [...t.yValues]));
          }
          get formattedXValues() {
            return this.xValues
              ? this.xValues.map((e) => this.getXCursorFormattedValue(e))
              : [];
          }
          get formattedYValues() {
            return this.yValues
              ? this.yValues.map((e) => this.getYCursorFormattedValue(e))
              : [];
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            o.push(
              this.concatValueWithLabel(
                this.dataSeriesIndex.toFixed(0),
                "Index"
              )
            );
            const a = this.formattedXValues,
              s = this.formattedYValues;
            for (let e = 0; e < a.length; e++) {
              const i = e + 1,
                n = a[e],
                l = s[e];
              o.push(
                this.concatTwoValuesWithLabels(n, l, `${t}${i}`, `${r}${i}`)
              );
            }
            return o;
          }
        }
        t.TriangleSeriesInfo = a;
      },
      50874: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XySeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              o.push(
                this.concatTwoValuesWithLabels(
                  this.formattedXValue,
                  this.formattedYValue,
                  t,
                  r
                )
              ),
              o
            );
          }
        }
        t.XySeriesInfo = o;
      },
      21780: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyySeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t),
              (this.isFirstSeries = !0),
              (this.y1Value = t.y1Value),
              (this.point2y1Value = t.point2y1Value),
              (this.y1Coordinate = t.y1Coord),
              (this.point2y1Coordinate = t.point2y1Coord);
          }
          get formattedY1Value() {
            return this.getYCursorFormattedValue(this.y1Value);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              i
                ? this.isFirstSeries
                  ? o.push(
                      this.concatTwoValuesWithLabels(
                        this.formattedXValue,
                        this.formattedYValue,
                        t,
                        r
                      )
                    )
                  : o.push(
                      this.concatTwoValuesWithLabels(
                        this.formattedXValue,
                        this.formattedY1Value,
                        t,
                        r
                      )
                    )
                : (o.push(this.concatValueWithLabel(this.formattedXValue, "X")),
                  o.push(this.concatValueWithLabel(this.formattedYValue, "Y")),
                  o.push(
                    this.concatValueWithLabel(this.formattedY1Value, "Y1")
                  )),
              o
            );
          }
        }
        t.XyySeriesInfo = o;
      },
      19581: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzSeriesInfo = void 0);
        const i = r(32025);
        class o extends i.SeriesInfo {
          constructor(e, t) {
            super(e, t), (this.zValue = t.zValue);
          }
          get formattedZValue() {
            return this.getYCursorFormattedValue(this.zValue);
          }
          getValuesWithLabels(e, t, r, i) {
            const o = super.getValuesWithLabels(e, t, r, i);
            return (
              i
                ? (o.push(
                    this.concatTwoValuesWithLabels(
                      this.formattedXValue,
                      this.formattedYValue,
                      t,
                      r
                    )
                  ),
                  o.push(this.concatValueWithLabel(this.formattedZValue, "Z")))
                : (o.push(this.concatValueWithLabel(this.formattedXValue, "X")),
                  o.push(this.concatValueWithLabel(this.formattedYValue, "Y")),
                  o.push(this.concatValueWithLabel(this.formattedZValue, "Z"))),
              o
            );
          }
        }
        t.XyzSeriesInfo = o;
      },
      33435: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataDistributionCalculator = void 0);
        const i = r(41493),
          o = r(45215),
          a = r(8591);
        t.DataDistributionCalculator = class {
          constructor() {
            (this.containsNanProperty = !1),
              (this.isSortedAscendingProperty = !0);
          }
          get containsNaN() {
            return this.containsNanProperty;
          }
          get isSortedAscending() {
            return this.isSortedAscendingProperty;
          }
          onAppend(e, t, r, s, n) {
            if (
              (void 0 !== t
                ? (this.containsNanProperty = t)
                : !1 === this.containsNanProperty &&
                  n &&
                  ((this.containsNanProperty = n.some(a.checkIsNaN)),
                  !1 === this.containsNanProperty &&
                    i.performanceWarnings.dataDistributionFlagNaN.warn()),
              void 0 !== e)
            )
              this.isSortedAscendingProperty = e;
            else if (!0 === this.isSortedAscendingProperty) {
              const e = (0, o.isArraySorted)(s),
                t = r.size(),
                a = 0 === t || r.get(t - 1) < s[0];
              (this.isSortedAscendingProperty = e && a),
                !0 === this.isSortedAscendingProperty &&
                  i.performanceWarnings.dataDistributionFlagSortedAscending.warn();
            }
          }
          onInsert(e, t, r, s, n, l) {
            if (
              (void 0 !== t
                ? (this.containsNanProperty = t)
                : !1 === this.containsNanProperty &&
                  n &&
                  ((this.containsNanProperty = n.some(a.checkIsNaN)),
                  !1 === this.containsNanProperty &&
                    i.performanceWarnings.dataDistributionFlagNaN.warn()),
              void 0 !== e)
            )
              this.isSortedAscendingProperty = e;
            else if (!0 === this.isSortedAscendingProperty && s) {
              const e = (0, o.isArraySorted)(s),
                t = 0 === l || r.get(l - 1) < s[0],
                a = l >= r.size() || s[s.length - 1] < r.get(l);
              (this.isSortedAscendingProperty = e && t && a),
                !0 === this.isSortedAscendingProperty &&
                  i.performanceWarnings.dataDistributionFlagSortedAscending.warn();
            }
          }
          onUpdate(e, t, r, i, s, n) {
            if (
              (void 0 !== t
                ? (this.containsNanProperty = t)
                : !1 === this.containsNanProperty &&
                  s &&
                  (this.containsNanProperty = s.some(a.checkIsNaN)),
              void 0 !== e)
            )
              this.isSortedAscendingProperty = e;
            else if (!0 === this.isSortedAscendingProperty && i) {
              const e = (0, o.isArraySorted)(i),
                t = 0 === n || r.get(n - 1) < i[0],
                a = r.size(),
                s = n + i.length,
                l = s >= a || i[i.length - 1] < r.get(s);
              this.isSortedAscendingProperty = e && t && l;
            }
          }
          clear(e, t) {
            (this.isSortedAscendingProperty = null == e || e),
              (this.containsNanProperty = null != t && t);
          }
          setIsSortedAscending(e) {
            this.isSortedAscendingProperty = e;
          }
          setContainsNaN(e) {
            this.containsNanProperty = e;
          }
        };
      },
      75619: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataPointSelectionPaletteProvider = void 0);
        const i = r(28436),
          o = r(5337),
          a = r(48008),
          s = r(32747);
        t.DataPointSelectionPaletteProvider = class {
          constructor(e) {
            (this.strokePaletteMode = s.EStrokePaletteMode.SOLID),
              (this.fillPaletteMode = s.EFillPaletteMode.SOLID),
              (null == e ? void 0 : e.stroke) &&
                (this.selectedStroke = (0, a.parseColorToUIntArgb)(
                  null == e ? void 0 : e.stroke
                )),
              (null == e ? void 0 : e.fill) &&
                (this.selectedFill = (0, a.parseColorToUIntArgb)(
                  null == e ? void 0 : e.fill
                )),
              (this.selectedPointMarker = {
                stroke: this.selectedStroke,
                fill: this.selectedFill,
              });
          }
          onAttached(e) {
            this.seriesType
              ? this.seriesType !== e.type &&
                ((e.paletteProvider = s.DefaultPaletteProvider.createEmpty()),
                console.error(
                  "One instance of a DataPointSelectionPaletteProvider cannot be shared between series of different types"
                ))
              : (this.seriesType = e.type);
          }
          onDetached() {}
          overridePointMarkerArgb(e, t, r, i, o) {
            if (null == o ? void 0 : o.isSelected)
              return this.selectedPointMarker;
          }
          overrideStrokeArgb(e, t, r, i, a) {
            if (
              [
                o.ESeriesType.OhlcSeries,
                o.ESeriesType.CandlestickSeries,
                o.ESeriesType.ColumnSeries,
              ].includes(this.seriesType) &&
              (null == a ? void 0 : a.isSelected)
            )
              return this.selectedStroke;
          }
          overrideFillArgb(e, t, r, i, a) {
            if (
              [
                o.ESeriesType.StackedColumnSeries,
                o.ESeriesType.ColumnSeries,
                o.ESeriesType.CandlestickSeries,
                o.ESeriesType.RectangleSeries,
              ].includes(this.seriesType) &&
              (null == a ? void 0 : a.isSelected)
            )
              return this.selectedFill;
          }
          toJSON() {
            return {
              type: i.EPaletteProviderType.DataPointSelection,
              options: {
                stroke: n(this.selectedStroke, a.parseArgbToHtmlColor),
                fill: n(this.selectedFill, a.parseArgbToHtmlColor),
              },
            };
          }
        };
        const n = (e, t) => {
          if (e) return t(e);
        };
      },
      84366: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FIFOVectorProvider = t.DoubleVectorProvider = void 0);
        const i = r(65885),
          o = r(27699);
        (t.DoubleVectorProvider = class {
          getDoubleVector(e) {
            return this.capacity
              ? new e.SCRTDoubleVector(this.capacity)
              : new e.SCRTDoubleVector();
          }
          appendArray(e, t, r) {
            (0, o.appendDoubleVectorFromJsArray)(e, t, r);
          }
        }),
          (t.FIFOVectorProvider = class {
            constructor(e) {
              this.capacity = e;
            }
            getDoubleVector(e) {
              return new e.SCRTFifoVector(this.capacity);
            }
            appendArray(e, t, r) {
              const a = t.size(),
                s = t.capacity(),
                n = r.length,
                l = t.getStartIndex();
              if (s >= a + n) {
                const i = t.dataPtr(a);
                e.HEAPF64.set(r, i / o.SIZEOF_NUMBER), t.notifyAppend(n);
              } else if (n > s) {
                const a = n - s,
                  l = (0, i.subArray)(r, a),
                  d = t.dataPtrZero();
                e.HEAPF64.set(l, d / o.SIZEOF_NUMBER), t.notifyAppend(s);
              } else if (s > a) {
                const l = s - a,
                  d = (0, i.subArray)(r, 0, l),
                  h = t.dataPtr(a);
                e.HEAPF64.set(d, h / o.SIZEOF_NUMBER);
                const u = (0, i.subArray)(r, l),
                  c = t.dataPtrZero();
                e.HEAPF64.set(u, c / o.SIZEOF_NUMBER), t.notifyAppend(n);
              } else {
                if (l + n > s) {
                  const a = s - l,
                    n = (0, i.subArray)(r, 0, a),
                    d = t.dataPtr(0);
                  e.HEAPF64.set(n, d / o.SIZEOF_NUMBER);
                  const h = (0, i.subArray)(r, a),
                    u = t.dataPtrZero();
                  e.HEAPF64.set(h, u / o.SIZEOF_NUMBER);
                } else {
                  const i = t.dataPtr(0);
                  e.HEAPF64.set(r, i / o.SIZEOF_NUMBER);
                }
                t.notifyAppend(n);
              }
            }
          });
      },
      37947: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcCustomFilter = void 0);
        const i = r(51885),
          o = r(22411);
        class a extends o.HlcFilterBase {
          get closefilterFunction() {
            return this.closefilterFunctionProperty;
          }
          set closefilterFunction(e) {
            (this.closefilterFunctionProperty = e), this.filterAll();
          }
          get highfilterFunction() {
            return this.highfilterFunctionProperty;
          }
          set highfilterFunction(e) {
            (this.highfilterFunctionProperty = e), this.filterAll();
          }
          get lowfilterFunction() {
            return this.lowfilterFunctionProperty;
          }
          set lowfilterFunction(e) {
            (this.lowfilterFunctionProperty = e), this.filterAll();
          }
          constructor(e, t) {
            var r, o, a;
            if ((super(e, t), e.type !== i.EDataSeriesType.Hlc))
              throw new Error(
                "HlcCustomFilter only supports Hlc original series"
              );
            (this.closefilterFunctionProperty =
              null !== (r = null == t ? void 0 : t.closefilterFunction) &&
              void 0 !== r
                ? r
                : this.closefilterFunctionProperty),
              (this.highfilterFunctionProperty =
                null !== (o = null == t ? void 0 : t.highfilterFunction) &&
                void 0 !== o
                  ? o
                  : this.closefilterFunction),
              (this.lowfilterFunctionProperty =
                null !== (a = null == t ? void 0 : t.lowfilterFunction) &&
                void 0 !== a
                  ? a
                  : this.closefilterFunction),
              this.getOriginalCount() > 0 &&
                ((null == t ? void 0 : t.closefilterFunction) ||
                  (null == t ? void 0 : t.highfilterFunction) ||
                  (null == t ? void 0 : t.lowfilterFunction)) &&
                this.filterAll();
          }
          highfilterFunctionProperty(e, t) {
            return t;
          }
          lowfilterFunctionProperty(e, t) {
            return t;
          }
          closefilterFunctionProperty(e, t) {
            return t;
          }
          filterOnAppend(e) {
            const {
              xValues: t,
              highValues: r,
              lowValues: i,
              closeValues: o,
              metadata: a,
            } = this.filter(this.count(), e);
            this.appendRange(t, o, r, i, a);
          }
          filterOnUpdate(e) {
            const t = this.originalSeries;
            this.update(
              e,
              this.highfilterFunction(e, t.getNativeHighValues().get(e)),
              this.lowfilterFunction(e, t.getNativeLowValues().get(e)),
              this.closefilterFunction(e, t.getNativeYValues().get(e)),
              this.originalSeries.getMetadataAt(e)
            );
          }
          filterOnInsert(e, t) {
            const {
              xValues: r,
              highValues: i,
              lowValues: o,
              closeValues: a,
              metadata: s,
            } = this.filter(e, t);
            this.insertRange(e, r, a, i, o, s);
          }
          filterOnRemove(e, t) {
            this.removeRange(e, t);
          }
          filterAll() {
            this.clear();
            const {
              xValues: e,
              highValues: t,
              lowValues: r,
              closeValues: i,
              metadata: o,
            } = this.filter(0, this.getOriginalCount());
            this.appendRange(e, i, t, r, o);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues(),
              o = this.getOriginalHighValues(),
              a = this.getOriginalLowValues(),
              s = [],
              n = [],
              l = [],
              d = [];
            let h;
            if (this.originalSeries.hasMetadata) {
              h = [];
              for (let u = e; u < e + t; u++)
                s.push(r.get(u)),
                  n.push(this.highfilterFunction(u, o.get(u))),
                  l.push(this.lowfilterFunction(u, a.get(u))),
                  d.push(this.closefilterFunction(u, i.get(u))),
                  h.push(this.originalSeries.getMetadataAt(u));
            } else
              for (let h = e; h < e + t; h++)
                s.push(r.get(h)),
                  n.push(this.highfilterFunction(h, o.get(h))),
                  l.push(this.lowfilterFunction(h, a.get(h))),
                  d.push(this.closefilterFunction(h, i.get(h)));
            return {
              xValues: s,
              highValues: n,
              lowValues: l,
              closeValues: d,
              metadata: h,
            };
          }
        }
        t.HlcCustomFilter = a;
      },
      22411: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcFilterBase = void 0);
        const i = r(56744),
          o = r(22382),
          a = r(51885),
          s = r(95079);
        class n extends o.HlcDataSeries {
          constructor(e, t) {
            var r, i;
            switch (
              (super(e.webAssemblyContext, t),
              (this.closefield = s.EDataSeriesField.Close),
              (this.highfield = s.EDataSeriesField.High),
              (this.lowfield = s.EDataSeriesField.Low),
              (this.originalSeriesProperty = e),
              (this.closefield =
                null !== (r = null == t ? void 0 : t.closefield) && void 0 !== r
                  ? r
                  : this.closefield),
              (this.highfield =
                null !== (i = null == t ? void 0 : t.highfield) && void 0 !== i
                  ? i
                  : this.highfield),
              (this.onBaseDataChanged = this.onBaseDataChanged.bind(this)),
              e.dataChanged.subscribe(this.onBaseDataChanged),
              this.originalSeries.type)
            ) {
              case a.EDataSeriesType.Ohlc:
                const e = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.closefield,
                    e.getNativeYValues(),
                    e.getNativeOpenValues(),
                    e.getNativeHighValues(),
                    e.getNativeLowValues()
                  )),
                  (this.getOriginalHighValues = () =>
                    (0, s.switchData)(
                      this.highfield,
                      e.getNativeYValues(),
                      e.getNativeOpenValues(),
                      e.getNativeHighValues(),
                      e.getNativeLowValues()
                    )),
                  (this.getOriginalLowValues = () =>
                    (0, s.switchData)(
                      this.lowfield,
                      e.getNativeYValues(),
                      e.getNativeOpenValues(),
                      e.getNativeHighValues(),
                      e.getNativeLowValues()
                    ));
                break;
              case a.EDataSeriesType.Xy:
                const t = this.originalSeries;
                (this.getOriginalYValues = () => t.getNativeYValues()),
                  (this.getOriginalHighValues = () => t.getNativeYValues()),
                  (this.getOriginalLowValues = () => t.getNativeYValues());
                break;
              case a.EDataSeriesType.Xyy:
                const r = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.closefield,
                    r.getNativeYValues(),
                    r.getNativeY1Values()
                  )),
                  (this.getOriginalHighValues = () =>
                    (0, s.switchData)(
                      this.highfield,
                      r.getNativeYValues(),
                      r.getNativeY1Values()
                    )),
                  (this.getOriginalLowValues = () =>
                    (0, s.switchData)(
                      this.lowfield,
                      r.getNativeYValues(),
                      r.getNativeY1Values()
                    ));
                break;
              case a.EDataSeriesType.Xyz:
                const i = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.closefield,
                    i.getNativeYValues(),
                    i.getNativeZValues()
                  )),
                  (this.getOriginalHighValues = () =>
                    (0, s.switchData)(
                      this.highfield,
                      i.getNativeYValues(),
                      i.getNativeZValues()
                    )),
                  (this.getOriginalLowValues = () =>
                    (0, s.switchData)(
                      this.lowfield,
                      i.getNativeYValues(),
                      i.getNativeZValues()
                    ));
            }
          }
          get originalSeries() {
            return this.originalSeriesProperty;
          }
          detachFromOriginalSeries() {
            this.originalSeries.dataChanged.unsubscribe(this.onBaseDataChanged),
              (this.originalSeriesProperty = void 0);
          }
          delete() {
            (this.originalSeriesProperty = (0, i.deleteSafe)(
              this.originalSeries
            )),
              super.delete();
          }
          getOriginalXValues() {
            return this.originalSeries.getNativeXValues();
          }
          getOriginalYValues() {
            return this.originalSeries.getNativeYValues();
          }
          getOriginalHighValues() {
            return this.originalSeries.getNativeHighValues();
          }
          getOriginalLowValues() {
            return this.originalSeries.getNativeLowValues();
          }
          getOriginalCount() {
            return this.originalSeries.count();
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.filterAll();
          }
          filterOnUpdate(e) {
            this.filterAll();
          }
          filterOnInsert(e, t) {
            this.filterAll();
          }
          filterOnRemove(e, t) {
            this.filterAll();
          }
          onClear() {
            this.clear();
          }
          onBaseDataChanged(e) {
            const { changeType: t, name: r, index: i, count: o } = e;
            switch (t) {
              case a.EDataChangeType.Property:
                return void this.onOriginalPropertyChanged(r);
              case a.EDataChangeType.Append:
                this.filterOnAppend(o);
                break;
              case a.EDataChangeType.Clear:
                this.onClear();
                break;
              case a.EDataChangeType.Insert:
                this.filterOnInsert(i, o);
                break;
              case a.EDataChangeType.Remove:
                this.filterOnRemove(i, o);
                break;
              case a.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
        }
        t.HlcFilterBase = n;
      },
      58465: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcScaleOffsetFilter = void 0);
        const i = r(51097),
          o = r(51885),
          a = r(37947);
        class s extends a.HlcCustomFilter {
          constructor(e, t) {
            var r, i;
            if (
              (super(e, t),
              (this.scaleProperty = 1),
              (this.offsetProperty = 0),
              e.type !== o.EDataSeriesType.Hlc)
            )
              throw new Error(
                "HlcScaleOffsetFilter only supports Hlc original series"
              );
            (this.scaleProperty =
              null !== (r = null == t ? void 0 : t.scale) && void 0 !== r
                ? r
                : this.scaleProperty),
              (this.offsetProperty =
                null !== (i = null == t ? void 0 : t.offset) && void 0 !== i
                  ? i
                  : this.offsetProperty),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            (this.scaleProperty = e), this.filterAll();
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            (this.offsetProperty = e), this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.HlcScaleOffset,
                options: { scale: this.scale, offset: this.offset },
              },
            });
          }
          defaultFunction(e, t) {
            return t * this.scaleProperty + this.offsetProperty;
          }
        }
        t.HlcScaleOffsetFilter = s;
      },
      12954: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcCustomFilter = void 0);
        const i = r(51885),
          o = r(21384);
        class a extends o.OhlcFilterBase {
          get closefilterFunction() {
            return this.closefilterFunctionProperty;
          }
          set closefilterFunction(e) {
            (this.closefilterFunctionProperty = e), this.filterAll();
          }
          get openfilterFunction() {
            return this.openfilterFunctionProperty;
          }
          set openfilterFunction(e) {
            (this.openfilterFunctionProperty = e), this.filterAll();
          }
          get highfilterFunction() {
            return this.highfilterFunctionProperty;
          }
          set highfilterFunction(e) {
            (this.highfilterFunctionProperty = e), this.filterAll();
          }
          get lowfilterFunction() {
            return this.lowfilterFunctionProperty;
          }
          set lowfilterFunction(e) {
            (this.lowfilterFunctionProperty = e), this.filterAll();
          }
          constructor(e, t) {
            var r, o, a, s;
            if ((super(e, t), e.type !== i.EDataSeriesType.Ohlc))
              throw new Error(
                "OhlcCustomFilter only supports Ohlc original series"
              );
            (this.closefilterFunctionProperty =
              null !== (r = null == t ? void 0 : t.closefilterFunction) &&
              void 0 !== r
                ? r
                : this.closefilterFunctionProperty),
              (this.openfilterFunctionProperty =
                null !== (o = null == t ? void 0 : t.openfilterFunction) &&
                void 0 !== o
                  ? o
                  : this.closefilterFunction),
              (this.highfilterFunctionProperty =
                null !== (a = null == t ? void 0 : t.highfilterFunction) &&
                void 0 !== a
                  ? a
                  : this.closefilterFunction),
              (this.lowfilterFunctionProperty =
                null !== (s = null == t ? void 0 : t.lowfilterFunction) &&
                void 0 !== s
                  ? s
                  : this.closefilterFunction),
              this.getOriginalCount() > 0 &&
                ((null == t ? void 0 : t.closefilterFunction) ||
                  (null == t ? void 0 : t.openfilterFunction) ||
                  (null == t ? void 0 : t.highfilterFunction) ||
                  (null == t ? void 0 : t.lowfilterFunction)) &&
                this.filterAll();
          }
          openfilterFunctionProperty(e, t) {
            return t;
          }
          highfilterFunctionProperty(e, t) {
            return t;
          }
          lowfilterFunctionProperty(e, t) {
            return t;
          }
          closefilterFunctionProperty(e, t) {
            return t;
          }
          filterOnAppend(e) {
            const {
              xValues: t,
              openValues: r,
              highValues: i,
              lowValues: o,
              closeValues: a,
              metadata: s,
            } = this.filter(this.count(), e);
            this.appendRange(t, r, i, o, a, s);
          }
          filterOnUpdate(e) {
            const t = this.originalSeries;
            this.update(
              e,
              this.openfilterFunction(e, t.getNativeOpenValues().get(e)),
              this.highfilterFunction(e, t.getNativeHighValues().get(e)),
              this.lowfilterFunction(e, t.getNativeLowValues().get(e)),
              this.closefilterFunction(e, t.getNativeCloseValues().get(e)),
              this.originalSeries.getMetadataAt(e)
            );
          }
          filterOnInsert(e, t) {
            const {
              xValues: r,
              openValues: i,
              highValues: o,
              lowValues: a,
              closeValues: s,
              metadata: n,
            } = this.filter(e, t);
            this.insertRange(e, r, i, o, a, s, n);
          }
          filterOnRemove(e, t) {
            this.removeRange(e, t);
          }
          filterAll() {
            this.clear();
            const {
              xValues: e,
              openValues: t,
              highValues: r,
              lowValues: i,
              closeValues: o,
              metadata: a,
            } = this.filter(0, this.getOriginalCount());
            this.appendRange(e, t, r, i, o, a);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.originalSeries,
              o = [],
              a = [],
              s = [],
              n = [],
              l = [];
            let d;
            if (this.originalSeries.hasMetadata) {
              d = [];
              for (let h = e; h < e + t; h++)
                o.push(r.get(h)),
                  a.push(
                    this.openfilterFunction(h, i.getNativeOpenValues().get(h))
                  ),
                  s.push(
                    this.highfilterFunction(h, i.getNativeHighValues().get(h))
                  ),
                  n.push(
                    this.lowfilterFunction(h, i.getNativeLowValues().get(h))
                  ),
                  l.push(
                    this.closefilterFunction(h, i.getNativeCloseValues().get(h))
                  ),
                  d.push(this.originalSeries.getMetadataAt(h));
            } else
              for (let d = e; d < e + t; d++)
                o.push(r.get(d)),
                  a.push(
                    this.openfilterFunction(d, i.getNativeOpenValues().get(d))
                  ),
                  s.push(
                    this.highfilterFunction(d, i.getNativeHighValues().get(d))
                  ),
                  n.push(
                    this.lowfilterFunction(d, i.getNativeLowValues().get(d))
                  ),
                  l.push(
                    this.closefilterFunction(d, i.getNativeCloseValues().get(d))
                  );
            return {
              xValues: o,
              openValues: a,
              highValues: s,
              lowValues: n,
              closeValues: l,
              metadata: d,
            };
          }
        }
        t.OhlcCustomFilter = a;
      },
      21384: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcFilterBase = void 0);
        const i = r(56744),
          o = r(51885),
          a = r(35471);
        class s extends a.OhlcDataSeries {
          constructor(e, t) {
            super(e.webAssemblyContext, t),
              (this.originalSeriesProperty = e),
              (this.onBaseDataChanged = this.onBaseDataChanged.bind(this)),
              e.dataChanged.subscribe(this.onBaseDataChanged);
          }
          get originalSeries() {
            return this.originalSeriesProperty;
          }
          detachFromOriginalSeries() {
            this.originalSeries.dataChanged.unsubscribe(this.onBaseDataChanged),
              (this.originalSeriesProperty = void 0);
          }
          delete() {
            (this.originalSeriesProperty = (0, i.deleteSafe)(
              this.originalSeries
            )),
              super.delete();
          }
          getOriginalXValues() {
            return this.originalSeries.getNativeXValues();
          }
          getOriginalCount() {
            return this.originalSeries.count();
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.filterAll();
          }
          filterOnUpdate(e) {
            this.filterAll();
          }
          filterOnInsert(e, t) {
            this.filterAll();
          }
          filterOnRemove(e, t) {
            this.filterAll();
          }
          onClear() {
            this.clear();
          }
          onBaseDataChanged(e) {
            const { changeType: t, name: r, index: i, count: a } = e;
            switch (t) {
              case o.EDataChangeType.Property:
                return void this.onOriginalPropertyChanged(r);
              case o.EDataChangeType.Append:
                this.filterOnAppend(a);
                break;
              case o.EDataChangeType.Clear:
                this.onClear();
                break;
              case o.EDataChangeType.Insert:
                this.filterOnInsert(i, a);
                break;
              case o.EDataChangeType.Remove:
                this.filterOnRemove(i, a);
                break;
              case o.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
        }
        t.OhlcFilterBase = s;
      },
      73165: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcScaleOffsetFilter = void 0);
        const i = r(51097),
          o = r(51885),
          a = r(12954);
        class s extends a.OhlcCustomFilter {
          constructor(e, t) {
            var r, i;
            if (
              (super(e, t),
              (this.scaleProperty = 1),
              (this.offsetProperty = 0),
              e.type !== o.EDataSeriesType.Ohlc)
            )
              throw new Error(
                "OhlcScaleOffsetFilter only supports Ohlc original series"
              );
            (this.scaleProperty =
              null !== (r = null == t ? void 0 : t.scale) && void 0 !== r
                ? r
                : this.scaleProperty),
              (this.offsetProperty =
                null !== (i = null == t ? void 0 : t.offset) && void 0 !== i
                  ? i
                  : this.offsetProperty),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            (this.scaleProperty = e), this.filterAll();
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            (this.offsetProperty = e), this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.OhlcScaleOffset,
                options: { scale: this.scale, offset: this.offset },
              },
            });
          }
          defaultFunction(e, t) {
            return t * this.scaleProperty + this.offsetProperty;
          }
        }
        t.OhlcScaleOffsetFilter = s;
      },
      65936: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyCustomFilter = void 0);
        const i = r(95079);
        class o extends i.XyFilterBase {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.filterFunctionProperty =
                null !== (r = null == t ? void 0 : t.filterFunction) &&
                void 0 !== r
                  ? r
                  : this.filterFunctionProperty),
              this.getOriginalCount() > 0 &&
                (null == t ? void 0 : t.filterFunction) &&
                this.filterAll();
          }
          get filterFunction() {
            return this.filterFunctionProperty;
          }
          set filterFunction(e) {
            (this.filterFunctionProperty = e), this.filterAll();
          }
          filterFunctionProperty(e, t) {
            return t;
          }
          filterOnAppend(e) {
            const {
              xValues: t,
              yValues: r,
              metadata: i,
            } = this.filter(this.count(), e);
            this.appendRange(t, r, i);
          }
          filterOnUpdate(e) {
            this.update(
              e,
              this.filterFunction(e, this.getOriginalYValues().get(e)),
              this.originalSeries.getMetadataAt(e)
            );
          }
          filterOnInsert(e, t) {
            const { xValues: r, yValues: i, metadata: o } = this.filter(e, t);
            this.insertRange(e, r, i, o);
          }
          filterOnRemove(e, t) {
            this.removeRange(e, t);
          }
          filterAll() {
            this.clear();
            const {
              xValues: e,
              yValues: t,
              metadata: r,
            } = this.filter(0, this.getOriginalCount());
            this.appendRange(e, t, r);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues(),
              o = [],
              a = [];
            let s;
            if (this.originalSeries.hasMetadata) {
              s = [];
              for (let n = e; n < e + t; n++)
                o.push(r.get(n)),
                  a.push(this.filterFunction(n, i.get(n))),
                  s.push(this.originalSeries.getMetadataAt(n));
            } else
              for (let s = e; s < e + t; s++)
                o.push(r.get(s)), a.push(this.filterFunction(s, i.get(s)));
            return { xValues: o, yValues: a, metadata: s };
          }
        }
        t.XyCustomFilter = o;
      },
      95079: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.switchData = t.XyFilterBase = t.EDataSeriesField = void 0);
        const i = r(56744),
          o = r(51885),
          a = r(9682);
        var s;
        !(function (e) {
          (e.X = "x"),
            (e.Open = "open"),
            (e.High = "high"),
            (e.Low = "low"),
            (e.Close = "close"),
            (e.Y = "y"),
            (e.Y1 = "y1"),
            (e.Z = "z");
        })((s = t.EDataSeriesField || (t.EDataSeriesField = {})));
        class n extends a.XyDataSeries {
          constructor(e, t) {
            var r, i;
            switch (
              (super(e.webAssemblyContext, t),
              (this.field = s.Y),
              (this.xField = s.X),
              (this.originalSeriesProperty = e),
              (this.field =
                null !== (r = null == t ? void 0 : t.field) && void 0 !== r
                  ? r
                  : this.field),
              (this.xField =
                null !== (i = null == t ? void 0 : t.xField) && void 0 !== i
                  ? i
                  : this.xField),
              (this.onBaseDataChanged = this.onBaseDataChanged.bind(this)),
              e.dataChanged.subscribe(this.onBaseDataChanged),
              this.originalSeries.type)
            ) {
              case o.EDataSeriesType.Xy:
                this.xField === s.Y &&
                  (this.getOriginalXValues = () =>
                    this.originalSeries.getNativeYValues()),
                  this.field === s.X &&
                    (this.getOriginalYValues = () =>
                      this.originalSeries.getNativeXValues());
                break;
              case o.EDataSeriesType.Ohlc:
                (this.getOriginalXValues = () =>
                  this.getValuesFromOHLC(this.xField, this.originalSeries)),
                  (this.getOriginalYValues = () =>
                    this.getValuesFromOHLC(this.field, this.originalSeries));
                break;
              case o.EDataSeriesType.Xyy:
                (this.getOriginalXValues = () =>
                  this.getValuesFromXyy(this.xField, this.originalSeries)),
                  (this.getOriginalYValues = () =>
                    this.getValuesFromXyy(this.field, this.originalSeries));
                break;
              case o.EDataSeriesType.Xyz:
                (this.getOriginalXValues = () =>
                  this.getValuesFromXyz(this.xField, this.originalSeries)),
                  (this.getOriginalYValues = () =>
                    this.getValuesFromXyz(this.field, this.originalSeries));
                break;
              case o.EDataSeriesType.Hlc:
                (this.getOriginalXValues = () =>
                  this.getValuesFromHlc(this.xField, this.originalSeries)),
                  (this.getOriginalYValues = () =>
                    this.getValuesFromHlc(this.field, this.originalSeries));
            }
          }
          get originalSeries() {
            return this.originalSeriesProperty;
          }
          detachFromOriginalSeries() {
            this.originalSeries.dataChanged.unsubscribe(this.onBaseDataChanged),
              (this.originalSeriesProperty = void 0);
          }
          delete() {
            (this.originalSeriesProperty = (0, i.deleteSafe)(
              this.originalSeries
            )),
              super.delete();
          }
          getOriginalXValues() {
            return this.originalSeries.getNativeXValues();
          }
          getOriginalYValues() {
            return this.originalSeries.getNativeYValues();
          }
          getOriginalCount() {
            return this.originalSeries.count();
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.filterAll();
          }
          filterOnUpdate(e) {
            this.filterAll();
          }
          filterOnInsert(e, t) {
            this.filterAll();
          }
          filterOnRemove(e, t) {
            this.filterAll();
          }
          onClear() {
            this.clear();
          }
          onBaseDataChanged(e) {
            const { changeType: t, name: r, index: i, count: a } = e;
            switch (t) {
              case o.EDataChangeType.Property:
                return void this.onOriginalPropertyChanged(r);
              case o.EDataChangeType.Append:
                this.filterOnAppend(a);
                break;
              case o.EDataChangeType.Clear:
                this.onClear();
                break;
              case o.EDataChangeType.Insert:
                this.filterOnInsert(i, a);
                break;
              case o.EDataChangeType.Remove:
                this.filterOnRemove(i, a);
                break;
              case o.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
          getValuesFromOHLC(e, r) {
            return (0, t.switchData)(
              e,
              r.getNativeXValues(),
              r.getNativeYValues(),
              r.getNativeOpenValues(),
              r.getNativeHighValues(),
              r.getNativeLowValues()
            );
          }
          getValuesFromXyy(e, r) {
            return (0, t.switchData)(
              e,
              r.getNativeXValues(),
              r.getNativeYValues(),
              r.getNativeY1Values()
            );
          }
          getValuesFromXyz(e, r) {
            return (0, t.switchData)(
              e,
              r.getNativeXValues(),
              r.getNativeYValues(),
              r.getNativeZValues()
            );
          }
          getValuesFromHlc(e, r) {
            return (0, t.switchData)(
              e,
              r.getNativeXValues(),
              r.getNativeYValues(),
              void 0,
              r.getNativeHighValues(),
              r.getNativeLowValues()
            );
          }
        }
        (t.XyFilterBase = n),
          (t.switchData = (e, t, r, i, o, a) => {
            let n;
            switch (e) {
              case s.X:
                n = t;
                break;
              case s.Close:
              case s.Y:
                n = r;
                break;
              case s.Open:
              case s.Y1:
              case s.Z:
                n = i;
                break;
              case s.High:
                n = o;
                break;
              case s.Low:
                n = a;
            }
            if (!n) throw new Error(`${e} does not exist`);
            return n;
          });
      },
      26974: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyLinearTrendFilter = void 0);
        const i = r(51097),
          o = r(95079);
        class a extends o.XyFilterBase {
          constructor(e, t) {
            super(e, t), this.getOriginalCount() > 0 && this.filterAll();
          }
          get slope() {
            return this.slopeProperty;
          }
          get intercept() {
            return this.interceptProperty;
          }
          get correlation() {
            return this.correlationProperty;
          }
          toJSON(e = !1) {
            const t = super.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.XyLinearTrend,
                options: {
                  field: this.field,
                  slope: this.slope,
                  intercept: this.intercept,
                },
              },
            });
          }
          filterAll() {
            let e = 0,
              t = 0,
              r = 0,
              i = 0,
              o = 0;
            const a = this.getOriginalXValues(),
              s = this.getOriginalYValues(),
              n = this.getOriginalCount();
            for (let n = 0; n < this.getOriginalCount(); n++) {
              const l = s.get(n),
                d = a.get(n);
              (e += d * l),
                (t += d),
                (r += l),
                (i += Math.pow(d, 2)),
                (o += Math.pow(l, 2));
            }
            const l = e * n,
              d = t * r,
              h = i * n,
              u = Math.pow(t, 2);
            (this.correlationProperty =
              (l - d) / Math.sqrt((h - u) * (o * n - Math.pow(r, 2)))),
              (this.slopeProperty = (l - d) / (h - u));
            const c = this.slopeProperty * t;
            this.interceptProperty = (r - c) / n;
            const p = [],
              g = [];
            for (let e = 0; e < n; e++) {
              const t = a.get(e);
              g.push(t),
                p.push(t * this.slopeProperty + this.interceptProperty);
            }
            this.clear(), this.appendRange(g, p);
          }
        }
        t.XyLinearTrendFilter = a;
      },
      95632: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyMovingAverageFilter = void 0);
        const i = r(51097),
          o = r(95079);
        class a extends o.XyFilterBase {
          constructor(e, t) {
            var r;
            if (
              (super(e, t),
              (this.lengthProperty = 30),
              (this.buffer = []),
              (this.pointer = -1),
              (this.bufferTotal = 0),
              (this.lengthProperty =
                null !== (r = null == t ? void 0 : t.length) && void 0 !== r
                  ? r
                  : this.lengthProperty),
              !e.dataDistributionCalculator.isSortedAscending)
            )
              throw new Error(
                "XyMovingAverageFilter requires original data to be sorted in X"
              );
            this.getOriginalCount() > 0 && this.calculate(0);
          }
          get length() {
            return this.lengthProperty;
          }
          set length(e) {
            (this.lengthProperty = e), this.calculate(0);
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.XyMovingAverage,
                options: { field: this.field, length: this.length },
              },
            });
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.calculate(this.count());
          }
          filterOnUpdate(e) {
            const t = this.getOriginalYValues().get(e) || 0;
            this.calculateUpdate(e, t);
          }
          filterOnInsert(e, t) {
            this.calculate(e);
          }
          filterOnRemove(e, t) {
            this.calculate(e);
          }
          filterAll() {
            this.calculate(0);
          }
          calculateUpdate(e, t) {
            if (e < this.count() - 1) this.calculate(e);
            else {
              const r = this.buffer[this.pointer];
              (this.bufferTotal = this.bufferTotal - r + t),
                (this.buffer[this.pointer] = t),
                this.update(e, this.bufferTotal / this.length);
            }
          }
          calculate(e) {
            const t = e;
            e < this.count() &&
              (0 === e ? this.clear() : this.removeRange(e, this.count() - e),
              (e = Math.max(0, e - this.length + 1)),
              (this.buffer = []),
              (this.pointer = -1),
              (this.bufferTotal = 0));
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues();
            Math.min(this.length, this.getOriginalCount());
            for (let o = e; o < this.getOriginalCount(); o++) {
              const e = r.get(o) || 0,
                a = i.get(o) || 0;
              this.pointer = (this.pointer + 1) % this.length;
              const s = this.buffer[this.pointer];
              (this.buffer[this.pointer] = a),
                (this.bufferTotal = this.bufferTotal + a - (null != s ? s : 0)),
                this.buffer.length === this.length
                  ? this.append(e, this.bufferTotal / this.length)
                  : t < this.length && this.append(e, NaN);
            }
          }
        }
        t.XyMovingAverageFilter = a;
      },
      55007: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyRatioFilter = void 0);
        const i = r(23866),
          o = r(51097),
          a = r(51885),
          s = r(95079);
        class n extends s.XyFilterBase {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.divisorField = s.EDataSeriesField.Y),
              i.Guard.notNull(t.divisorSeries, "divisorSeries"),
              (this.divisorSeries = t.divisorSeries),
              (this.divisorField =
                null !== (r = t.divisorField) && void 0 !== r
                  ? r
                  : this.divisorField),
              (this.onDivisorDataChanged =
                this.onDivisorDataChanged.bind(this)),
              this.divisorSeries.dataChanged.subscribe(
                this.onDivisorDataChanged
              ),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e),
              r = [],
              i = this.getDivisorYValues();
            for (let e = 0; e < this.divisorSeries.count(); e++)
              r.push(i.get(e));
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: o.EDataFilterType.XyRatio,
                options: { field: this.field, divisorSeries: r },
              },
            });
          }
          filterOnAppend(e) {
            if (this.getOriginalCount() !== this.divisorSeries.count()) return;
            const { xValues: t, yValues: r } = this.filter(this.count(), e);
            this.appendRange(t, r);
          }
          filterOnUpdate(e) {
            this.update(
              e,
              this.getOriginalYValues().get(e) / this.getDivisorYValues().get(e)
            );
          }
          filterOnInsert(e, t) {
            if (this.getOriginalCount() !== this.divisorSeries.count()) return;
            const { xValues: r, yValues: i } = this.filter(e, t);
            this.insertRange(e, r, i);
          }
          filterOnRemove(e, t) {
            this.getOriginalCount() === this.divisorSeries.count() &&
              this.removeRange(e, t);
          }
          filterAll() {
            if (this.getOriginalCount() !== this.divisorSeries.count()) return;
            this.clear();
            const { xValues: e, yValues: t } = this.filter(
              0,
              this.getOriginalCount()
            );
            this.appendRange(e, t);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues(),
              o = [],
              a = [];
            for (let s = e; s < e + t; s++)
              o.push(r.get(s)),
                a.push(i.get(s) / this.getDivisorYValues().get(s));
            return { xValues: o, yValues: a };
          }
          getDivisorYValues() {
            let e = this.divisorSeries.getNativeYValues();
            if (this.divisorSeries.type === a.EDataSeriesType.Xyy) {
              const t = this.divisorSeries;
              e = (0, s.switchData)(
                this.divisorField,
                t.getNativeYValues(),
                t.getNativeY1Values()
              );
            } else if (this.divisorSeries.type === a.EDataSeriesType.Xyz) {
              const t = this.divisorSeries;
              e = (0, s.switchData)(
                this.field,
                t.getNativeYValues(),
                t.getNativeZValues()
              );
            } else if (this.divisorSeries.type === a.EDataSeriesType.Ohlc) {
              const t = this.divisorSeries;
              e = (0, s.switchData)(
                this.field,
                t.getNativeYValues(),
                t.getNativeOpenValues(),
                t.getNativeHighValues(),
                t.getNativeLowValues()
              );
            }
            return e;
          }
          onDivisorDataChanged(e) {
            const { changeType: t, name: r, index: i, count: o } = e;
            switch (t) {
              case a.EDataChangeType.Append:
                this.filterOnAppend(o);
                break;
              case a.EDataChangeType.Clear:
                this.onClear();
                break;
              case a.EDataChangeType.Insert:
                this.filterOnInsert(i, o);
                break;
              case a.EDataChangeType.Remove:
                this.filterOnRemove(i, o);
                break;
              case a.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
        }
        t.XyRatioFilter = n;
      },
      39892: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyScaleOffsetFilter = void 0);
        const i = r(51097),
          o = r(65936);
        class a extends o.XyCustomFilter {
          constructor(e, t) {
            var r, i;
            super(e, t),
              (this.scaleProperty = 1),
              (this.offsetProperty = 0),
              (this.scaleProperty =
                null !== (r = null == t ? void 0 : t.scale) && void 0 !== r
                  ? r
                  : this.scaleProperty),
              (this.offsetProperty =
                null !== (i = null == t ? void 0 : t.offset) && void 0 !== i
                  ? i
                  : this.offsetProperty),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            (this.scaleProperty = e), this.filterAll();
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            (this.offsetProperty = e), this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.XyScaleOffset,
                options: {
                  field: this.field,
                  scale: this.scale,
                  offset: this.offset,
                },
              },
            });
          }
          filterFunctionProperty(e, t) {
            return t * this.scaleProperty + this.offsetProperty;
          }
        }
        t.XyScaleOffsetFilter = a;
      },
      42790: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyyCustomFilter = void 0);
        const i = r(20278);
        class o extends i.XyyFilterBase {
          constructor(e, t) {
            var r, i;
            super(e, t),
              (this.filterFunctionProperty =
                null !== (r = null == t ? void 0 : t.filterFunction) &&
                void 0 !== r
                  ? r
                  : this.filterFunctionProperty),
              (this.y1filterFunctionProperty =
                null !== (i = null == t ? void 0 : t.y1filterFunction) &&
                void 0 !== i
                  ? i
                  : this.filterFunctionProperty),
              this.getOriginalCount() > 0 &&
                ((null == t ? void 0 : t.filterFunction) ||
                  (null == t ? void 0 : t.y1filterFunction)) &&
                this.filterAll();
          }
          get filterFunction() {
            return this.filterFunctionProperty;
          }
          set filterFunction(e) {
            (this.filterFunctionProperty = e), this.filterAll();
          }
          filterFunctionProperty(e, t) {
            return t;
          }
          get y1filterFunction() {
            return this.y1filterFunctionProperty;
          }
          set y1yfilterFunction(e) {
            (this.y1filterFunctionProperty = e), this.filterAll();
          }
          y1filterFunctionProperty(e, t) {
            return t;
          }
          filterOnAppend(e) {
            const {
              xValues: t,
              yValues: r,
              y1Values: i,
              metadata: o,
            } = this.filter(this.count(), e);
            this.appendRange(t, r, i, o);
          }
          filterOnUpdate(e) {
            this.update(
              e,
              this.filterFunction(e, this.getOriginalYValues().get(e)),
              this.y1filterFunction(e, this.getOriginalY1Values().get(e)),
              this.originalSeries.getMetadataAt(e)
            );
          }
          filterOnInsert(e, t) {
            const {
              xValues: r,
              yValues: i,
              y1Values: o,
              metadata: a,
            } = this.filter(e, t);
            this.insertRange(e, r, i, o, a);
          }
          filterOnRemove(e, t) {
            this.removeRange(e, t);
          }
          filterAll() {
            this.clear();
            const {
              xValues: e,
              yValues: t,
              y1Values: r,
              metadata: i,
            } = this.filter(0, this.getOriginalCount());
            this.appendRange(e, t, r, i);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues(),
              o = this.getOriginalY1Values(),
              a = [],
              s = [],
              n = [];
            let l;
            if (this.originalSeries.hasMetadata) {
              l = [];
              for (let d = e; d < e + t; d++)
                a.push(r.get(d)),
                  s.push(this.filterFunction(d, i.get(d))),
                  n.push(this.y1filterFunction(d, o.get(d))),
                  l.push(this.originalSeries.getMetadataAt(d));
            } else
              for (let l = e; l < e + t; l++)
                a.push(r.get(l)),
                  s.push(this.filterFunction(l, i.get(l))),
                  n.push(this.y1filterFunction(l, o.get(l)));
            return { xValues: a, yValues: s, y1Values: n, metadata: l };
          }
        }
        t.XyyCustomFilter = o;
      },
      20278: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyyFilterBase = void 0);
        const i = r(56744),
          o = r(51885),
          a = r(75650),
          s = r(95079);
        class n extends a.XyyDataSeries {
          constructor(e, t) {
            var r, i;
            switch (
              (super(e.webAssemblyContext, t),
              (this.yfield = s.EDataSeriesField.Y),
              (this.y1field = s.EDataSeriesField.Y1),
              (this.originalSeriesProperty = e),
              (this.yfield =
                null !== (r = null == t ? void 0 : t.yfield) && void 0 !== r
                  ? r
                  : this.yfield),
              (this.yfield =
                null !== (i = null == t ? void 0 : t.yfield) && void 0 !== i
                  ? i
                  : this.yfield),
              (this.onBaseDataChanged = this.onBaseDataChanged.bind(this)),
              e.dataChanged.subscribe(this.onBaseDataChanged),
              this.originalSeries.type)
            ) {
              case o.EDataSeriesType.Ohlc:
                const e = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    e.getNativeYValues(),
                    e.getNativeOpenValues(),
                    e.getNativeHighValues(),
                    e.getNativeLowValues()
                  )),
                  (this.getOriginalY1Values = () =>
                    (0, s.switchData)(
                      this.y1field,
                      e.getNativeYValues(),
                      e.getNativeOpenValues(),
                      e.getNativeHighValues(),
                      e.getNativeLowValues()
                    ));
                break;
              case o.EDataSeriesType.Xy:
                const t = this.originalSeries;
                (this.getOriginalYValues = () => t.getNativeYValues()),
                  (this.getOriginalY1Values = () => t.getNativeYValues());
                break;
              case o.EDataSeriesType.Xyz:
                const r = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    r.getNativeYValues(),
                    r.getNativeZValues()
                  )),
                  (this.getOriginalY1Values = () =>
                    (0, s.switchData)(
                      this.y1field,
                      r.getNativeYValues(),
                      r.getNativeZValues()
                    ));
                break;
              case o.EDataSeriesType.Hlc:
                const i = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    i.getNativeYValues(),
                    void 0,
                    i.getNativeHighValues(),
                    i.getNativeLowValues()
                  )),
                  (this.getOriginalY1Values = () =>
                    (0, s.switchData)(
                      this.y1field,
                      i.getNativeYValues(),
                      void 0,
                      i.getNativeHighValues(),
                      i.getNativeLowValues()
                    ));
            }
          }
          get originalSeries() {
            return this.originalSeriesProperty;
          }
          detachFromOriginalSeries() {
            this.originalSeries.dataChanged.unsubscribe(this.onBaseDataChanged),
              (this.originalSeriesProperty = void 0);
          }
          delete() {
            (this.originalSeriesProperty = (0, i.deleteSafe)(
              this.originalSeries
            )),
              super.delete();
          }
          getOriginalXValues() {
            return this.originalSeries.getNativeXValues();
          }
          getOriginalYValues() {
            return this.originalSeries.getNativeYValues();
          }
          getOriginalY1Values() {
            return this.originalSeries.getNativeY1Values();
          }
          getOriginalCount() {
            return this.originalSeries.count();
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.filterAll();
          }
          filterOnUpdate(e) {
            this.filterAll();
          }
          filterOnInsert(e, t) {
            this.filterAll();
          }
          filterOnRemove(e, t) {
            this.filterAll();
          }
          onClear() {
            this.clear();
          }
          onBaseDataChanged(e) {
            const { changeType: t, name: r, index: i, count: a } = e;
            switch (t) {
              case o.EDataChangeType.Property:
                return void this.onOriginalPropertyChanged(r);
              case o.EDataChangeType.Append:
                this.filterOnAppend(a);
                break;
              case o.EDataChangeType.Clear:
                this.onClear();
                break;
              case o.EDataChangeType.Insert:
                this.filterOnInsert(i, a);
                break;
              case o.EDataChangeType.Remove:
                this.filterOnRemove(i, a);
                break;
              case o.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
        }
        t.XyyFilterBase = n;
      },
      91154: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyyScaleOffsetFilter = void 0);
        const i = r(51097),
          o = r(42790);
        class a extends o.XyyCustomFilter {
          constructor(e, t) {
            var r, i;
            super(e, t),
              (this.scaleProperty = 1),
              (this.offsetProperty = 0),
              (this.scaleProperty =
                null !== (r = null == t ? void 0 : t.scale) && void 0 !== r
                  ? r
                  : this.scaleProperty),
              (this.offsetProperty =
                null !== (i = null == t ? void 0 : t.offset) && void 0 !== i
                  ? i
                  : this.offsetProperty),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            (this.scaleProperty = e), this.filterAll();
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            (this.offsetProperty = e), this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.XyyScaleOffset,
                options: {
                  yfield: this.yfield,
                  y1field: this.y1field,
                  scale: this.scale,
                  offset: this.offset,
                },
              },
            });
          }
          filterFunctionProperty(e, t) {
            return t * this.scaleProperty + this.offsetProperty;
          }
        }
        t.XyyScaleOffsetFilter = a;
      },
      86241: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzCustomFilter = void 0);
        const i = r(84872);
        class o extends i.XyzFilterBase {
          constructor(e, t) {
            var r, i;
            super(e, t),
              (this.filterFunctionProperty =
                null !== (r = null == t ? void 0 : t.filterFunction) &&
                void 0 !== r
                  ? r
                  : this.filterFunctionProperty),
              (this.zfilterFunctionProperty =
                null !== (i = null == t ? void 0 : t.zfilterFunction) &&
                void 0 !== i
                  ? i
                  : this.filterFunctionProperty),
              this.getOriginalCount() > 0 &&
                ((null == t ? void 0 : t.filterFunction) ||
                  (null == t ? void 0 : t.zfilterFunction)) &&
                this.filterAll();
          }
          get filterFunction() {
            return this.filterFunctionProperty;
          }
          set filterFunction(e) {
            (this.filterFunctionProperty = e), this.filterAll();
          }
          filterFunctionProperty(e, t) {
            return t;
          }
          get zfilterFunction() {
            return this.zfilterFunctionProperty;
          }
          set zfilterFunction(e) {
            (this.zfilterFunctionProperty = e), this.filterAll();
          }
          zfilterFunctionProperty(e, t) {
            return t;
          }
          filterOnAppend(e) {
            const {
              xValues: t,
              yValues: r,
              zValues: i,
              metadata: o,
            } = this.filter(this.count(), e);
            this.appendRange(t, r, i, o);
          }
          filterOnUpdate(e) {
            this.update(
              e,
              this.filterFunction(e, this.getOriginalYValues().get(e)),
              this.zfilterFunction(e, this.getOriginalZValues().get(e)),
              this.originalSeries.getMetadataAt(e)
            );
          }
          filterOnInsert(e, t) {
            const {
              xValues: r,
              yValues: i,
              zValues: o,
              metadata: a,
            } = this.filter(e, t);
            this.insertRange(e, r, i, o, a);
          }
          filterOnRemove(e, t) {
            this.removeRange(e, t);
          }
          filterAll() {
            this.clear();
            const {
              xValues: e,
              yValues: t,
              zValues: r,
              metadata: i,
            } = this.filter(0, this.getOriginalCount());
            this.appendRange(e, t, r, i);
          }
          filter(e, t) {
            const r = this.getOriginalXValues(),
              i = this.getOriginalYValues(),
              o = this.getOriginalZValues(),
              a = [],
              s = [],
              n = [];
            let l;
            if (this.originalSeries.hasMetadata) {
              l = [];
              for (let d = e; d < e + t; d++)
                a.push(r.get(d)),
                  s.push(this.filterFunction(d, i.get(d))),
                  n.push(this.zfilterFunction(d, o.get(d))),
                  l.push(this.originalSeries.getMetadataAt(d));
            } else
              for (let l = e; l < e + t; l++)
                a.push(r.get(l)),
                  s.push(this.filterFunction(l, i.get(l))),
                  n.push(this.zfilterFunction(l, o.get(l)));
            return { xValues: a, yValues: s, zValues: n, metadata: l };
          }
        }
        t.XyzCustomFilter = o;
      },
      84872: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzFilterBase = void 0);
        const i = r(56744),
          o = r(51885),
          a = r(35508),
          s = r(95079);
        class n extends a.XyzDataSeries {
          constructor(e, t) {
            var r, i;
            switch (
              (super(e.webAssemblyContext, t),
              (this.yfield = s.EDataSeriesField.Y),
              (this.zfield = s.EDataSeriesField.Z),
              (this.originalSeriesProperty = e),
              (this.yfield =
                null !== (r = null == t ? void 0 : t.yfield) && void 0 !== r
                  ? r
                  : this.yfield),
              (this.zfield =
                null !== (i = null == t ? void 0 : t.zfield) && void 0 !== i
                  ? i
                  : this.zfield),
              (this.onBaseDataChanged = this.onBaseDataChanged.bind(this)),
              e.dataChanged.subscribe(this.onBaseDataChanged),
              this.originalSeries.type)
            ) {
              case o.EDataSeriesType.Ohlc:
                const e = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    e.getNativeYValues(),
                    e.getNativeOpenValues(),
                    e.getNativeHighValues(),
                    e.getNativeLowValues()
                  )),
                  (this.getOriginalZValues = () =>
                    (0, s.switchData)(
                      this.zfield,
                      e.getNativeYValues(),
                      e.getNativeOpenValues(),
                      e.getNativeHighValues(),
                      e.getNativeLowValues()
                    ));
                break;
              case o.EDataSeriesType.Xy:
                const t = this.originalSeries;
                (this.getOriginalYValues = () => t.getNativeYValues()),
                  (this.getOriginalZValues = () => t.getNativeYValues());
                break;
              case o.EDataSeriesType.Xyy:
                const r = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    r.getNativeYValues(),
                    r.getNativeY1Values()
                  )),
                  (this.getOriginalZValues = () =>
                    (0, s.switchData)(
                      this.zfield,
                      r.getNativeYValues(),
                      r.getNativeY1Values()
                    ));
                break;
              case o.EDataSeriesType.Hlc:
                const i = this.originalSeries;
                (this.getOriginalYValues = () =>
                  (0, s.switchData)(
                    this.yfield,
                    i.getNativeYValues(),
                    void 0,
                    i.getNativeHighValues(),
                    i.getNativeLowValues()
                  )),
                  (this.getOriginalZValues = () =>
                    (0, s.switchData)(
                      this.zfield,
                      i.getNativeYValues(),
                      void 0,
                      i.getNativeHighValues(),
                      i.getNativeLowValues()
                    ));
            }
          }
          get originalSeries() {
            return this.originalSeriesProperty;
          }
          detachFromOriginalSeries() {
            this.originalSeries.dataChanged.unsubscribe(this.onBaseDataChanged),
              (this.originalSeriesProperty = void 0);
          }
          delete() {
            (this.originalSeriesProperty = (0, i.deleteSafe)(
              this.originalSeries
            )),
              super.delete();
          }
          getOriginalXValues() {
            return this.originalSeries.getNativeXValues();
          }
          getOriginalYValues() {
            return this.originalSeries.getNativeYValues();
          }
          getOriginalZValues() {
            return this.originalSeries.getNativeZValues();
          }
          getOriginalCount() {
            return this.originalSeries.count();
          }
          onOriginalPropertyChanged(e) {}
          filterOnAppend(e) {
            this.filterAll();
          }
          filterOnUpdate(e) {
            this.filterAll();
          }
          filterOnInsert(e, t) {
            this.filterAll();
          }
          filterOnRemove(e, t) {
            this.filterAll();
          }
          onClear() {
            this.clear();
          }
          onBaseDataChanged(e) {
            const { changeType: t, name: r, index: i, count: a } = e;
            switch (t) {
              case o.EDataChangeType.Property:
                return void this.onOriginalPropertyChanged(r);
              case o.EDataChangeType.Append:
                this.filterOnAppend(a);
                break;
              case o.EDataChangeType.Clear:
                this.onClear();
                break;
              case o.EDataChangeType.Insert:
                this.filterOnInsert(i, a);
                break;
              case o.EDataChangeType.Remove:
                this.filterOnRemove(i, a);
                break;
              case o.EDataChangeType.Update:
                this.filterOnUpdate(i);
            }
          }
        }
        t.XyzFilterBase = n;
      },
      92475: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzScaleOffsetFilter = void 0);
        const i = r(51097),
          o = r(86241);
        class a extends o.XyzCustomFilter {
          constructor(e, t) {
            var r, i;
            super(e, t),
              (this.scaleProperty = 1),
              (this.offsetProperty = 0),
              (this.scaleProperty =
                null !== (r = null == t ? void 0 : t.scale) && void 0 !== r
                  ? r
                  : this.scaleProperty),
              (this.offsetProperty =
                null !== (i = null == t ? void 0 : t.offset) && void 0 !== i
                  ? i
                  : this.offsetProperty),
              this.getOriginalCount() > 0 && this.filterAll();
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            (this.scaleProperty = e), this.filterAll();
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            (this.offsetProperty = e), this.filterAll();
          }
          toJSON(e = !1) {
            const t = this.originalSeries.toJSON(e);
            return Object.assign(Object.assign({}, t), {
              filter: {
                type: i.EDataFilterType.XyzScaleOffset,
                options: {
                  yfield: this.yfield,
                  zfield: this.zfield,
                  scale: this.scale,
                  offset: this.offset,
                },
              },
            });
          }
          filterFunctionProperty(e, t) {
            return t * this.scaleProperty + this.offsetProperty;
          }
        }
        t.XyzScaleOffsetFilter = a;
      },
      22382: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcDataSeries = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(26361),
          n = r(54624),
          l = r(9073),
          d = r(72934),
          h = r(24933),
          u = r(51885);
        class c extends h.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 3,
                valueNames: [
                  n.EValueName.Close,
                  n.EValueName.High,
                  n.EValueName.Low,
                ],
                includeInYRange: [!0, !0, !0],
              })
            ),
              (this.type = u.EDataSeriesType.Hlc),
              (null == t ? void 0 : t.xValues) &&
                (o.Guard.notNull(t.yValues, "options.yValues"),
                o.Guard.notNull(t.highValues, "options.highValues"),
                o.Guard.notNull(t.lowValues, "options.lowValues"),
                this.appendRange(
                  t.xValues,
                  t.yValues,
                  t.highValues,
                  t.lowValues,
                  t.metadata
                ),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.highValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.lowValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get highValues() {
            return this.getNativeYValues(1);
          }
          get lowValues() {
            return this.getNativeYValues(2);
          }
          getNativeHighValues() {
            return this.highValues;
          }
          getNativeLowValues() {
            return this.lowValues;
          }
          append(e, t, r, i, o) {
            super.appendN(e, [t, r, i], o);
          }
          appendRange(e, t, r, i, o) {
            super.appendRangeN(e, [t, r, i], o);
          }
          update(e, t, r, i, o) {
            super.updateN(e, [t, r, i], o);
          }
          updateXyhl(e, t, r, i, o, a) {
            super.updateXyN(e, t, [r, i, o], a);
          }
          insert(e, t, r, i, o, a) {
            super.insertN(e, t, [r, i, o], a);
          }
          insertRange(e, t, r, i, o, a) {
            super.insertRangeN(e, t, [r, i, o], a);
          }
          getXRange(e, t, r, o) {
            const s = this.getXValues(e),
              { hValues: n, lValues: l } = this.getHlcValues(e);
            let h;
            if (t) {
              if (1 === this.count()) {
                const e = r ? n : s,
                  t = (o ? l : s).get(0) - 1,
                  i = e.get(0) + 1;
                return new a.NumberRange(t, i);
              }
              if (this.count() > 1) {
                let e, t, s;
                try {
                  if (
                    ((s = this.webAssemblyContext.NumberUtil.MinMax(
                      o ? this.getNativeLowValues() : this.getNativeXValues()
                    )),
                    (e = s.minD),
                    (s = this.webAssemblyContext.NumberUtil.MinMax(
                      r ? this.getNativeHighValues() : this.getNativeXValues()
                    )),
                    (t = s.maxD),
                    !(0, d.isRealNumber)(e) || !(0, d.isRealNumber)(t))
                  )
                    return new a.NumberRange(0, 0);
                } finally {
                  (0, i.deleteSafe)(s);
                }
                return e === t
                  ? new a.NumberRange(e - 1, t + 1)
                  : (e > t && ((h = e), (e = t), (t = h)),
                    new a.NumberRange(e, t));
              }
            } else {
              if (1 === this.count()) {
                const e = s.get(0) - 1,
                  t = s.get(0) + 1;
                return new a.NumberRange(e, t);
              }
              if (this.count() > 1) {
                let e = s.get(0),
                  t = s.get(this.count() - 1);
                if (!this.dataDistributionCalculator.isSortedAscending) {
                  let r;
                  try {
                    if (
                      ((r = this.webAssemblyContext.NumberUtil.MinMax(
                        this.getNativeXValues()
                      )),
                      !(0, d.isRealNumber)(r.minD) ||
                        !(0, d.isRealNumber)(r.maxD))
                    )
                      return new a.NumberRange(0, 0);
                    (e = r.minD), (t = r.maxD);
                  } finally {
                    (0, i.deleteSafe)(r);
                  }
                }
                return e === t
                  ? new a.NumberRange(e - 1, t + 1)
                  : (e > t && ((h = e), (e = t), (t = h)),
                    new a.NumberRange(e, t));
              }
            }
            return new a.NumberRange(0, 0);
          }
          getWindowedYRange(
            e,
            t,
            r = !1,
            o = u.EDataSeriesValueType.Default,
            n = l.EYRangeMode.Visible,
            h = !1,
            c,
            p
          ) {
            const { hValues: g, lValues: y, yValues: f } = this.getHlcValues(o);
            if (1 === this.count() && !h) {
              if (h) {
                const e = f.get(0);
                return new a.NumberRange(e, e);
              }
              {
                const e = Math.min(g.get(0), y.get(0)),
                  t = Math.max(g.get(0), y.get(0));
                return new a.NumberRange(e, t);
              }
            }
            const v = r
              ? e
              : this.getIndicesRange(
                  e,
                  !1,
                  n === l.EYRangeMode.Visible
                    ? s.ESearchMode.RoundUp
                    : s.ESearchMode.RoundDown,
                  n === l.EYRangeMode.Visible
                    ? s.ESearchMode.RoundDown
                    : s.ESearchMode.RoundUp
                );
            let m = Number.MAX_VALUE,
              S = Number.NEGATIVE_INFINITY;
            const P = Math.max(Math.floor(v.min), 0),
              C = Math.min(Math.ceil(v.max), this.count() - 1);
            if (!(C < P)) {
              if (h) {
                let e;
                try {
                  if (
                    ((e = this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                      f,
                      P,
                      C - P + 1
                    )),
                    !(0, d.isRealNumber)(e.minD) ||
                      !(0, d.isRealNumber)(e.maxD))
                  )
                    return new a.NumberRange(0, 0);
                  (m = e.minD), (S = e.maxD);
                } finally {
                  (0, i.deleteSafe)(e);
                }
              } else {
                const e = c ? g : f,
                  t = p ? y : f;
                let r;
                try {
                  if (
                    ((r = this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                      e,
                      P,
                      C - P + 1
                    )),
                    !(0, d.isRealNumber)(r.minD) ||
                      !(0, d.isRealNumber)(r.maxD))
                  )
                    return new a.NumberRange(0, 0);
                  if (
                    ((S = r.maxD),
                    (r = this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                      t,
                      P,
                      C - P + 1
                    )),
                    !(0, d.isRealNumber)(r.minD) ||
                      !(0, d.isRealNumber)(r.maxD))
                  )
                    return new a.NumberRange(0, 0);
                  m = r.minD;
                } finally {
                  (0, i.deleteSafe)(r);
                }
              }
              return new a.NumberRange(m, S);
            }
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e),
                a = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t)),
                    (o[t] = this.highValues.getRaw(t)),
                    (a[t] = this.lowValues.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.yValues.get(t)),
                    (o[t] = this.highValues.get(t)),
                    (a[t] = this.lowValues.get(t));
              const s = { xValues: r, yValues: i, highValues: o, lowValues: a };
              Object.assign(t, s);
            }
            return t;
          }
          getHlcValues(e) {
            let t, r, i;
            switch (e) {
              case u.EDataSeriesValueType.FinalAnimationValues:
                (t = this.yFinalAnimationValuesArray[1]),
                  (r = this.yFinalAnimationValuesArray[2]),
                  (i = this.yFinalAnimationValuesArray[0]);
                break;
              case u.EDataSeriesValueType.InitialAnimationValues:
                (t = this.yInitialAnimationValuesArray[1]),
                  (r = this.yInitialAnimationValuesArray[2]),
                  (i = this.yInitialAnimationValuesArray[0]);
                break;
              default:
                (t = this.highValues), (r = this.lowValues), (i = this.yValues);
            }
            return { hValues: t, lValues: r, yValues: i };
          }
        }
        t.HlcDataSeries = c;
      },
      51885: (e, t) => {
        "use strict";
        var r, i, o;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDataSeriesValueType =
            t.EDataChangeType =
            t.EDataSeriesType =
              void 0),
          ((o = t.EDataSeriesType || (t.EDataSeriesType = {})).XyN = "XyN"),
          (o.Xy = "Xy"),
          (o.Xyy = "Xyy"),
          (o.Xyz = "Xyz"),
          (o.Ohlc = "Ohlc"),
          (o.HeatmapUniform = "UniformHeatmap"),
          (o.HeatmapNonUniform = "NonUniformHeatmap"),
          (o.Hlc = "Hlc"),
          (o.XyText = "XyText"),
          (o.Xyxy = "Xyxy"),
          (o.Xyx = "Xyx"),
          (o.X = "X"),
          (o.BoxPlot = "BoxPlot"),
          ((i = t.EDataChangeType || (t.EDataChangeType = {}))[(i.Append = 0)] =
            "Append"),
          (i[(i.Insert = 1)] = "Insert"),
          (i[(i.Update = 2)] = "Update"),
          (i[(i.Remove = 3)] = "Remove"),
          (i[(i.Clear = 4)] = "Clear"),
          (i[(i.Property = 5)] = "Property"),
          ((r =
            t.EDataSeriesValueType || (t.EDataSeriesValueType = {})).Default =
            "Default"),
          (r.InitialAnimationValues = "InitialAnimationValues"),
          (r.FinalAnimationValues = "FinalAnimationValues");
      },
      32747: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DefaultPaletteProvider =
            t.EFillPaletteMode =
            t.EStrokePaletteMode =
              void 0),
          (function (e) {
            (e.GRADIENT = "GRADIENT"), (e.SOLID = "SOLID");
          })((r = t.EStrokePaletteMode || (t.EStrokePaletteMode = {}))),
          (function (e) {
            (e.GRADIENT = "GRADIENT"), (e.SOLID = "SOLID");
          })((i = t.EFillPaletteMode || (t.EFillPaletteMode = {})));
        class o {
          constructor() {
            (this.strokePaletteMode = r.GRADIENT),
              (this.fillPaletteMode = i.GRADIENT);
          }
          static createEmpty() {
            const e = new o();
            return (
              (e.overrideFillArgb = void 0),
              (e.overrideStrokeArgb = void 0),
              (e.overridePointMarkerArgb = void 0),
              e
            );
          }
          onAttached(e) {
            this.parentSeries = e;
          }
          onDetached() {
            this.parentSeries = void 0;
          }
          get isRangeIndependant() {
            return !1;
          }
          shouldUpdatePalette() {
            return !0;
          }
          overrideFillArgb(e, t, r, i, o) {}
          overrideStrokeArgb(e, t, r, i, o) {}
          overridePointMarkerArgb(e, t, r, i, o) {}
          toJSON() {}
        }
        t.DefaultPaletteProvider = o;
      },
      33906: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TemplateMetadataGenerator = void 0),
          (t.TemplateMetadataGenerator = class {
            constructor(e) {
              this.template = e;
            }
            getSingleMetadata() {
              return Object.assign({}, this.template);
            }
            getMetadata() {}
            toJSON() {
              return "toJSON" in this.template
                ? this.template.toJSON()
                : this.template;
            }
          });
      },
      25907: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MetadataPaletteProvider = void 0);
        const i = r(48008),
          o = r(32747);
        t.MetadataPaletteProvider = class {
          constructor() {
            (this.strokePaletteMode = o.EStrokePaletteMode.SOLID),
              (this.fillPaletteMode = o.EFillPaletteMode.SOLID);
          }
          onAttached(e) {}
          onDetached() {}
          overrideFillArgb(e, t, r, o, a) {
            if (a && a.fill)
              return "string" == typeof a.fill
                ? (0, i.parseColorToUIntArgb)(a.fill)
                : a.fill;
          }
          overrideStrokeArgb(e, t, r, o, a) {
            if (a && a.stroke)
              return "string" == typeof a.stroke
                ? (0, i.parseColorToUIntArgb)(a.stroke)
                : a.stroke;
          }
          overridePointMarkerArgb(e, t, r, o, a) {
            if (!a) return;
            let s, n;
            return (
              (s =
                "string" == typeof a.stroke
                  ? (0, i.parseColorToUIntArgb)(a.stroke)
                  : a.stroke),
              (n =
                "string" == typeof a.fill
                  ? (0, i.parseColorToUIntArgb)(a.fill)
                  : a.fill),
              { stroke: s, fill: n }
            );
          }
        };
      },
      43427: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonUniformHeatmapDataSeries = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(99176),
          n = r(27699),
          l = r(24933),
          d = r(16179),
          h = r(51885);
        class u extends d.BaseHeatmapDataSeries {
          constructor(e, t) {
            if (
              (super(e, t),
              (this.type = h.EDataSeriesType.HeatmapNonUniform),
              o.Guard.notNull(t.xCellOffsets, "options.xCellOffsets"),
              o.Guard.notNull(t.yCellOffsets, "options.yCellOffsets"),
              Array.isArray(t.xCellOffsets))
            ) {
              if (t.xCellOffsets.length < this.arrayWidth + 1)
                throw new Error(
                  "xCellOffsets array should not be smaller than zValues width!"
                );
              this.xCellOffsetsProperty = t.xCellOffsets;
            } else this.xCellOffsetsGeneratorFunction = t.xCellOffsets;
            if (Array.isArray(t.yCellOffsets)) {
              if (t.yCellOffsets.length < this.arrayHeight + 1)
                throw new Error(
                  "yCellOffsets array should not be smaller than zValues height!"
                );
              this.yCellOffsetsProperty = t.yCellOffsets;
            } else this.yCellOffsetsGeneratorFunction = t.yCellOffsets;
            (this.nativeXOffsetsProperty =
              new this.webAssemblyContext.SCRTDoubleVector()),
              (this.nativeYOffsetsProperty =
                new this.webAssemblyContext.SCRTDoubleVector()),
              this.getZValues() &&
                this.notifyDataChanged(h.EDataChangeType.Append);
          }
          get xCellSizes() {
            return (
              this.xCellSizesProperty ||
                (this.xCellSizesProperty = this.calculateCellSizes(
                  this.xCellOffsetsProperty
                )),
              this.xCellSizesProperty
            );
          }
          get yCellSizes() {
            return (
              this.yCellSizesProperty ||
                (this.yCellSizesProperty = this.calculateCellSizes(
                  this.yCellOffsetsProperty
                )),
              this.yCellSizesProperty
            );
          }
          get xCellOffsets() {
            return this.xCellOffsetsProperty;
          }
          get yCellOffsets() {
            return this.yCellOffsetsProperty;
          }
          get nativeXCellOffsets() {
            return (
              this.nativeXOffsetsProperty ||
                ((this.nativeXOffsetsProperty = new s.SCRTDoubleVector()),
                (0, n.appendDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  this.nativeXOffsetsProperty,
                  this.xCellOffsets
                )),
              this.nativeXOffsetsProperty
            );
          }
          get nativeYCellOffsets() {
            return (
              this.nativeYOffsetsProperty ||
                ((this.nativeYOffsetsProperty = new s.SCRTDoubleVector()),
                (0, n.appendDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  this.nativeYOffsetsProperty,
                  this.yCellOffsets
                )),
              this.nativeYOffsetsProperty
            );
          }
          getXValue(e) {
            return this.xCellOffsetsProperty[e];
          }
          getYValue(e) {
            return this.yCellOffsetsProperty[e];
          }
          notifyDataChanged(e, t) {
            (this.xCellOffsets || this.xCellOffsetsGeneratorFunction) &&
              (this.yCellOffsets || this.yCellOffsetsGeneratorFunction) &&
              (e === h.EDataChangeType.Append &&
                (this.xCellOffsetsGeneratorFunction &&
                  ((this.xCellOffsetsProperty = this.mapCellSizes(
                    this.arrayWidth,
                    this.xCellOffsetsGeneratorFunction
                  )),
                  (this.xCellSizesProperty = this.calculateCellSizes(
                    this.xCellOffsetsProperty
                  ))),
                this.yCellOffsetsGeneratorFunction &&
                  ((this.yCellOffsetsProperty = this.mapCellSizes(
                    this.arrayHeight,
                    this.yCellOffsetsGeneratorFunction
                  )),
                  (this.yCellSizesProperty = this.calculateCellSizes(
                    this.yCellOffsetsProperty
                  ))),
                this.nativeXOffsetsProperty.clear(),
                this.nativeYOffsetsProperty.clear(),
                (0, n.appendDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  this.nativeXOffsetsProperty,
                  this.xCellOffsetsProperty
                ),
                (0, n.appendDoubleVectorFromJsArray)(
                  this.webAssemblyContext,
                  this.nativeYOffsetsProperty,
                  this.yCellOffsetsProperty
                )),
              (this.xRangeProperty = new a.NumberRange(
                this.getXValue(0),
                this.getXValue(this.arrayWidth)
              )),
              (this.yRangeProperty = new a.NumberRange(
                this.getYValue(0),
                this.getYValue(this.arrayHeight)
              )),
              super.notifyDataChanged(e, t));
          }
          getXRange() {
            return this.xRangeProperty;
          }
          getYRange() {
            return this.yRangeProperty;
          }
          getXIndicesRange(e, t, r, i) {
            return (0, l.getIndicesRange)(
              this.webAssemblyContext,
              this.nativeXCellOffsets,
              e,
              !0
            );
          }
          getYIndicesRange(e, t, r, i) {
            return (0, l.getIndicesRange)(
              this.webAssemblyContext,
              this.nativeYCellOffsets,
              e,
              !0
            );
          }
          delete() {
            super.delete(),
              (this.nativeXOffsetsProperty = (0, i.deleteSafe)(
                this.nativeXOffsetsProperty
              )),
              (this.nativeYOffsetsProperty = (0, i.deleteSafe)(
                this.nativeYOffsetsProperty
              ));
          }
          getOptions(e) {
            const t = super.getOptions(e),
              r = {
                xCellOffsets: this.xCellOffsetsProperty,
                yCellOffsets: this.yCellOffsetsProperty,
              };
            return Object.assign(t, r);
          }
          mapCellSizes(e, t) {
            const r = [],
              i = e + 1;
            for (let e = 0; e < i; ++e) r.push(t(e));
            return r;
          }
          calculateCellSizes(e) {
            if (!e || 0 === e.length) return [];
            const t = e.length,
              r = e[t - 1] - e[0],
              i = [];
            for (let o = 0; o < t - 1; ++o) {
              const t = e[o + 1] - e[o];
              i.push(t / r);
            }
            return i;
          }
        }
        t.NonUniformHeatmapDataSeries = u;
      },
      35471: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getOHLCYRange = t.OhlcDataSeries = void 0);
        const i = r(98140),
          o = r(26361),
          a = r(54624),
          s = r(9073),
          n = r(24933),
          l = r(51885);
        class d extends n.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 4,
                valueNames: [
                  a.EValueName.Close,
                  a.EValueName.Open,
                  a.EValueName.High,
                  a.EValueName.Low,
                ],
                includeInYRange: [!0, !0, !0, !0],
              })
            ),
              (this.type = l.EDataSeriesType.Ohlc),
              (null == t ? void 0 : t.xValues) &&
                (this.appendRange(
                  t.xValues,
                  t.openValues,
                  t.highValues,
                  t.lowValues,
                  t.closeValues,
                  t.metadata
                ),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.openValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.highValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.lowValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get openValues() {
            return this.getNativeOpenValues();
          }
          get highValues() {
            return this.getNativeHighValues();
          }
          get lowValues() {
            return this.getNativeLowValues();
          }
          getNativeOpenValues() {
            return this.getNativeYValues(1);
          }
          getNativeHighValues() {
            return this.getNativeYValues(2);
          }
          getNativeLowValues() {
            return this.getNativeYValues(3);
          }
          getNativeCloseValues() {
            return this.getNativeYValues();
          }
          append(e, t, r, i, o, a) {
            super.appendN(e, [o, t, r, i], a);
          }
          appendRange(e, t, r, i, o, a) {
            super.appendRangeN(e, [o, t, r, i], a);
          }
          update(e, t, r, i, o, a) {
            super.updateN(e, [o, t, r, i], a);
          }
          updateXohlc(e, t, r, i, o, a, s) {
            super.updateXyN(e, t, [a, r, i, o], s);
          }
          insert(e, t, r, i, o, a, s) {
            super.insertN(e, t, [a, r, i, o], s);
          }
          insertRange(e, t, r, i, o, a, s) {
            super.insertRangeN(e, t, [a, r, i, o], s);
          }
          getWindowedYRange(
            e,
            t,
            r = !1,
            a = l.EDataSeriesValueType.Default,
            n = s.EYRangeMode.Visible
          ) {
            const {
              openValues: d,
              closeValues: u,
              highValues: c,
              lowValues: p,
            } = this.getOHLCValues(a);
            if (1 === this.count()) {
              const e = Math.min(d.get(0), p.get(0)),
                t = Math.max(u.get(0), c.get(0));
              return new i.NumberRange(e, t);
            }
            return h(
              r
                ? e
                : this.getIndicesRange(
                    e,
                    !1,
                    n === s.EYRangeMode.Visible
                      ? o.ESearchMode.RoundUp
                      : o.ESearchMode.RoundDown,
                    n === s.EYRangeMode.Visible
                      ? o.ESearchMode.RoundDown
                      : o.ESearchMode.RoundUp
                  ),
              d,
              c,
              p
            );
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e),
                a = new Array(e),
                s = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.openValues.getRaw(t)),
                    (s[t] = this.yValues.getRaw(t)),
                    (o[t] = this.highValues.getRaw(t)),
                    (a[t] = this.lowValues.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.openValues.get(t)),
                    (s[t] = this.yValues.get(t)),
                    (o[t] = this.highValues.get(t)),
                    (a[t] = this.lowValues.get(t));
              const n = {
                xValues: r,
                openValues: i,
                highValues: o,
                lowValues: a,
                closeValues: s,
              };
              Object.assign(t, n);
            }
            return t;
          }
          getOHLCValues(e) {
            let t, r, i, o;
            switch (e) {
              case l.EDataSeriesValueType.FinalAnimationValues:
                (t = this.yFinalAnimationValuesArray[1]),
                  (r = this.yFinalAnimationValuesArray[2]),
                  (i = this.yFinalAnimationValuesArray[3]),
                  (o = this.yFinalAnimationValuesArray[0]);
                break;
              case l.EDataSeriesValueType.InitialAnimationValues:
                (t = this.yInitialAnimationValuesArray[1]),
                  (r = this.yInitialAnimationValuesArray[2]),
                  (i = this.yInitialAnimationValuesArray[3]),
                  (o = this.yInitialAnimationValuesArray[0]);
                break;
              default:
                (t = this.openValues),
                  (r = this.highValues),
                  (i = this.lowValues),
                  (o = this.yValues);
            }
            return {
              openValues: t,
              highValues: r,
              lowValues: i,
              closeValues: o,
            };
          }
        }
        function h(e, t, r, o, a) {
          let s = Number.MAX_VALUE,
            n = Number.NEGATIVE_INFINITY;
          const l = Math.max(e.min, 0),
            d = Math.min(e.max, t.size() - 1);
          if (!(d < l)) {
            for (let e = l; e <= d; e++) {
              const t = r.get(e),
                i = o.get(e);
              i < s && (s = i), t > n && (n = t);
            }
            return new i.NumberRange(s, n);
          }
        }
        (t.OhlcDataSeries = d), (t.getOHLCYRange = h);
      },
      52881: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PaletteFactory = void 0);
        const i = r(28436),
          o = r(22950),
          a = r(48008),
          s = r(32747);
        class n {
          static createGradient(e, t, r) {
            t.endPoint.x, t.startPoint.x, t.endPoint.y, t.startPoint.y;
            const a = n.createColorMap(e, t.gradientStops.slice(0));
            let l;
            const d = (t, r, i, s = 1) => {
                const n = i / (l.getDataSeriesValuesCount() - 1),
                  d = e.NumberUtil.Constrain(
                    Math.round(n * (a.length - 1)),
                    0,
                    a.length - 1
                  ),
                  h = a[d];
                return (0, o.uintArgbColorMultiplyOpacity)(h, s);
              },
              h = void 0 === r || !0 === (null == r ? void 0 : r.enableStroke),
              u = !0 === (null == r ? void 0 : r.enableFill),
              c = !0 === (null == r ? void 0 : r.enablePointMarkers);
            return {
              strokePaletteMode: s.EStrokePaletteMode.GRADIENT,
              fillPaletteMode: s.EFillPaletteMode.GRADIENT,
              onAttached(e) {
                l = e;
              },
              onDetached() {},
              overrideStrokeArgb(e, t, i) {
                var o;
                return h
                  ? d(
                      0,
                      0,
                      i,
                      null !== (o = null == r ? void 0 : r.strokeOpacity) &&
                        void 0 !== o
                        ? o
                        : 1
                    )
                  : void 0;
              },
              overrideFillArgb(e, t, i, o, a) {
                var s;
                return u
                  ? d(
                      0,
                      0,
                      i,
                      null !== (s = null == r ? void 0 : r.fillOpacity) &&
                        void 0 !== s
                        ? s
                        : 1
                    )
                  : void 0;
              },
              overridePointMarkerArgb(e, t, i, o, a) {
                var s;
                const n =
                  null !== (s = null == r ? void 0 : r.pointMarkerOpacity) &&
                  void 0 !== s
                    ? s
                    : 1;
                return c
                  ? { fill: d(0, 0, i, n), stroke: d(0, 0, i, n) }
                  : void 0;
              },
              toJSON: () => ({
                type: i.EPaletteProviderType.Gradient,
                options: t,
              }),
            };
          }
          static createYGradient(e, t, r, a) {
            const l = n.createColorMap(e, t.gradientStops.slice(0));
            let d;
            const h = (t, i = 1) => {
                const a = (t - r.min) / r.diff,
                  s = e.NumberUtil.Constrain(
                    Math.round(a * (l.length - 1)),
                    0,
                    l.length - 1
                  ),
                  n = l[s];
                return (0, o.uintArgbColorMultiplyOpacity)(n, i);
              },
              u = void 0 === a || !0 === (null == a ? void 0 : a.enableStroke),
              c = !0 === (null == a ? void 0 : a.enableFill),
              p = !0 === (null == a ? void 0 : a.enablePointMarkers);
            return {
              strokePaletteMode: s.EStrokePaletteMode.GRADIENT,
              fillPaletteMode: s.EFillPaletteMode.GRADIENT,
              onAttached(e) {
                d = e;
              },
              onDetached() {},
              overrideStrokeArgb(e, t, r) {
                var i;
                return u
                  ? h(
                      t,
                      null !== (i = null == a ? void 0 : a.strokeOpacity) &&
                        void 0 !== i
                        ? i
                        : 1
                    )
                  : void 0;
              },
              overrideFillArgb(e, t, r, i, o) {
                var s;
                return c
                  ? h(
                      t,
                      null !== (s = null == a ? void 0 : a.strokeOpacity) &&
                        void 0 !== s
                        ? s
                        : 1
                    )
                  : void 0;
              },
              overridePointMarkerArgb(e, t, r, i, o) {
                var s;
                const n =
                  null !== (s = null == a ? void 0 : a.pointMarkerOpacity) &&
                  void 0 !== s
                    ? s
                    : 1;
                return p ? { fill: h(t, n), stroke: h(t, n) } : void 0;
              },
              toJSON: () => ({
                type: i.EPaletteProviderType.Gradient,
                options: t,
              }),
            };
          }
          static createColorMap(e, t) {
            const r = [],
              i = t.length,
              o = t[0].offset;
            let s = t[t.length - 1].offset - o;
            const l = s / (n.precision - 1);
            let d = (0, a.parseColorToUIntArgb)(t[0].color),
              h = t[0].offset,
              u = d,
              c = h;
            i > 1 &&
              ((u = (0, a.parseColorToUIntArgb)(t[1].color)),
              (c = t[1].offset)),
              (s = c - h);
            let p = 0;
            for (let g = 0; g < n.precision; ++g) {
              const n = o + g * l;
              n >= c &&
                (p++,
                (h = c),
                (d = u),
                p + 1 < i &&
                  ((u = (0, a.parseColorToUIntArgb)(t[p + 1].color)),
                  (c = t[p + 1].offset)),
                (s = c - h));
              let y = 0;
              if (d === u || s <= 1e-11) y = u;
              else {
                const t = (n - h) / s;
                y = e.NumberUtil.LinearInterpolateI(d, u, t);
              }
              r.push(y);
            }
            return r;
          }
        }
        (t.PaletteFactory = n), (n.precision = 500);
      },
      39484: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePointSeriesResampled = void 0);
        const i = r(55023),
          o = r(54624),
          a = r(51885);
        class s extends i.DeletableEntity {
          constructor(e, t, r = 1, i) {
            super(),
              (this.type = a.EDataSeriesType.Xy),
              (this.yValuesArray = []),
              (this.arrayCount = 1),
              (this.resampled = !0),
              (this.wasmContext = e),
              (this.arrayCount = r),
              (this.intIndexes = new e.IntVector()),
              (this.indexes = new e.SCRTDoubleVector()),
              (this.xValues = new e.SCRTDoubleVector());
            for (let t = 0; t < this.arrayCount; t++)
              this.yValuesArray.push(new e.SCRTDoubleVector());
            (this.valueNames =
              null != i
                ? i
                : (0, o.generateValueNamesForDataSeries)(
                    this.yValuesArray.length
                  )),
              (this.xRange = t);
          }
          get count() {
            return this.xValues.size();
          }
          get yValues() {
            return this.yValuesArray[0];
          }
          getYValues(e, t = !0) {
            return e < this.arrayCount
              ? this.yValuesArray[e]
              : t && void 0 !== e
              ? void 0
              : this.yValuesArray[0];
          }
          getYValuesByName(e, t = !0) {
            const r = this.valueNames.indexOf(e);
            return r >= 0
              ? this.getYValues(r, t)
              : t
              ? void 0
              : this.yValuesArray[0];
          }
          delete() {
            this.intIndexes.delete(),
              this.indexes.delete(),
              this.xValues.delete(),
              this.yValuesArray.forEach((e) => e.delete()),
              (this.yValuesArray.length = 0),
              (this.wasmContext = void 0);
          }
          clearIntIndexes() {
            this.intIndexes.clear();
          }
          debugOutputForUnitTests() {
            console.log(`points count ${this.count}`),
              console.log("xResampled at min", this.xValues.get(0)),
              console.log("openResampled at min", this.yValues.get(0));
            const e = Math.round(this.count / 2);
            console.log("middle", e),
              console.log("xResampled at middle", this.xValues.get(e)),
              console.log("yValues at middle", this.yValues.get(e));
            const t = this.count - 1;
            console.log("xResampled at end", this.xValues.get(t)),
              console.log("yValues at end", this.yValues.get(t));
          }
        }
        t.BasePointSeriesResampled = s;
      },
      33070: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePointSeriesWrapped = void 0);
        const i = r(51885);
        t.BasePointSeriesWrapped = class {
          constructor(e, t, r, o) {
            var a;
            if (
              ((this.type = i.EDataSeriesType.XyN),
              (this.yValuesArray = []),
              (this.resampled = !1),
              (this.dataSeries = e),
              (this.xValues = this.dataSeries.getXValues(r)),
              t && 0 !== t.length && void 0 !== t[0])
            ) {
              this.count = t.length;
              for (let r = 0; r < t.length; r++)
                this.yValuesArray.push(
                  null !== (a = t[r]) && void 0 !== a ? a : e.yValuesArray[r]
                );
            } else
              (this.count = e.count()),
                (this.yValuesArray = e.getYValuesArray(r));
            (this.valueNamesProperty =
              null != o ? o : this.dataSeries.valueNames),
              (this.fifoStartIndex = e.fifoStartIndex);
          }
          get indexes() {
            return (
              this.indexesProperty ||
                (this.indexesProperty = this.dataSeries.getNativeIndexes()),
              this.indexesProperty
            );
          }
          get valueNames() {
            return this.valueNamesProperty;
          }
          get arrayCount() {
            return this.dataSeries.arrayCount;
          }
          get yValues() {
            return this.yValuesArray[0];
          }
          getYValues(e) {
            return this.yValuesArray[null != e ? e : 0];
          }
          getYValuesByName(e) {
            const t = this.valueNames.indexOf(e);
            return t >= 0 ? this.yValuesArray[t] : void 0;
          }
          delete() {}
        };
      },
      22769: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxPlotPointSeriesWrapped = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(33070);
        class s extends a.BasePointSeriesWrapped {
          constructor(e) {
            super(e, void 0, o.EDataSeriesValueType.Default, [
              i.EValueName.BoxPlotMedian,
              i.EValueName.BoxPlotMax,
              i.EValueName.BoxPlotUpper,
              i.EValueName.BoxPlotLower,
              i.EValueName.BoxPlotMinimum,
            ]),
              (this.type = o.EDataSeriesType.BoxPlot);
          }
          get medianValues() {
            return this.yValuesArray[0];
          }
          get maximumValues() {
            return this.yValuesArray[1];
          }
          get upperQuartileValues() {
            return this.yValuesArray[2];
          }
          get lowerQuartileValues() {
            return this.yValuesArray[3];
          }
          get minimumValues() {
            return this.yValuesArray[4];
          }
        }
        t.BoxPlotPointSeriesWrapped = s;
      },
      89236: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HlcPointSeriesWrapped = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(33070);
        class s extends a.BasePointSeriesWrapped {
          constructor(e) {
            super(e, void 0, o.EDataSeriesValueType.Default, [
              i.EValueName.Close,
              i.EValueName.High,
              i.EValueName.Low,
            ]),
              (this.type = o.EDataSeriesType.Hlc);
          }
          get closeValues() {
            return this.yValuesArray[0];
          }
          get highValues() {
            return this.yValuesArray[1];
          }
          get lowValues() {
            return this.yValuesArray[2];
          }
        }
        t.HlcPointSeriesWrapped = s;
      },
      65052: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcPointSeriesResampled = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(39484);
        class s extends a.BasePointSeriesResampled {
          constructor(e, t) {
            super(e, t, 4, [
              i.EValueName.Close,
              i.EValueName.Open,
              i.EValueName.High,
              i.EValueName.Low,
            ]),
              (this.type = o.EDataSeriesType.Ohlc);
          }
          get closeValues() {
            return this.yValuesArray[0];
          }
          get openValues() {
            return this.yValuesArray[1];
          }
          get highValues() {
            return this.yValuesArray[2];
          }
          get lowValues() {
            return this.yValuesArray[3];
          }
          debugOutputForUnitTests() {
            console.log(`points count ${this.count}`),
              console.log("xResampled at min", this.xValues.get(0)),
              console.log("openResampled at min", this.openValues.get(0)),
              console.log("highResampled at min", this.highValues.get(0)),
              console.log("lowResampled at min", this.lowValues.get(0)),
              console.log("closeResampled at min", this.closeValues.get(0));
            const e = Math.round(this.count / 2);
            console.log("middle", e),
              console.log("xResampled at middle", this.xValues.get(e)),
              console.log("openResampled at middle", this.openValues.get(e)),
              console.log("highResampled at middle", this.highValues.get(e)),
              console.log("lowResampled at middle", this.lowValues.get(e)),
              console.log("closeResampled at middle", this.closeValues.get(e));
            const t = this.count - 1;
            console.log("xResampled at end", this.xValues.get(t)),
              console.log("openResampled at end", this.openValues.get(t)),
              console.log("highResampled at end", this.highValues.get(t)),
              console.log("lowResampled at end", this.lowValues.get(t)),
              console.log("closeResampled at end", this.closeValues.get(t));
          }
        }
        t.OhlcPointSeriesResampled = s;
      },
      6328: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcPointSeriesWrapped = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(33070);
        class s extends a.BasePointSeriesWrapped {
          constructor(e) {
            super(e, void 0, o.EDataSeriesValueType.Default, [
              i.EValueName.Close,
              i.EValueName.Open,
              i.EValueName.High,
              i.EValueName.Low,
            ]),
              (this.type = o.EDataSeriesType.Ohlc);
          }
          get closeValues() {
            return this.yValuesArray[0];
          }
          get openValues() {
            return this.yValuesArray[1];
          }
          get highValues() {
            return this.yValuesArray[2];
          }
          get lowValues() {
            return this.yValuesArray[3];
          }
        }
        t.OhlcPointSeriesWrapped = s;
      },
      25919: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyNPointSeriesResampled = void 0);
        const i = r(55023),
          o = r(54624),
          a = r(51885),
          s = r(58564);
        class n extends i.DeletableEntity {
          constructor(e, t, r = 1, i) {
            super(),
              (this.type = a.EDataSeriesType.XyN),
              (this.subSeries = []),
              (this.arrayCount = 1),
              (this.resampled = !0),
              (this.wasmContext = e),
              (this.arrayCount = r),
              (this.valueNames =
                null != i
                  ? i
                  : (0, o.generateValueNamesForDataSeries)(this.arrayCount));
            for (let r = 0; r < this.arrayCount; r++)
              this.subSeries.push(
                new s.XyPointSeriesResampled(e, t, this.valueNames[r])
              );
            this.xRange = t;
          }
          get intIndexes() {
            return this.subSeries[0].intIndexes;
          }
          get indexes() {
            return this.subSeries[0].indexes;
          }
          get xValues() {
            return this.subSeries[0].xValues;
          }
          get count() {
            return this.subSeries[0].xValues.size();
          }
          get yValues() {
            return this.subSeries[0].yValues;
          }
          getYValues(e) {
            return this.subSeries[0].getYValues(e);
          }
          getYValuesByName(e) {
            return this.subSeries[0].getYValuesByName(e);
          }
          getSubSeriesByName(e) {
            const t = this.valueNames.indexOf(e);
            return t >= 0 ? this.subSeries[t] : void 0;
          }
          delete() {
            this.subSeries.forEach((e) => e.delete()),
              (this.subSeries.length = 0),
              (this.wasmContext = void 0);
          }
          clearIntIndexes() {}
        }
        t.XyNPointSeriesResampled = n;
      },
      58564: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyPointSeriesResampled = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(39484);
        class s extends a.BasePointSeriesResampled {
          constructor(e, t, r = i.EValueName.Y) {
            super(e, t, 1, [r]), (this.type = o.EDataSeriesType.Xy);
          }
        }
        t.XyPointSeriesResampled = s;
      },
      88915: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyPointSeriesWrapped = void 0);
        const i = r(51885),
          o = r(33070),
          a = r(54624);
        class s extends o.BasePointSeriesWrapped {
          constructor(e, t, r) {
            super(e, [t], r, [a.EValueName.Y]),
              (this.type = i.EDataSeriesType.Xy);
          }
        }
        t.XyPointSeriesWrapped = s;
      },
      14023: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyyPointSeriesResampled = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(39484);
        class s extends a.BasePointSeriesResampled {
          constructor(e, t) {
            super(e, t, 2, [i.EValueName.Y, i.EValueName.Y1]),
              (this.type = o.EDataSeriesType.Xyy);
          }
          get y1Values() {
            return this.yValuesArray[1];
          }
          debugOutputForUnitTests() {
            console.log(`points count ${this.count}`),
              console.log("xResampled at min", this.xValues.get(0)),
              console.log("yValues at min", this.yValues.get(0)),
              console.log("y1Values at min", this.y1Values.get(0));
            const e = Math.round(this.count / 2);
            console.log("middle", e),
              console.log("xResampled at middle", this.xValues.get(e)),
              console.log("yValues at middle", this.yValues.get(e)),
              console.log("y1Values at middle", this.y1Values.get(e));
            const t = this.count - 1;
            console.log("xResampled at end", this.xValues.get(t)),
              console.log("yValues at end", this.yValues.get(t)),
              console.log("y1Values at end", this.y1Values.get(t));
          }
        }
        t.XyyPointSeriesResampled = s;
      },
      2354: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyyPointSeriesWrapped = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(33070);
        class s extends a.BasePointSeriesWrapped {
          constructor(e, t, r) {
            super(e, [t, r], o.EDataSeriesValueType.Default, [
              i.EValueName.Y,
              i.EValueName.Y1,
            ]),
              (this.type = o.EDataSeriesType.Xyy);
          }
          get y1Values() {
            return this.yValuesArray[1];
          }
          getYValues(e) {
            return 1 === e ? this.y1Values : this.yValues;
          }
        }
        t.XyyPointSeriesWrapped = s;
      },
      45425: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzPointSeriesResampled = void 0);
        const i = r(54624),
          o = r(39484);
        class a extends o.BasePointSeriesResampled {
          constructor(e, t) {
            super(e, t, 2, [i.EValueName.Y, i.EValueName.Z]);
          }
          get zValues() {
            return this.yValuesArray[1];
          }
        }
        t.XyzPointSeriesResampled = a;
      },
      62507: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzPointSeriesWrapped = void 0);
        const i = r(54624),
          o = r(51885),
          a = r(33070);
        class s extends a.BasePointSeriesWrapped {
          constructor(e) {
            super(e, void 0, o.EDataSeriesValueType.Default, [
              i.EValueName.Y,
              i.EValueName.Z,
            ]),
              (this.type = o.EDataSeriesType.Xyz);
          }
          get zValues() {
            return this.yValuesArray[1];
          }
          getYValues(e) {
            return 1 === e ? this.zValues : this.yValues;
          }
        }
        t.XyzPointSeriesWrapped = s;
      },
      15799: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformHeatmapDataSeries = void 0);
        const i = r(98140),
          o = r(16179),
          a = r(51885);
        class s extends o.BaseHeatmapDataSeries {
          constructor(e, t) {
            super(e, t),
              (this.type = a.EDataSeriesType.HeatmapUniform),
              (this.xStartProperty = t.xStart),
              (this.xStepProperty = t.xStep),
              (this.yStartProperty = t.yStart),
              (this.yStepProperty = t.yStep),
              (this.xRangeProperty = new i.NumberRange(
                this.xStart,
                this.getXValue(this.arrayWidth)
              )),
              (this.yRangeProperty = new i.NumberRange(
                this.yStart,
                this.getYValue(this.arrayHeight)
              ));
          }
          get xStart() {
            return this.xStartProperty;
          }
          set xStart(e) {
            (this.xStartProperty = e),
              this.notifyDataChanged(a.EDataChangeType.Update);
          }
          get xStep() {
            return this.xStepProperty;
          }
          set xStep(e) {
            (this.xStepProperty = e),
              this.notifyDataChanged(a.EDataChangeType.Update);
          }
          get yStart() {
            return this.yStartProperty;
          }
          set yStart(e) {
            (this.yStartProperty = e),
              this.notifyDataChanged(a.EDataChangeType.Update);
          }
          get yStep() {
            return this.yStepProperty;
          }
          set yStep(e) {
            (this.yStepProperty = e),
              this.notifyDataChanged(a.EDataChangeType.Update);
          }
          getXValue(e) {
            const t = this.xStep * e;
            return this.xStart + t;
          }
          getYValue(e) {
            const t = this.yStep * e;
            return this.yStart + t;
          }
          notifyDataChanged(e, t) {
            (this.xRangeProperty = new i.NumberRange(
              this.xStart,
              this.getXValue(this.arrayWidth)
            )),
              (this.yRangeProperty = new i.NumberRange(
                this.yStart,
                this.getYValue(this.arrayHeight)
              )),
              super.notifyDataChanged(e, t);
          }
          getOptions(e) {
            const t = super.getOptions(e),
              r = {
                xStart: this.xStart,
                xStep: this.xStep,
                yStart: this.yStart,
                yStep: this.yStep,
              };
            return Object.assign(t, r);
          }
          getXRange() {
            return this.xRangeProperty;
          }
          getYRange() {
            return this.yRangeProperty;
          }
        }
        t.UniformHeatmapDataSeries = s;
      },
      52452: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XDataSeries = void 0);
        const i = r(98140),
          o = r(24933),
          a = r(51885);
        class s extends o.BaseDataSeries {
          constructor(e, t) {
            super(e, Object.assign(Object.assign({}, t), { arrayCount: 0 })),
              (this.type = a.EDataSeriesType.X),
              (null == t ? void 0 : t.xValues) &&
                (this.appendRange(t.xValues, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ));
          }
          append(e, t) {
            super.appendN(e, [], t, void 0);
          }
          appendRange(e, t) {
            super.appendRangeN(e, [], t);
          }
          updateX(e, t, r) {
            super.updateXyN(e, t, [], r);
          }
          insert(e, t, r) {
            super.insertN(e, t, [], r);
          }
          insertRange(e, t, r) {
            super.insertRangeN(e, t, [], r);
          }
          getWindowedYRange(e, t, r, o, a) {
            return new i.NumberRange(0, 1);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++) r[t] = this.xValues.getRaw(t);
              else for (let t = 0; t < e; t++) r[t] = this.xValues.get(t);
              const i = { xValues: r, yValues: void 0 };
              Object.assign(t, i);
            }
            return t;
          }
        }
        t.XDataSeries = s;
      },
      9682: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyDataSeries = void 0);
        const i = r(23866),
          o = r(54624),
          a = r(24933),
          s = r(51885),
          n = r(58564),
          l = r(88915);
        class d extends a.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 1,
                valueNames: [o.EValueName.Y],
                includeInYRange: [!0],
              })
            ),
              (this.type = s.EDataSeriesType.Xy),
              (null == t ? void 0 : t.xValues) &&
                (i.Guard.notNull(t.yValues, "options.yValues"),
                this.appendRange(t.xValues, t.yValues, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          append(e, t, r) {
            super.appendN(e, [t], r, void 0);
          }
          appendRange(e, t, r) {
            super.appendRangeN(e, [t], r);
          }
          update(e, t, r) {
            super.updateN(e, [t], r);
          }
          updateXy(e, t, r, i) {
            super.updateXyN(e, t, [r], i);
          }
          insert(e, t, r, i) {
            super.insertN(e, t, [r], i);
          }
          insertRange(e, t, r, i) {
            super.insertRangeN(e, t, [r], i);
          }
          toPointSeries(e, t, r) {
            if (e) {
              t
                ? (t.xRange = e.xVisibleRange)
                : (t = new n.XyPointSeriesResampled(
                    this.webAssemblyContext,
                    e.xVisibleRange
                  )),
                i.Guard.notNull(r, "resamplerHelper");
              const o = r.resampleIntoPointSeries(
                this.webAssemblyContext,
                e,
                this.getNativeXValues(),
                this.getNativeYValues(),
                t.intIndexes,
                t.indexes,
                t.xValues,
                t.yValues,
                !1
              );
              return (
                (t.fifoStartIndex = o.OutputSplitIndex), t.clearIntIndexes(), t
              );
            }
            return new l.XyPointSeriesWrapped(this);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)), (i[t] = this.yValues.get(t));
              const o = { xValues: r, yValues: i };
              Object.assign(t, o);
            }
            return t;
          }
        }
        t.XyDataSeries = d;
      },
      38446: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyNDataSeries = void 0);
        const i = r(23866),
          o = r(33240),
          a = r(24933),
          s = r(51885),
          n = r(33070),
          l = r(25919);
        class d extends a.BaseDataSeries {
          constructor(e, t) {
            var r, i, a;
            if (
              (super(
                e,
                Object.assign(Object.assign({}, t), {
                  arrayCount:
                    null !==
                      (i =
                        null === (r = t.yValuesArray) || void 0 === r
                          ? void 0
                          : r.length) && void 0 !== i
                      ? i
                      : t.arrayCount,
                })
              ),
              (this.type = s.EDataSeriesType.XyN),
              !t.arrayCount && !t.yValuesArray)
            )
              throw new Error(
                "XyNDataSeries requres either arrayCount or yValuesArray to initialize the size"
              );
            (this.resamplingModes =
              null !== (a = null == t ? void 0 : t.resamplingModes) &&
              void 0 !== a
                ? a
                : this.valueNames.map((e) => o.EResamplingMode.Auto)),
              (null == t ? void 0 : t.xValues) &&
                (null == t ? void 0 : t.yValuesArray) &&
                (this.appendRangeN(t.xValues, t.yValuesArray, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValuesArray.forEach((e) => {
                    e.notifyAppend(null == t ? void 0 : t.fifoStartIndex);
                  })));
          }
          notifyDataChanged(e, t, r, i) {
            (this.resamplingParams = void 0),
              super.notifyDataChanged(e, t, r, i);
          }
          toPointSeries(e, t, r) {
            if (
              e &&
              (e.dataIsFifo || e.resamplingMode !== o.EResamplingMode.None)
            ) {
              if (
                (this.pointSeries
                  ? (this.pointSeries.xRange = e.xVisibleRange)
                  : (this.pointSeries = new l.XyNPointSeriesResampled(
                      this.webAssemblyContext,
                      e.xVisibleRange,
                      this.arrayCount,
                      this.valueNames
                    )),
                this.resamplingParams)
              ) {
                if (
                  this.resamplingParams.indexesRange.equals(e.indexesRange) &&
                  this.resamplingParams.precision == e.precision &&
                  this.resamplingParams.viewportSize === e.viewportSize
                )
                  return this.pointSeries;
              } else this.resamplingParams = e;
              this.resamplingParams = e;
              const t = this.pointSeries;
              i.Guard.notNull(r, "resamplerHelper");
              for (let i = 0; i < this.arrayCount; i++) {
                const o = t.subSeries[i],
                  a = e.clone({ resamplingMode: this.resamplingModes[i] }),
                  s = r.resampleIntoPointSeries(
                    this.webAssemblyContext,
                    a,
                    this.getNativeXValues(),
                    this.getNativeYValues(i),
                    o.intIndexes,
                    o.indexes,
                    o.xValues,
                    o.yValues,
                    !1
                  );
                (o.fifoStartIndex = s.OutputSplitIndex), o.clearIntIndexes();
              }
              return this.pointSeries;
            }
            return new n.BasePointSeriesWrapped(this);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              let e = Array.from(Array(this.arrayCount)).map(
                (e) => new Array(r)
              );
              const r = this.count(),
                i = new Array(r);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < r; t++) {
                  i[t] = this.xValues.getRaw(t);
                  for (let r = 0; r < this.arrayCount; r++)
                    e[r][t] = this.yValuesArray[r].getRaw(t);
                }
              else
                for (let t = 0; t < r; t++) {
                  i[t] = this.xValues.get(t);
                  for (let r = 0; r < this.arrayCount; r++)
                    e[r][t] = this.yValuesArray[r].get(t);
                }
              const o = {
                xValues: i,
                yValuesArray: e,
                resamplingModes: this.resamplingModes,
                yValues: void 0,
              };
              Object.assign(t, o);
            }
            return t;
          }
        }
        t.XyNDataSeries = d;
      },
      29803: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyTextDataSeries = void 0);
        const i = r(23866),
          o = r(45215),
          a = r(24933),
          s = r(51885);
        class n extends a.BaseDataSeries {
          constructor(e, t) {
            super(e, t),
              (this.type = s.EDataSeriesType.XyText),
              (this.textValuesProperty = []),
              (null == t ? void 0 : t.xValues) &&
                (i.Guard.notNull(t.yValues, "options.yValues"),
                this.appendRange(
                  t.xValues,
                  t.yValues,
                  t.textValues,
                  t.metadata
                ));
          }
          get textValues() {
            return this.textValuesProperty;
          }
          getTextValue(e) {
            if (!this.fifoCapacity) return this.textValuesProperty[e];
            if (this.fifoSweeping)
              return this.fifoCapacity - e < this.fifoSweepingGap
                ? ""
                : this.textValuesProperty[e];
            {
              const t = (this.xValues.getStartIndex() + e) % this.fifoCapacity;
              return this.textValuesProperty[t];
            }
          }
          append(e, t, r, i) {
            super.appendN(e, [t], i, () => {
              this.fifoCapacity && this.count() === this.fifoCapacity
                ? (this.textValuesProperty[this.xValues.getStartIndex()] = r)
                : this.textValuesProperty.push(r);
            });
          }
          appendRange(e, t, r, i) {
            super.appendRangeN(e, [t], i, () => {
              this.fifoCapacity
                ? (0, o.appendRangeFifo)(
                    r,
                    this.textValuesProperty,
                    this.fifoCapacity,
                    this.xValues.getStartIndex()
                  )
                : this.textValuesProperty.push(...r);
            });
          }
          update(e, t, r, i) {
            super.updateN(e, [t], i, () => (this.textValuesProperty[e] = r));
          }
          updateXyText(e, t, r, i, o) {
            super.updateXyN(
              e,
              t,
              [r],
              o,
              () => (this.textValuesProperty[e] = i)
            );
          }
          insert(e, t, r, i, o) {
            super.insertN(e, t, [r], o, () =>
              this.textValuesProperty.splice(e, 0, i)
            );
          }
          insertRange(e, t, r, i, o) {
            super.insertRangeN(e, t, [r], o, () =>
              this.textValuesProperty.splice(e, 0, ...i)
            );
          }
          removeAt(e) {
            this.getIsDeleted() ||
              (this.textValuesProperty.splice(e, 1), super.removeAt(e));
          }
          removeRange(e, t) {
            this.getIsDeleted() ||
              (this.textValuesProperty.splice(e, t), super.removeRange(e, t));
          }
          clear() {
            this.getIsDeleted() ||
              ((this.textValuesProperty = []), super.clear());
          }
          get yValues() {
            return this.getNativeYValues();
          }
          getOptions(e = !1) {
            const t = super.getOptions();
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e);
              for (let t = 0; t < e; t++)
                (r[t] = this.xValues.get(t)), (i[t] = this.yValues.get(t));
              const o = {
                xValues: r,
                yValues: i,
                textValues: this.textValuesProperty,
              };
              Object.assign(t, o);
            }
            return t;
          }
        }
        t.XyTextDataSeries = n;
      },
      73016: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyxDataSeries = void 0);
        const i = r(23866),
          o = r(54624),
          a = r(24933),
          s = r(51885);
        class n extends a.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 2,
                valueNames: [o.EValueName.Y, o.EValueName.X1],
                includeInYRange: [!0, !1],
              })
            ),
              (this.type = s.EDataSeriesType.Xyx),
              (null == t ? void 0 : t.xValues) &&
                (i.Guard.notNull(t.yValues, "options.yValues"),
                i.Guard.notNull(t.x1Values, "options.x1Values"),
                this.appendRange(t.xValues, t.yValues, t.x1Values, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.x1Values.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get x1Values() {
            return this.getNativeYValues(1);
          }
          append(e, t, r, i) {
            super.appendN(e, [t, r], i);
          }
          appendRange(e, t, r, i) {
            super.appendRangeN(e, [t, r], i);
          }
          update(e, t, r, i) {
            super.updateN(e, [t, r], i);
          }
          updateXyz(e, t, r, i, o) {
            super.updateXyN(e, t, [r, i], o);
          }
          insert(e, t, r, i, o) {
            super.insertN(e, t, [r, i], o);
          }
          insertRange(e, t, r, i, o) {
            super.insertRangeN(e, t, [r, i], o);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t)),
                    (o[t] = this.x1Values.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.yValues.get(t)),
                    (o[t] = this.x1Values.get(t));
              const a = { xValues: r, yValues: i, x1Values: o };
              Object.assign(t, a);
            }
            return t;
          }
        }
        t.XyxDataSeries = n;
      },
      19663: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyxyDataSeries = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(26361),
          n = r(54624),
          l = r(72934),
          d = r(24933),
          h = r(51885);
        class u extends d.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 3,
                valueNames: [n.EValueName.Y, n.EValueName.X1, n.EValueName.Y1],
                includeInYRange: [!0, !1, !0],
              })
            ),
              (this.type = h.EDataSeriesType.Xyxy),
              (null == t ? void 0 : t.xValues) &&
                (o.Guard.notNull(t.yValues, "options.yValues"),
                o.Guard.notNull(t.x1Values, "options.x1Values"),
                o.Guard.notNull(t.y1Values, "options.y1Values"),
                this.appendRange(
                  t.xValues,
                  t.yValues,
                  t.x1Values,
                  t.y1Values,
                  t.metadata
                ),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.x1Values.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.y1Values.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get x1Values() {
            return this.getNativeYValues(1);
          }
          get y1Values() {
            return this.getNativeYValues(2);
          }
          append(e, t, r, i, o) {
            super.appendN(e, [t, r, i], o);
          }
          appendRange(e, t, r, i, o) {
            super.appendRangeN(e, [t, r, i], o);
          }
          update(e, t, r, i, o) {
            super.updateN(e, [t, r, i], o);
          }
          updateXyz(e, t, r, i, o, a) {
            super.updateXyN(e, t, [r, i, o], a);
          }
          insert(e, t, r, i, o, a) {
            super.insertN(e, t, [r, i, o], a);
          }
          insertRange(e, t, r, i, o, a) {
            super.insertRangeN(e, t, [r, i, o], a);
          }
          getIndicesRange(
            e,
            t = !1,
            r = s.ESearchMode.RoundDown,
            i = s.ESearchMode.RoundUp
          ) {
            const o = t ? this.getNativeIndexes() : this.xValues,
              a = (0, d.getIndicesRange)(
                this.webAssemblyContext,
                o,
                e,
                this.dataDistributionCalculator.isSortedAscending,
                r,
                i
              ),
              n = t ? this.getNativeIndexes() : this.x1Values,
              l = (0, d.getIndicesRange)(
                this.webAssemblyContext,
                n,
                e,
                this.dataDistributionCalculator.isSortedAscending,
                r,
                i
              );
            return a.union(l);
          }
          getXRange(e) {
            const t = this.getXValues(e),
              { x1Values: r } = this.getXyxyValues(e);
            let o;
            if (1 === this.count()) {
              const e = t.get(0),
                i = r.get(0);
              let o = Math.min(e, i),
                s = Math.max(e, i);
              return o === s && ((o -= 1), (s += 1)), new a.NumberRange(o, s);
            }
            if (this.count() > 1) {
              let e, s, n, d;
              try {
                if (
                  ((n = this.webAssemblyContext.NumberUtil.MinMax(t)),
                  (d = this.webAssemblyContext.NumberUtil.MinMax(r)),
                  (e = Math.min(n.minD, d.minD)),
                  (s = Math.max(n.maxD, d.maxD)),
                  !(0, l.isRealNumber)(e) || !(0, l.isRealNumber)(s))
                )
                  return new a.NumberRange(0, 0);
              } finally {
                (0, i.deleteSafe)(n), (0, i.deleteSafe)(d);
              }
              return e === s
                ? new a.NumberRange(e - 1, s + 1)
                : (e > s && ((o = e), (e = s), (s = o)),
                  new a.NumberRange(e, s));
            }
            return new a.NumberRange(0, 0);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e),
                a = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t)),
                    (o[t] = this.x1Values.getRaw(t)),
                    (a[t] = this.y1Values.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.yValues.get(t)),
                    (o[t] = this.x1Values.get(t)),
                    (a[t] = this.y1Values.get(t));
              const s = { xValues: r, yValues: i, x1Values: o, y1Values: a };
              Object.assign(t, s);
            }
            return t;
          }
          getXyxyValues(e) {
            let t, r, i;
            switch (e) {
              case h.EDataSeriesValueType.FinalAnimationValues:
                (t = this.yFinalAnimationValuesArray[0]),
                  (r = this.yFinalAnimationValuesArray[1]),
                  (i = this.yFinalAnimationValuesArray[2]);
                break;
              case h.EDataSeriesValueType.InitialAnimationValues:
                (t = this.yInitialAnimationValuesArray[0]),
                  (r = this.yInitialAnimationValuesArray[1]),
                  (i = this.yInitialAnimationValuesArray[2]);
                break;
              default:
                (t = this.yValues), (r = this.x1Values), (i = this.y1Values);
            }
            return { yValues: t, x1Values: r, y1Values: i };
          }
        }
        t.XyxyDataSeries = u;
      },
      75650: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getYyYRange = t.XyyDataSeries = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(98140),
          s = r(26361),
          n = r(54624),
          l = r(9073),
          d = r(72934),
          h = r(24933),
          u = r(51885);
        class c extends h.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 2,
                valueNames: [n.EValueName.Y, n.EValueName.Y1],
                includeInYRange: [!0, !0],
              })
            ),
              (this.type = u.EDataSeriesType.Xyy),
              (null == t ? void 0 : t.xValues) &&
                (o.Guard.notNull(t.yValues, "options.yValues"),
                o.Guard.notNull(t.y1Values, "options.y1Values"),
                this.appendRange(t.xValues, t.yValues, t.y1Values, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.y1Values.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get y1Values() {
            return this.getNativeY1Values();
          }
          getNativeY1Values() {
            return this.getNativeYValues(1);
          }
          append(e, t, r, i) {
            super.appendN(e, [t, r], i);
          }
          appendRange(e, t, r, i) {
            super.appendRangeN(e, [t, r], i);
          }
          update(e, t, r, i) {
            super.updateN(e, [t, r], i);
          }
          updateXyy1(e, t, r, i, o) {
            super.updateXyN(e, t, [r, i], o);
          }
          insert(e, t, r, i, o) {
            super.insertN(e, t, [r, i], o);
          }
          insertRange(e, t, r, i, o) {
            super.insertRangeN(e, t, [r, i], o);
          }
          getWindowedYRange(
            e,
            t,
            r = !1,
            i = u.EDataSeriesValueType.Default,
            o = l.EYRangeMode.Visible
          ) {
            const { yValues: n, y1Values: d } = this.getYY1Values(i);
            if (1 === this.count()) {
              const e = Math.min(n.get(0), d.get(0)),
                t = Math.max(n.get(0), d.get(0));
              return new a.NumberRange(e, t);
            }
            const h = r
              ? e
              : this.getIndicesRange(
                  e,
                  !1,
                  o === l.EYRangeMode.Visible
                    ? s.ESearchMode.RoundUp
                    : s.ESearchMode.RoundDown,
                  o === l.EYRangeMode.Visible
                    ? s.ESearchMode.RoundDown
                    : s.ESearchMode.RoundUp
                );
            return p(this.webAssemblyContext, h, n, d);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t)),
                    (o[t] = this.y1Values.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.yValues.get(t)),
                    (o[t] = this.y1Values.get(t));
              const a = { xValues: r, yValues: i, y1Values: o };
              Object.assign(t, a);
            }
            return t;
          }
          getYY1Values(e) {
            let t, r;
            switch (e) {
              case u.EDataSeriesValueType.FinalAnimationValues:
                (t = this.yFinalAnimationValuesArray[0]),
                  (r = this.yFinalAnimationValuesArray[1]);
                break;
              case u.EDataSeriesValueType.InitialAnimationValues:
                (t = this.yInitialAnimationValuesArray[0]),
                  (r = this.yInitialAnimationValuesArray[1]);
                break;
              default:
                (t = this.yValues), (r = this.y1Values);
            }
            return { yValues: t, y1Values: r };
          }
        }
        function p(e, t, r, o) {
          const s = Math.max(Math.floor(t.min), 0),
            n = Math.min(Math.ceil(t.max), r.size() - 1);
          if (n < s) return;
          let l, h;
          try {
            if (
              ((l = e.NumberUtil.MinMaxWithIndex(r, s, n - s + 1)),
              !(0, d.isRealNumber)(l.minD) || !(0, d.isRealNumber)(l.maxD))
            )
              return;
            if (
              ((h = e.NumberUtil.MinMaxWithIndex(o, s, n - s + 1)),
              !(0, d.isRealNumber)(h.minD) || !(0, d.isRealNumber)(h.maxD))
            )
              return;
            return new a.NumberRange(
              Math.min(l.minD, h.minD),
              Math.max(l.maxD, h.maxD)
            );
          } finally {
            (0, i.deleteSafe)(l), (0, i.deleteSafe)(h);
          }
        }
        (t.XyyDataSeries = c), (t.getYyYRange = p);
      },
      35508: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyzDataSeries = void 0);
        const i = r(23866),
          o = r(54624),
          a = r(24933),
          s = r(51885);
        class n extends a.BaseDataSeries {
          constructor(e, t) {
            super(
              e,
              Object.assign(Object.assign({}, t), {
                arrayCount: 2,
                valueNames: [o.EValueName.Y, o.EValueName.Z],
                includeInYRange: [!0, !1],
              })
            ),
              (this.type = s.EDataSeriesType.Xyz),
              (null == t ? void 0 : t.xValues) &&
                (i.Guard.notNull(t.yValues, "options.yValues"),
                i.Guard.notNull(t.zValues, "options.zValues"),
                this.appendRange(t.xValues, t.yValues, t.zValues, t.metadata),
                (null == t ? void 0 : t.fifoCapacity) &&
                  (null == t ? void 0 : t.fifoStartIndex) &&
                  (this.xValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.yValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  ),
                  this.zValues.notifyAppend(
                    null == t ? void 0 : t.fifoStartIndex
                  )));
          }
          get yValues() {
            return this.getNativeYValues();
          }
          get zValues() {
            return this.getNativeZValues();
          }
          getNativeZValues() {
            return this.getNativeYValues(1);
          }
          append(e, t, r, i) {
            super.appendN(e, [t, r], i);
          }
          appendRange(e, t, r, i) {
            super.appendRangeN(e, [t, r], i);
          }
          update(e, t, r, i) {
            super.updateN(e, [t, r], i);
          }
          updateXyz(e, t, r, i, o) {
            super.updateXyN(e, t, [r, i], o);
          }
          insert(e, t, r, i, o) {
            super.insertN(e, t, [r, i], o);
          }
          insertRange(e, t, r, i, o) {
            super.insertRangeN(e, t, [r, i], o);
          }
          getOptions(e = !1) {
            const t = super.getOptions(e);
            if (!e) {
              const e = this.count(),
                r = new Array(e),
                i = new Array(e),
                o = new Array(e);
              if (this.fifoCapacity && this.fifoSweeping)
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.getRaw(t)),
                    (i[t] = this.yValues.getRaw(t)),
                    (o[t] = this.zValues.getRaw(t));
              else
                for (let t = 0; t < e; t++)
                  (r[t] = this.xValues.get(t)),
                    (i[t] = this.yValues.get(t)),
                    (o[t] = this.zValues.get(t));
              const a = { xValues: r, yValues: i, zValues: o };
              Object.assign(t, a);
            }
            return t;
          }
        }
        t.XyzDataSeries = n;
      },
      48804: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CategoryCoordinateCalculator = void 0);
        const i = r(72307);
        class o extends i.CoordinateCalculatorBase {
          constructor(e, t, r, i, o = 0) {
            super(e, t, r, i, o, !0, !0),
              (this.indexMin = r),
              (this.indexMax = i),
              (this.nativeCalculator = new e.CategoryCoordinateCalculatorDouble(
                this.viewportDimension,
                this.visibleMin,
                this.visibleMax,
                -1,
                this.offset,
                this.indexMin,
                this.indexMax
              ));
          }
          transformIndexToData(e) {
            return this.nativeCalculator.TransformIndexToData(
              e,
              this.baseXValues
            );
          }
          transformDataToIndex(e) {
            return this.nativeCalculator.TransformDataToIndex(
              e,
              this.baseXValues
            );
          }
        }
        t.CategoryCoordinateCalculator = o;
      },
      72307: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CoordinateCalculatorBase = void 0);
        const i = r(55023),
          o = r(98140);
        class a extends i.DeletableEntity {
          constructor(e, t, r, i, o, a, s = !1) {
            super(),
              (this.webAssemblyContext = e),
              (this.visibleMax = i),
              (this.visibleMin = r),
              (this.viewportDimension = t),
              (this.offset = o),
              (this.hasFlippedCoordinates = a),
              (this.isCategoryCoordinateCalculator = s);
          }
          getCoordinate(e) {
            return this.nativeCalculator.GetCoordinate(e);
          }
          getDataValue(e) {
            return this.nativeCalculator.GetDataValue(e);
          }
          translateBy(e, t) {
            let r = this.getDataValue(e) - this.getDataValue(0);
            return (
              this.hasFlippedCoordinates && (r = -r),
              new o.NumberRange(t.min + r, t.max + r)
            );
          }
          zoomTranslateBy(e, t, r) {
            return r.growBy(new o.NumberRange(e, t));
          }
          getDataWidth(e) {
            return Math.abs(this.getDataValue(e) - this.getDataValue(0));
          }
          getCoordWidth(e) {
            return Math.abs(this.getCoordinate(e) - this.getCoordinate(0));
          }
          get isFlipped() {
            return this.nativeCalculator.IsFlipped();
          }
          delete() {
            var e;
            null === (e = this.nativeCalculator) || void 0 === e || e.delete(),
              (this.nativeCalculator = void 0),
              (this.webAssemblyContext = void 0);
          }
        }
        t.CoordinateCalculatorBase = a;
      },
      25762: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FlippedCategoryCoordinateCalculator = void 0);
        const i = r(72307);
        class o extends i.CoordinateCalculatorBase {
          constructor(e, t, r, i, o = 0) {
            super(e, t, r, i, o, !1, !0),
              (this.indexMin = r),
              (this.indexMax = i),
              (this.nativeCalculator =
                new e.FlippedCategoryCoordinateCalculatorDouble(
                  this.viewportDimension,
                  this.visibleMin,
                  this.visibleMax,
                  -1,
                  this.offset,
                  this.indexMin,
                  this.indexMax
                ));
          }
          transformIndexToData(e) {
            return this.nativeCalculator.TransformIndexToData(
              e,
              this.baseXValues
            );
          }
          transformDataToIndex(e) {
            return this.nativeCalculator.TransformDataToIndex(
              e,
              this.baseXValues
            );
          }
        }
        t.FlippedCategoryCoordinateCalculator = o;
      },
      33166: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FlippedNumericCoordinateCalculator = void 0);
        const i = r(72307);
        class o extends i.CoordinateCalculatorBase {
          constructor(e, t, r, i, o = 0, a = !1, s = -1) {
            super(e, t, r, i, o, !0),
              (this.nativeCalculator = a
                ? new e.FlippedLinearCoordinateCalculatorSingle(
                    this.viewportDimension,
                    this.visibleMin,
                    this.visibleMax,
                    s,
                    this.offset
                  )
                : new e.FlippedLinearCoordinateCalculatorDouble(
                    this.viewportDimension,
                    this.visibleMin,
                    this.visibleMax,
                    s,
                    this.offset
                  ));
          }
        }
        t.FlippedNumericCoordinateCalculator = o;
      },
      46650: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogarithmicCoordinateCalculator = void 0);
        const i = r(98140),
          o = r(86699),
          a = r(72307);
        class s extends a.CoordinateCalculatorBase {
          constructor(e, t, r, i, a, s, n, l = 0) {
            o.EXyDirection.XDirection,
              super(e, t, r, i, l, n),
              (this.logBaseProperty = s),
              (this.nativeCalculator = n
                ? new e.FlippedLogarithmicCoordinateCalculator(
                    this.viewportDimension,
                    this.visibleMin,
                    this.visibleMax,
                    -1,
                    this.offset,
                    this.logBase
                  )
                : new e.LogarithmicCoordinateCalculator(
                    this.viewportDimension,
                    this.visibleMin,
                    this.visibleMax,
                    -1,
                    this.offset,
                    this.logBase
                  ));
          }
          get logBase() {
            return this.logBaseProperty;
          }
          translateBy(e, t) {
            if (0 === e) return t;
            const r = Math.abs(this.nativeCalculator.GetDataValue(0)),
              o = Math.abs(this.nativeCalculator.GetDataValue(e)),
              a = this.webAssemblyContext.NumberUtil,
              s = t.min < 0;
            s && (t = new i.NumberRange(Math.abs(t.max), Math.abs(t.min)));
            let n = a.Log(o, this.logBase) - a.Log(r, this.logBase);
            this.hasFlippedCoordinates && (n = -n);
            const l = a.Log(t.min, this.logBase),
              d = a.Log(t.max, this.logBase),
              h = Math.pow(this.logBase, l + n),
              u = Math.pow(this.logBase, d + n);
            return s ? new i.NumberRange(-u, -h) : new i.NumberRange(h, u);
          }
          zoomTranslateBy(e, t, r) {
            return r.growByLog(new i.NumberRange(e, t), this.logBase);
          }
        }
        t.LogarithmicCoordinateCalculator = s;
      },
      40194: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericCoordinateCalculator = void 0);
        const i = r(72307);
        class o extends i.CoordinateCalculatorBase {
          constructor(e, t, r, i, o = 0, a = !1, s = -1, n = 1) {
            super(e, t, r, i, o, !1);
            const l = a
              ? new e.LinearCoordinateCalculatorSingle(
                  this.viewportDimension,
                  this.visibleMin,
                  this.visibleMax,
                  s,
                  this.offset
                )
              : new e.LinearCoordinateCalculatorDouble(
                  this.viewportDimension,
                  this.visibleMin,
                  this.visibleMax,
                  s,
                  this.offset
                );
            (l.extraOffset = n), (this.nativeCalculator = l);
          }
        }
        t.NumericCoordinateCalculator = o;
      },
      78644: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ExtremeResamplerHelper = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(23866),
          s = r(17575),
          n = r(33240),
          l = r(97742);
        class d extends i.DeletableEntity {
          constructor(e) {
            super(),
              (this.isDeleted = !1),
              (this.nativeMergeIndexParams =
                new e.SCRTDoubleResamplerMergeIndicesParams()),
              (this.wasmContext = e),
              (this.nativeResampler =
                new this.wasmContext.SCRTDoubleResampler()),
              (this.xInput = new this.wasmContext.SCRTXvaluesProvider()),
              (this.nativeArgs = new this.wasmContext.ResamplingArgs()),
              (this.output =
                new this.wasmContext.SCRTDoubleArraysXyResampleOutput());
          }
          static resampleSeries(e, t, r) {
            if (!t.supportsResampling)
              return {
                pointSeries: t.toPointSeries(),
                renderableSeries: t,
                indicesRange: t.isStacked
                  ? void 0
                  : t.getIndicesRange(e.visibleRange, e.isCategoryAxis),
                resamplingHash: void 0,
              };
            let i = t.getResamplingParams();
            const o = t.getCurrentRenderPassData();
            if (!i || (i.resampleRequired && !o)) {
              if (
                ((i = new l.ResamplingParams(r, t, e)), !t.needsResampling(i))
              )
                return {
                  pointSeries: t.toPointSeries(),
                  renderableSeries: t,
                  indicesRange: i.indexesRange,
                  resamplingHash: void 0,
                };
              const o = d.calculateResamplingHash(t, i),
                a = t.getCurrentRenderPassData();
              return {
                pointSeries: Boolean(a && a.resamplingHash === o)
                  ? a.pointSeries
                  : t.toPointSeries(i),
                renderableSeries: t,
                indicesRange: i.indexesRange,
                resamplingHash: o,
              };
            }
            return i.resampleRequired
              ? {
                  pointSeries: o.pointSeries,
                  renderableSeries: t,
                  indicesRange: i.indexesRange,
                  resamplingHash: i.hash,
                }
              : {
                  pointSeries: t.toPointSeries(),
                  renderableSeries: t,
                  indicesRange: i.indexesRange,
                  resamplingHash: void 0,
                };
          }
          static calculateResamplingHash(e, t) {
            const r = [],
              i = e.dataSeries;
            if (i) {
              const e = s.hashUtils.generateHash(i.id);
              r.push(e);
              const t = s.hashUtils.generateNumberHash(i.count());
              r.push(t);
              const o = s.hashUtils.generateBooleanHash(
                i.dataDistributionCalculator.isSortedAscending
              );
              r.push(o);
              const a = s.hashUtils.generateNumberHash(i.changeCount);
              r.push(a);
            }
            const o = s.hashUtils.generateObjectHash(t);
            return (
              r.push(o), (t.hash = s.hashUtils.generateCombinedHash(r)), t.hash
            );
          }
          needsResampling(e, t, r = !0, i = !1) {
            r && this.resetAndFillBasicNativeArgs(e, t);
            const o = this.nativeResampler.RequiresReduction(this.nativeArgs),
              a = e.dataIsFifo || o;
            return (
              ((i && !a) || (a && !o)) &&
                (this.nativeArgs.Resampling = this.getNativeResamplingMode(
                  n.EResamplingMode.None
                )),
              a
            );
          }
          resampleIntoPointSeries(e, t, r, i, o, s, n, l, d = !0) {
            if (this.isDeleted)
              throw new Error(
                "should not call resampleIntoPointSeries() if deleted"
              );
            a.Guard.notNull(r, "xDataValues"),
              a.Guard.notNull(i, "yDataValues"),
              a.Guard.notNull(r, "xOriginalValues"),
              a.Guard.notNull(i, "yOriginalValues"),
              a.Guard.notNull(t, "resamplingParams"),
              d && this.resetAndFillBasicNativeArgs(t, r),
              this.xInput.SetInput(r),
              (this.nativeArgs.ResamplingPrecision = t.precision),
              (this.nativeArgs.ZeroLineY = t.zeroLineY),
              (this.nativeArgs.NewDataPointCount = -1),
              !0 === d && this.needsResampling(t, r, !1, !0);
            const h = this.nativeResampler.UpdateIndices(
              o,
              this.xInput,
              i,
              this.nativeArgs.Resampling,
              this.nativeArgs
            );
            s && s.resizeFast(h + 1),
              n.resizeFast(h + 1),
              l.resizeFast(h + 1),
              s
                ? this.output.ResetWithIndices(s, n, l)
                : this.output.Reset(n, l),
              this.nativeResampler.Execute(
                this.xInput,
                i,
                this.output,
                o,
                this.nativeArgs.Resampling,
                this.nativeArgs
              );
            const u = o.size();
            return (
              s && s.resizeFast(u),
              n.resizeFast(u),
              l.resizeFast(u),
              {
                OutputSplitIndex:
                  this.output.OutputSplitIndex ||
                  this.nativeArgs.OutputSplitIndex,
              }
            );
          }
          mergeIndexes(e, t, r, i) {
            return this.nativeResampler.MergeIndices(e, t, r, i);
          }
          copyValuesByIndexes(e, t, r, i, o, a, s, n, l, d, h, u = 0) {
            const c = this.nativeMergeIndexParams;
            c.SetIndices(e),
              c.SetXInput(t),
              c.SetYInput(r),
              c.SetY1Input(i),
              c.SetY1Offset(u),
              (c.count = o),
              (c.isCategoryData = a),
              (c.isFifoSweeping = s),
              c.SetIndicesOut(n),
              c.SetXOut(l),
              c.SetYOut(d),
              c.SetY1Out(h),
              this.nativeResampler.CopyValuesByIndices(c);
          }
          delete() {
            this.isDeleted ||
              ((0, o.deleteSafe)(this.nativeResampler),
              (0, o.deleteSafe)(this.xInput),
              (0, o.deleteSafe)(this.nativeArgs),
              (0, o.deleteSafe)(this.output),
              (0, o.deleteSafe)(this.nativeMergeIndexParams),
              (this.isDeleted = !0),
              (this.wasmContext = void 0));
          }
          getNativeResamplingMode(e) {
            switch (e) {
              case n.EResamplingMode.Auto:
                return this.wasmContext.ResamplingMode.Auto;
              case n.EResamplingMode.Max:
                return this.wasmContext.ResamplingMode.Max;
              case n.EResamplingMode.Mid:
                return this.wasmContext.ResamplingMode.Mid;
              case n.EResamplingMode.Min:
                return this.wasmContext.ResamplingMode.Min;
              case n.EResamplingMode.MinMax:
                return this.wasmContext.ResamplingMode.MinMax;
              case n.EResamplingMode.MinOrMax:
                return this.wasmContext.ResamplingMode.MinOrMax;
              case n.EResamplingMode.None:
                return this.wasmContext.ResamplingMode.None;
              default:
                throw new Error(`Unknown resamplingMode ${e}`);
            }
          }
          resetAndFillBasicNativeArgs(e, t) {
            if (
              (this.nativeArgs.Reset(),
              (this.nativeArgs.Data = this.getDataDistribution(
                e.dataEvenlySpaced,
                e.isCategoryAxis
              )),
              (this.nativeArgs.StartIndex = e.indexesRange.min),
              (this.nativeArgs.EndIndex = e.indexesRange.max),
              (this.nativeArgs.MaxXInclusive = e.xVisibleRange.max),
              (this.nativeArgs.MinXInclusive = e.xVisibleRange.min),
              (this.nativeArgs.Resampling = this.getNativeResamplingMode(
                e.resamplingMode
              )),
              (this.nativeArgs.ViewportWidth = e.viewportSize),
              (this.nativeArgs.FifoCapacity = e.fifoCapacity || 0),
              (this.nativeArgs.HasNaN = e.dataHasNaN),
              (this.nativeArgs.IsFifo = e.dataIsFifo),
              (this.nativeArgs.InputBaseIndex = e.fifoStartIndex || 0),
              e.isCategoryAxis)
            )
              (this.nativeArgs.MinXInclusive = e.indexesRange.min),
                (this.nativeArgs.MaxXInclusive = e.indexesRange.max);
            else if (e.fifoCapacity && !e.dataIsFifo) {
              const r = t.getRaw(e.indexesRange.min),
                i = t.getRaw(e.indexesRange.max);
              (this.nativeArgs.MinXInclusive = Math.max(
                r,
                e.xVisibleRange.min
              )),
                (this.nativeArgs.MaxXInclusive = Math.min(
                  i,
                  e.xVisibleRange.max
                ));
            } else {
              const r = t.get(e.indexesRange.min),
                i = t.get(e.indexesRange.max);
              (this.nativeArgs.MinXInclusive = Math.max(
                r,
                e.xVisibleRange.min
              )),
                (this.nativeArgs.MaxXInclusive = Math.min(
                  i,
                  e.xVisibleRange.max
                ));
            }
          }
          debugParameters(e, t) {
            console.log(31415),
              console.log("ResamplingParams:"),
              console.log(`.. zeroLineY: ${e.zeroLineY}`),
              console.log(`.. resamplingPrecision: ${e.precision}`),
              console.log(`.. xVisibleRange: ${e.xVisibleRange}`),
              console.log(`.. indicesRange: ${e.indexesRange}`),
              console.log(`.. viewportSize: ${e.viewportSize}`),
              console.log(`.. isCategoryAxis: ${e.isCategoryAxis}`),
              console.log(`.. isXAxisAutoRanged: ${e.isXAxisAutoRanged}`),
              console.log(`.. resamplingMode: ${e.resamplingMode}`),
              console.log(
                `.. enableExperimentalResampling: ${e.enableExperimentalResampling}`
              ),
              console.log(`.. dataHasNan: ${e.dataHasNaN}`),
              console.log(`.. dataIsFifo: ${e.dataIsFifo}`),
              console.log(`.. fifoCapacity: ${e.fifoCapacity}`),
              console.log(`.. dataEvenlySpaced: ${e.dataEvenlySpaced}`),
              console.log("native Resampling Args:"),
              console.log(
                `.. ResamplingData: ${this.debugResamplingDataEnum(t.Data)}`
              ),
              console.log(`.. StartIndex: ${t.StartIndex}`),
              console.log(`.. EndIndex: ${t.EndIndex}`),
              console.log(`.. FifoCapacity: ${t.FifoCapacity}`),
              console.log(`.. HasNaN: ${t.HasNaN}`),
              console.log(`.. IsFifo: ${t.IsFifo}`),
              console.log(`.. MaxXInclusive: ${t.MaxXInclusive}`),
              console.log(`.. MinXInclusive: ${t.MinXInclusive}`),
              console.log(
                `.. ResamplingMode: ${this.debugResamplingModeEnum(
                  t.Resampling
                )}`
              ),
              console.log(`.. ResamplingPrecision: ${t.ResamplingPrecision}`),
              console.log(`.. ViewportWidth: ${t.ViewportWidth}`),
              console.log(`.. ZeroLineY: ${t.ZeroLineY}`),
              console.log(`.. NewDataPointCount: ${t.NewDataPointCount}`),
              console.log(`.. InputBaseIndex: ${t.InputBaseIndex}`);
          }
          debugRect(e) {
            return `X ${e.x} Y ${e.y} Width ${e.width} Height ${e.height}`;
          }
          debugResamplingDataEnum(e) {
            return e === this.wasmContext.ResamplingData.LinearData
              ? "LinearData"
              : e === this.wasmContext.ResamplingData.CategoryData
              ? "CategoryData"
              : e === this.wasmContext.ResamplingData.UnsortedData
              ? "UnsortedData"
              : e === this.wasmContext.ResamplingData.UnevenlySpacedData
              ? "UnevenlySpacedData"
              : "Unknown";
          }
          debugResamplingModeEnum(e) {
            return e === this.wasmContext.ResamplingMode.MinMax
              ? "MinMax"
              : e === this.wasmContext.ResamplingMode.Auto
              ? "Auto"
              : "Unknown";
          }
          getDataDistribution(e, t) {
            return t
              ? this.wasmContext.ResamplingData.CategoryData
              : e
              ? this.wasmContext.ResamplingData.LinearData
              : this.wasmContext.ResamplingData.UnevenlySpacedData;
          }
        }
        t.ExtremeResamplerHelper = d;
      },
      33240: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EResamplingMode = void 0),
          ((r = t.EResamplingMode || (t.EResamplingMode = {})).None = "None"),
          (r.MinMax = "MinMax"),
          (r.Mid = "Mid"),
          (r.Max = "Max"),
          (r.Min = "Min"),
          (r.MinMaxWithUnevenSpacing = "MinMaxWithUnevenSpacing"),
          (r.Auto = "Auto"),
          (r.MinOrMax = "MinOrMax");
      },
      97742: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ResamplingParams = void 0);
        const i = r(12785);
        class o {
          constructor(e, t, r) {
            if (
              ((this.zeroLineY = 0),
              (this.precision = 0),
              (this.enableExperimentalResampling = !1),
              (this.fifoCapacity = 0),
              (this.fifoStartIndex = 0),
              t)
            ) {
              const o = t.dataSeries;
              (this.resamplingMode = t.resamplingMode),
                (this.precision = t.resamplingPrecision),
                r &&
                  ((this.indexesRange = t.getIndicesRange(
                    r.visibleRange,
                    r.isCategoryAxis
                  )),
                  (this.isCategoryAxis = r.isCategoryAxis),
                  (this.isXAxisAutoRanged =
                    r.autoRange === i.EAutoRange.Always),
                  (this.xVisibleRange = r.visibleRange),
                  (this.viewportSize = r.isVerticalChart ? e.height : e.width)),
                o &&
                  ((this.dataHasNaN =
                    null == o
                      ? void 0
                      : o.dataDistributionCalculator.containsNaN),
                  (this.dataEvenlySpaced =
                    null == o ? void 0 : o.isEvenlySpaced),
                  (this.fifoCapacity = o.fifoCapacity),
                  (this.fifoStartIndex = o.fifoStartIndex),
                  (this.dataIsFifo = o.fifoCapacity > 0 && !o.fifoSweeping));
            }
          }
          clone(e) {
            var t, r, i, a, s, n, l, d, h, u, c, p, g, y;
            const f = new o(void 0, void 0, void 0);
            return (
              (f.zeroLineY =
                null !== (t = null == e ? void 0 : e.zeroLineY) && void 0 !== t
                  ? t
                  : this.zeroLineY),
              (f.precision =
                null !== (r = null == e ? void 0 : e.precision) && void 0 !== r
                  ? r
                  : this.precision),
              (f.xVisibleRange =
                null !== (i = null == e ? void 0 : e.xVisibleRange) &&
                void 0 !== i
                  ? i
                  : this.xVisibleRange),
              (f.indexesRange =
                null !== (a = null == e ? void 0 : e.indicesRange) &&
                void 0 !== a
                  ? a
                  : this.indexesRange),
              (f.viewportSize =
                null !== (s = null == e ? void 0 : e.viewportSize) &&
                void 0 !== s
                  ? s
                  : this.viewportSize),
              (f.isCategoryAxis =
                null !== (n = null == e ? void 0 : e.isCategoryAxis) &&
                void 0 !== n
                  ? n
                  : this.isCategoryAxis),
              (f.isXAxisAutoRanged =
                null !== (l = null == e ? void 0 : e.isXAxisAutoRanged) &&
                void 0 !== l
                  ? l
                  : this.isXAxisAutoRanged),
              (f.resamplingMode =
                null !== (d = null == e ? void 0 : e.resamplingMode) &&
                void 0 !== d
                  ? d
                  : this.resamplingMode),
              (f.enableExperimentalResampling =
                null !==
                  (h = null == e ? void 0 : e.enableExperimentalResampling) &&
                void 0 !== h
                  ? h
                  : this.enableExperimentalResampling),
              (f.dataHasNaN =
                null !== (u = null == e ? void 0 : e.dataHasNaN) && void 0 !== u
                  ? u
                  : this.dataHasNaN),
              (f.dataEvenlySpaced =
                null !== (c = null == e ? void 0 : e.dataEvenlySpaced) &&
                void 0 !== c
                  ? c
                  : this.dataEvenlySpaced),
              (f.fifoCapacity =
                null !== (p = e.fifoCapacity) && void 0 !== p
                  ? p
                  : this.fifoCapacity),
              (f.fifoStartIndex =
                null !== (g = e.fifoStartIndex) && void 0 !== g
                  ? g
                  : this.fifoStartIndex),
              (f.dataIsFifo =
                null !== (y = e.dataIsFifo) && void 0 !== y
                  ? y
                  : this.dataIsFifo),
              f
            );
          }
        }
        t.ResamplingParams = o;
      },
      65707: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DefaultTickCoordinatesProvider = void 0);
        const i = r(73423);
        class o extends i.TickCoordinatesProvider {
          getTickCoordinates(e, t) {
            if (void 0 === e)
              return {
                majorTickCoords: void 0,
                minorTickCoords: void 0,
                majorTickOverrides: void 0,
                minorTickOverRides: void 0,
              };
            const r = this.parentAxis.getCurrentCoordinateCalculator();
            return {
              majorTickCoords: e.map(
                (e) => Math.round(r.getCoordinate(e)) + 0.5
              ),
              minorTickCoords: t.map(
                (e) => Math.round(r.getCoordinate(e)) + 0.5
              ),
              majorTickOverrides: e,
              minorTickOverRides: t,
            };
          }
        }
        t.DefaultTickCoordinatesProvider = o;
      },
      21430: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarTickCoordinatesProvider = void 0);
        const i = r(73423);
        class o extends i.TickCoordinatesProvider {
          getTickCoordinates(e, t) {
            if (void 0 === e)
              return {
                majorTickCoords: void 0,
                minorTickCoords: void 0,
                majorTickOverrides: void 0,
                minorTickOverRides: void 0,
              };
            const r = this.parentAxis.getCurrentCoordinateCalculator();
            return {
              majorTickCoords: e.map((e) => r.getCoordinate(e)),
              minorTickCoords: t.map((e) => r.getCoordinate(e)),
              majorTickOverrides: e,
              minorTickOverRides: t,
            };
          }
        }
        t.PolarTickCoordinatesProvider = o;
      },
      22019: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StaticTickCoordinatesProvider = void 0);
        const i = r(65707);
        class o extends i.DefaultTickCoordinatesProvider {
          getTickCoordinates(e, t) {
            var r = !this.parentAxis.visibleRange.equals(this.prevRange),
              i = this.parentAxis.getAxisSize() !== this.prevSize,
              o = this.parentAxis.getCurrentCoordinateCalculator();
            let a, s;
            if (void 0 === this.tickCoords || i) {
              if (void 0 === e)
                return {
                  majorTickCoords: void 0,
                  minorTickCoords: void 0,
                  majorTickOverrides: void 0,
                  minorTickOverRides: void 0,
                };
              const r = e.map((e) => o.getCoordinate(e)),
                i = t.map((e) => o.getCoordinate(e));
              this.tickCoords = {
                majorTickCoords: r,
                minorTickCoords: i,
                majorTicks: e,
                minorTicks: t,
                majorTickLabels: void 0,
              };
            } else
              r
                ? (this.OverrideTickValues(this.tickCoords),
                  (a = this.tickCoords.majorTicks),
                  (s = this.tickCoords.minorTicks))
                : this.OverrideTickCoordinates(this.tickCoords);
            return (
              (this.prevRange = this.parentAxis.visibleRange),
              (this.prevSize = this.parentAxis.getAxisSize()),
              {
                majorTickCoords: this.tickCoords.majorTickCoords.map((e) =>
                  Math.round(e + 0.5)
                ),
                minorTickCoords: this.tickCoords.minorTickCoords.map((e) =>
                  Math.round(e + 0.5)
                ),
                majorTickOverrides: a,
                minorTickOverRides: s,
              }
            );
          }
          forceRecalculateCoords() {
            this.tickCoords = void 0;
          }
          OverrideTickValues(e) {
            var t = this.parentAxis.getCurrentCoordinateCalculator();
            null != t &&
              (e.minorTickCoords.forEach(
                (r, i) => (e.minorTicks[i] = t.getDataValue(r))
              ),
              e.majorTickCoords.forEach(
                (r, i) => (e.majorTicks[i] = t.getDataValue(r))
              ));
          }
          OverrideTickCoordinates(e) {
            var t = this.parentAxis.getCurrentCoordinateCalculator();
            null != t &&
              null != t &&
              (e.minorTicks.forEach(
                (r, i) => (e.minorTickCoords[i] = t.getCoordinate(r))
              ),
              e.majorTicks.forEach(
                (r, i) => (e.majorTickCoords[i] = t.getCoordinate(r))
              ));
          }
        }
        t.StaticTickCoordinatesProvider = o;
      },
      73423: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TickCoordinatesProvider = void 0),
          (t.TickCoordinatesProvider = class {
            attachedToAxis(e) {
              this.parentAxis = e;
            }
            detachedFromAxis() {
              this.parentAxis = void 0;
            }
          });
      },
      98172: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogarithmicTickProvider =
            t.ELogarithmicMajorTickMode =
            t.ELogarithmicMinorTickMode =
              void 0);
        const i = r(23866),
          o = r(98140),
          a = r(72934),
          s = r(63345);
        var n, l;
        !(function (e) {
          (e.Linear = "Linear"),
            (e.Logarithmic = "Logarithmic"),
            (e.Auto = "Auto");
        })(
          (n =
            t.ELogarithmicMinorTickMode || (t.ELogarithmicMinorTickMode = {}))
        ),
          (function (e) {
            (e.EqualSpacing = "EqualSpacing"),
              (e.RoundNumbers = "RoundNumbers");
          })(
            (l =
              t.ELogarithmicMajorTickMode || (t.ELogarithmicMajorTickMode = {}))
          );
        class d extends s.TickProvider {
          constructor(e) {
            super(),
              (this.logarithmicBase = 10),
              (this.isHighPrecisionTicks = !0),
              (this.majorTickModeProperty = l.EqualSpacing),
              (this.minorTickModeProperty = n.Linear),
              (this.wasmContext = e);
          }
          get majorTickMode() {
            return this.majorTickModeProperty;
          }
          set majorTickMode(e) {
            var t;
            (this.majorTickModeProperty = e),
              (null === (t = this.parentAxis) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                this.parentAxis.invalidateParentCallback();
          }
          get minorTickMode() {
            return this.minorTickModeProperty;
          }
          set minorTickMode(e) {
            var t;
            (this.minorTickModeProperty = e),
              (null === (t = this.parentAxis) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                this.parentAxis.invalidateParentCallback();
          }
          getMajorTicks(e, t, r) {
            const i = new o.NumberRange(e, t),
              a = this.parentAxis;
            let s = 1;
            if (
              ((null == a ? void 0 : a.isNegative) &&
                r.min < 0 &&
                ((s = -1),
                (r = new o.NumberRange(Math.abs(r.max), Math.abs(r.min)))),
              !this.isParamsValid(r, i))
            )
              return [];
            if (this.majorTickMode === l.RoundNumbers)
              return this.getRoundNumberMajorTicks(e, t, r);
            {
              const e = [];
              if (0 === this.logarithmicBase) return e;
              let i = r.min;
              r.min;
              const o = r.max,
                a = this.wasmContext.NumberUtil;
              this.isHighPrecisionTicks ||
                a.IsPowerOf(i, this.logarithmicBase, this.logarithmicBase) ||
                (i = a.RoundDownPower(
                  i,
                  this.logarithmicBase,
                  this.logarithmicBase
                ));
              let n = a.Log(i, this.logarithmicBase);
              (n = a.RoundToDigits(n, 10)),
                a.IsDivisibleBy(n, t) || (n = a.RoundUp(n, t));
              let l = n;
              i = Math.pow(this.logarithmicBase, l);
              let d = 0;
              for (; i <= o; )
                a.IsDivisibleBy(l, t) && e.push(s * i),
                  (l = n + ++d * t),
                  (i = Math.pow(this.logarithmicBase, l));
              return -1 === s ? e.reverse() : e;
            }
          }
          getRoundNumberMajorTicks(e, t, r) {
            const i = [];
            let o = r.min;
            const a = r.min,
              s = r.max,
              n = Math.pow(this.logarithmicBase, t),
              l = this.roundNum(a * (n - 1));
            for (o = this.roundNum(o, l), i.push(o); o <= s; ) {
              const e = o * (n - 1);
              let t = this.roundNum(o * n, e),
                r = t;
              for (; t === o; ) (r *= n), (t = this.roundNum(r, e));
              (o = t), i.push(o);
            }
            return i;
          }
          roundNum(e, t) {
            if (0 === e) return 0;
            let r = Math.floor(Math.log10(e));
            t && (r = Math.min(r, Math.round(Math.log10(t))));
            const i = this.wasmContext.NumberUtil.RoundToDigits(
                e / Math.pow(10, r),
                1
              ),
              o = Math.floor(i),
              a = i - o;
            let s = NaN;
            return (
              (s = a < 0.3 ? 0 : a < 0.7 ? 0.5 : 1), (o + s) * Math.pow(10, r)
            );
          }
          getMinorTicks(e, t, r) {
            const i = this.parentAxis;
            let a = 1;
            (null == i ? void 0 : i.isNegative) &&
              ((a = -1),
              (r = new o.NumberRange(Math.abs(r.max), Math.abs(r.min))));
            const s = r.min * e,
              l = r.min * Math.pow(this.logarithmicBase, 0.7 * t),
              d = (Math.pow(this.logarithmicBase, t) - 1) / e,
              h =
                this.minorTickMode === n.Logarithmic ||
                (this.minorTickMode === n.Auto && l < s),
              u = [],
              c = this.getMajorTicks(e, t, r),
              p = c.length,
              g = Math.pow(this.logarithmicBase, t);
            if (p > 0)
              for (let i = 0; i <= p; i++) {
                const s = i < p ? c[i] : c[i - 1] * g,
                  n = Math.max(s / g, r.min),
                  l = n * e;
                if (h)
                  this.getMajorTicks(1, t / d, new o.NumberRange(n, s)).forEach(
                    (e) => u.push(a * e)
                  );
                else {
                  let e = n + l;
                  for (; e < s && l > 0; ) u.push(a * e), (e += l);
                }
              }
            return u;
          }
          isParamsValid(e, t) {
            return (
              i.Guard.notNull(e, "visibleRange"),
              i.Guard.notNull(t, "deltaRange"),
              (0, a.isRealNumber)(e.min) &&
                (0, a.isRealNumber)(e.max) &&
                (0, a.isRealNumber)(t.min) &&
                (0, a.isRealNumber)(t.max)
            );
          }
        }
        t.LogarithmicTickProvider = d;
      },
      3346: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericTickProvider = void 0);
        const i = r(23866),
          o = r(98140),
          a = r(72934),
          s = r(63345);
        class n extends s.TickProvider {
          constructor(e) {
            super(),
              (this.minDeltaValue = 1e-13),
              (this.webAssemblyContext = e);
          }
          getMinorTicks(e, t, r) {
            const i = new o.NumberRange(e, t),
              a = r;
            return this.isParamsValid(a, i)
              ? this.calculateTicks(a, i.min, i.max)
              : [];
          }
          getMajorTicks(e, t, r) {
            const i = new o.NumberRange(e, t),
              a = r;
            return this.isParamsValid(a, i)
              ? this.calculateTicks(a, i.max, i.max)
              : [];
          }
          isParamsValid(e, t) {
            return (
              i.Guard.notNull(e, "visibleRange"),
              i.Guard.notNull(t, "deltaRange"),
              (0, a.isRealNumber)(e.min) &&
                (0, a.isRealNumber)(e.max) &&
                t.min > 0 &&
                t.max > 0
            );
          }
          calculateTicks(e, t, r) {
            const i = [],
              o = e.min,
              a = e.max,
              s = t === r,
              n = this.webAssemblyContext.NumberUtil;
            let l = n.RoundUp(o, t);
            const d = l;
            let h = 0;
            for (; l <= a; )
              n.IsDivisibleBy(l, r) === s && i.push(l), (l = d + ++h * t);
            return i;
          }
        }
        t.NumericTickProvider = n;
      },
      63345: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TickProvider = void 0),
          (t.TickProvider = class {
            attachedToAxis(e) {
              this.parentAxis = e;
            }
            detachedFromAxis() {
              this.parentAxis = void 0;
            }
          });
      },
      3434: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChartTitleRenderer = void 0);
        const i = r(87108),
          o = r(71238),
          a = r(14184),
          s = r(24156);
        class n extends s.TitleRendererBase {
          constructor() {
            super(...arguments),
              (this.titleOffsetProperty = i.Thickness.fromNumber(0));
          }
          get titleOffset() {
            return this.titleOffsetProperty;
          }
          measure(e, t, r) {
            var i;
            const a =
              e !== this.text ||
              !(0, o.areEqualTextStyles)(t, this.originalTextStyle) ||
              (null === (i = this.originalTextStyle) || void 0 === i
                ? void 0
                : i.position) !== t.position;
            e &&
              e.length > 0 &&
              (!this.useCache || (!this.texture && !t.useNativeText) || a
                ? (this.invalidateCache(),
                  (this.text = e),
                  (this.originalTextStyle = Object.assign({}, t)),
                  (this.textStyle = (0, o.adjustTextStyle)(t)),
                  (this.useNativeTextProperty = t.useNativeText),
                  (this.titlePosition = t.position),
                  this.getTextSize(e, this.textStyle, r))
                : ((this.textStyle.alignment = t.alignment),
                  (this.textStyle.placeWithinChart = t.placeWithinChart))),
              (this.titleOffsetProperty = this.getTitleOffset(
                e,
                this.textStyle
              ));
          }
          layout(e) {
            this.text && 0 !== this.text.length
              ? (this.viewRectProperty = this.getViewRect(
                  this.text,
                  e,
                  this.textStyle.position,
                  this.textStyle.alignment
                ))
              : (this.viewRectProperty = void 0);
          }
          draw(e, t) {
            if (!this.text || 0 === this.text.length) return;
            a.DebugForDpi &&
              console.log(
                `ChartTitleRenderer.draw fontSize: ${this.textStyle.fontSize}`
              );
            const {
              useNativeText: r,
              position: i,
              lineSpacing: o,
            } = this.textStyle;
            this.drawInternal(e, r, i, t),
              this.drawDebug && this.drawTitleDebugViewRect(e);
          }
          getTitleTexture() {
            const e = this.textStyle.position;
            let t = (0, s.getAdjustedRotation)(this.textStyle.rotation, e);
            const r = Array.isArray(this.text)
              ? this.text
              : this.text.split("\n");
            return this.textureManager.createTextTexture(
              r,
              this.textStyle,
              t,
              this.textStyle.lineSpacing
            );
          }
          getTitleOffset(e, t) {
            if (!this.text || 0 === this.text.length || t.placeWithinChart)
              return i.Thickness.fromNumber(0);
            const r = this.textHeight;
            switch (t.position) {
              case o.ETitlePosition.Top:
                return new i.Thickness(r, 0, 0, 0);
              case o.ETitlePosition.Bottom:
                return new i.Thickness(0, 0, r, 0);
              case o.ETitlePosition.Left:
                return new i.Thickness(0, 0, 0, r);
              case o.ETitlePosition.Right:
                return new i.Thickness(0, r, 0, 0);
              default:
                return (0, o.handleInvalidChartTitlePosition)(t.position);
            }
          }
        }
        t.ChartTitleRenderer = n;
      },
      48570: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderPassData = void 0),
          (t.RenderPassData = class {
            constructor(e, t, r, i, o, a) {
              (this.indexRange = e),
                (this.getxCoordinateCalculator = t),
                (this.getyCoordinateCalculator = r),
                (this.isVerticalChart = i),
                (this.pointSeries = o),
                (this.resamplingHash = a);
            }
            get xCoordinateCalculator() {
              return this.getxCoordinateCalculator();
            }
            get yCoordinateCalculator() {
              return this.getyCoordinateCalculator();
            }
          });
      },
      648: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderPassDataCollection = void 0),
          (t.RenderPassDataCollection = class {});
      },
      17611: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderPassInfo = void 0),
          (t.RenderPassInfo = class {
            constructor(e, t) {
              (this.renderableSeriesArray = []),
                (this.rendermap = new Map()),
                (this.reverseMap = new Map()),
                (this.relativeItems = []),
                (this.seriesViewRect = t);
            }
            addRenderable(e, t) {
              var r;
              let i = e.getSurfaceRenderOrder(),
                o = e.getRenderLayer();
              if (e.getRenderNextTo())
                return void this.relativeItems.push({
                  renderable: e,
                  drawFunction: t,
                  tries: 0,
                });
              this.rendermap.has(i) || this.rendermap.set(i, new Map()),
                this.rendermap.get(i).get(o) ||
                  this.rendermap.get(i).set(o, []);
              const a = this.rendermap.get(i).get(o),
                s =
                  null !== (r = e.getRenderOrder()) && void 0 !== r
                    ? r
                    : a.length;
              a.push({ renderable: e, resolvedOrder: s, drawFunction: t }),
                this.reverseMap.set(e.id, {
                  surfaceOrder: i,
                  layer: o,
                  resolvedOrder: s,
                });
            }
            resolveNextTo() {
              for (; this.relativeItems.length > 0; ) {
                const e = this.relativeItems.shift(),
                  t = e.renderable.getRenderNextTo(),
                  r =
                    "string" == typeof t.renderable
                      ? t.renderable
                      : t.renderable.id;
                if (e.tries < this.relativeItems.length + 3)
                  if (this.reverseMap.has(r)) {
                    const {
                        surfaceOrder: i,
                        layer: o,
                        resolvedOrder: a,
                      } = this.reverseMap.get(r),
                      s = this.rendermap.get(i).get(o),
                      n = a + t.offset;
                    s.push({
                      renderable: e.renderable,
                      resolvedOrder: n,
                      drawFunction: e.drawFunction,
                    }),
                      this.reverseMap.set(e.renderable.id, {
                        surfaceOrder: i,
                        layer: o,
                        resolvedOrder: n,
                      });
                  } else (e.tries += 1), this.relativeItems.push(e);
                else console.warn(`Could not find relative item ${r} `);
              }
            }
          });
      },
      23059: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartRenderer = void 0);
        const i = r(84745),
          o = r(87459),
          a = r(12785),
          s = r(3777),
          n = r(16185),
          l = r(84626),
          d = r(14184),
          h = r(86127),
          u = r(48570),
          c = r(17611),
          p = r(98353),
          g = r(63458),
          y = r(48008),
          f = r(9254),
          v = r(16602),
          m = r(78644),
          S = r(66405),
          P = r(32873),
          C = r(77376),
          b = r(87108),
          x = r(34496);
        t.SciChartRenderer = class {
          constructor(e) {
            (this.isInvalidated = !1), (this.sciChartSurface = e);
          }
          render(e) {
            var t, r, a, n, d, h, u;
            if (this.sciChartSurface.isDeleted) return;
            const c = v.PerformanceDebugHelper.mark(
              v.EPerformanceMarkType.RenderStart,
              {
                contextId: this.sciChartSurface.id,
                level: v.EPerformanceDebugLevel.Verbose,
              }
            );
            f.Logger.debug("render start"), (this.isInvalidated = !1);
            const p = e.getNativeContext(),
              g = this.sciChartSurface.webAssemblyContext2D;
            let y;
            i.IS_TEST_ENV ||
              ((y = p.GetBlendMode()),
              p.SetBlendMode(g.eSCRTBlendMode.BlendAdditiveOneAlpha)),
              this.validate();
            const m = this.previousTime ? Date.now() - this.previousTime : 0;
            this.previousTime = Date.now();
            const S = v.PerformanceDebugHelper.mark(
              v.EPerformanceMarkType.GenericAnimationStart,
              {
                contextId: this.sciChartSurface.id,
                level: v.EPerformanceDebugLevel.Verbose,
              }
            );
            this.sciChartSurface.onAnimate(m),
              this.sciChartSurface.genericAnimationsRun.raiseEvent(),
              v.PerformanceDebugHelper.mark(
                v.EPerformanceMarkType.GenericAnimationEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == S ? void 0 : S.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: v.EPerformanceDebugLevel.Verbose,
                }
              ),
              e.enqueueLayeredDraw(() => {
                this.sciChartSurface.updateBackground(e);
              }, this.getAbsoluteLayer(s.EDefaultRenderLayer.Background)),
              this.sciChartSurface.updateStackedCollectionAccumulatedVectors();
            const P = v.PerformanceDebugHelper.mark(
              v.EPerformanceMarkType.AutoRangeStart,
              {
                contextId: this.sciChartSurface.id,
                level: v.EPerformanceDebugLevel.Verbose,
              }
            );
            this.sciChartSurface.xAxes
              .asArray()
              .forEach((e) =>
                this.tryPerformAutoRangeOn(e, this.sciChartSurface)
              );
            const C =
                null !== (r = this.sciChartSurface.seriesViewRect) &&
                void 0 !== r
                  ? r
                  : o.Rect.create(
                      0,
                      0,
                      e.viewportSize.width,
                      e.viewportSize.height
                    ),
              A = this.prepareSeriesRenderData(C);
            this.sciChartSurface.yAxes
              .asArray()
              .forEach((e) =>
                this.tryPerformAutoRangeOn(e, this.sciChartSurface)
              ),
              v.PerformanceDebugHelper.mark(
                v.EPerformanceMarkType.AutoRangeEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (a = null == P ? void 0 : P.detail) || void 0 === a
                      ? void 0
                      : a.relatedId,
                  level: v.EPerformanceDebugLevel.Verbose,
                }
              );
            const T = v.PerformanceDebugHelper.mark(
              v.EPerformanceMarkType.LayoutStart,
              {
                contextId: this.sciChartSurface.id,
                level: v.EPerformanceDebugLevel.Verbose,
              }
            );
            l.SciChartSurface.isSubSurface(this.sciChartSurface) &&
              this.sciChartSurface.updateSubLayout();
            const E = this.measureTitle(e),
              R = b.Thickness.mergeAdd(
                null !== (n = this.sciChartSurface.offset) && void 0 !== n
                  ? n
                  : b.Thickness.fromNumber(0),
                E
              ),
              D = this.sciChartSurface.layoutManager.layoutChart(
                e.viewportSize,
                R
              );
            if (
              (this.sciChartSurface.setCoordSvgTranslation(D.x, D.y),
              this.resizeAnnotationRootElements(D),
              this.layoutTitle(D),
              this.scheduleTitleDraw(e),
              v.PerformanceDebugHelper.mark(v.EPerformanceMarkType.LayoutEnd, {
                contextId: this.sciChartSurface.id,
                relatedId:
                  null === (d = null == T ? void 0 : T.detail) || void 0 === d
                    ? void 0
                    : d.relatedId,
                level: v.EPerformanceDebugLevel.Verbose,
              }),
              this.sciChartSurface.layoutMeasured.raiseEvent(),
              this.prepareAxesRenderData(),
              e.enqueueLayeredDraw(() => {
                this.sciChartSurface.drawBorder(e);
              }, this.getAbsoluteLayer(s.EDefaultRenderLayer.AxisBandsLayer)),
              this.sciChartSurface.debugRendering &&
                this.drawDebugAxes(this.sciChartSurface, e),
              this.drawAxes(this.sciChartSurface, e),
              this.getSeriesDrawFunctions(this.sciChartSurface, A, e),
              this.getAnnotationDrawFunctions(this.sciChartSurface, A, e),
              this.sciChartSurface.dataLabelLayoutManager)
            ) {
              const e = new x.OrderedRenderable(
                this.sciChartSurface.getSurfaceRenderOrder(),
                s.EDefaultRenderLayer.Foreground,
                void 0
              );
              A.addRenderable(e, () => {
                var e;
                const t = v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.PerformTextLayoutStart,
                  {
                    contextId: this.sciChartSurface.id,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.sciChartSurface.dataLabelLayoutManager.performTextLayout(
                  this.sciChartSurface,
                  A
                ),
                  v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.PerformTextLayoutEnd,
                    {
                      contextId: this.sciChartSurface.id,
                      relatedId:
                        null === (e = null == t ? void 0 : t.detail) ||
                        void 0 === e
                          ? void 0
                          : e.relatedId,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
              });
            }
            const w = new x.OrderedRenderable(
              this.sciChartSurface.getSurfaceRenderOrder(),
              s.EDefaultRenderLayer.Foreground,
              void 0
            );
            A.addRenderable(w, () => {
              A.renderableSeriesArray.forEach((t, r) => {
                var i;
                if (t.dataLabelProvider) {
                  const r = v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.DrawDataLabelsStart,
                    {
                      contextId: t.id,
                      parentContextId: this.sciChartSurface.id,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
                  t.dataLabelProvider.draw(e),
                    v.PerformanceDebugHelper.mark(
                      v.EPerformanceMarkType.DrawDataLabelsEnd,
                      {
                        contextId: t.id,
                        parentContextId: this.sciChartSurface.id,
                        relatedId:
                          null === (i = null == r ? void 0 : r.detail) ||
                          void 0 === i
                            ? void 0
                            : i.relatedId,
                        level: v.EPerformanceDebugLevel.Verbose,
                      }
                    );
                }
              });
            }),
              this.enqueueRenderables(e, A);
            const M = this.getAbsoluteLayer(s.EDefaultRenderLayer.Foreground);
            e.enqueueLayeredDraw(() => {
              const t = this.sciChartSurface.clipRect;
              p.PushMatrix(),
                p.PushState(),
                p.SetClipRect(t.x, t.y, t.width, t.height),
                e.endFonts(),
                p.PopMatrix(),
                p.PopState();
            }, M),
              e.drawLayers(),
              l.SciChartSurface.isSubSurface(this.sciChartSurface)
                ? e.doDraw &&
                  this.updateWatermark(
                    e,
                    this.sciChartSurface.parentSurface.seriesViewRect
                  )
                : this.updateWatermark(e, D);
            const L = v.PerformanceDebugHelper.mark(
              v.EPerformanceMarkType.PostDrawActionsStart,
              {
                contextId: this.sciChartSurface.id,
                level: v.EPerformanceDebugLevel.Verbose,
              }
            );
            this.onParentSurfaceRendered(),
              i.IS_TEST_ENV || p.SetBlendMode(y),
              this.sciChartSurface.isRunningAnimation &&
                setTimeout(this.sciChartSurface.invalidateElement, 0),
              v.PerformanceDebugHelper.mark(
                v.EPerformanceMarkType.PostDrawActionsEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (h = null == L ? void 0 : L.detail) || void 0 === h
                      ? void 0
                      : h.relatedId,
                  level: v.EPerformanceDebugLevel.Verbose,
                }
              ),
              v.PerformanceDebugHelper.mark(v.EPerformanceMarkType.RenderEnd, {
                contextId: this.sciChartSurface.id,
                relatedId:
                  null === (u = null == c ? void 0 : c.detail) || void 0 === u
                    ? void 0
                    : u.relatedId,
                level: v.EPerformanceDebugLevel.Verbose,
              }),
              f.Logger.debug("render end");
          }
          getSeriesDrawFunctions(e, t, r) {
            const { renderableSeriesArray: i } = t,
              a = r.getNativeContext(),
              s = this.sciChartSurface.seriesViewRect,
              n = o.Rect.intersect(
                this.sciChartSurface.seriesViewRect,
                this.sciChartSurface.clipRect
              );
            for (const e of i) {
              if (!e.isVisible) continue;
              const i = () => {
                a.PushMatrix(),
                  a.PushState(),
                  a.Translate(s.x, s.y),
                  a.SetClipRect(n.x, n.y, n.width, n.height),
                  e.draw(r, e.getCurrentRenderPassData()),
                  a.PopMatrix(),
                  a.PopState();
              };
              t.addRenderable(e, i);
            }
          }
          getAnnotationDrawFunctions(e, t, r) {
            const i = this.sciChartSurface.seriesViewRect,
              o = this.sciChartSurface.annotations.asArray(),
              a = this.sciChartSurface.modifierAnnotations.asArray(),
              s = this.sciChartSurface.getCoordSvgTranslation();
            for (const e of o)
              e.isDomAnnotation
                ? this.getHTMLAnnotationDrawFunction(e, s)
                : e.isVisible &&
                  this.getRenderContextAnnotationDrawFunction(e, r, i, t);
            for (const e of a)
              e.isDomAnnotation
                ? this.getHTMLAnnotationDrawFunction(e, s)
                : e.isVisible &&
                  this.getRenderContextAnnotationDrawFunction(e, r, i, t);
          }
          getHTMLAnnotationDrawFunction(e, t) {
            var r;
            e.linkAxes();
            const i = e.xAxis,
              o = e.yAxis;
            if (i && o) {
              const a = v.PerformanceDebugHelper.mark(
                v.EPerformanceMarkType.DrawAnnotationStart,
                {
                  contextId: e.id,
                  parentContextId: this.sciChartSurface.id,
                  level: v.EPerformanceDebugLevel.Verbose,
                }
              );
              e.update(
                i.getCurrentCoordinateCalculator(),
                o.getCurrentCoordinateCalculator(),
                t.x / h.DpiHelper.PIXEL_RATIO,
                t.y / h.DpiHelper.PIXEL_RATIO
              ),
                v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.DrawAnnotationEnd,
                  {
                    contextId: e.id,
                    parentContextId: this.sciChartSurface.id,
                    relatedId:
                      null === (r = null == a ? void 0 : a.detail) ||
                      void 0 === r
                        ? void 0
                        : r.relatedId,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
            } else
              console.error(
                "Cannot draw annotations before axes have been configured. Add axes first, or use suspendUpdates to pause drawing until axes are available."
              );
          }
          getRenderContextAnnotationDrawFunction(e, t, r, i) {
            const o = this.sciChartSurface.viewRect,
              a = this.sciChartSurface.chartViewRect;
            if (e.isVisible) {
              const s = () => {
                var i;
                e.linkAxes();
                const s = e.xAxis,
                  n = e.yAxis;
                if (s && n) {
                  const l = v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.DrawAnnotationStart,
                    {
                      contextId: e.id,
                      parentContextId: this.sciChartSurface.id,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
                  e.drawWithContext(
                    t,
                    s.getCurrentCoordinateCalculator(),
                    n.getCurrentCoordinateCalculator(),
                    r,
                    o,
                    a
                  ),
                    v.PerformanceDebugHelper.mark(
                      v.EPerformanceMarkType.DrawAnnotationEnd,
                      {
                        contextId: e.id,
                        parentContextId: this.sciChartSurface.id,
                        relatedId:
                          null === (i = null == l ? void 0 : l.detail) ||
                          void 0 === i
                            ? void 0
                            : i.relatedId,
                        level: v.EPerformanceDebugLevel.Verbose,
                      }
                    );
                } else
                  console.error(
                    "Cannot draw annotations before axes have been configured. Add axes first, or use suspendUpdates to pause drawing until axes are available."
                  );
              };
              i.addRenderable(e, s);
            }
          }
          enqueueRenderables(e, t) {
            t.resolveNextTo();
            const r = Array.from(t.rendermap.keys());
            r.sort((e, t) => e - t);
            for (const i of r) {
              const r = Array.from(t.rendermap.get(i).keys());
              r.sort((e, t) => e - t);
              for (const o of r) {
                const r = t.rendermap.get(i).get(o);
                r.sort((e, t) => e.resolvedOrder - t.resolvedOrder);
                const a = (0, n.calculateAbsoluteRenderLayer)(
                  i,
                  this.sciChartSurface.stepBetweenLayers,
                  o
                );
                for (const t of r)
                  (null == t ? void 0 : t.drawFunction) &&
                    this.enqueueRenderable(e, t, a);
              }
            }
          }
          enqueueRenderable(e, t, r) {
            e.enqueueLayeredDraw(t.drawFunction, r);
          }
          drawRenderContextAnnotations(e, t, r, i) {
            const o = this.sciChartSurface.viewRect,
              a = this.sciChartSurface.chartViewRect;
            e.filter((e) => e.annotationLayer === t).forEach((e) => {
              var t;
              e.linkAxes();
              const s = e.xAxis,
                n = e.yAxis;
              if (s && n) {
                if (!e.isHidden) {
                  const l = v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.DrawAnnotationStart,
                    {
                      contextId: e.id,
                      parentContextId: this.sciChartSurface.id,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
                  e.drawWithContext(
                    r,
                    s.getCurrentCoordinateCalculator(),
                    n.getCurrentCoordinateCalculator(),
                    i,
                    o,
                    a
                  ),
                    v.PerformanceDebugHelper.mark(
                      v.EPerformanceMarkType.DrawAnnotationEnd,
                      {
                        contextId: e.id,
                        parentContextId: this.sciChartSurface.id,
                        relatedId:
                          null === (t = null == l ? void 0 : l.detail) ||
                          void 0 === t
                            ? void 0
                            : t.relatedId,
                        level: v.EPerformanceDebugLevel.Verbose,
                      }
                    );
                }
              } else
                console.error(
                  "Cannot draw annotations before axes have been configured. Add axes first, or use suspendUpdates to pause drawing until axes are available."
                );
            });
          }
          drawHtmlBasedAnnotations(e, t) {
            e.forEach((e) => {
              var r;
              e.linkAxes();
              const i = e.xAxis,
                o = e.yAxis;
              if (i && o) {
                const a = v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.DrawAnnotationStart,
                  {
                    contextId: this.sciChartSurface.id,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
                e.update(
                  i.getCurrentCoordinateCalculator(),
                  o.getCurrentCoordinateCalculator(),
                  t.x / h.DpiHelper.PIXEL_RATIO,
                  t.y / h.DpiHelper.PIXEL_RATIO
                ),
                  v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.DrawAnnotationEnd,
                    {
                      contextId: this.sciChartSurface.id,
                      relatedId:
                        null === (r = null == a ? void 0 : a.detail) ||
                        void 0 === r
                          ? void 0
                          : r.relatedId,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
              } else
                console.error(
                  "Cannot draw annotations before axes have been configured. Add axes first, or use suspendUpdates to pause drawing until axes are available."
                );
            });
          }
          validate() {
            if (
              (this.sciChartSurface.xAxes
                .asArray()
                .forEach((e) => (e.isMeasured = !1)),
              this.sciChartSurface.yAxes
                .asArray()
                .forEach((e) => (e.isMeasured = !1)),
              this.sciChartSurface.renderableSeries.size() > 0)
            ) {
              const e = this.sciChartSurface.validateAndLink();
              if (e.length > 0) throw new Error(e.join("\n"));
            }
          }
          resizeAnnotationRootElements(e) {
            const t = this.sciChartSurface.clipRect,
              r = (0, P.translateToNotScaledRect)(t),
              i = o.Rect.intersect((0, P.translateToNotScaledRect)(e), r),
              a = this.sciChartSurface.viewRect,
              s = o.Rect.intersect((0, P.translateToNotScaledRect)(a), r);
            if (this.prevRect && this.prevSurfaceRect) {
              if (
                o.Rect.isEqual(this.prevRect, i) &&
                o.Rect.isEqual(this.prevSurfaceRect, s)
              )
                return;
            } else (this.prevRect = i), (this.prevSurfaceRect = s);
            (this.prevRect = i), (this.prevSurfaceRect = a);
            const n = this.sciChartSurface.domSvgContainer;
            n && this.sciChartSurface.setSvgClipPathDefinitions(n, i, s);
            const l = this.sciChartSurface.domBackgroundSvgContainer;
            l && this.sciChartSurface.setSvgClipPathDefinitions(l, i, s);
            const d = this.sciChartSurface.domSvgAdornerLayer;
            d && this.sciChartSurface.setSvgClipPathDefinitions(d, i, s);
          }
          prepareAxesRenderData() {
            this.sciChartSurface.xAxes.asArray().forEach((e) => {
              e.prepareRenderData();
            }),
              this.sciChartSurface.yAxes.asArray().forEach((e) => {
                e.prepareRenderData();
              });
          }
          prepareSeriesRenderData(e) {
            var t;
            const r = this.sciChartSurface.renderableSeries.size(),
              i = new c.RenderPassInfo(r, e);
            for (
              let r = 0;
              r < this.sciChartSurface.renderableSeries.size();
              r++
            ) {
              const o = this.sciChartSurface.renderableSeries.get(r);
              if (!o.isStacked && !o.dataSeries) continue;
              if (!o.isStacked && o.dataSeries.getIsDeleted())
                throw new Error(
                  `SciChartSurface.renderableSeries[index=${r}] dataSeries has been deleted. This is an invalid state for SciChart. Have you shared this DataSeries between chart surfaces?`
                );
              const a = v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.ResampleSingleSeriesStart,
                  {
                    contextId: o.id,
                    parentContextId: this.sciChartSurface.id,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                ),
                s = o.xAxis,
                n = o.yAxis,
                l = m.ExtremeResamplerHelper.resampleSeries(s, o, e);
              i.renderableSeriesArray.push(l.renderableSeries);
              const d = new u.RenderPassData(
                l.indicesRange,
                s.getCurrentCoordinateCalculator,
                n.getCurrentCoordinateCalculator,
                s.isVerticalChart,
                l.pointSeries,
                l.resamplingHash
              );
              o.setCurrentRenderPassData(d),
                v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.ResampleSingleSeriesEnd,
                  {
                    contextId: o.id,
                    parentContextId: this.sciChartSurface.id,
                    relatedId:
                      null === (t = null == a ? void 0 : a.detail) ||
                      void 0 === t
                        ? void 0
                        : t.relatedId,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
            }
            return i;
          }
          drawAxes(e, t) {
            e.xAxes.asArray().forEach((e) => {
              e.draw(t);
            }),
              e.yAxes.asArray().forEach((e) => {
                e.draw(t);
              });
          }
          drawSeries(e, t, r) {
            var i;
            const { renderableSeriesArray: a } = t,
              s = r.getNativeContext(),
              n = this.sciChartSurface.seriesViewRect,
              l = o.Rect.intersect(
                this.sciChartSurface.seriesViewRect,
                this.sciChartSurface.clipRect
              );
            if (
              (s.PushMatrix(),
              s.PushState(),
              s.Translate(n.x, n.y),
              s.SetClipRect(l.x, l.y, l.width, l.height),
              a.forEach((e, t) => {
                !e.isVisible ||
                  e.isSelected ||
                  e.isHovered ||
                  e.draw(r, e.getCurrentRenderPassData());
              }),
              a.forEach((e, t) => {
                e.isVisible &&
                  e.isHovered &&
                  e.draw(r, e.getCurrentRenderPassData());
              }),
              a.forEach((e, t) => {
                e.isVisible &&
                  e.isSelected &&
                  e.draw(r, e.getCurrentRenderPassData());
              }),
              this.sciChartSurface.dataLabelLayoutManager)
            ) {
              const e = v.PerformanceDebugHelper.mark(
                v.EPerformanceMarkType.PerformTextLayoutStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: v.EPerformanceDebugLevel.Verbose,
                }
              );
              this.sciChartSurface.dataLabelLayoutManager.performTextLayout(
                this.sciChartSurface,
                t
              ),
                v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.PerformTextLayoutEnd,
                  {
                    contextId: this.sciChartSurface.id,
                    relatedId:
                      null === (i = null == e ? void 0 : e.detail) ||
                      void 0 === i
                        ? void 0
                        : i.relatedId,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
            }
            a.forEach((e, t) => {
              var i;
              if (e.isVisible && e.dataLabelProvider) {
                const t = v.PerformanceDebugHelper.mark(
                  v.EPerformanceMarkType.DrawDataLabelsStart,
                  {
                    contextId: e.id,
                    parentContextId: this.sciChartSurface.id,
                    level: v.EPerformanceDebugLevel.Verbose,
                  }
                );
                e.dataLabelProvider.draw(r),
                  v.PerformanceDebugHelper.mark(
                    v.EPerformanceMarkType.DrawDataLabelsEnd,
                    {
                      contextId: e.id,
                      parentContextId: this.sciChartSurface.id,
                      relatedId:
                        null === (i = null == t ? void 0 : t.detail) ||
                        void 0 === i
                          ? void 0
                          : i.relatedId,
                      level: v.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }
            }),
              s.PopMatrix(),
              s.PopState();
          }
          drawDebugAxes(e, t) {
            t.enqueueLayeredDraw(() => {
              e.xAxes.asArray().forEach((e) => {
                e.drawDebug(t);
              }),
                e.yAxes.asArray().forEach((e) => {
                  e.drawDebug(t);
                });
            });
          }
          tryPerformAutoRangeOn(e, t) {
            const r = !e.hasValidVisibleRange() || e.hasDefaultVisibleRange();
            if (
              e.autoRange === a.EAutoRange.Always ||
              (e.autoRange === a.EAutoRange.Once && r)
            ) {
              const t = e.getMaximumRange();
              t.equals(e.visibleRange) ||
                (!e.autoRangeAnimation ||
                (r && !e.autoRangeAnimation.animateInitialRanging) ||
                (!r && !e.autoRangeAnimation.animateSubsequentRanging)
                  ? (e.visibleRange = t)
                  : t.equals(e.animatedVisibleRange) ||
                    e.animateVisibleRange(
                      t,
                      e.autoRangeAnimation.duration,
                      e.autoRangeAnimation.easing
                    ));
            }
          }
          onParentSurfaceRendered() {
            var e;
            this.sciChartSurface.isSubSurface ||
              this.sciChartSurface.chartModifiers.asArray().forEach((e) => {
                e.modifierType !== S.EModifierType.Chart3DModifier &&
                  e.linkAxes(),
                  e.onParentSurfaceRendered();
              }),
              null === (e = this.sciChartSurface.subCharts) ||
                void 0 === e ||
                e.forEach((e) => {
                  e.chartModifiers.asArray().forEach((e) => {
                    e.onParentSurfaceRendered();
                  });
                });
          }
          updateWatermark(e, t) {
            const r = this.sciChartSurface.isCopyCanvasSurface
                ? d.SciChartSurfaceBase.domMasterCanvas.height
                : e.viewportSize.height,
              i = this.sciChartSurface.isCopyCanvasSurface
                ? d.SciChartSurfaceBase.domMasterCanvas.width
                : e.viewportSize.width,
              { left: o, bottom: a } = C.watermarkHelpers.calcPosition(
                i,
                r,
                this.sciChartSurface.watermarkPosition,
                this.sciChartSurface.watermarkRelativeToCanvas,
                t,
                e.viewportSize
              );
            this.sciChartSurface.updateWatermark(o, a);
          }
          scheduleTitleDraw(e) {
            e.enqueueLayeredDraw(() => {
              this.sciChartSurface.chartTitleRenderer.draw(
                e,
                this.sciChartSurface.clipRect
              );
            }, this.getAbsoluteLayer(s.EDefaultRenderLayer.AnnotationsAboveSeriesLayer));
          }
          measureTitle(e) {
            return (
              this.sciChartSurface.chartTitleRenderer.measure(
                this.sciChartSurface.title,
                this.sciChartSurface.titleStyle,
                e
              ),
              this.sciChartSurface.chartTitleRenderer.titleOffset
            );
          }
          layoutTitle(e) {
            const t = this.sciChartSurface.titleStyle.placeWithinChart
              ? e
              : this.sciChartSurface.viewRect;
            this.sciChartSurface.chartTitleRenderer.layout(t);
          }
          getAbsoluteLayer(e) {
            return (0, n.calculateAbsoluteRenderLayer)(
              this.sciChartSurface.getSurfaceRenderOrder(),
              this.sciChartSurface.stepBetweenLayers,
              e
            );
          }
          drawDebugSurfaceRect(e, t, r) {
            const i = (0, p.getVectorRectVertex)(r),
              o = new r.SCRTSolidBrush(
                (0, y.parseColorToUIntArgb)("rgba(0,255,0,0.7)"),
                !1
              ),
              a = (0, g.createNativeRect)(r, 0, 0, t.width, t.height);
            i.push_back(a),
              e.drawRects(
                i,
                o,
                this.sciChartSurface.chartViewRect,
                t.left,
                t.top
              ),
              o.delete();
          }
        };
      },
      24156: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAdjustedRotation = t.TitleRendererBase = void 0);
        const i = r(84745),
          o = r(55023),
          a = r(56744),
          s = r(87459),
          n = r(36420),
          l = r(71238),
          d = r(48008),
          h = r(87092),
          u = r(63458),
          c = r(98353),
          p = r(86127),
          g = r(76829);
        class y extends o.DeletableEntity {
          constructor(e) {
            super(),
              (this.drawDebug = !1),
              (this.useCache = !0),
              (this.viewRectProperty = s.Rect.createZero()),
              (this.textHeight = 0),
              (this.textWidth = 0),
              (this.desiredHeightProperty = 0),
              (this.desiredWidthProperty = 0),
              (this.useNativeTextProperty = !1),
              (this.webAssemblyContext = e),
              (this.textureManager = new g.TextureManager(e)),
              (this.onDpiChanged = this.onDpiChanged.bind(this)),
              p.DpiHelper.dpiChanged.subscribe(this.onDpiChanged);
          }
          get viewRect() {
            return this.viewRectProperty;
          }
          measure(...e) {}
          layout(e) {}
          draw(...e) {}
          delete() {
            this.resetCache(),
              (this.textureManager = (0, a.deleteSafe)(this.textureManager)),
              (this.webAssemblyContext = void 0),
              p.DpiHelper.dpiChanged.unsubscribe(this.onDpiChanged);
          }
          resetCache() {
            this.invalidateCache(),
              (this.textStyle = void 0),
              (this.originalTextStyle = void 0);
          }
          invalidateCache() {
            var e;
            (0, a.deleteSafe)(
              null === (e = this.texture) || void 0 === e
                ? void 0
                : e.bitmapTexture
            ),
              (this.texture = void 0);
          }
          onDpiChanged(e) {
            this.resetCache();
          }
          drawInternal(e, t, r, i) {
            this.text &&
              0 !== this.text.length &&
              (t
                ? this.drawWithNativeText(e, r, i)
                : this.drawWithTexture(e, r, i));
          }
          drawWithNativeText(e, r, i) {
            const o = Array.isArray(this.text)
                ? this.text.join("\n")
                : this.text,
              a = e.getFont(this.textStyle, !0);
            let s = this.viewRect.left + this.nativeTextShiftX,
              l = this.viewRect.top + this.nativeTextShiftY;
            const h =
                (-(0, t.getAdjustedRotation)(this.textStyle.rotation, r) *
                  Math.PI) /
                180,
              u = (0, n.convertMultiLineAlignment)(
                this.textStyle.multilineAlignment,
                this.webAssemblyContext
              ),
              p = (0, d.parseColorToUIntArgb)(this.textStyle.color);
            a.DrawStringAdvanced(
              o,
              p,
              Math.round(s),
              Math.round(l),
              (0, c.getVector4)(this.webAssemblyContext, s, l, h, 0),
              u,
              this.nativeLineSpacing
            ),
              a.End();
          }
          drawWithTexture(e, t, r) {
            const {
              bitmapTexture: i,
              textureHeight: o,
              textureWidth: a,
            } = this.texture;
            if (i)
              try {
                const t = e.getNativeContext();
                t.PushState(),
                  t.SetClipRect(r.x, r.y, r.width, r.height),
                  t.DrawTexture(
                    i,
                    Math.round(this.viewRect.left),
                    Math.round(this.viewRect.top),
                    a,
                    o
                  ),
                  t.PopState(),
                  this.useCache || (i.delete(), (this.texture = void 0));
              } catch (e) {
                console.error("Error while drawing title: ", e),
                  this.resetCache();
              }
          }
          getTextSize(e = "", r, o) {
            if (!e || 0 === e.length)
              return (
                (this.desiredHeightProperty = 0),
                (this.desiredWidthProperty = 0),
                (this.textHeight = 0),
                void (this.textWidth = 0)
              );
            const a = (0, l.getIsHorizontalPlacement)(this.titlePosition);
            if (this.useNativeTextProperty) {
              const i = o.getFont(r, !a),
                s = Array.isArray(e) ? e.join("\n") : e,
                n = (0, t.getAdjustedRotation)(r.rotation, this.titlePosition),
                {
                  textHeight: l,
                  textWidth: d,
                  nativeLineSpacing: u,
                  deltaX: c,
                  deltaY: p,
                } = (0, h.getNativeTextSize)(
                  s,
                  i,
                  r,
                  this.webAssemblyContext,
                  n
                );
              (this.textHeight = a ? l : d),
                (this.textWidth = a ? d : l),
                (this.nativeLineSpacing = u),
                (this.nativeTextShiftX = c),
                (this.nativeTextShiftY = p),
                (this.desiredHeightProperty = a
                  ? this.textHeight
                  : this.textWidth),
                (this.desiredWidthProperty = a
                  ? this.textWidth
                  : this.textHeight);
            } else {
              const e = this.getTitleTexture();
              (this.texture = e),
                (this.desiredHeightProperty = e.textureHeight),
                (this.desiredWidthProperty = e.textureWidth),
                (this.textHeight = a
                  ? this.desiredHeightProperty
                  : this.desiredWidthProperty),
                (this.textWidth = a
                  ? this.desiredWidthProperty
                  : this.desiredHeightProperty);
            }
            i.IS_TEST_ENV &&
              (a
                ? ((this.desiredHeightProperty =
                    (0, g.measureTextHeight)(r.fontSize) +
                    this.textStyle.padding.top +
                    this.textStyle.padding.bottom),
                  (this.desiredWidthProperty = 0))
                : ((this.desiredHeightProperty = 0),
                  (this.desiredWidthProperty =
                    (0, g.measureTextHeight)(r.fontSize) +
                    this.textStyle.padding.top +
                    this.textStyle.padding.bottom)));
          }
          getTitleTexture() {
            const e = Array.isArray(this.text)
              ? this.text
              : this.text.split("\n");
            return this.textureManager.createTextTexture(e, this.textStyle);
          }
          getViewRect(e = "", t, r, i) {
            if (!e || 0 === e.length) return s.Rect.createZero();
            const o = (0, l.getIsHorizontalPlacement)(r),
              a = this.getAlignmentAdjustmentDelta(
                o ? t.width : t.height,
                r,
                i
              );
            switch (r) {
              case l.ETitlePosition.Top:
                return new s.Rect(
                  t.x + a,
                  t.y,
                  this.textWidth,
                  this.textHeight
                );
              case l.ETitlePosition.Bottom:
                return new s.Rect(
                  t.x + a,
                  t.bottom - this.textHeight,
                  this.textWidth,
                  this.textHeight
                );
              case l.ETitlePosition.Left:
                return new s.Rect(
                  t.x,
                  t.y + a,
                  this.textHeight,
                  this.textWidth
                );
              case l.ETitlePosition.Right:
                return new s.Rect(
                  t.right - this.textHeight,
                  t.y + a,
                  this.textHeight,
                  this.textWidth
                );
              default:
                return (0, l.handleInvalidChartTitlePosition)(r);
            }
          }
          drawTitleDebugViewRect(e) {
            const t = this.viewRect,
              r = (0, c.getVectorRectVertex)(this.webAssemblyContext),
              i = new this.webAssemblyContext.SCRTSolidBrush(
                (0, d.parseColorToUIntArgb)("rgba(0,255,0,0.7)"),
                !1
              ),
              o = (0, u.createNativeRect)(
                this.webAssemblyContext,
                0,
                0,
                t.width,
                t.height
              );
            r.push_back(o), e.drawRects(r, i, t, t.left, t.top), i.delete();
          }
          getAlignmentAdjustmentDelta(e, t, r) {
            switch (r) {
              case l.ETextAlignment.Center:
                return e / 2 - this.textWidth / 2;
              case l.ETextAlignment.Left:
                return t === l.ETitlePosition.Left ? e - this.textWidth : 0;
              case l.ETextAlignment.Right:
                return t === l.ETitlePosition.Left ? 0 : e - this.textWidth;
              default:
                return (0, l.handleInvalidTextAlignment)(r);
            }
          }
        }
        (t.TitleRendererBase = y),
          (t.getAdjustedRotation = (e, t) => {
            if (void 0 !== e) return (e + 360) % 360;
            let r = 0;
            return (
              t === l.ETitlePosition.Left
                ? (r += -90)
                : t === l.ETitlePosition.Right && (r += 90),
              (r + 360) % 360
            );
          });
      },
      84392: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.stripAutoColor = t.ThemeProvider = t.AUTO_COLOR = void 0);
        const i = r(48008),
          o = r(52881);
        (t.AUTO_COLOR = "auto"),
          (t.ThemeProvider = class {
            constructor() {
              (this.strokePalette = []), (this.fillPalette = []);
            }
            getStrokeColor(e, t, r) {
              return this.getPaletteColor(e, t, r, !0);
            }
            getFillColor(e, t, r) {
              return this.getPaletteColor(e, t, r, !1);
            }
            applyOverrides(e) {
              (this.overrides = e), Object.assign(this, e);
            }
            toJSON() {
              return Object.assign({ type: this.type }, this.overrides);
            }
            getPaletteColor(e, t, r, a) {
              const s = a ? this.strokePalette : this.fillPalette;
              if (!s || 0 === s.length)
                throw new Error(
                  `${
                    a ? "stroke" : "fill"
                  }Palette must not be empty to use get${
                    a ? "Stroke" : "Fill"
                  }Color`
                );
              if (s.length < 2) return this.toColor(s[0]);
              if (e > t)
                throw new Error("index must be less than or equal to max");
              if (t <= s.length) return this.toColor(s[e]);
              let n = a ? this.strokeGradient : this.fillGradient;
              if (!n) {
                const e =
                  "string" == typeof s[0]
                    ? s.map((e, t) => ({ color: e, offset: t / s.length - 1 }))
                    : s;
                (n = o.PaletteFactory.createColorMap(r, e)),
                  a ? (this.strokeGradient = n) : (this.fillGradient = n);
              }
              const l = e / t,
                d =
                  n[
                    r.NumberUtil.Constrain(
                      Math.round(l * (n.length - 1)),
                      0,
                      n.length - 1
                    )
                  ];
              return (0, i.parseArgbToHtmlColor)(d);
            }
            toColor(e) {
              return "string" == typeof e ? e : e.color;
            }
          }),
          (t.stripAutoColor = (e) =>
            e === t.AUTO_COLOR
              ? "#00000000"
              : e && e.startsWith(t.AUTO_COLOR)
              ? e.substring(t.AUTO_COLOR.length)
              : e);
      },
      99016: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartJSDarkTheme = void 0);
        const i = r(62916),
          o = r(84392);
        class a extends o.ThemeProvider {
          constructor() {
            super(...arguments),
              (this.type = i.EThemeProviderType.Dark),
              (this.sciChartBackground = "#1C1C1EFF"),
              (this.loadingAnimationBackground = "#1C1C1EFF"),
              (this.loadingAnimationForeground = "#AAA"),
              (this.gridBorderBrush = "#5A5B5BFF"),
              (this.axisBandsFill = "#202123E1"),
              (this.axisBorder = "#00000000"),
              (this.tickTextBrush = "#A6A7ACFF"),
              (this.majorGridLineBrush = "#323539FF"),
              (this.minorGridLineBrush = "#232426FF"),
              (this.gridBackgroundBrush = "TRANSPARENT"),
              (this.rolloverLineBrush = "#42b64933"),
              (this.cursorLineBrush = "#228B22FF"),
              (this.rubberBandFillBrush = "#42b64933"),
              (this.rubberBandStrokeBrush = "#42b64977"),
              (this.legendBackgroundBrush = "#1D2C35FF"),
              (this.labelBackgroundBrush = "#42b649AA"),
              (this.labelBorderBrush = "#42b649FF"),
              (this.labelForegroundBrush = "#EEEEEEFF"),
              (this.textAnnotationForeground = "#EEEEEEFF"),
              (this.textAnnotationBackground = "#42b649AA"),
              (this.annotationsGripsBorderBrush = "#CDCDCD99"),
              (this.annotationsGripsBackgroundBrush = "#CDCDCD22"),
              (this.annotationSelectionStroke = "#f00e0e66"),
              (this.overviewFillBrush = "#262728BB"),
              (this.scrollbarBackgroundBrush = "#262728FF"),
              (this.scrollbarBorderBrush = "#121212FF"),
              (this.scrollbarGripsBackgroundBrush = "#535353FF"),
              (this.scrollbarViewportBackgroundBrush = "#222222FF"),
              (this.scrollbarViewportBorderBrush = "#232323FF"),
              (this.upWickColor = "#50ff50FF"),
              (this.downWickColor = "#ff5050FF"),
              (this.upBodyBrush = "#50ff50B2"),
              (this.downBodyBrush = "#ff5050B2"),
              (this.upBandSeriesLineColor = "#279B27FF"),
              (this.downBandSeriesLineColor = "#FF1919FF"),
              (this.upBandSeriesFillColor = "#279B2733"),
              (this.downBandSeriesFillColor = "#FF191933"),
              (this.mountainAreaBrush = "#4083B777"),
              (this.mountainLineColor = "#C6E6FFFF"),
              (this.lineSeriesColor = "#C6E6FFFF"),
              (this.columnLineColor = "#FFFFFFFF"),
              (this.columnFillBrush = "#FFFFFFFF"),
              (this.impulseFillBrush = "#FFFFFFFF"),
              (this.defaultColorMapBrush = [
                { offset: 0, color: "DARKBLUE" },
                { offset: 0.5, color: "CORNFLOWERBLUE" },
                { offset: 1, color: "#FF22AAFF" },
              ]),
              (this.axisTitleColor = "#C8C7C3FF"),
              (this.chartTitleColor = "#C8C7C3FF"),
              (this.shadowEffectColor = "#000000FF"),
              (this.planeBorderColor = "#333333FF"),
              (this.axisPlaneBackgroundFill = "TRANSPARENT"),
              (this.axis3DBandsFill = "#202123E1"),
              (this.isLightBackground = !1);
          }
        }
        t.SciChartJSDarkTheme = a;
      },
      2705: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartJSDarkv2Theme = void 0);
        const i = r(62916),
          o = r(99016);
        class a extends o.SciChartJSDarkTheme {
          constructor() {
            super(),
              (this.type = i.EThemeProviderType.DarkV2),
              (this.sciChartBackground =
                "radial-gradient(circle, #3C3C3FFF 0%, #1C1C1EFF 100%)"),
              (this.loadingAnimationBackground =
                "radial-gradient(circle, #3C3C3FFF 0%, #1C1C1EFF 100%)"),
              (this.axisBandsFill = "#20212333"),
              (this.majorGridLineBrush = "#AAAAAA37"),
              (this.minorGridLineBrush = "#77777719"),
              (this.strokePalette = [
                "#F48420",
                "#AE408E",
                "#209FD9",
                "#264B93",
              ]),
              (this.fillPalette = [
                "#F4842077",
                "#AE408E77",
                "#209FD977",
                "#264B9377",
              ]),
              (this.isLightBackground = !1);
          }
        }
        t.SciChartJSDarkv2Theme = a;
      },
      60819: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartJSLightTheme = void 0);
        const i = r(62916),
          o = r(84392);
        class a extends o.ThemeProvider {
          constructor() {
            super(...arguments),
              (this.strokePalette = [
                "#F48420",
                "#AE408E",
                "#30BC9A",
                "#209FD9",
                "#264B93",
              ]),
              (this.fillPalette = [
                "#F4842077",
                "#AE408E77",
                "#30BC9A77",
                "#209FD977",
                "#264B9377",
              ]),
              (this.type = i.EThemeProviderType.Light),
              (this.sciChartBackground = "#F9F9F9FF"),
              (this.loadingAnimationBackground = "#F9F9F9FF"),
              (this.loadingAnimationForeground = "#777777FF"),
              (this.gridBorderBrush = "#33333399"),
              (this.axisBandsFill = "#AAAAAA09"),
              (this.axisBorder = "#00000000"),
              (this.tickTextBrush = "#333333FF"),
              (this.majorGridLineBrush = "#CFCFCFFF"),
              (this.minorGridLineBrush = "#CFCFCF77"),
              (this.gridBackgroundBrush = "#05333377"),
              (this.rolloverLineBrush = "#33333333"),
              (this.cursorLineBrush = "#33333355"),
              (this.rubberBandFillBrush = "#33333333"),
              (this.rubberBandStrokeBrush = "#33333377"),
              (this.legendBackgroundBrush = "#33333333"),
              (this.labelBackgroundBrush = "#D0D0D0BB"),
              (this.labelBorderBrush = "#33333377"),
              (this.labelForegroundBrush = "#555555FF"),
              (this.textAnnotationForeground = "#000000FF"),
              (this.textAnnotationBackground = "#FFFFFFFF"),
              (this.annotationsGripsBorderBrush = "#232323FF"),
              (this.annotationsGripsBackgroundBrush = "#FFFFFF33"),
              (this.annotationSelectionStroke = "#f00e0e66"),
              (this.overviewFillBrush = "#33333322"),
              (this.scrollbarBackgroundBrush = "#33333322"),
              (this.scrollbarBorderBrush = "#12121255"),
              (this.scrollbarGripsBackgroundBrush = "#FFFFFF66"),
              (this.scrollbarViewportBackgroundBrush = "#FFFFFF44"),
              (this.scrollbarViewportBorderBrush = "#12121255"),
              (this.upWickColor = "#52CC54FF"),
              (this.downWickColor = "#E26565FF"),
              (this.upBodyBrush = "#52CC54A0"),
              (this.downBodyBrush = "#E26565D0"),
              (this.upBandSeriesLineColor = "#52CC54FF"),
              (this.downBandSeriesLineColor = "#E26565FF"),
              (this.upBandSeriesFillColor = "#52CC5490"),
              (this.downBandSeriesFillColor = "#E26565A0"),
              (this.mountainAreaBrush = "#76B7E2B4"),
              (this.mountainLineColor = "#777777FF"),
              (this.lineSeriesColor = "#777777FF"),
              (this.columnLineColor = "#777777FF"),
              (this.columnFillBrush = "#777777FF"),
              (this.impulseFillBrush = "#777777FF"),
              (this.defaultColorMapBrush = [
                { offset: 0, color: "DARKBLUE" },
                { offset: 0.5, color: "CORNFLOWERBLUE" },
                { offset: 1, color: "#FF22AAFF" },
              ]),
              (this.axisTitleColor = "#777777FF"),
              (this.chartTitleColor = "#777777FF"),
              (this.shadowEffectColor = "#A0AABAFA"),
              (this.planeBorderColor = "#EEEEEEFF"),
              (this.axisPlaneBackgroundFill = "TRANSPARENT"),
              (this.axis3DBandsFill = "#33333333"),
              (this.isLightBackground = !0);
          }
        }
        t.SciChartJSLightTheme = a;
      },
      66010: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartJsNavyTheme = void 0);
        const i = r(62916),
          o = r(84392),
          a = r(2705);
        class s extends a.SciChartJSDarkv2Theme {
          constructor() {
            super(),
              (this.type = i.EThemeProviderType.Navy),
              (this.background1 = "#22365B"),
              (this.background2 = "#17243d"),
              (this.loadingBackground1 = "#21253D"),
              (this.loadingBackground2 = "#09090F"),
              (this.sciChartBackground = `radial-gradient(circle, ${this.background1} 0%, ${this.background2} 100%)`),
              (this.loadingAnimationBackground = `radial-gradient(circle, ${this.loadingBackground1} 0%, ${this.loadingBackground2} 100%)`),
              (this.loadingAnimationForeground = "#2A2F4C"),
              (this.axisBandsFill = "#52469503"),
              (this.majorGridLineBrush = "#191C6D77"),
              (this.minorGridLineBrush = "#2B2D7077"),
              (this.tickTextBrush = "#8398ba"),
              (this.strokePalette = [
                "#274b92",
                "#47bde6",
                "#ae418d",
                "#e97064",
                "#68bcae",
                "#634e96",
              ]),
              (this.fillPalette = [
                "#274b9288",
                "#47bde688",
                "#ae418d88",
                "#e9706488",
                "#68bcae88",
                "#634e9688",
              ]),
              (this.lineSeriesColor = o.AUTO_COLOR),
              (this.planeBorderColor = "#191C6D77"),
              (this.axisPlaneBackgroundFill = "TRANSPARENT"),
              (this.axis3DBandsFill = "#52469503"),
              (this.isLightBackground = !1);
          }
        }
        t.SciChartJsNavyTheme = s;
      },
      5102: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AdornerLayer = void 0),
          (t.AdornerLayer = class {
            constructor(e) {
              this.parentSurface = e;
            }
            selectAnnotation(e) {
              const t = this.parentSurface;
              let r;
              const i = (t) => {
                for (let i = t.length - 1; i >= 0; i--) {
                  const o = t[i];
                  o.click(e, !r && o.isEditable) && (r = o);
                }
              };
              return (
                i(t.annotations.asArray()),
                i(t.modifierAnnotations.asArray()),
                (this.selectedAnnotationProperty = r),
                !!r
              );
            }
            deselectAnnotation(e) {
              this.selectedAnnotationProperty === e &&
                (this.selectedAnnotationProperty = void 0);
            }
            get selectedAnnotation() {
              return this.selectedAnnotationProperty;
            }
            set selectedAnnotation(e) {
              this.selectedAnnotationProperty = e;
            }
            get isAnnotationSelected() {
              return !!this.selectedAnnotationProperty;
            }
          });
      },
      31306: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnnotationBase =
            t.ECoordinateMode =
            t.EDraggingGripPoint =
              void 0);
        const i = r(45921),
          o = r(55023),
          a = r(3214),
          s = r(23866),
          n = r(16819),
          l = r(75772),
          d = r(87459),
          h = r(11043),
          u = r(3777),
          c = r(19145),
          p = r(86699),
          g = r(73538),
          y = r(21670),
          f = r(32873),
          v = r(84626),
          m = r(14184),
          S = r(86127),
          P = r(28792),
          C = r(26520),
          b = r(78895),
          x = r(92415),
          A = r(49641),
          T = r(91380),
          E = r(84736);
        var R, D;
        !(function (e) {
          (e.x1y1 = "x1y1"),
            (e.x1y2 = "x1y2"),
            (e.x2y2 = "x2y2"),
            (e.x2y1 = "x2y1"),
            (e.x3y3 = "x3y3"),
            (e.Body = "Body");
        })((R = t.EDraggingGripPoint || (t.EDraggingGripPoint = {}))),
          (function (e) {
            (e.DataValue = "DataValue"),
              (e.Pixel = "Pixel"),
              (e.Relative = "Relative");
          })((D = t.ECoordinateMode || (t.ECoordinateMode = {})));
        class w extends o.DeletableEntity {
          constructor(e) {
            var t,
              r,
              o,
              s,
              n,
              l,
              d,
              u,
              y,
              f,
              v,
              S,
              P,
              b,
              x,
              A,
              w,
              M,
              L,
              O,
              I,
              k,
              _,
              V,
              N,
              B,
              F;
            super(),
              (this.surfaceTypes = [c.ESurfaceType.SciChartSurfaceType]),
              (this.prevIsSelected = !0),
              (this.annotationBorders = { x1: 0, x2: 0, y1: 0, y2: 0 }),
              (this.typeMap = new Map()),
              (this.isHiddenProperty = !1),
              (this.annotationsGripsStrokeProperty =
                m.SciChartSurfaceBase.DEFAULT_THEME.annotationsGripsBorderBrush),
              (this.annotationsGripsFillProperty =
                m.SciChartSurfaceBase.DEFAULT_THEME.annotationsGripsBackgroundBrush),
              (this.annotationsGripsRadiusProperty = T.ADORNER_GRIP_RADIUS),
              (this.selectionBoxStrokeProperty =
                m.SciChartSurfaceBase.DEFAULT_THEME.annotationSelectionStroke),
              (this.selectionBoxDeltaProperty = 1.5),
              (this.selectionBoxThicknessProperty = 6),
              (this.dragPointsProperty = [
                R.Body,
                R.x1y1,
                R.x2y2,
                R.x2y1,
                R.x1y2,
              ]),
              (this.clippingProperty =
                C.EAnnotationClippingMode.SeriesViewRect),
              (this.adornerClippingProperty = C.EAnnotationClippingMode.Chart),
              (this.surfaceRenderOrderProperty = void 0),
              (this.renderOrderProperty = void 0),
              (this.annotationLayerProperty = E.EAnnotationLayer.AboveChart),
              (this.isEditableProperty = !1),
              (this.xCoordinateModeProperty = D.DataValue),
              (this.yCoordinateModeProperty = D.DataValue),
              (this.isSelectedProperty = !1),
              (this.isHoveredProperty = !1),
              (this.resizeDirectionsProperty = p.EXyDirection.XyDirection),
              (this.id =
                null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                  ? t
                  : (0, g.generateGuid)()),
              (this.dragStarted = new a.EventHandler()),
              (this.dragEnded = new a.EventHandler()),
              (this.dragDelta = new a.EventHandler()),
              (this.selectedChanged = new a.EventHandler()),
              (this.clicked = new a.EventHandler()),
              (this.hovered = new a.EventHandler()),
              (this.annotationLayerProperty =
                null !== (r = null == e ? void 0 : e.annotationLayer) &&
                void 0 !== r
                  ? r
                  : this.annotationLayerProperty),
              (this.resizeDirectionsProperty =
                null !== (o = null == e ? void 0 : e.resizeDirections) &&
                void 0 !== o
                  ? o
                  : this.resizeDirectionsProperty),
              (this.isEditableProperty =
                null !== (s = null == e ? void 0 : e.isEditable) && void 0 !== s
                  ? s
                  : this.isEditableProperty),
              (this.isHiddenProperty =
                null !== (n = null == e ? void 0 : e.isHidden) && void 0 !== n
                  ? n
                  : this.isHiddenProperty),
              (this.x1Property =
                null !== (l = null == e ? void 0 : e.x1) && void 0 !== l
                  ? l
                  : this.x1Property),
              (this.y1Property =
                null !== (d = null == e ? void 0 : e.y1) && void 0 !== d
                  ? d
                  : this.y1Property),
              (this.x2Property =
                null !== (u = null == e ? void 0 : e.x2) && void 0 !== u
                  ? u
                  : this.x2Property),
              (this.y2Property =
                null !== (y = null == e ? void 0 : e.y2) && void 0 !== y
                  ? y
                  : this.y2Property),
              (this.xAxisIdProperty =
                null !== (f = null == e ? void 0 : e.xAxisId) && void 0 !== f
                  ? f
                  : this.xAxisIdProperty),
              (this.yAxisIdProperty =
                null !== (v = null == e ? void 0 : e.yAxisId) && void 0 !== v
                  ? v
                  : this.yAxisIdProperty),
              (this.xCoordinateModeProperty =
                null !== (S = null == e ? void 0 : e.xCoordinateMode) &&
                void 0 !== S
                  ? S
                  : this.xCoordinateModeProperty),
              (this.yCoordinateModeProperty =
                null !== (P = null == e ? void 0 : e.yCoordinateMode) &&
                void 0 !== P
                  ? P
                  : this.yCoordinateModeProperty),
              (this.isSelectedProperty =
                null !== (b = null == e ? void 0 : e.isSelected) && void 0 !== b
                  ? b
                  : this.isSelectedProperty),
              (this.opacityProperty =
                null !== (x = null == e ? void 0 : e.opacity) && void 0 !== x
                  ? x
                  : 1),
              (this.annotationsGripsStrokeProperty =
                null !== (A = null == e ? void 0 : e.annotationsGripsStroke) &&
                void 0 !== A
                  ? A
                  : this.annotationsGripsStrokeProperty),
              (this.annotationsGripsFillProperty =
                null !== (w = null == e ? void 0 : e.annotationsGripsFill) &&
                void 0 !== w
                  ? w
                  : this.annotationsGripsFillProperty),
              (this.annotationsGripsRadiusProperty =
                null !== (M = null == e ? void 0 : e.annotationsGripsRadius) &&
                void 0 !== M
                  ? M
                  : this.annotationsGripsRadius),
              (this.selectionBoxStroke =
                null !== (L = null == e ? void 0 : e.selectionBoxStroke) &&
                void 0 !== L
                  ? L
                  : this.selectionBoxStrokeProperty),
              (this.selectionBoxDelta =
                null !== (O = null == e ? void 0 : e.selectionBoxDelta) &&
                void 0 !== O
                  ? O
                  : this.selectionBoxDeltaProperty),
              (this.selectionBoxThickness =
                null !== (I = null == e ? void 0 : e.selectionBoxThickness) &&
                void 0 !== I
                  ? I
                  : this.selectionBoxThicknessProperty),
              (this.dragPointsProperty =
                null !== (k = null == e ? void 0 : e.dragPoints) && void 0 !== k
                  ? k
                  : this.dragPointsProperty),
              (this.clippingProperty =
                null !== (_ = null == e ? void 0 : e.clipping) && void 0 !== _
                  ? _
                  : this.clippingProperty),
              (this.surfaceRenderOrderProperty =
                null !== (V = null == e ? void 0 : e.surfaceRenderOrder) &&
                void 0 !== V
                  ? V
                  : this.surfaceRenderOrderProperty),
              (this.renderLayerProperty =
                null !== (N = null == e ? void 0 : e.renderLayer) &&
                void 0 !== N
                  ? N
                  : this.renderLayerProperty),
              (this.renderOrderProperty =
                null !== (B = null == e ? void 0 : e.renderOrder) &&
                void 0 !== B
                  ? B
                  : this.renderOrderProperty),
              (this.renderNextToProperty =
                null !== (F = null == e ? void 0 : e.renderNextTo) &&
                void 0 !== F
                  ? F
                  : this.renderNextToProperty),
              (null == e ? void 0 : e.onDragStarted) &&
                ("string" == typeof e.onDragStarted
                  ? (this.typeMap.set("onDragStarted", e.onDragStarted),
                    this.dragStarted.subscribe(
                      (0, i.getFunction)(
                        h.EBaseType.OptionFunction,
                        e.onDragStarted
                      )
                    ))
                  : this.dragStarted.subscribe(e.onDragStarted)),
              (null == e ? void 0 : e.onDragEnded) &&
                ("string" == typeof e.onDragEnded
                  ? (this.typeMap.set("onDragEnded", e.onDragEnded),
                    this.dragEnded.subscribe(
                      (0, i.getFunction)(
                        h.EBaseType.OptionFunction,
                        e.onDragEnded
                      )
                    ))
                  : this.dragEnded.subscribe(e.onDragEnded)),
              (null == e ? void 0 : e.onDrag) &&
                ("string" == typeof e.onDrag
                  ? (this.typeMap.set("onDrag", e.onDrag),
                    this.dragDelta.subscribe(
                      (0, i.getFunction)(h.EBaseType.OptionFunction, e.onDrag)
                    ))
                  : this.dragDelta.subscribe(e.onDrag)),
              (null == e ? void 0 : e.onClick) &&
                ("string" == typeof e.onClick
                  ? (this.typeMap.set("onClick", e.onClick),
                    this.clicked.subscribe(
                      (0, i.getFunction)(h.EBaseType.OptionFunction, e.onClick)
                    ))
                  : this.clicked.subscribe(e.onClick)),
              (null == e ? void 0 : e.onHover) &&
                ("string" == typeof e.onHover
                  ? (this.typeMap.set("onHover", e.onHover),
                    this.hovered.subscribe(
                      (0, i.getFunction)(h.EBaseType.OptionFunction, e.onHover)
                    ))
                  : this.hovered.subscribe(e.onHover));
          }
          get annotationLayer() {
            return this.annotationLayerProperty;
          }
          set annotationLayer(e) {
            this.annotationLayerProperty !== e &&
              ((this.annotationLayerProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.ANNOTATION_CANVAS));
          }
          get adornerDraggingPoint() {
            return this.adornerDraggingPointProperty;
          }
          set adornerDraggingPoint(e) {
            var t;
            this.adornerDraggingPointProperty !== e &&
              ((this.adornerDraggingPointProperty = e),
              e &&
                (null === (t = this.dragStarted) ||
                  void 0 === t ||
                  t.raiseEvent()));
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          set parentSurface(e) {
            this.parentSurfaceProperty !== e &&
              ((this.parentSurfaceProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.PARENT_SURFACE));
          }
          get isEditable() {
            return this.isEditableProperty;
          }
          set isEditable(e) {
            this.isEditableProperty !== e &&
              ((this.isEditableProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.IS_EDITABLE));
          }
          get isHidden() {
            return this.isHiddenProperty;
          }
          set isHidden(e) {
            this.isHiddenProperty !== e &&
              ((this.isHiddenProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.IS_HIDDEN));
          }
          get isVisible() {
            return !this.isHidden;
          }
          set isVisible(e) {
            this.isHidden = !e;
          }
          get xCoordinateMode() {
            return this.xCoordinateModeProperty;
          }
          set xCoordinateMode(e) {
            this.xCoordinateModeProperty !== e &&
              ((this.xCoordinateModeProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.X_COORDINATE_MODE));
          }
          get yCoordinateMode() {
            return this.yCoordinateModeProperty;
          }
          set yCoordinateMode(e) {
            this.yCoordinateModeProperty !== e &&
              ((this.yCoordinateModeProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.Y_COORDINATE_MODE));
          }
          get x1() {
            return this.x1Property;
          }
          set x1(e) {
            this.x1Property !== e &&
              ((this.x1Property = e),
              this.notifyPropertyChanged(T.PROPERTY.X1));
          }
          get x2() {
            return this.x2Property;
          }
          set x2(e) {
            this.x2Property !== e &&
              ((this.x2Property = e),
              this.notifyPropertyChanged(T.PROPERTY.X2));
          }
          get y1() {
            return this.y1Property;
          }
          set y1(e) {
            this.y1Property !== e &&
              ((this.y1Property = e),
              this.notifyPropertyChanged(T.PROPERTY.Y1));
          }
          get y2() {
            return this.y2Property;
          }
          set y2(e) {
            this.y2Property !== e &&
              ((this.y2Property = e),
              this.notifyPropertyChanged(T.PROPERTY.Y2));
          }
          get xAxisId() {
            return this.xAxisIdProperty;
          }
          set xAxisId(e) {
            this.xAxisIdProperty !== e &&
              ((this.xAxisIdProperty = e),
              (this.xAxisProperty = void 0),
              this.notifyPropertyChanged(T.PROPERTY.XAXIS_ID));
          }
          get yAxisId() {
            return this.yAxisIdProperty;
          }
          set yAxisId(e) {
            this.yAxisIdProperty !== e &&
              ((this.yAxisIdProperty = e),
              (this.yAxisProperty = void 0),
              this.notifyPropertyChanged(T.PROPERTY.YAXIS_ID));
          }
          get xAxis() {
            return this.xAxisProperty;
          }
          get yAxis() {
            return this.yAxisProperty;
          }
          get isVerticalChart() {
            var e;
            return null === (e = this.xAxis) || void 0 === e
              ? void 0
              : e.isVerticalChart;
          }
          set resizeDirections(e) {
            this.resizeDirectionsProperty !== e &&
              ((this.resizeDirectionsProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.RESIZE_DIRECTIONS));
          }
          get resizeDirections() {
            return this.resizeDirectionsProperty;
          }
          set isSelected(e) {
            this.isSelectedProperty !== e &&
              ((this.isSelectedProperty = e),
              this.selectedChanged.raiseEvent(this.isSelectedProperty),
              this.notifyPropertyChanged(T.PROPERTY.IS_SELECTED));
          }
          get isSelected() {
            return this.isSelectedProperty;
          }
          get isHovered() {
            return this.isHoveredProperty;
          }
          set isHovered(e) {
            this.isHoveredProperty !== e &&
              ((this.isHoveredProperty = e),
              this.hovered.raiseEvent(
                new A.AnnotationHoverEventArgs({
                  sender: this,
                  mouseArgs: void 0,
                  isHovered: e,
                })
              ),
              this.notifyPropertyChanged(T.PROPERTY.IS_HOVERED));
          }
          get annotationsGripsStroke() {
            return this.annotationsGripsStrokeProperty;
          }
          set annotationsGripsStroke(e) {
            this.annotationsGripsStrokeProperty !== e &&
              ((this.annotationsGripsStrokeProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.ADORNER_STROKE));
          }
          get annotationsGripsFill() {
            return this.annotationsGripsFillProperty;
          }
          set annotationsGripsFill(e) {
            this.annotationsGripsFillProperty !== e &&
              ((this.annotationsGripsFillProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.ADORNER_FILL));
          }
          get annotationsGripsRadius() {
            return this.annotationsGripsRadiusProperty;
          }
          set annotationsGripsRadius(e) {
            this.annotationsGripsRadiusProperty !== e &&
              ((this.annotationsGripsRadiusProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.ADORNER_RADIUS));
          }
          get selectionBoxStroke() {
            return this.selectionBoxStrokeProperty;
          }
          set selectionBoxStroke(e) {
            this.selectionBoxStrokeProperty !== e &&
              ((this.selectionBoxStrokeProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.SELECTION_STROKE));
          }
          get selectionBoxDelta() {
            return this.selectionBoxDeltaProperty;
          }
          set selectionBoxDelta(e) {
            this.selectionBoxDeltaProperty !== e &&
              ((this.selectionBoxDeltaProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.SELECTION_DELTA));
          }
          get selectionBoxThickness() {
            return this.selectionBoxThicknessProperty;
          }
          set selectionBoxThickness(e) {
            this.selectionBoxThicknessProperty !== e &&
              ((this.selectionBoxThicknessProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.SELECTION_DELTA));
          }
          get isDraggingStarted() {
            return !!this.adornerDraggingPoint;
          }
          get opacity() {
            return this.opacityProperty;
          }
          set opacity(e) {
            this.opacityProperty !== e &&
              ((this.opacityProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.OPACITY));
          }
          get clipping() {
            return this.clippingProperty;
          }
          set clipping(e) {
            this.clippingProperty !== e &&
              ((this.clippingProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.CLIPPING));
          }
          get adornerClipping() {
            return this.adornerClippingProperty;
          }
          set adornerClipping(e) {
            this.adornerClippingProperty !== e &&
              ((this.adornerClippingProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.CLIPPING));
          }
          get svgAdornerRoot() {
            return this.svgAdornerRootProperty;
          }
          onAttach(e) {
            if (!this.surfaceTypes.includes(e.surfaceType))
              throw new Error(
                `Modifier's type does not match SciChartSurface type. Please check ${this.constructor.name}.surfaceTypes property to match ${e.constructor.name}.surfaceType`
              );
            this.linkAxes(),
              (this.svgAdornerRootProperty = e.domSvgAdornerLayer),
              this.isSelected &&
                (this.parentSurface.adornerLayer.selectedAnnotation = this);
          }
          onDetach() {
            this.isSelected &&
              ((this.isSelected = !1),
              this.parentSurface.adornerLayer.deselectAnnotation(this)),
              this.isHovered && (this.isHovered = !1),
              this.selectedChanged.unsubscribeAll(),
              this.deleteAdorner(),
              (this.svgAdornerRootProperty = void 0);
          }
          get dragPoints() {
            return this.dragPointsProperty;
          }
          set dragPoints(e) {
            (this.dragPointsProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.DRAGPOINTS);
          }
          checkIsWithinBounds(e) {
            const t = (0, f.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect,
              !0
            );
            return !!t && this.checkIsClickedOnAnnotationInternal(t.x, t.y);
          }
          hover(e) {
            const { args: t, notifyPositionUpdate: r, notifyOutEvent: i } = e,
              o =
                void 0 !== e.isHovered
                  ? e.isHovered
                  : this.checkIsWithinBounds(t),
              a = this.isHovered;
            (this.isHoveredProperty = o),
              ((o && !a) || (a && !o && i) || (o && a && r)) &&
                this.hovered.raiseEvent(
                  new A.AnnotationHoverEventArgs({
                    sender: this,
                    mouseArgs: t,
                    isHovered: o,
                  })
                ),
              o !== a && this.notifyPropertyChanged(T.PROPERTY.IS_HOVERED);
          }
          click(e, t) {
            const r = (0, f.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect,
              !0
            );
            if (!r) return !1;
            if (
              this.checkIsPointWithinClipArea(e.mousePoint) &&
              this.checkIsClickedOnAnnotationInternal(r.x, r.y)
            ) {
              const r = this.getAdornerAnnotationBorders(!0),
                i = e.mousePoint.x / S.DpiHelper.PIXEL_RATIO,
                o = e.mousePoint.y / S.DpiHelper.PIXEL_RATIO,
                a = new l.Point(i - r.x1, o - r.y1);
              return (
                (this.isSelected = t),
                this.clicked.raiseEvent(
                  new P.AnnotationClickEventArgs(this, e, a)
                ),
                this.isSelected
              );
            }
            return (this.isSelected = !1), this.isSelected;
          }
          clickToSelect(e) {
            const t = (0, f.translateFromCanvasToSeriesViewRect)(
              e.mousePoint,
              this.parentSurface.seriesViewRect,
              !0
            );
            return (
              !!t &&
              ((this.isSelected = this.checkIsClickedOnAnnotationInternal(
                t.x,
                t.y
              )),
              this.isSelected)
            );
          }
          calcDragDistance(e) {}
          onDragStarted(e) {
            return !1;
          }
          checkIsClickedOnAnnotation(e, t) {
            const r = (0, f.translateFromCanvasToSeriesViewRect)(
              new l.Point(
                e * S.DpiHelper.PIXEL_RATIO,
                t * S.DpiHelper.PIXEL_RATIO
              ),
              this.parentSurface.seriesViewRect,
              !0
            );
            return !!r && this.checkIsClickedOnAnnotationInternal(r.x, r.y);
          }
          checkIsPointWithinClipArea(e) {
            const {
              left: t,
              bottom: r,
              right: i,
              top: o,
            } = this.getClippingRect(
              this.adornerClipping,
              this.parentSurface.seriesViewRect,
              this.parentSurface.viewRect,
              this.parentSurface.chartViewRect
            );
            return (0, y.testIsInBounds)(e.x, e.y, t, r, i, o);
          }
          onDragAdorner(e) {
            const t = this.getValuesFromCoordinates(e.mousePoint, !0);
            t && this.calcDragDistance(t),
              this.dragDelta.raiseEvent(new b.AnnotationDragDeltaEventArgs());
          }
          onDragEnded() {
            var e;
            null === (e = this.dragEnded) || void 0 === e || e.raiseEvent(),
              (this.adornerDraggingPoint = void 0),
              (this.prevValue = void 0);
          }
          onDpiChanged(e) {}
          suspendInvalidate() {
            this.invalidateState = {
              isHidden: this.isHidden,
              x1: this.x1,
              y1: this.y1,
            };
          }
          resumeInvalidate() {
            this.invalidateState &&
              ((this.isHidden === this.invalidateState.isHidden &&
                this.x1 === this.invalidateState.x1 &&
                this.y1 === this.invalidateState.y1) ||
                (this.invalidateParentCallback &&
                  this.invalidateParentCallback()),
              (this.invalidateState = void 0));
          }
          getSurfaceRenderOrder() {
            var e, t, r;
            return null !== (e = this.surfaceRenderOrderProperty) &&
              void 0 !== e
              ? e
              : null ===
                  (r =
                    null === (t = this.parentSurface) || void 0 === t
                      ? void 0
                      : t.getSurfaceRenderOrder) || void 0 === r
              ? void 0
              : r.call(t);
          }
          setSurfaceRenderOrder(e) {
            this.surfaceRenderOrderProperty != e &&
              ((this.surfaceRenderOrderProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.SURFACE_RENDER_ORDER));
          }
          getRenderLayer() {
            if (this.renderLayerProperty) return this.renderLayerProperty;
            switch (this.annotationLayer) {
              case E.EAnnotationLayer.AboveChart:
                return u.EDefaultRenderLayer.AnnotationsAboveSeriesLayer;
              case E.EAnnotationLayer.BelowChart:
                return u.EDefaultRenderLayer.AnnotationsBelowSeriesLayer;
              case E.EAnnotationLayer.Background:
                return u.EDefaultRenderLayer.Background;
              default:
                throw new Error(
                  `Invalid annotationLayer ${this.annotationLayer}!`
                );
            }
          }
          setRenderLayer(e) {
            this.renderLayerProperty != e &&
              ((this.renderLayerProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.RENDER_LAYER));
          }
          getRenderOrder() {
            return this.renderOrderProperty;
          }
          setRenderOrder(e) {
            this.renderOrderProperty != e &&
              ((this.renderOrderProperty = e),
              this.notifyPropertyChanged(T.PROPERTY.RENDER_LAYER));
          }
          setRenderNextTo(e, t) {
            s.Guard.notNull(e, "renderable"),
              (this.renderNextToProperty = { renderable: e, offset: t });
          }
          getRenderNextTo() {
            return this.renderNextToProperty;
          }
          toJSON() {
            const e = this.getRenderNextTo(),
              t = e && {
                renderable:
                  "string" == typeof e.renderable
                    ? e.renderable
                    : e.renderable.id,
                offset: e.offset,
              },
              r = {
                id: this.id,
                annotationLayer: this.annotationLayer,
                isEditable: this.isEditable,
                isHidden: this.isHidden,
                isSelected: this.isSelected,
                onDrag: this.typeMap.get("onDrag"),
                onDragEnded: this.typeMap.get("onDragEnded"),
                onDragStarted: this.typeMap.get("onDragStarted"),
                onClick: this.typeMap.get("onClick"),
                onHover: this.typeMap.get("onHover"),
                opacity: this.opacity,
                resizeDirections: this.resizeDirections,
                x1: this.x1Property,
                x2: this.x2Property,
                y1: this.y1Property,
                y2: this.y2Property,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
                xCoordinateMode: this.xCoordinateMode,
                yCoordinateMode: this.yCoordinateMode,
                surfaceRenderOrder: this.surfaceRenderOrderProperty,
                renderLayer: this.getRenderLayer(),
                renderOrder: this.getRenderOrder(),
                renderNextTo: t,
                annotationsGripsStroke: this.annotationsGripsStroke,
                annotationsGripsFill: this.annotationsGripsFill,
                annotationsGripsRadius: this.annotationsGripsRadius,
                selectionBoxStroke: this.selectionBoxStroke,
                selectionBoxDelta: this.selectionBoxDelta,
                selectionBoxThickness: this.selectionBoxThickness,
                dragPoints: this.dragPointsProperty,
                clipping: this.clippingProperty,
              };
            return { type: this.type, options: r };
          }
          getAnnotationBorders(e = !1, t = !1) {
            if (!e && !t) return this.annotationBorders;
            let { x1: r, x2: i, y1: o, y2: a } = this.annotationBorders;
            const s = t ? this.selectionBoxDelta : 0;
            return (
              e
                ? (i < r ? ([r, i] = [i - s, r + s]) : ((r -= s), (i += s)),
                  a < o ? ([o, a] = [a - s, o + s]) : ((o -= s), (a += s)))
                : (i < r ? ((r += s), (i -= s)) : ((r -= s), (i += s)),
                  a < o ? ((o += s), (a -= s)) : ((o -= s), (a += s))),
              { x1: r, x2: i, y1: o, y2: a }
            );
          }
          getAdornerAnnotationBorders(e = !1, t = !1) {
            const r = this.getAnnotationBorders(e, t),
              i = this.isDomAnnotation ? r.x1 * S.DpiHelper.PIXEL_RATIO : r.x1,
              o = this.isDomAnnotation ? r.x2 * S.DpiHelper.PIXEL_RATIO : r.x2,
              a = this.isDomAnnotation ? r.y1 * S.DpiHelper.PIXEL_RATIO : r.y1,
              s = this.isDomAnnotation ? r.y2 * S.DpiHelper.PIXEL_RATIO : r.y2,
              n = (0, f.translateFromSeriesViewRectToCanvas)(
                new l.Point(i, a),
                this.parentSurface.seriesViewRect,
                !0
              ),
              d = (0, f.translateFromSeriesViewRectToCanvas)(
                new l.Point(o, s),
                this.parentSurface.seriesViewRect,
                !0
              );
            return {
              x1: n.x / S.DpiHelper.PIXEL_RATIO,
              x2: d.x / S.DpiHelper.PIXEL_RATIO,
              y1: n.y / S.DpiHelper.PIXEL_RATIO,
              y2: d.y / S.DpiHelper.PIXEL_RATIO,
            };
          }
          getAnnotationGripSvg(e, t) {
            return `<circle cx="${e}" cy="${t}" r="${this.annotationsGripsRadius}" fill="${this.annotationsGripsFill}" stroke="${this.annotationsGripsStroke}"/>`;
          }
          canDragPoint(e) {
            return this.dragPointsProperty.includes(e);
          }
          svgStringAdornerTemplate(e, t, r, i) {
            return '<svg xmlns="http://www.w3.org/2000/svg"></svg>';
          }
          getClippingRect(e, t, r, i) {
            let o;
            switch (e) {
              case C.EAnnotationClippingMode.SeriesViewRect:
                o = t;
                break;
              case C.EAnnotationClippingMode.SubChart:
                o = r;
                break;
              case C.EAnnotationClippingMode.Chart:
                o = i;
                break;
              default:
                throw new Error(`Unhandled clipping value: "${e}"`);
            }
            const a = this.parentSurface.clipRect;
            return d.Rect.intersect(o, a);
          }
          linkAxes() {
            if (((0, n.updateAxisIds)(this), this.parentSurface)) {
              if (!this.xAxisProperty && this.xAxisId) {
                const e = this.parentSurface.getXAxisById(this.xAxisId);
                e
                  ? (this.xAxisProperty = e)
                  : (console.warn(
                      `Annotation looked for xAxis Id "${this.xAxisId}" but did not find. Default xAxis will be used`
                    ),
                    (this.xAxisProperty =
                      this.parentSurface.getDefaultXAxis()));
              }
              if (!this.yAxisProperty && this.yAxisId) {
                const e = this.parentSurface.getYAxisById(this.yAxisId);
                e
                  ? (this.yAxisProperty = e)
                  : (console.warn(
                      `Annotation looked for yAxis Id "${this.yAxisId}" but did not find. Default yAxis will be used`
                    ),
                    (this.yAxisProperty =
                      this.parentSurface.getDefaultYAxis()));
              }
            }
          }
          getClipPath(e) {
            switch (e) {
              case C.EAnnotationClippingMode.Chart: {
                const e = this.parentSurface;
                return `url(#surfaceViewRectClip_${
                  v.SciChartSurface.isSubSurface(e) ? e.parentSurface.id : e.id
                })`;
              }
              case C.EAnnotationClippingMode.SeriesViewRect:
                return `url(#seriesViewRectClip_${this.parentSurface.id})`;
              case C.EAnnotationClippingMode.SubChart:
                return `url(#surfaceViewRectClip_${this.parentSurface.id})`;
              default:
                return e;
            }
          }
          applySvgClipping(e, t) {
            const r = this.getClipPath(t);
            return r ? `<svg clip-path="${r}" >${e}</svg>` : `<svg>${e}</svg>`;
          }
          notifyPropertyChanged(e) {
            this.invalidateParentCallback &&
              !this.invalidateState &&
              this.invalidateParentCallback();
          }
          getCoordinate(e, t, r) {
            if (
              (s.Guard.notNull(r, "coordinateMode"),
              s.Guard.notNull(t, "calculator"),
              void 0 !== e)
            )
              switch (r) {
                case D.Pixel:
                  return this.isDomAnnotation ? e : e * S.DpiHelper.PIXEL_RATIO;
                case D.DataValue: {
                  const r = null != e ? t.getCoordinate(e) : void 0;
                  return this.isDomAnnotation ? r / S.DpiHelper.PIXEL_RATIO : r;
                }
                case D.Relative:
                  return this.isDomAnnotation
                    ? (e * t.viewportDimension + t.offset) /
                        S.DpiHelper.PIXEL_RATIO
                    : e * t.viewportDimension + t.offset;
                default:
                  throw new Error(
                    `AnnotationBase.getCoordinate with CoordinateMode.${r} is not implemented`
                  );
              }
          }
          getResolvedCoordinate(e, t, r, i, o) {
            return (o ? this.isVerticalChart : !this.isVerticalChart)
              ? this.getCoordinate(null != i ? i : 0, t, this.yCoordinateMode)
              : this.getCoordinate(null != r ? r : 0, e, this.xCoordinateMode);
          }
          getX1Coordinate(e, t) {
            return this.getResolvedCoordinate(e, t, this.x1, this.y1, !0);
          }
          getX2Coordinate(e, t) {
            return this.getResolvedCoordinate(e, t, this.x2, this.y2, !0);
          }
          getY1Coordinate(e, t) {
            return this.getResolvedCoordinate(e, t, this.x1, this.y1, !1);
          }
          getY2Coordinate(e, t) {
            return this.getResolvedCoordinate(e, t, this.x2, this.y2, !1);
          }
          getValue(e, t, r) {
            switch (r) {
              case D.Pixel:
                return this.isDomAnnotation
                  ? t.getDataValue(e * S.DpiHelper.PIXEL_RATIO)
                  : t.getDataValue(e);
              case D.DataValue:
                return e;
              case D.Relative:
                return (t.visibleMax - t.visibleMin) * e + t.visibleMin;
              default:
                throw new Error("Not implemented");
            }
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            return !1;
          }
          deleteAdorner() {
            this.svgAdorner &&
              this.parentSurface &&
              !this.parentSurface.isDeleted &&
              (this.svgAdornerRoot.removeChild(this.svgAdorner),
              (this.svgAdorner = void 0));
          }
          getValuesFromCoordinates(e, t) {
            const r = this.parentSurface.seriesViewRect,
              i = t ? (0, f.translateFromCanvasToSeriesViewRect)(e, r, !0) : e;
            if (!i) return;
            const { x: o, y: a } = this.convertCartesianToPolar(i.x, i.y),
              s = this.xAxis.getCurrentCoordinateCalculator(),
              n = this.yAxis.getCurrentCoordinateCalculator(),
              d = this.convertFromCoordinate(
                this.xAxis.isHorizontalAxis ? o : a,
                s,
                this.xCoordinateMode
              ),
              h = this.convertFromCoordinate(
                this.yAxis.isHorizontalAxis ? o : a,
                n,
                this.yCoordinateMode
              );
            return new l.Point(d, h);
          }
          getXYCoordinatesFromValues(e) {
            const t = this.parentSurface.seriesViewRect,
              { x: r, y: i } = this.getAbsoluteCoordinates(e),
              o = this.convertPolarToCartesian(r, i, this.isDomAnnotation),
              a = (0, f.translateFromSeriesViewRectToCanvas)(
                new l.Point(o.x, o.y),
                t,
                !0
              );
            if (a) return new l.Point(a.x, a.y);
          }
          convertFromCoordinate(e, t, r) {
            switch (r) {
              case D.Pixel:
                return e / S.DpiHelper.PIXEL_RATIO;
              case D.DataValue:
                return null != e ? t.getDataValue(e) : void 0;
              case D.Relative:
                return (e - t.offset) / t.viewportDimension;
              default:
                throw new Error("Not implemented");
            }
          }
          getAbsoluteCoordinates(e) {
            const t = this.xAxis.getCurrentCoordinateCalculator(),
              r = this.yAxis.getCurrentCoordinateCalculator(),
              i = this.getCoordinate(e.x, t, this.xCoordinateMode),
              o = this.getCoordinate(e.y, r, this.yCoordinateMode);
            return this.isVerticalChart ? new l.Point(o, i) : new l.Point(i, o);
          }
          getAbsoluteHorizontalCoordinate(e) {
            const t = this.xAxis.getCurrentCoordinateCalculator(),
              r = this.yAxis.getCurrentCoordinateCalculator();
            return this.isVerticalChart
              ? this.getCoordinate(e, r, this.yCoordinateMode)
              : this.getCoordinate(e, t, this.xCoordinateMode);
          }
          getAbsoluteVerticalCoordinate(e) {
            const t = this.xAxis.getCurrentCoordinateCalculator(),
              r = this.yAxis.getCurrentCoordinateCalculator();
            return this.isVerticalChart
              ? this.getCoordinate(e, t, this.xCoordinateMode)
              : this.getCoordinate(e, r, this.yCoordinateMode);
          }
          setAnnotationBorders(e, t, r, i) {
            this.annotationBorders = { x1: e, x2: t, y1: r, y2: i };
          }
          convertPolarToCartesian(e, t, r = !1) {
            if (!this.parentSurface.isPolar) return { x: e, y: t };
            const i = this.parentSurface;
            return x.annotationHelpers.convertPolarToCartesian(
              this.xAxis,
              r,
              i.webAssemblyContext2D,
              this.xCoordinateMode,
              e,
              t
            );
          }
          convertCartesianToPolar(e, t) {
            if (!this.parentSurface.isPolar) return { x: e, y: t };
            const r = this.parentSurface,
              i = this.xAxis.getTransform(),
              o = new r.webAssemblyContext2D.TSRVector2();
            i.ReverseTransformPoint(e, t, o);
            const a = -o.y,
              s = o.x;
            return o.delete(), { x: a, y: s };
          }
          applyPixelRatioToDragDist(e) {
            return this.parentSurface.isPolar &&
              this.xCoordinateMode === D.Pixel
              ? e * S.DpiHelper.PIXEL_RATIO
              : e;
          }
        }
        t.AnnotationBase = w;
      },
      28792: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnnotationClickEventArgs = void 0),
          (t.AnnotationClickEventArgs = class {
            constructor(e, t, r) {
              (this.sender = e),
                (this.mouseArgs = t),
                (this.relativeCoords = r);
            }
          });
      },
      78895: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnnotationDragDeltaEventArgs = void 0),
          (t.AnnotationDragDeltaEventArgs = class {
            constructor() {}
          });
      },
      49641: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnnotationHoverEventArgs = void 0);
        const i = r(75772),
          o = r(86127);
        t.AnnotationHoverEventArgs = class {
          constructor(e) {
            const { sender: t, mouseArgs: r, isHovered: i } = e;
            (this.sender = t), (this.mouseArgs = r), (this.isHovered = i);
          }
          getRelativeCoordinates() {
            const e = this.sender.getAdornerAnnotationBorders(!0),
              t = this.mouseArgs.mousePoint.x / o.DpiHelper.PIXEL_RATIO,
              r = this.mouseArgs.mousePoint.y / o.DpiHelper.PIXEL_RATIO;
            return new i.Point(t - e.x1, r - e.y1);
          }
        };
      },
      40301: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ArcAnnotation = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(19145),
          s = r(86699),
          n = r(21670),
          l = r(21915),
          d = r(98353),
          h = r(86127),
          u = r(31306),
          c = r(68955),
          p = r(91380),
          g = r(84736);
        class y extends c.ArcAnnotationBase {
          constructor(e) {
            var t, r;
            if (
              (super(e),
              (this.type = g.EAnnotationType.RenderContextArcAnnotation),
              (this.surfaceTypes = [a.ESurfaceType.SciChartSurfaceType]),
              (this.innerRadiusProperty = 0),
              (this.heightProperty = 0),
              this.xCoordinateMode === u.ECoordinateMode.Relative)
            )
              throw new Error(
                "ECoordinateMode.Relative is not supported for ArcAnnotation use DataValue or Pixel mode"
              );
            if (this.xCoordinateMode !== this.yCoordinateMode)
              throw new Error(
                "xCoordinateMode and yCoordinateMode should be the same for ArcAnnotation"
              );
            (this.innerRadiusProperty =
              null !== (t = null == e ? void 0 : e.innerRadius) && void 0 !== t
                ? t
                : this.innerRadiusProperty),
              (this.heightProperty =
                null !== (r = null == e ? void 0 : e.height) && void 0 !== r
                  ? r
                  : this.heightProperty);
          }
          get innerRadius() {
            return this.innerRadiusProperty;
          }
          set innerRadius(e) {
            (this.innerRadiusProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.INNER_RADIUS);
          }
          get height() {
            return this.heightProperty;
          }
          set height(e) {
            (this.heightProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.HEIGHT);
          }
          drawWithContext(e, t, r, o, a, s) {
            var n, u, c, p;
            i.Guard.notNull(e, "renderContext"),
              i.Guard.notNull(t, "xCalc"),
              i.Guard.notNull(r, "yCalc");
            const g =
                this.stroke && void 0 !== this.strokeThickness
                  ? (0, l.getWebGlPenFromCache)(this.strokePenCache)
                  : void 0,
              y = this.getResolvedCoordinate(t, r, this.x1, this.y1, !0),
              f = this.getResolvedCoordinate(t, r, this.x1, this.y1, !1),
              v = this.getResolvedCoordinate(t, r, this.x2, this.y2, !0),
              m = this.getResolvedCoordinate(t, r, this.x2, this.y2, !1),
              S = e.webAssemblyContext,
              P = (0, d.getVectorArcVertex)(S),
              C = (0, d.getArcVertex)(S),
              b =
                (null !==
                  (u =
                    null === (n = this.parentSurface.padding) || void 0 === n
                      ? void 0
                      : n.left) && void 0 !== u
                  ? u
                  : 0) * h.DpiHelper.PIXEL_RATIO,
              x =
                (null !==
                  (p =
                    null === (c = this.parentSurface.padding) || void 0 === c
                      ? void 0
                      : c.top) && void 0 !== p
                  ? p
                  : 0) * h.DpiHelper.PIXEL_RATIO,
              A = this.getCircleCenterXCoordinate(t, r),
              T = A,
              E = this.getCircleCenterYCoordinate(t, r),
              R = this.getViewportHeight() - E,
              { startAngle: D, endAngle: w } = this.calcStartEndAngles(
                t.isFlipped,
                r.isFlipped
              );
            C.MakeCircularArc(
              T,
              R,
              D,
              w,
              this.getRadius(t, r),
              this.getInnerRadius(t, r),
              this.getDrawMode(),
              this.getAspectRatio(t, r)
            ),
              P.push_back(C);
            const M = this.getClippingRect(this.clipping, o, a, s);
            e.drawArcs(P, T, R, 0, M, g.scrtPen, this.getBrush(), b, x),
              this.setArcAnnotationBorders(y, v, A, f, m, E),
              this.updateAdornerInner();
          }
          calcDragDistance(e) {
            if (this.prevValue) {
              if (
                (this.adornerDraggingPoint === u.EDraggingGripPoint.Body
                  ? ((this.x1 = this.x1 - (this.prevValue.x - e.x)),
                    (this.x2 = this.x2 - (this.prevValue.x - e.x)),
                    (this.y1 = this.y1 - (this.prevValue.y - e.y)),
                    (this.y2 = this.y2 - (this.prevValue.y - e.y)))
                  : this.adornerDraggingPoint === u.EDraggingGripPoint.x1y1
                  ? this.resizeDirections === s.EXyDirection.XDirection
                    ? (this.x1 -= this.prevValue.x - e.x)
                    : (this.resizeDirections === s.EXyDirection.YDirection ||
                        (this.x1 -= this.prevValue.x - e.x),
                      (this.y1 -= this.prevValue.y - e.y))
                  : this.adornerDraggingPoint === u.EDraggingGripPoint.x2y2 &&
                    (this.resizeDirections === s.EXyDirection.XDirection
                      ? (this.x2 -= this.prevValue.x - e.x)
                      : (this.resizeDirections === s.EXyDirection.YDirection ||
                          (this.x2 -= this.prevValue.x - e.x),
                        (this.y2 -= this.prevValue.y - e.y))),
                this.adornerDraggingPoint === u.EDraggingGripPoint.x3y3)
              ) {
                const t = (0, n.calcDistanceFromLineSegment)(
                    e.x,
                    e.y,
                    this.x1,
                    this.y1,
                    this.x2,
                    this.y2
                  ),
                  r =
                    (0, n.calcCrossProduct)(
                      e.x,
                      e.y,
                      this.x1,
                      this.y1,
                      this.x2,
                      this.y2
                    ) > 0
                      ? 1
                      : -1;
                this.height = r * t;
              }
              this.prevValue = e;
            } else this.prevValue = e;
          }
          toJSON() {
            const e = super.toJSON(),
              t = { innerRadius: this.innerRadius, height: this.height };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
              x1: r,
              x2: i,
              y1: a,
              y2: s,
              xCenter: l,
              yCenter: d,
            } = this.getArcAnnotationBorders();
            if (
              (0, n.calcDistance)(e, t, r, a) <=
              p.DISTANCE_TO_LINE * h.DpiHelper.PIXEL_RATIO
            )
              return !0;
            if (
              (0, n.calcDistance)(e, t, i, s) <=
              p.DISTANCE_TO_LINE * h.DpiHelper.PIXEL_RATIO
            )
              return !0;
            if ((0, n.calcDistance)(e, t, l, d) <= p.DISTANCE_TO_LINE)
              return !0;
            const { x: u, y: c } = this.getDataValuesFromCoordinates(e, t),
              { x: g, y } = this.getCircleCenterDataCoords(),
              f = (0, n.calcDistance)(u, c, g, y) < this.calcDataRadius(),
              { isHit: v } = this.calcStartEndAngles(
                this.xAxis.getCurrentCoordinateCalculator().isFlipped,
                this.yAxis.getCurrentCoordinateCalculator().isFlipped,
                new o.Point(u, c)
              ),
              m = f && v,
              S = (0, n.testPointInTriangle)(e, t, r, a, i, s, l, d);
            return m || S;
          }
          getCircleCenterDataCoords() {
            const e = (this.x1 + this.x2) / 2,
              t = (this.y1 + this.y2) / 2,
              r = this.x1 - this.x2,
              i = this.y1 - this.y2,
              o = Math.sqrt(r * r + i * i),
              a = i / o,
              s = -r / o,
              n = this.height;
            return { x: e + a * n, y: t + s * n };
          }
          getCircleCenterXCoordinate(e, t) {
            const r = this.getCircleCenterDataCoords();
            return this.getResolvedCoordinate(e, t, r.x, r.y, !0);
          }
          getCircleCenterYCoordinate(e, t) {
            const r = this.getCircleCenterDataCoords();
            return this.getResolvedCoordinate(e, t, r.x, r.y, !1);
          }
          calcDataRadius() {
            const e = this.x1 - this.x2,
              t = this.y1 - this.y2,
              r = Math.sqrt(e * e + t * t) / 2;
            return Math.sqrt(r * r + this.height * this.height);
          }
          getRadius(e, t) {
            const r = this.calcDataRadius();
            return this.isDataValueMode()
              ? this.isVerticalChart
                ? e.getCoordWidth(r)
                : t.getCoordWidth(r)
              : r * h.DpiHelper.PIXEL_RATIO;
          }
          getInnerRadius(e, t) {
            return this.isLineMode
              ? 0
              : this.getRadius(e, t) * this.innerRadius;
          }
          getAspectRatio(e, t) {
            return this.isDataValueMode()
              ? this.isVerticalChart
                ? t.getCoordWidth(1) / e.getCoordWidth(1)
                : e.getCoordWidth(1) / t.getCoordWidth(1)
              : 1;
          }
          calcStartEndAngles(e, t, r) {
            const i = this.getCircleCenterDataCoords();
            let o = 0,
              a = 0,
              s = 0,
              n = !1,
              l = !1;
            if (
              (this.isVerticalChart
                ? ((a = Math.atan2(this.x1 - i.x, this.y1 - i.y)),
                  (o = Math.atan2(this.x2 - i.x, this.y2 - i.y)),
                  (s = r ? Math.atan2(r.x - i.x, r.y - i.y) : 0),
                  (n = !t),
                  (l = e))
                : ((o = Math.atan2(this.y1 - i.y, this.x1 - i.x)),
                  (a = Math.atan2(this.y2 - i.y, this.x2 - i.x)),
                  (s = r ? Math.atan2(r.y - i.y, r.x - i.x) : 0),
                  (n = !e),
                  (l = t)),
              this.isDataValueMode())
            ) {
              if (!l) {
                const e = o;
                (o = 2 * Math.PI - a),
                  (a = 2 * Math.PI - e),
                  (s = 2 * Math.PI - s);
              }
              if (!n) {
                const e = o;
                (o = Math.PI - a), (a = Math.PI - e), (s = Math.PI - s);
              }
            } else {
              const e = o;
              (o = 2 * Math.PI - a),
                (a = 2 * Math.PI - e),
                (s = 2 * Math.PI - s);
            }
            return this.normalizeAnglesAndHitTest(o, a, r ? s : void 0);
          }
          getDataValuesFromCoordinates(e, t) {
            let r = 0,
              i = 0;
            if (this.isDataValueMode()) {
              const o = this.xAxis.getCurrentCoordinateCalculator(),
                a = this.yAxis.getCurrentCoordinateCalculator();
              return (
                (r = o.getDataValue(this.isVerticalChart ? t : e)),
                (i = a.getDataValue(this.isVerticalChart ? e : t)),
                { x: r, y: i }
              );
            }
            return (
              (r = e / h.DpiHelper.PIXEL_RATIO),
              (i = t / h.DpiHelper.PIXEL_RATIO),
              this.isVerticalChart ? { x: i, y: r } : { x: r, y: i }
            );
          }
        }
        t.ArcAnnotation = y;
      },
      68955: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ArcAnnotationBase = void 0);
        const i = r(56744),
          o = r(75772),
          a = r(21670),
          s = r(32873),
          n = r(51269),
          l = r(21915),
          d = r(10572),
          h = r(14184),
          u = r(86127),
          c = r(31306),
          p = r(92415),
          g = r(91380),
          y = r(29530);
        class f extends y.RenderContextAnnotationBase {
          constructor(e) {
            var t, r, i, o, a;
            super(e),
              (this.dragPointsProperty = [
                c.EDraggingGripPoint.Body,
                c.EDraggingGripPoint.x1y1,
                c.EDraggingGripPoint.x2y2,
                c.EDraggingGripPoint.x3y3,
              ]),
              (this.arcAnnotationBorders = {
                x1: 0,
                x2: 0,
                y1: 0,
                y2: 0,
                xCenter: 0,
                yCenter: 0,
              }),
              (this.strokeThicknessProperty = 1),
              (this.strokeDashArrayProperty = []),
              (this.strokeProperty = "#FFFFFF"),
              (this.isLineModeProperty = !1),
              (this.strokeProperty =
                null !== (t = null == e ? void 0 : e.stroke) && void 0 !== t
                  ? t
                  : this.strokeProperty),
              (this.strokeThicknessProperty =
                null !== (r = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== r
                  ? r
                  : this.strokeThicknessProperty),
              (this.strokeDashArrayProperty =
                null !== (i = null == e ? void 0 : e.strokeDashArray) &&
                void 0 !== i
                  ? i
                  : this.strokeDashArrayProperty),
              (this.isLineModeProperty =
                null !== (o = null == e ? void 0 : e.isLineMode) && void 0 !== o
                  ? o
                  : this.isLineModeProperty),
              (this.fillProperty =
                null !== (a = null == e ? void 0 : e.fill) && void 0 !== a
                  ? a
                  : this.fillProperty);
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE);
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE_THICKNESS);
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE_DASH_ARRAY);
          }
          get isLineMode() {
            return this.isLineModeProperty;
          }
          set isLineMode(e) {
            (this.isLineModeProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.IS_LINE_MODE);
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(g.PROPERTY.FILL);
          }
          delete() {
            (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache));
          }
          onAttach(e) {
            super.onAttach(e),
              this.strokePenCache ||
                (this.strokePenCache = new l.Pen2DCache(
                  e.webAssemblyContext2D
                )),
              (0, l.createPenInCache)(
                this.strokePenCache,
                this.stroke,
                this.strokeThickness,
                this.opacity,
                this.strokeDashArray
              ),
              this.fillBrushCache ||
                (this.fillBrushCache = new n.BrushCache(
                  e.webAssemblyContext2D
                )),
              (0, n.createBrushInCache)(
                this.fillBrushCache,
                this.fill,
                this.opacity
              );
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(g.PROPERTY.STROKE);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                stroke: this.stroke,
                strokeDashArray: this.strokeDashArray,
                strokeThickness: this.strokeThickness,
                isLineMode: this.isLineMode,
                fill: this.fill,
              };
            return Object.assign(e.options, t), e;
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const {
                x1: t,
                x2: r,
                xCenter: i,
                y1: o,
                y2: s,
                yCenter: n,
              } = this.getArcAnnotationBorders(!0),
              l = e.mousePoint.x,
              d = e.mousePoint.y;
            return this.canDragPoint(c.EDraggingGripPoint.x1y1) &&
              (0, a.calcDistance)(t, o, l, d) <
                this.annotationsGripsRadius * u.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = c.EDraggingGripPoint.x1y1), !0)
              : this.canDragPoint(c.EDraggingGripPoint.x2y2) &&
                (0, a.calcDistance)(r, s, l, d) <
                  this.annotationsGripsRadius * u.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = c.EDraggingGripPoint.x2y2), !0)
              : this.canDragPoint(c.EDraggingGripPoint.x3y3) &&
                (0, a.calcDistance)(i, n, l, d) <
                  this.annotationsGripsRadius * u.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = c.EDraggingGripPoint.x3y3), !0)
              : !(
                  !this.canDragPoint(c.EDraggingGripPoint.Body) ||
                  !this.clickToSelect(e) ||
                  ((this.adornerDraggingPoint = c.EDraggingGripPoint.Body), 0)
                );
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              [
                g.PROPERTY.STROKE,
                g.PROPERTY.STROKE_THICKNESS,
                g.PROPERTY.STROKE_DASH_ARRAY,
                g.PROPERTY.OPACITY,
              ].includes(e) &&
                this.strokePenCache &&
                (0, l.createPenInCache)(
                  this.strokePenCache,
                  this.stroke,
                  this.strokeThickness,
                  this.opacity,
                  this.strokeDashArray
                ),
              [g.PROPERTY.FILL, g.PROPERTY.OPACITY].includes(e) &&
                this.fillBrushCache &&
                (0, n.createBrushInCache)(
                  this.fillBrushCache,
                  this.fill,
                  this.opacity
                );
          }
          getBrush() {
            if (!this.isLineMode) {
              const e = this.fill
                ? (0, n.getWebGlBrushFromCache)(this.fillBrushCache)
                : void 0;
              return (
                null == e || e.setOpacity(this.opacity),
                e ? e.scrtBrush : void 0
              );
            }
          }
          getDrawMode() {
            return this.isLineMode ? 1 : 0;
          }
          setArcAnnotationBorders(e, t, r, i, o, a) {
            this.arcAnnotationBorders = {
              x1: e,
              x2: t,
              xCenter: r,
              y1: i,
              y2: o,
              yCenter: a,
            };
          }
          getArcAnnotationBorders(e = !1, t = 1) {
            if (e) {
              const { seriesViewRect: e } = this.parentSurface,
                {
                  x1: r,
                  x2: i,
                  xCenter: a,
                  y1: n,
                  y2: l,
                  yCenter: d,
                } = this.arcAnnotationBorders,
                h = (0, s.translateFromSeriesViewRectToCanvas)(
                  new o.Point(r, n),
                  e,
                  !0
                ),
                u = (0, s.translateFromSeriesViewRectToCanvas)(
                  new o.Point(i, l),
                  e,
                  !0
                ),
                c = (0, s.translateFromSeriesViewRectToCanvas)(
                  new o.Point(a, d),
                  e,
                  !0
                );
              return {
                x1: h.x * t,
                y1: h.y * t,
                x2: u.x * t,
                y2: u.y * t,
                xCenter: c.x * t,
                yCenter: c.y * t,
              };
            }
            return this.arcAnnotationBorders;
          }
          svgStringArcAdornerTemplate(e, t, r, i, o, a) {
            const s = this.selectionBoxStroke;
            return `<svg xmlns="http://www.w3.org/2000/svg">\n    <line x1="${e}" y1="${t}" x2="${r}" y2="${i}" stroke="${s}" stroke-width="6" />\n    <line x1="${e}" y1="${t}" x2="${o}" y2="${a}" stroke="${s}" stroke-width="6" />\n    <line x1="${o}" y1="${a}" x2="${r}" y2="${i}" stroke="${s}" stroke-width="6" />\n    ${
              this.canDragPoint(c.EDraggingGripPoint.x1y1)
                ? this.getAnnotationGripSvg(e, t)
                : ""
            }\n    ${
              this.canDragPoint(c.EDraggingGripPoint.x2y2)
                ? this.getAnnotationGripSvg(r, i)
                : ""
            }\n    ${this.getAnnotationGripSvg(o, a)}\n    </svg>`;
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                  xCenter: o,
                  yCenter: a,
                } = this.getArcAnnotationBorders(
                  !0,
                  1 / u.DpiHelper.PIXEL_RATIO
                ),
                s = this.svgStringArcAdornerTemplate(e, r, t, i, o, a);
              this.svgAdorner = p.annotationHelpers.createSvg(
                s,
                this.svgAdornerRoot
              );
            }
          }
          getViewportHeight() {
            return this.parentSurface.isCopyCanvasSurface
              ? h.SciChartSurfaceBase.domMasterCanvas.height
              : this.parentSurface.renderSurface.viewportSize.height;
          }
          normalizeAnglesAndHitTest(e, t, r) {
            let i = d.labelHelper.normalizeAngle(e),
              o = d.labelHelper.normalizeAngle(t);
            i > o && (o += 2 * Math.PI);
            let a = !1;
            if (r) {
              let e = d.labelHelper.normalizeAngle(r);
              e < i && (e += 2 * Math.PI), i <= e && e <= o && (a = !0);
            }
            return { startAngle: i, endAngle: o, isHit: a };
          }
          isDataValueMode() {
            return this.xCoordinateMode === c.ECoordinateMode.DataValue;
          }
        }
        t.ArcAnnotationBase = f;
      },
      29371: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisMarkerAnnotation = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(52578),
          s = r(21670),
          n = r(32873),
          l = r(3441),
          d = r(86127),
          h = r(31306),
          u = r(26520),
          c = r(92415),
          p = r(91380),
          g = r(84736),
          y = r(29530);
        class f extends y.RenderContextAnnotationBase {
          constructor(e) {
            var t, r, i, o, s, n, l, d, h, c, p;
            super(e),
              (this.type = g.EAnnotationType.RenderContextAxisMarkerAnnotation),
              (this.clippingProperty = u.EAnnotationClippingMode.Chart),
              (this.fontSizeProperty = 14),
              (this.fontFamilyProperty = a.DEFAULT_FONT_FAMILY),
              (this.fontWeightProperty = "Normal"),
              (this.fontStyleProperty = "Normal"),
              (this.colorProperty = "#FFFFFF"),
              (this.backgroundColorProperty = "#b36200"),
              (this.fontSizeProperty =
                null !== (t = null == e ? void 0 : e.fontSize) && void 0 !== t
                  ? t
                  : this.fontSizeProperty),
              (this.fontFamilyProperty =
                null !== (r = null == e ? void 0 : e.fontFamily) && void 0 !== r
                  ? r
                  : this.fontFamilyProperty),
              (this.fontWeightProperty =
                null !== (i = null == e ? void 0 : e.fontWeight) && void 0 !== i
                  ? i
                  : this.fontWeightProperty),
              (this.fontStyleProperty =
                null !== (o = null == e ? void 0 : e.fontStyle) && void 0 !== o
                  ? o
                  : this.fontStyleProperty),
              (this.colorProperty =
                null !== (s = null == e ? void 0 : e.color) && void 0 !== s
                  ? s
                  : this.colorProperty),
              (this.paddingProperty =
                null !== (n = null == e ? void 0 : e.padding) && void 0 !== n
                  ? n
                  : this.paddingProperty),
              (this.backgroundColorProperty =
                null !== (l = null == e ? void 0 : e.backgroundColor) &&
                void 0 !== l
                  ? l
                  : this.backgroundColorProperty),
              (this.formattedValueProperty =
                null !== (d = null == e ? void 0 : e.formattedValue) &&
                void 0 !== d
                  ? d
                  : this.formattedValueProperty),
              (this.imageProperty =
                null !== (h = null == e ? void 0 : e.image) && void 0 !== h
                  ? h
                  : this.imageProperty),
              (this.imageWidthProperty =
                null !== (c = null == e ? void 0 : e.imageWidth) && void 0 !== c
                  ? c
                  : this.imageWidthProperty),
              (this.imageHeightProperty =
                null !== (p = null == e ? void 0 : e.imageHeight) &&
                void 0 !== p
                  ? p
                  : this.imageHeightProperty),
              (null == e ? void 0 : e.x1) && (this.x1 = e.x1),
              (null == e ? void 0 : e.x2) && (this.x2 = e.x2),
              (null == e ? void 0 : e.y2) && (this.y2 = e.y2);
          }
          delete() {}
          get y2() {
            throw Error(
              "y2 property is not supported for AxisMarkerAnnotation"
            );
          }
          set y2(e) {
            throw Error(
              "y2 property is not supported for AxisMarkerAnnotation"
            );
          }
          get x2() {
            throw Error(
              "x2 property is not supported for AxisMarkerAnnotation"
            );
          }
          set x2(e) {
            throw Error(
              "x2 property is not supported for AxisMarkerAnnotation"
            );
          }
          get backgroundColor() {
            return this.backgroundColorProperty;
          }
          set backgroundColor(e) {
            (this.backgroundColorProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.BACKGROUND_COLOR);
          }
          get color() {
            return this.colorProperty;
          }
          set color(e) {
            (this.colorProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.COLOR);
          }
          get fontSize() {
            return this.fontSizeProperty;
          }
          set fontSize(e) {
            (this.fontSizeProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FONT_SIZE);
          }
          get fontFamily() {
            return this.fontFamilyProperty;
          }
          set fontFamily(e) {
            (this.fontFamilyProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FONT_FAMILY);
          }
          get fontWeight() {
            return this.fontWeightProperty;
          }
          set fontWeight(e) {
            (this.fontWeightProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FONT_WEIGHT);
          }
          get fontStyle() {
            return this.fontStyleProperty;
          }
          set fontStyle(e) {
            (this.fontStyleProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FONT_STYLE);
          }
          get padding() {
            return this.paddingProperty;
          }
          set padding(e) {
            (this.paddingProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.PADDING);
          }
          get formattedValue() {
            return this.formattedValueProperty;
          }
          set formattedValue(e) {
            (this.formattedValueProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FORMATTED_VALUE);
          }
          get image() {
            return this.imageProperty;
          }
          set image(e) {
            (this.imageProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.IMAGE);
          }
          get imageWidth() {
            return this.imageWidthProperty;
          }
          set imageWidth(e) {
            (this.imageWidthProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.IMAGE_WIDTH);
          }
          get imageHeight() {
            return this.imageHeightProperty;
          }
          set imageHeight(e) {
            (this.imageHeightProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.IMAGE_HEIGHT);
          }
          drawWithContext(e, t, r, a, s, h) {
            i.Guard.notNull(e, "renderContext"),
              i.Guard.notNull(t, "xCalc"),
              i.Guard.notNull(r, "yCalc");
            const u = this.getX1Coordinate(t, r),
              c = this.getY1Coordinate(t, r),
              p = null == this.x1,
              g = p ? this.y1 : this.x1;
            i.Guard.argumentIsRealNumber(g, "x1 or y1");
            const y = p ? this.yAxis : this.xAxis;
            if (!y || !1 === y.isVisible) return;
            const f = p ? this.yCoordinateMode : this.xCoordinateMode,
              v = p ? r : t,
              m = this.getCoordinate(g, v, f);
            if (
              y.isHorizontalAxis
                ? m >= 0 && m <= a.width
                : m >= 0 && m <= a.height
            ) {
              const t = {
                  fontFamily: this.fontFamilyProperty,
                  fontSize: this.fontSizeProperty * d.DpiHelper.PIXEL_RATIO,
                  fontStyle: this.fontStyleProperty,
                  color: this.colorProperty,
                },
                r = (0, l.drawAxisMarkerAnnotation)(
                  y,
                  e,
                  this.formattedValueProperty,
                  m,
                  u,
                  c,
                  t,
                  this.backgroundColorProperty,
                  this.opacity,
                  this.image,
                  this.imageWidth,
                  this.imageHeight
                ),
                i = (0, n.translateFromCanvasToSeriesViewRect)(
                  new o.Point(r.xPosition, r.yPosition),
                  a,
                  !0
                ),
                s = (0, n.translateFromCanvasToSeriesViewRect)(
                  new o.Point(
                    r.xPosition + r.textureWidth,
                    r.yPosition + r.textureHeight
                  ),
                  a,
                  !0
                );
              this.setAnnotationBorders(i.x, s.x, i.y, s.y),
                this.updateAdornerInner();
            } else this.deleteAdorner();
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const { x: t, y: r } = this.calculateAdornerCenter(),
              i = (0, n.translateFromCanvasToSeriesViewRect)(
                new o.Point(e.mousePoint.x, e.mousePoint.y),
                this.parentSurface.seriesViewRect,
                !0
              ),
              a = (0, n.translateFromCanvasToSeriesViewRect)(
                new o.Point(
                  t * d.DpiHelper.PIXEL_RATIO,
                  r * d.DpiHelper.PIXEL_RATIO
                ),
                this.parentSurface.seriesViewRect,
                !0
              );
            if (i) {
              if (
                a &&
                (0, s.calcDistance)(a.x, a.y, i.x, i.y) <
                  this.annotationsGripsRadius * d.DpiHelper.PIXEL_RATIO
              )
                return (
                  (this.adornerDraggingPoint = h.EDraggingGripPoint.x1y1), !0
                );
              if (this.clickToSelect(e))
                return (
                  (this.adornerDraggingPoint = h.EDraggingGripPoint.Body), !0
                );
            }
            return !1;
          }
          calcDragDistance(e) {
            this.prevValue
              ? (void 0 !== this.x1
                  ? (this.x1 -= this.prevValue.x - e.x)
                  : void 0 !== this.y1 && (this.y1 -= this.prevValue.y - e.y),
                (this.prevValue = e))
              : (this.prevValue = e);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                backgroundColor: this.backgroundColor,
                color: this.color,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontWeight: this.fontWeight,
                formattedValue: this.formattedValue,
                padding: this.padding,
                image: void 0,
                imageHeight: this.imageHeight,
                imageWidth: this.imageWidth,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
              x1: r,
              x2: i,
              y1: o,
              y2: a,
            } = this.getAnnotationBorders(!0);
            return (0, s.testIsInBounds)(e, t, r, a, i, o);
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(!0, !0),
                o = this.svgStringAdornerTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = c.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          svgStringAdornerTemplate(e, t, r, i) {
            const o = this.selectionBoxStroke,
              { x: a, y: s } = this.calculateAdornerCenter();
            return `<svg xmlns="http://www.w3.org/2000/svg">\n        <rect x="${e}" y="${t}" width="${
              r - e
            }" height="${i - t}" stroke="${o}" stroke-width="${
              this.selectionBoxThickness
            }px" fill="none" />\n        ${this.getAnnotationGripSvg(
              a,
              s
            )}\n        </svg>`;
          }
          calculateAdornerCenter() {
            const {
              x1: e,
              x2: t,
              y1: r,
              y2: i,
            } = this.getAdornerAnnotationBorders();
            return { x: Math.abs((e + t) / 2), y: Math.abs((r + i) / 2) };
          }
        }
        t.AxisMarkerAnnotation = f;
      },
      89171: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxAnnotation = void 0);
        const i = r(84745),
          o = r(56744),
          a = r(23866),
          s = r(75772),
          n = r(87459),
          l = r(86699),
          d = r(21670),
          h = r(32873),
          u = r(51269),
          c = r(21915),
          p = r(86127),
          g = r(31306),
          y = r(92415),
          f = r(91380),
          v = r(84736),
          m = r(29530);
        class S extends m.RenderContextAnnotationBase {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type = v.EAnnotationType.RenderContextBoxAnnotation),
              (this.strokeThicknessProperty = 1),
              (this.stroke =
                null !== (t = null == e ? void 0 : e.stroke) && void 0 !== t
                  ? t
                  : "#ffffff"),
              (this.strokeThickness =
                null !== (r = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== r
                  ? r
                  : 1),
              (this.fill =
                null !== (i = null == e ? void 0 : e.fill) && void 0 !== i
                  ? i
                  : "#777777");
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE);
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE_THICKNESS);
          }
          get fill() {
            return this.fillProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.FILL);
          }
          delete() {
            (this.strokePenCache = (0, o.deleteSafe)(this.strokePenCache)),
              (this.fillBrushCache = (0, o.deleteSafe)(this.fillBrushCache)),
              (this.nativeDrawingProvider = (0, o.deleteSafe)(
                this.nativeDrawingProvider
              )),
              (this.xValues = (0, o.deleteSafe)(this.xValues)),
              (this.yValues = (0, o.deleteSafe)(this.yValues));
          }
          drawWithContext(e, t, r, o, l, d) {
            a.Guard.notNull(e, "renderContext"),
              a.Guard.notNull(t, "xCalc"),
              a.Guard.notNull(r, "yCalc");
            const h =
              this.stroke && this.strokeThickness
                ? (0, c.getWebGlPenFromCache)(this.strokePenCache)
                : void 0;
            null == h || h.setOpacity(this.opacity);
            const p = this.fill
              ? (0, u.getWebGlBrushFromCache)(this.fillBrushCache)
              : void 0;
            null == p || p.setOpacity(this.opacity);
            const g = this.getX1Coordinate(t, r),
              y = this.getX2Coordinate(t, r),
              f = this.getY1Coordinate(t, r),
              v = this.getY2Coordinate(t, r);
            this.setAnnotationBorders(g, y, f, v);
            const m = n.Rect.createWithPoints(
              new s.Point(g, f),
              new s.Point(y, v)
            );
            if (!i.IS_TEST_ENV) {
              const i = this.getClippingRect(this.clipping, o, l, d);
              this.strokeThickness > 0
                ? this.drawWithProvider(
                    e,
                    h.scrtPen,
                    p.scrtBrush,
                    t,
                    r,
                    m,
                    o,
                    i
                  )
                : e.drawRect(m, o, i, h, p, !1, this.strokeThickness);
            }
            this.updateAdornerInner();
          }
          onAttach(e) {
            super.onAttach(e),
              (this.nativeDrawingProvider =
                new e.webAssemblyContext2D.SCRTColumnSeriesDrawingProvider()),
              this.strokePenCache ||
                (this.strokePenCache = new c.Pen2DCache(
                  e.webAssemblyContext2D
                )),
              (0, c.createPenInCache)(
                this.strokePenCache,
                this.stroke,
                this.strokeThickness,
                this.opacity
              ),
              this.fillBrushCache ||
                (this.fillBrushCache = new u.BrushCache(
                  e.webAssemblyContext2D
                )),
              (0, u.createBrushInCache)(
                this.fillBrushCache,
                this.fill,
                this.opacity
              );
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const {
                x1: t,
                x2: r,
                y1: i,
                y2: o,
              } = this.getAnnotationBorders(!1, !0),
              {
                x1y1: a,
                x2y1: n,
                x1y2: l,
                x2y2: u,
              } = y.annotationHelpers.calcNewApex(
                t,
                i,
                r,
                o,
                this.isVerticalChart
              ),
              c = (0, h.translateFromCanvasToSeriesViewRect)(
                new s.Point(e.mousePoint.x, e.mousePoint.y),
                this.parentSurface.seriesViewRect,
                !0
              );
            return a &&
              this.canDragPoint(g.EDraggingGripPoint.x1y1) &&
              (0, d.calcDistance)(a.x, a.y, c.x, c.y) <
                this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x1y1), !0)
              : n &&
                this.canDragPoint(g.EDraggingGripPoint.x2y1) &&
                (0, d.calcDistance)(n.x, n.y, c.x, c.y) <
                  this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x2y1), !0)
              : l &&
                this.canDragPoint(g.EDraggingGripPoint.x1y2) &&
                (0, d.calcDistance)(l.x, l.y, c.x, c.y) <
                  this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x1y2), !0)
              : u &&
                this.canDragPoint(g.EDraggingGripPoint.x2y2) &&
                (0, d.calcDistance)(u.x, u.y, c.x, c.y) <
                  this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x2y2), !0)
              : !!(
                  c &&
                  this.canDragPoint(g.EDraggingGripPoint.Body) &&
                  this.clickToSelect(e)
                ) &&
                ((this.adornerDraggingPoint = g.EDraggingGripPoint.Body), !0);
          }
          calcDragDistance(e) {
            this.prevValue
              ? (this.adornerDraggingPoint === g.EDraggingGripPoint.Body
                  ? ((this.x1 = this.x1 - (this.prevValue.x - e.x)),
                    (this.x2 = this.x2 - (this.prevValue.x - e.x)),
                    (this.y1 = this.y1 - (this.prevValue.y - e.y)),
                    (this.y2 = this.y2 - (this.prevValue.y - e.y)))
                  : this.adornerDraggingPoint === g.EDraggingGripPoint.x1y1
                  ? this.resizeDirections === l.EXyDirection.XDirection
                    ? (this.x1 -= this.prevValue.x - e.x)
                    : (this.resizeDirections === l.EXyDirection.YDirection ||
                        (this.x1 -= this.prevValue.x - e.x),
                      (this.y1 -= this.prevValue.y - e.y))
                  : this.adornerDraggingPoint === g.EDraggingGripPoint.x2y2
                  ? this.resizeDirections === l.EXyDirection.XDirection
                    ? (this.x2 -= this.prevValue.x - e.x)
                    : (this.resizeDirections === l.EXyDirection.YDirection ||
                        (this.x2 -= this.prevValue.x - e.x),
                      (this.y2 -= this.prevValue.y - e.y))
                  : this.adornerDraggingPoint === g.EDraggingGripPoint.x2y1
                  ? this.resizeDirections === l.EXyDirection.XDirection
                    ? (this.x2 -= this.prevValue.x - e.x)
                    : (this.resizeDirections === l.EXyDirection.YDirection ||
                        (this.x2 -= this.prevValue.x - e.x),
                      (this.y1 -= this.prevValue.y - e.y))
                  : this.adornerDraggingPoint === g.EDraggingGripPoint.x1y2 &&
                    (this.resizeDirections === l.EXyDirection.XDirection
                      ? (this.x1 -= this.prevValue.x - e.x)
                      : (this.resizeDirections === l.EXyDirection.YDirection ||
                          (this.x1 -= this.prevValue.x - e.x),
                        (this.y2 -= this.prevValue.y - e.y))),
                (this.prevValue = e))
              : (this.prevValue = e);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                fill: this.fill,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
              x1: r,
              x2: i,
              y1: o,
              y2: a,
            } = this.getAnnotationBorders(!0);
            return (0, d.testIsInBounds)(e, t, r, a, i, o);
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e);
            const t = [
              f.PROPERTY.STROKE,
              f.PROPERTY.STROKE_THICKNESS,
              f.PROPERTY.STROKE_DASH_ARRAY,
              f.PROPERTY.OPACITY,
            ];
            this.strokePenCache &&
              t.includes(e) &&
              (0, c.createPenInCache)(
                this.strokePenCache,
                this.stroke,
                this.strokeThickness,
                this.opacity
              );
            const r = [f.PROPERTY.FILL, f.PROPERTY.OPACITY];
            this.fillBrushCache &&
              r.includes(e) &&
              (0, u.createBrushInCache)(
                this.fillBrushCache,
                this.fill,
                this.opacity
              );
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(!0, !0),
                o = this.svgStringAdornerTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = y.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          svgStringAdornerTemplate(e, t, r, i) {
            let o = `<svg xmlns="http://www.w3.org/2000/svg">\n        <rect x="${e}" y="${t}" width="${
              r - e
            }" height="${i - t}" stroke="${
              this.selectionBoxStroke
            }" stroke-width="${
              this.selectionBoxThickness
            }px" fill="none" />\n        `;
            const a = this.getAdornerAnnotationBorders(!1, !0);
            return (
              this.canDragPoint(g.EDraggingGripPoint.x1y1) &&
                (o += this.getAnnotationGripSvg(a.x1, a.y1)),
              this.canDragPoint(g.EDraggingGripPoint.x2y2) &&
                (o += this.getAnnotationGripSvg(a.x2, a.y2)),
              this.canDragPoint(g.EDraggingGripPoint.x2y1) &&
                (o += this.getAnnotationGripSvg(a.x2, a.y1)),
              this.canDragPoint(g.EDraggingGripPoint.x1y2) &&
                (o += this.getAnnotationGripSvg(a.x1, a.y2)),
              (o += "</svg>"),
              o
            );
          }
          drawWithProvider(e, t, r, i, o, a, s, n) {
            const l = this.parentSurface.webAssemblyContext2D,
              d = new l.SCRTColumnDrawingParams();
            (d.forceShaderMethod = !0),
              (d.verticalChart = this.isVerticalChart),
              (d.zeroLineY = this.isVerticalChart
                ? o.getDataValue(a.left)
                : o.getDataValue(a.bottom)),
              (d.columnWidth = this.isVerticalChart ? a.height : a.width),
              (d.clipCoordinates = !1),
              t && d.SetLinesPen(t),
              r && d.SetFillBrush(r),
              (d.viewportWidth = s.width),
              (d.viewportHeight = s.height);
            const h = this.isVerticalChart
                ? (a.top + a.bottom) / 2
                : (a.left + a.right) / 2,
              u = i.getDataValue(h);
            this.xValues
              ? this.xValues.clear()
              : (this.xValues = new l.SCRTDoubleVector(1)),
              this.xValues.push_back(u);
            const c = this.isVerticalChart
              ? o.getDataValue(a.right)
              : o.getDataValue(a.top);
            this.yValues
              ? this.yValues.clear()
              : (this.yValues = new l.SCRTDoubleVector(1)),
              this.yValues.push_back(c),
              (d.count = 1);
            const p = e.getNativeContext();
            p.PushMatrix(),
              p.PushState(),
              p.Translate(s.x, s.y),
              p.SetClipRect(n.x, n.y, n.width, n.height),
              this.nativeDrawingProvider.DrawPointsVec(
                p,
                this.xValues,
                this.yValues,
                i.nativeCalculator,
                o.nativeCalculator,
                d
              ),
              p.PopMatrix(),
              p.PopState(),
              d.delete();
          }
        }
        t.BoxAnnotation = S;
      },
      64584: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CursorTooltipSvgAnnotation = void 0);
        const i = r(57935),
          o = r(19145),
          a = r(92415),
          s = r(91380),
          n = r(84736),
          l = r(84690);
        class d extends l.SvgAnnotationBase {
          constructor(e) {
            var t, r, i, a, s, l, d, h, u;
            if (
              (super(e),
              (this.type = n.EAnnotationType.SVG),
              (this.surfaceTypes = [
                o.ESurfaceType.SciChartSurfaceType,
                o.ESurfaceType.SciChartPolarSurfaceType,
              ]),
              (this.showTooltipProperty = !1),
              (this.seriesInfosProperty = []),
              (this.isHidden = !0),
              (this.titleProperty =
                null !== (t = null == e ? void 0 : e.title) && void 0 !== t
                  ? t
                  : this.titleProperty),
              (this.tooltipSvgTemplateProperty =
                null !== (r = null == e ? void 0 : e.tooltipSvgTemplate) &&
                void 0 !== r
                  ? r
                  : this.tooltipSvgTemplateProperty),
              (this.tooltipLegendTemplateProperty =
                null !== (i = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== i
                  ? i
                  : this.tooltipLegendTemplateProperty),
              (this.seriesInfosProperty =
                null !== (a = null == e ? void 0 : e.seriesInfos) &&
                void 0 !== a
                  ? a
                  : this.seriesInfosProperty),
              (this.containerBackgroundProperty =
                null !== (s = null == e ? void 0 : e.containerBackground) &&
                void 0 !== s
                  ? s
                  : this.containerBackgroundProperty),
              (this.textStrokeProperty =
                null !== (l = null == e ? void 0 : e.textStroke) && void 0 !== l
                  ? l
                  : this.textStrokeProperty),
              (this.tooltipLegendOffsetXProperty =
                null !== (d = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== d
                  ? d
                  : this.tooltipLegendOffsetXProperty),
              (this.tooltipLegendOffsetYProperty =
                null !== (h = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== h
                  ? h
                  : this.tooltipLegendOffsetYProperty),
              (this.cursorModifier = e.cursorModifier),
              (this.placementDivId =
                null !== (u = null == e ? void 0 : e.placementDivId) &&
                void 0 !== u
                  ? u
                  : this.placementDivId),
              this.placementDivId)
            ) {
              const e = document.querySelector(`[id='${this.placementDivId}']`);
              this.svgDivRoot = e;
            }
          }
          get seriesInfos() {
            return this.seriesInfosProperty;
          }
          set seriesInfos(e) {
            this.seriesInfosProperty &&
              e &&
              ((this.seriesInfosProperty = e),
              (e.length !== this.seriesInfosProperty.length ||
                this.seriesInfosProperty
                  .map((t) =>
                    t.equals(
                      e.find(
                        (e) => e.renderableSeries.id === t.renderableSeries.id
                      )
                    )
                  )
                  .some((e) => !1 === e)) &&
                this.notifyPropertyChanged(s.PROPERTY.SERIES_INFOS));
          }
          get title() {
            return this.titleProperty;
          }
          set title(e) {
            this.titleProperty !== e &&
              ((this.titleProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TITLE));
          }
          get tooltipSvgTemplate() {
            return this.tooltipSvgTemplateProperty;
          }
          set tooltipSvgTemplate(e) {
            (this.tooltipSvgTemplateProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_SVG_TEMPLATE);
          }
          get tooltipLegendTemplate() {
            return this.tooltipLegendTemplateProperty;
          }
          set tooltipLegendTemplate(e) {
            (this.tooltipLegendTemplateProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_TEMPLATE);
          }
          get containerBackground() {
            return this.containerBackgroundProperty;
          }
          set containerBackground(e) {
            this.containerBackgroundProperty !== e &&
              ((this.containerBackgroundProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTAINER_BACKGROUND));
          }
          get tooltipLegendOffsetX() {
            return this.tooltipLegendOffsetXProperty;
          }
          set tooltipLegendOffsetX(e) {
            this.tooltipLegendOffsetXProperty !== e &&
              ((this.tooltipLegendOffsetXProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_OFFSET_X));
          }
          get tooltipLegendOffsetY() {
            return this.tooltipLegendOffsetYProperty;
          }
          set tooltipLegendOffsetY(e) {
            this.tooltipLegendOffsetYProperty !== e &&
              ((this.tooltipLegendOffsetYProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TOOLTIP_LEGEND_OFFSET_Y));
          }
          get textStroke() {
            return this.textStrokeProperty;
          }
          set textStroke(e) {
            this.textStrokeProperty !== e &&
              ((this.textStrokeProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.TEXT_STROKE));
          }
          get showTooltip() {
            return this.showTooltipProperty;
          }
          set showTooltip(e) {
            this.showTooltipProperty !== e &&
              ((this.showTooltipProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.SHOW_LABEL));
          }
          update(e, t, r, o) {
            const a = this.cursorModifier.getMousePosition();
            (this.previousMousePosition === a &&
              a !== i.EMousePosition.SeriesArea) ||
              ((this.previousMousePosition =
                this.cursorModifier.getMousePosition()),
              this.svg && this.clear(),
              this.create(e, t, r, o),
              this.placementDivId
                ? this.updateExternalLegendTooltip()
                : (this.updateTooltip(r, o), this.updateLegendTooltip(r, o)));
          }
          clear() {
            this.parentSurface &&
              !this.parentSurface.isDeleted &&
              this.svg &&
              (this.placementDivId
                ? this.svgDivRoot.removeChild(this.svg)
                : this.svgRoot.removeChild(this.svg),
              this.setSvg(void 0),
              this.svgLegend &&
                (this.svgRoot.removeChild(this.svgLegend),
                (this.svgLegend = void 0)));
          }
          create(e, t, r, i) {
            if (!this.tooltipSvgTemplate)
              throw Error(
                "Please provide a tooltipSvgTemplate for CursorTooltipSvgAnnotation"
              );
            const o = this.tooltipSvgTemplate(this.seriesInfos, this),
              s = this.applyClipping(o, this.clipping);
            if (this.placementDivId) {
              const e = a.annotationHelpers.createSvg(s, this.svgDivRoot);
              this.setSvg(e);
            } else {
              const e = a.annotationHelpers.createSvg(
                s,
                this.svgRoot,
                this.nextSibling
              );
              this.setSvg(e);
            }
          }
          updateTooltip(e, t) {
            var r, i, o, a;
            const s = null !== (r = this.xCoordShift) && void 0 !== r ? r : 0,
              n = null !== (i = this.yCoordShift) && void 0 !== i ? i : 0;
            this.svg.style.display = this.showTooltip ? "block" : "none";
            const l = s + (null !== (o = this.x1) && void 0 !== o ? o : 0) + e,
              d = n + (null !== (a = this.y1) && void 0 !== a ? a : 0) + t;
            isNaN(l) || isNaN(d)
              ? (this.svg.style.display = "none")
              : (this.setSvgAttribute("x", l), this.setSvgAttribute("y", d));
          }
          updateLegendTooltip(e, t) {
            if (this.tooltipLegendTemplate) {
              const r = this.seriesInfos
                ? this.tooltipLegendTemplate(this.seriesInfos, this)
                : "<svg></svg>";
              this.svgLegend && this.svgRoot.removeChild(this.svgLegend);
              const i = this.applyClipping(r, this.clipping),
                o = a.annotationHelpers.createSvg(i, this.svgRoot);
              (this.svgLegend = o),
                this.svgLegend.setAttribute(
                  "x",
                  (this.tooltipLegendOffsetX + e).toString()
                ),
                this.svgLegend.setAttribute(
                  "y",
                  (this.tooltipLegendOffsetY + t).toString()
                );
            }
          }
          updateExternalLegendTooltip() {
            if (this.tooltipLegendTemplate) {
              const e = this.seriesInfos
                ? this.tooltipLegendTemplate(this.seriesInfos, this)
                : "<svg style='display: none'></svg>";
              this.svgLegend && this.svgLegend.removeChild(this.svgLegend);
              const t = this.applyClipping(e, this.clipping),
                r = a.annotationHelpers.createSvg(t, this.svgRoot);
              this.svgLegend = r;
            }
          }
        }
        t.CursorTooltipSvgAnnotation = d;
      },
      48882: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomAnnotation = void 0);
        const i = r(19145),
          o = r(92415),
          a = r(84736),
          s = r(84690);
        class n extends s.SvgAnnotationBase {
          constructor(e) {
            var t;
            super(e),
              (this.type = a.EAnnotationType.SVGCustomAnnotation),
              (this.surfaceTypes = [
                i.ESurfaceType.SciChartSurfaceType,
                i.ESurfaceType.SciChartPolarSurfaceType,
              ]),
              (this.isPositionDependent = !1),
              (this.isDirty = !0),
              (this.svgStringProperty =
                null !== (t = null == e ? void 0 : e.svgString) && void 0 !== t
                  ? t
                  : void 0);
          }
          get svgString() {
            return this.svgStringProperty;
          }
          set svgString(e) {
            this.svgStringProperty !== e &&
              ((this.isDirty = !0),
              (this.svgStringProperty = e),
              this.notifyPropertyChanged("svgString"));
          }
          getSvgString(e) {
            return e.svgString;
          }
          updateSvg(e, t) {
            return t;
          }
          toJSON() {
            const e = super.toJSON(),
              t = { svgString: this.svgString };
            return Object.assign(e.options, t), e;
          }
          create(e, t, r, i) {
            if (this.svg && !this.isDirty && !this.isPositionDependent)
              return (
                this.calcAndSetAnnotationBorders(e, t),
                void (
                  (this.isSelected ||
                    this.prevIsSelected !== this.isSelected) &&
                  (this.updateAdornerInner(),
                  (this.prevIsSelected = this.isSelected))
                )
              );
            if (
              this.isDirty ||
              !this.svg ||
              (this.svg &&
                this.isPositionDependent &&
                (this.prevX1Coordinate !== this.getX1Coordinate(e, t) ||
                  this.prevY1Coordinate !== this.getY1Coordinate(e, t)))
            ) {
              (this.prevX1Coordinate = this.getX1Coordinate(e, t)),
                (this.prevY1Coordinate = this.getY1Coordinate(e, t)),
                this.svg && this.clear();
              const r = this.getSvgString(this),
                i = this.applyClipping(r, this.clipping);
              let a = o.annotationHelpers.createSvg(
                i,
                this.svgRoot,
                this.nextSibling
              );
              this.setSvg(this.updateSvg(this, a)),
                this.calcAndSetAnnotationBorders(e, t),
                this.updateAdornerInner(),
                (this.prevIsSelected = this.isSelected),
                (this.isDirty = !1);
            }
            this.prevIsSelected !== this.isSelected &&
              this.svg &&
              this.isEditable &&
              (this.updateAdornerInner(),
              (this.prevIsSelected = this.isSelected));
          }
        }
        t.CustomAnnotation = n;
      },
      25107: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomHtmlAnnotation = void 0);
        const i = r(84736),
          o = r(75704),
          a = r(91380),
          s = r(22022);
        class n extends o.DomAnnotationBase {
          constructor(e) {
            super(e),
              (this.type = i.EAnnotationType.HtmlCustomAnnotation),
              (this.isSvgAnnotation = !1),
              (this.isDomAnnotation = !0),
              this.create();
          }
          onAttach(e) {
            super.onAttach(e), this.attachToLayerRoot();
          }
          onDetach() {
            super.onDetach(),
              this.layerRoot.removeChild(this.htmlElement.parentElement);
          }
          get htmlElement() {
            return this.htmlElementProperty;
          }
          update(e, t, r, i) {
            this.calcAndSetAnnotationBorders(e, t);
            const { x1: o, x2: a, y1: n, y2: l } = this.getAnnotationBorders();
            this.htmlElementProperty.parentElement.style.opacity =
              this.opacity.toString();
            const d = o + r,
              h = n + i;
            if (isNaN(d) || isNaN(h) || !isFinite(d) || !isFinite(h))
              this.htmlElementProperty.parentElement.style.visibility =
                "hidden";
            else if (
              ((this.htmlElementProperty.parentElement.style.visibility = this
                .isHidden
                ? "hidden"
                : "visible"),
              (this.htmlElementProperty.style.left = `${d}px`),
              (this.htmlElementProperty.style.top = `${h}px`),
              void 0 !== this.x2 || void 0 !== this.y2)
            ) {
              (this.isVerticalChart
                ? void 0 !== this.y2
                : void 0 !== this.x2) &&
                (this.htmlElementProperty.style.width = a - o + "px"),
                (this.isVerticalChart
                  ? void 0 !== this.x2
                  : void 0 !== this.y2) &&
                  (this.htmlElementProperty.style.height = l - n + "px"),
                this.calcAndSetAnnotationBorders(e, t);
              const { x1: s, y1: d } = this.getAnnotationBorders();
              (this.htmlElementProperty.style.left = `${s + r}px`),
                (this.htmlElementProperty.style.top = `${d + i}px`);
            }
            this.updateAdornerInner(),
              this.resizeObserver ||
                ((this.resizeObserver = new ResizeObserver((e) => {
                  var t;
                  const r = this.measure();
                  s.Size.isEqual(this.sizeProperty, r) ||
                    ((this.sizeProperty = r),
                    null === (t = this.invalidateParentCallback) ||
                      void 0 === t ||
                      t.call(this));
                })),
                this.resizeObserver.observe(this.htmlElement, {
                  box: "border-box",
                }));
          }
          delete() {
            var e, t;
            null ===
              (t =
                null === (e = this.resizeObserver) || void 0 === e
                  ? void 0
                  : e.disconnect) ||
              void 0 === t ||
              t.call(e),
              super.delete();
          }
          create() {
            if (this.htmlElementProperty) return;
            const e = document.createElement("div");
            (e.id = `sciChartHtmlAnnotationContainer_${this.id}`),
              (e.className = "sciChartHtmlAnnotationContainer"),
              (e.style.position = "absolute"),
              (this.htmlElementProperty = e);
          }
          get layerRoot() {
            return this.layerRootProperty;
          }
          attachToLayerRoot() {
            if (!this.layerRoot) return;
            const e = document.createElement("div");
            e.style.visibility = "hidden";
            const t = this.getClipPath(this.clipping);
            t && (e.style.clipPath = t),
              e.appendChild(this.htmlElement),
              this.layerRoot.appendChild(e);
          }
          selectLayerRoot() {
            var e, t, r;
            if (this.annotationLayer === i.EAnnotationLayer.AboveChart)
              this.layerRootProperty =
                null === (e = this.parentSurface) || void 0 === e
                  ? void 0
                  : e.domDivContainer;
            else if (this.annotationLayer === i.EAnnotationLayer.BelowChart)
              this.layerRootProperty =
                null === (t = this.parentSurface) || void 0 === t
                  ? void 0
                  : t.domDivContainer;
            else {
              if (this.annotationLayer !== i.EAnnotationLayer.Background)
                throw new Error(
                  `Unexpected annotationLayer value: "${this.annotationLayer}!"`
                );
              this.layerRootProperty =
                null === (r = this.parentSurface) || void 0 === r
                  ? void 0
                  : r.domSeriesBackground;
            }
          }
          notifyPropertyChanged(e) {
            var t, r;
            if (e === a.PROPERTY.ANNOTATION_CANVAS)
              return (
                null ===
                  (r =
                    null === (t = this.layerRoot) || void 0 === t
                      ? void 0
                      : t.removeChild) ||
                  void 0 === r ||
                  r.call(t, this.htmlElement.parentElement),
                super.notifyPropertyChanged(e),
                void this.attachToLayerRoot()
              );
            super.notifyPropertyChanged(e);
          }
          getSize() {
            if (this.htmlElementProperty)
              return (
                this.sizeProperty || (this.sizeProperty = this.measure()),
                this.sizeProperty
              );
          }
          measure() {
            const { width: e, height: t } =
              this.htmlElementProperty.getBoundingClientRect();
            return new s.Size(e, t);
          }
        }
        t.CustomHtmlAnnotation = n;
      },
      75704: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DomAnnotationBase = void 0);
        const i = r(75772),
          o = r(60986),
          a = r(21670),
          s = r(32873),
          n = r(86127),
          l = r(31306),
          d = r(92415),
          h = r(91380);
        class u extends l.AnnotationBase {
          constructor(e) {
            var t, r, i, a;
            super(e),
              (this.isDomAnnotation = !0),
              (this.isDeleted = !1),
              (this.xCoordShiftProperty = 0),
              (this.yCoordShiftProperty = 0),
              (this.verticalAnchorPointProperty = o.EVerticalAnchorPoint.Top),
              (this.horizontalAnchorPointProperty =
                o.EHorizontalAnchorPoint.Left),
              (this.prevX1Coordinate = 0),
              (this.prevY1Coordinate = 0),
              (this.xCoordShiftProperty =
                null !== (t = null == e ? void 0 : e.xCoordShift) &&
                void 0 !== t
                  ? t
                  : this.xCoordShiftProperty),
              (this.yCoordShiftProperty =
                null !== (r = null == e ? void 0 : e.yCoordShift) &&
                void 0 !== r
                  ? r
                  : this.yCoordShiftProperty),
              (this.verticalAnchorPointProperty =
                null !== (i = null == e ? void 0 : e.verticalAnchorPoint) &&
                void 0 !== i
                  ? i
                  : this.verticalAnchorPointProperty),
              (this.horizontalAnchorPointProperty =
                null !== (a = null == e ? void 0 : e.horizontalAnchorPoint) &&
                void 0 !== a
                  ? a
                  : this.horizontalAnchorPointProperty);
          }
          onAttach(e) {
            super.onAttach(e), this.selectLayerRoot();
          }
          get xCoordShift() {
            return this.xCoordShiftProperty;
          }
          set xCoordShift(e) {
            this.xCoordShiftProperty !== e &&
              ((this.xCoordShiftProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.X_COORD_SHIFT));
          }
          get yCoordShift() {
            return this.yCoordShiftProperty;
          }
          set yCoordShift(e) {
            this.yCoordShiftProperty !== e &&
              ((this.yCoordShiftProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.Y_COORD_SHIFT));
          }
          get verticalAnchorPoint() {
            return this.verticalAnchorPointProperty;
          }
          set verticalAnchorPoint(e) {
            this.verticalAnchorPointProperty !== e &&
              ((this.verticalAnchorPointProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.VERTICAL_ANCHOR_POINT));
          }
          get horizontalAnchorPoint() {
            return this.horizontalAnchorPointProperty;
          }
          set horizontalAnchorPoint(e) {
            this.horizontalAnchorPointProperty !== e &&
              ((this.horizontalAnchorPointProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.HORIZONTAL_ANCHOR_POINT));
          }
          suspendInvalidate() {
            super.suspendInvalidate(),
              (this.invalidateState.xCoordShift = this.xCoordShift),
              (this.invalidateState.yCoordShift = this.yCoordShift);
          }
          resumeInvalidate() {
            this.invalidateState &&
              ((this.xCoordShift === this.invalidateState.xCoordShift &&
                this.yCoordShift === this.invalidateState.yCoordShift) ||
                (this.invalidateParentCallback &&
                  this.invalidateParentCallback()),
              super.resumeInvalidate());
          }
          calcDragDistance(e) {
            if (this.prevValue) {
              if (
                this.adornerDraggingPoint === l.EDraggingGripPoint.Body ||
                this.adornerDraggingPoint === l.EDraggingGripPoint.x1y1
              ) {
                let t =
                    this.x1 +
                    this.applyPixelRatioToDragDist(e.x - this.prevValue.x),
                  r = this.y1 + e.y - this.prevValue.y;
                void 0 !== this.x2 &&
                  (this.x2 =
                    this.x2 +
                    this.applyPixelRatioToDragDist(e.x - this.prevValue.x)),
                  void 0 !== this.y2 &&
                    (this.y2 = this.y2 + e.y - this.prevValue.y),
                  this.parentSurface.isPolar &&
                    0 === this.x1 &&
                    0 === this.y1 &&
                    ((t = e.x), (r = e.y)),
                  (this.x1 = t),
                  (this.y1 = r);
              }
              this.prevValue = e;
            } else this.prevValue = e;
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const { x1: t, x2: r, y1: n, y2: d } = this.getAnnotationBorders(),
              h = new i.Point(t, n);
            let u = t,
              c = n;
            const p = Math.abs((n - d) / 2),
              g = Math.abs((t - r) / 2);
            this.verticalAnchorPoint === o.EVerticalAnchorPoint.Center &&
              (c += p),
              this.horizontalAnchorPoint === o.EHorizontalAnchorPoint.Center &&
                (u += g);
            const y = (0, s.translateFromCanvasToSeriesViewRect)(
              new i.Point(e.mousePoint.x, e.mousePoint.y),
              this.parentSurface.seriesViewRect
            );
            return (
              !!y &&
              (h &&
              this.canDragPoint(l.EDraggingGripPoint.x1y1) &&
              (0, a.calcDistance)(
                u,
                c,
                (0, s.translateToNotScaled)(y.x),
                (0, s.translateToNotScaled)(y.y)
              ) < this.annotationsGripsRadius
                ? ((this.adornerDraggingPoint = l.EDraggingGripPoint.x1y1), !0)
                : !(
                    !this.canDragPoint(l.EDraggingGripPoint.Body) ||
                    !this.clickToSelect(e) ||
                    ((this.adornerDraggingPoint = l.EDraggingGripPoint.Body), 0)
                  ))
            );
          }
          delete() {
            this.isDeleted = !0;
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                xCoordShift: this.xCoordShift,
                yCoordShift: this.yCoordShift,
                verticalAnchorPoint: this.verticalAnchorPoint,
                horizontalAnchorPoint: this.horizontalAnchorPoint,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
                x1: r,
                x2: i,
                y1: o,
                y2: s,
              } = this.getAnnotationBorders(!0),
              l = e / n.DpiHelper.PIXEL_RATIO,
              d = t / n.DpiHelper.PIXEL_RATIO;
            return (0, a.testIsInBounds)(l, d, r, s, i, o);
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(!0, !0),
                o = this.svgStringAdornerTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = d.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          notifyPropertyChanged(e) {
            e === h.PROPERTY.ANNOTATION_CANVAS && this.selectLayerRoot(),
              super.notifyPropertyChanged(e);
          }
          calcAndSetAnnotationBorders(e, t) {
            const r = this.getSize();
            if (!r) return;
            const { width: i, height: a } = r,
              { x: s, y: n } = this.convertPolarToCartesian(
                this.getX1Coordinate(e, t),
                this.getY1Coordinate(e, t),
                !0
              ),
              { x: l, y: d } = this.convertPolarToCartesian(
                this.getX2Coordinate(e, t),
                this.getY2Coordinate(e, t),
                !0
              );
            let h = s + this.xCoordShift,
              u = n + this.yCoordShift,
              c = h + i,
              p = u + a;
            if (
              this.isVerticalChart ? void 0 === this.y2 : void 0 === this.x2
            ) {
              const { x1: e, x2: t } = (function (e, t, r, i) {
                return (
                  e === o.EHorizontalAnchorPoint.Right && (r = t - i),
                  e === o.EHorizontalAnchorPoint.Center &&
                    ((r = t + i / 2), (t -= i / 2)),
                  { x1: t, x2: r }
                );
              })(this.horizontalAnchorPoint, h, c, i);
              (h = e), (c = t);
            } else c = l + this.xCoordShift;
            if (
              this.isVerticalChart ? void 0 === this.x2 : void 0 === this.y2
            ) {
              const { y1: e, y2: t } = (function (e, t, r, i) {
                return (
                  e === o.EVerticalAnchorPoint.Bottom && (r = t - i),
                  e === o.EVerticalAnchorPoint.Center &&
                    ((r = t + i / 2), (t -= i / 2)),
                  { y1: t, y2: r }
                );
              })(this.verticalAnchorPoint, u, p, a);
              (u = e), (p = t);
            } else p = d + this.yCoordShift;
            this.setAnnotationBorders(h, c, u, p);
          }
          svgStringAdornerTemplate(e, t, r, i) {
            let a = e,
              s = t;
            const n = Math.abs((t - i) / 2),
              d = Math.abs((e - r) / 2);
            return (
              this.verticalAnchorPoint === o.EVerticalAnchorPoint.Center &&
                (s += n),
              this.horizontalAnchorPoint === o.EHorizontalAnchorPoint.Center &&
                (a += d),
              `<svg xmlns="http://www.w3.org/2000/svg">\n        <rect x="${e}" y="${t}" width="${Math.abs(
                e - r
              )}" height="${Math.abs(t - i)}" stroke="${
                this.selectionBoxStroke
              }" stroke-width="${
                this.selectionBoxThickness
              }px" fill="none" />\n        ${
                this.canDragPoint(l.EDraggingGripPoint.x1y1)
                  ? this.getAnnotationGripSvg(a, s)
                  : ""
              }\n      </svg>`
            );
          }
        }
        t.DomAnnotationBase = u;
      },
      96696: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HorizontalLineAnnotation = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(87459),
          s = r(87108),
          n = r(38215),
          l = r(19145),
          d = r(21670),
          h = r(32873),
          u = r(21915),
          c = r(3441),
          p = r(86127),
          g = r(31306),
          y = r(84736),
          f = r(28677);
        class v extends f.LineAnnotation {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type =
                y.EAnnotationType.RenderContextHorizontalLineAnnotation),
              (this.surfaceTypes = [l.ESurfaceType.SciChartSurfaceType]),
              (this.dragOnLine = !0),
              (this.dragOnLabel = !0),
              (null == e ? void 0 : e.x2) && (this.x2 = e.x2),
              (null == e ? void 0 : e.y2) && (this.y2 = e.y2),
              (this.dragOnLine =
                null !== (t = null == e ? void 0 : e.dragOnLine) && void 0 !== t
                  ? t
                  : this.dragOnLine),
              (this.dragOnLabel =
                null !== (r = null == e ? void 0 : e.dragOnLabel) &&
                void 0 !== r
                  ? r
                  : this.dragOnLabel),
              (this.horizontalAlignment =
                null !== (i = null == e ? void 0 : e.horizontalAlignment) &&
                void 0 !== i
                  ? i
                  : this.horizontalAlignment);
          }
          get y2() {
            throw Error(
              "y2 property is not supported for HorizontalLineAnnotation"
            );
          }
          set y2(e) {
            throw Error(
              "y2 property is not supported for HorizontalLineAnnotation"
            );
          }
          get x2() {
            throw Error(
              "x2 property is not supported for HorizontalLineAnnotation"
            );
          }
          set x2(e) {
            throw Error(
              "x2 property is not supported for HorizontalLineAnnotation"
            );
          }
          drawWithContext(e, t, r, n, l, d) {
            i.Guard.notNull(e, "renderContext"),
              i.Guard.notNull(t, "xCalc"),
              i.Guard.notNull(r, "yCalc");
            const g =
                this.stroke && this.strokeThickness
                  ? (0, u.getWebGlPenFromCache)(this.strokePenCache)
                  : void 0,
              {
                annotationCoord: y,
                lineAnnotationEdgeCoord: f,
                horizontalAxis: v,
                verticalAxis: m,
                horizontalAxisCoordinateMode: S,
                verticalAxisCoordinateMode: P,
                horizontalCoordinateCalculator: C,
                verticalCoordinateCalculator: b,
                isAlignmentRight: x,
              } = this.getDrawConfig(t, r);
            if (!v || !m) return;
            let A = 0,
              T = n.width;
            x && ((A = n.width), (T = 0));
            const E = this.getValue(f, C, S),
              R = E || 0 === E;
            R && (T = T = this.getX1Coordinate(t, r));
            const D = this.getY1Coordinate(t, r),
              w = D;
            this.setAnnotationBorders(A, T, D, w);
            const M = this.getCoordinate(f, C, S),
              L = this.getCoordinate(y, b, P),
              O = L >= 0 && L <= m.parentSurface.seriesViewRect.height,
              I = x ? M <= v.parentSurface.seriesViewRect.width : M >= 0;
            if (O && (!R || I)) {
              const t = Object.assign(Object.assign({}, m.labelStyle), {
                  padding: new s.Thickness(2, 2, 2, 2),
                  color: this.axisLabelStroke,
                  fontSize: this.axisFontSize * p.DpiHelper.PIXEL_RATIO,
                  fontFamily: this.axisFontFamily,
                }),
                r = (0, c.drawLineAnnotation)(
                  m,
                  e,
                  this.labelPlacement,
                  this.labelValue,
                  A,
                  T,
                  D,
                  w,
                  t,
                  this.axisLabelFill,
                  g,
                  n,
                  this.showLabel,
                  this.opacity,
                  this.horizontalAlignment
                );
              if (r) {
                const e = (0, h.translateFromCanvasToSeriesViewRect)(
                    new o.Point(r.left, r.top),
                    n,
                    !0
                  ),
                  t = (0, h.translateFromCanvasToSeriesViewRect)(
                    new o.Point(r.right, r.bottom),
                    n,
                    !0
                  );
                this.labelRect = a.Rect.createWithPoints(e, t);
              }
            }
            this.dragOnLine && this.updateAdornerInner();
          }
          onDragStarted(e) {
            return this.dragOnLine
              ? super.onDragStarted(e)
              : !!(
                  this.dragOnLabel &&
                  this.labelRect &&
                  this.clickToSelect(e)
                ) &&
                  ((this.adornerDraggingPoint = g.EDraggingGripPoint.Body), !0);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                dragOnLabel: this.dragOnLabel,
                dragOnLine: this.dragOnLine,
                horizontalAlignment: this.horizontalAlignment,
                verticalAlignment: void 0,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            if (
              this.dragOnLine &&
              super.checkIsClickedOnAnnotationInternal(e, t)
            )
              return !0;
            if (this.dragOnLabel && this.labelRect) {
              const { left: r, top: i, right: o, bottom: a } = this.labelRect;
              if ((0, d.testIsInBounds)(e, t, r, a, o, i)) return !0;
            }
            return !1;
          }
          getDrawConfig(e, t) {
            const r = this.xAxis,
              i = this.yAxis,
              o = {
                annotationCoord: this.y1,
                lineAnnotationEdgeCoord: this.x1,
                horizontalAxis: r,
                verticalAxis: i,
                horizontalAxisCoordinateMode: this.xCoordinateMode,
                verticalAxisCoordinateMode: this.yCoordinateMode,
                horizontalCoordinateCalculator: e,
                verticalCoordinateCalculator: t,
                isAlignmentRight:
                  (null == i ? void 0 : i.axisAlignment) ===
                  n.EAxisAlignment.Right,
              },
              a = {
                annotationCoord: this.x1,
                lineAnnotationEdgeCoord: this.y1,
                horizontalAxis: i,
                verticalAxis: r,
                horizontalAxisCoordinateMode: this.yCoordinateMode,
                verticalAxisCoordinateMode: this.xCoordinateMode,
                horizontalCoordinateCalculator: t,
                verticalCoordinateCalculator: e,
                isAlignmentRight:
                  (null == r ? void 0 : r.axisAlignment) ===
                  n.EAxisAlignment.Right,
              };
            return this.isVerticalChart ? a : o;
          }
        }
        t.HorizontalLineAnnotation = v;
      },
      23272: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HtmlTextAnnotation = void 0);
        const i = r(91380),
          o = r(25107),
          a = r(84736);
        class s extends o.CustomHtmlAnnotation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = a.EAnnotationType.HtmlTextAnnotation),
              (this.textProperty = null),
              (this.text =
                null !== (t = null == e ? void 0 : e.text) && void 0 !== t
                  ? t
                  : this.textProperty),
              (this.textContainerStyle =
                null !== (r = null == e ? void 0 : e.textContainerStyle) &&
                void 0 !== r
                  ? r
                  : this.textContainerStyleProperty);
          }
          get text() {
            return this.textProperty;
          }
          set text(e) {
            this.textProperty !== e &&
              ((this.textProperty = e),
              this.setText(this.textProperty),
              this.notifyPropertyChanged(i.PROPERTY.TEXT_STYLE));
          }
          get textContainerStyle() {
            return this.textContainerStyleProperty;
          }
          set textContainerStyle(e) {
            this.textContainerStyleProperty !== e &&
              ((this.textContainerStyleProperty = e),
              this.setStyle(this.textContainerStyle),
              this.notifyPropertyChanged(i.PROPERTY.TEXT));
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                textContainerStyle: this.textContainerStyle,
                text: this.text,
              };
            return Object.assign(e.options, t), e;
          }
          setText(e) {
            this.htmlElement.innerText = e;
          }
          setStyle(e) {
            Object.entries(e).forEach(([e, t]) => {
              let r = e.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase());
              this.htmlElement.style.setProperty(r, t);
            });
          }
        }
        t.HtmlTextAnnotation = s;
      },
      84736: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAnnotationType = t.EAnnotationLayer = void 0),
          ((i = t.EAnnotationLayer || (t.EAnnotationLayer = {})).AboveChart =
            "AboveChart"),
          (i.BelowChart = "BelowChart"),
          (i.Background = "Background"),
          ((r = t.EAnnotationType || (t.EAnnotationType = {})).SVG = "SVG"),
          (r.RenderContextBoxAnnotation = "RenderContextBoxAnnotation"),
          (r.RenderContextLineAnnotation = "RenderContextLineAnnotation"),
          (r.RenderContextHorizontalLineAnnotation =
            "RenderContextHorizontalLineAnnotation"),
          (r.RenderContextVerticalLineAnnotation =
            "RenderContextVerticalLineAnnotation"),
          (r.RenderContextLineArrowAnnotation =
            "RenderContextLineArrowAnnotation"),
          (r.RenderContextArcAnnotation = "RenderContextArcAnnotation"),
          (r.RenderContextPolarArcAnnotation =
            "RenderContextPolarArcAnnotation"),
          (r.RenderContextAxisMarkerAnnotation =
            "RenderContextAxisMarkerAnnotation"),
          (r.RenderContextNativeTextAnnotation =
            "RenderContextNativeTextAnnotation"),
          (r.RenderContextCustomAnnotation = "RenderContextCustomAnnotation"),
          (r.SVGTextAnnotation = "SVGTextAnnotation"),
          (r.SVGCustomAnnotation = "SVGCustomAnnotation"),
          (r.SVGPolarPointerAnnotation = "SVGPolarPointerAnnotation"),
          (r.HtmlCustomAnnotation = "HtmlCustomAnnotation"),
          (r.HtmlTextAnnotation = "HtmlTextAnnotation");
      },
      28677: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineAnnotation = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(75772),
          s = r(11805),
          n = r(19145),
          l = r(86699),
          d = r(52578),
          h = r(21670),
          u = r(21915),
          c = r(3441),
          p = r(86127),
          g = r(31306),
          y = r(92415),
          f = r(91380),
          v = r(84736),
          m = r(29530);
        class S extends m.RenderContextAnnotationBase {
          constructor(e) {
            var t, r, i, o, a, l, h, u, c, p;
            super(e),
              (this.type = v.EAnnotationType.RenderContextLineAnnotation),
              (this.surfaceTypes = [
                n.ESurfaceType.SciChartSurfaceType,
                n.ESurfaceType.SciChartPolarSurfaceType,
              ]),
              (this.axisFontSizeProperty = 14),
              (this.axisFontFamilyProperty = d.DEFAULT_FONT_FAMILY),
              (this.strokeThicknessProperty = 1),
              (this.strokeDashArrayProperty = []),
              (this.strokeProperty = "#FFFFFF"),
              (this.showLabelProperty = !1),
              (this.axisLabelStrokeProperty = "#ffffff"),
              (this.axisLabelFillProperty = "#b36200"),
              (this.labelPlacementProperty = s.ELabelPlacement.Auto),
              (this.labelValueProperty = ""),
              (this.stroke =
                null !== (t = null == e ? void 0 : e.stroke) && void 0 !== t
                  ? t
                  : this.strokeProperty),
              (this.strokeThickness =
                null !== (r = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== r
                  ? r
                  : this.strokeThicknessProperty),
              (this.strokeDashArray =
                null !== (i = null == e ? void 0 : e.strokeDashArray) &&
                void 0 !== i
                  ? i
                  : this.strokeDashArrayProperty),
              (this.showLabelProperty =
                null !== (o = null == e ? void 0 : e.showLabel) && void 0 !== o
                  ? o
                  : this.showLabelProperty),
              (this.axisLabelStrokeProperty =
                null !== (a = null == e ? void 0 : e.axisLabelStroke) &&
                void 0 !== a
                  ? a
                  : this.axisLabelStrokeProperty),
              (this.axisLabelFillProperty =
                null !== (l = null == e ? void 0 : e.axisLabelFill) &&
                void 0 !== l
                  ? l
                  : this.axisLabelFillProperty),
              (this.axisFontSizeProperty =
                null !== (h = null == e ? void 0 : e.axisFontSize) &&
                void 0 !== h
                  ? h
                  : this.axisFontSizeProperty),
              (this.axisFontFamilyProperty =
                null !== (u = null == e ? void 0 : e.axisFontFamily) &&
                void 0 !== u
                  ? u
                  : this.axisFontFamilyProperty),
              (this.labelPlacementProperty =
                null !== (c = null == e ? void 0 : e.labelPlacement) &&
                void 0 !== c
                  ? c
                  : this.labelPlacementProperty),
              (this.labelValueProperty =
                null !== (p = null == e ? void 0 : e.labelValue) && void 0 !== p
                  ? p
                  : this.labelValueProperty);
          }
          get stroke() {
            return this.strokeProperty;
          }
          set stroke(e) {
            (this.strokeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE);
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE_THICKNESS);
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE_DASH_ARRAY);
          }
          get showLabel() {
            return this.showLabelProperty;
          }
          set showLabel(e) {
            (this.showLabelProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.SHOW_LABEL);
          }
          get axisLabelStroke() {
            return this.axisLabelStrokeProperty;
          }
          set axisLabelStroke(e) {
            (this.axisLabelStrokeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_LABELS_STROKE);
          }
          get axisLabelFill() {
            return this.axisLabelFillProperty;
          }
          set axisLabelFill(e) {
            (this.axisLabelFillProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_LABELS_FILL);
          }
          get axisFontSize() {
            return this.axisFontSizeProperty;
          }
          set axisFontSize(e) {
            (this.axisFontSizeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_FONT_SIZE);
          }
          get axisFontFamily() {
            return this.axisFontFamilyProperty;
          }
          set axisFontFamily(e) {
            (this.axisFontFamilyProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_FONT_FAMILY);
          }
          get labelPlacement() {
            return this.labelPlacementProperty;
          }
          set labelPlacement(e) {
            (this.labelPlacementProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.LABEL_PLACEMENT);
          }
          get labelValue() {
            return this.labelValueProperty;
          }
          set labelValue(e) {
            (this.labelValueProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.LABEL_VALUE);
          }
          delete() {
            this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache);
          }
          onAttach(e) {
            super.onAttach(e),
              this.strokePenCache ||
                (this.strokePenCache = new u.Pen2DCache(
                  e.webAssemblyContext2D
                )),
              (0, u.createPenInCache)(
                this.strokePenCache,
                this.stroke,
                this.strokeThickness,
                this.opacity,
                this.strokeDashArray
              );
          }
          drawWithContext(e, t, r, i, a, s) {
            o.Guard.notNull(e, "renderContext"),
              o.Guard.notNull(t, "xCalc"),
              o.Guard.notNull(r, "yCalc");
            const n =
                this.stroke && this.strokeThickness && this.strokePenCache
                  ? (0, u.getWebGlPenFromCache)(this.strokePenCache)
                  : void 0,
              { x: l, y: d } = this.convertPolarToCartesian(
                this.getX1Coordinate(t, r),
                this.getY1Coordinate(t, r)
              ),
              { x: h, y: p } = this.convertPolarToCartesian(
                this.getX2Coordinate(t, r),
                this.getY2Coordinate(t, r)
              );
            if ((this.setAnnotationBorders(l, h, d, p), n)) {
              const t = this.getClippingRect(this.clipping, i, a, s);
              e.drawLine(l, d, h, p, n, i, t);
            }
            if (!this.parentSurface.isPolar && this.showLabel) {
              let t,
                r = [],
                i = [];
              l === h
                ? ((r = this.parentSurface.xAxes
                    .asArray()
                    .filter((e) => !e.isVerticalChart)),
                  (i = this.parentSurface.yAxes
                    .asArray()
                    .filter((e) => e.isVerticalChart)),
                  (t = l))
                : d === p &&
                  ((r = this.parentSurface.yAxes
                    .asArray()
                    .filter((e) => !e.isVerticalChart)),
                  (i = this.parentSurface.xAxes
                    .asArray()
                    .filter((e) => e.isVerticalChart)),
                  (t = d)),
                (r.length > 0 || i.length > 0) &&
                  [...r, ...i].forEach((r) => {
                    r.drawLabels &&
                      (!r.isStackedAxis ||
                        (r.offset < t && r.offset + r.getAxisSize() > t)) &&
                      (0, c.drawModifiersAxisLabel)(
                        r,
                        e,
                        t,
                        this.axisLabelFill,
                        this.axisLabelStroke
                      );
                  });
            }
            this.updateAdornerInner();
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const t = this.x1,
              r =
                this.type ===
                  v.EAnnotationType.RenderContextHorizontalLineAnnotation ||
                this.type ===
                  v.EAnnotationType.RenderContextVerticalLineAnnotation
                  ? this.x1
                  : this.x2,
              i = this.y1,
              o =
                this.type ===
                  v.EAnnotationType.RenderContextHorizontalLineAnnotation ||
                this.type ===
                  v.EAnnotationType.RenderContextVerticalLineAnnotation
                  ? this.y1
                  : this.y2,
              s = this.getXYCoordinatesFromValues(new a.Point(t, i)),
              n = this.getXYCoordinatesFromValues(new a.Point(r, o)),
              l = new a.Point(e.mousePoint.x, e.mousePoint.y);
            return s &&
              this.canDragPoint(g.EDraggingGripPoint.x1y1) &&
              (0, h.calcDistance)(s.x, s.y, e.mousePoint.x, e.mousePoint.y) <
                this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x1y1), !0)
              : n &&
                this.canDragPoint(g.EDraggingGripPoint.x2y2) &&
                (0, h.calcDistance)(n.x, n.y, e.mousePoint.x, e.mousePoint.y) <
                  this.annotationsGripsRadius * p.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = g.EDraggingGripPoint.x2y2), !0)
              : !!(
                  l &&
                  this.canDragPoint(g.EDraggingGripPoint.Body) &&
                  this.clickToSelect(e)
                ) &&
                ((this.adornerDraggingPoint = g.EDraggingGripPoint.Body), !0);
          }
          calcDragDistance(e) {
            if (!this.prevValue) return void (this.prevValue = e);
            const t = this.yAxis.isVerticalChart;
            this.adornerDraggingPoint === g.EDraggingGripPoint.Body
              ? this.type ===
                v.EAnnotationType.RenderContextHorizontalLineAnnotation
                ? t
                  ? (this.x1 = this.x1 - (this.prevValue.x - e.x))
                  : (this.y1 = this.y1 - (this.prevValue.y - e.y))
                : this.type ===
                  v.EAnnotationType.RenderContextVerticalLineAnnotation
                ? t
                  ? (this.y1 = this.y1 - (this.prevValue.y - e.y))
                  : (this.x1 = this.x1 - (this.prevValue.x - e.x))
                : this.type === v.EAnnotationType.RenderContextLineAnnotation &&
                  ((this.x1 =
                    this.x1 +
                    this.applyPixelRatioToDragDist(e.x - this.prevValue.x)),
                  (this.x2 =
                    this.x2 +
                    this.applyPixelRatioToDragDist(e.x - this.prevValue.x)),
                  (this.y1 = this.y1 + (e.y - this.prevValue.y)),
                  (this.y2 = this.y2 + (e.y - this.prevValue.y)))
              : this.adornerDraggingPoint === g.EDraggingGripPoint.x1y1
              ? this.resizeDirections === l.EXyDirection.XDirection
                ? (this.x1 += this.applyPixelRatioToDragDist(
                    e.x - this.prevValue.x
                  ))
                : (this.resizeDirections === l.EXyDirection.YDirection ||
                    (this.x1 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    )),
                  (this.y1 += e.y - this.prevValue.y))
              : this.adornerDraggingPoint === g.EDraggingGripPoint.x2y2 &&
                (this.resizeDirections === l.EXyDirection.XDirection
                  ? (this.x2 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    ))
                  : (this.resizeDirections === l.EXyDirection.YDirection ||
                      (this.x2 += this.applyPixelRatioToDragDist(
                        e.x - this.prevValue.x
                      )),
                    (this.y2 += e.y - this.prevValue.y))),
              (this.prevValue = e);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                axisFontFamily: this.axisFontFamily,
                axisFontSize: this.axisFontSize,
                axisLabelFill: this.axisLabelFill,
                axisLabelStroke: this.axisLabelStroke,
                labelPlacement: this.labelPlacement,
                labelValue: this.labelValue,
                showLabel: this.showLabel,
                stroke: this.stroke,
                strokeDashArray: this.strokeDashArray,
                strokeThickness: this.strokeThickness,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const { x1: r, x2: i, y1: o, y2: a } = this.getAnnotationBorders();
            return (
              (0, h.calcDistanceFromLineSegment)(e, t, r, o, i, a) <=
              f.DISTANCE_TO_LINE * p.DpiHelper.PIXEL_RATIO
            );
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              [
                f.PROPERTY.STROKE,
                f.PROPERTY.STROKE_THICKNESS,
                f.PROPERTY.STROKE_DASH_ARRAY,
                f.PROPERTY.OPACITY,
              ].includes(e) &&
                this.strokePenCache &&
                (0, u.createPenInCache)(
                  this.strokePenCache,
                  this.stroke,
                  this.strokeThickness,
                  this.opacity,
                  this.strokeDashArray
                );
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(),
                o = this.svgStringAdornerTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = y.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          svgStringAdornerTemplate(e, t, r, i) {
            return `<svg xmlns="http://www.w3.org/2000/svg">\n    <line x1="${e}" y1="${t}" x2="${r}" y2="${i}" stroke="${
              this.selectionBoxStroke
            }" stroke-width="6" />\n    ${
              this.canDragPoint(g.EDraggingGripPoint.x1y1)
                ? this.getAnnotationGripSvg(e, t)
                : ""
            }\n    ${
              this.canDragPoint(g.EDraggingGripPoint.x2y2)
                ? this.getAnnotationGripSvg(r, i)
                : ""
            }\n    </svg>`;
          }
        }
        t.LineAnnotation = S;
      },
      40734: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineArrowAnnotation = t.EArrowHeadPosition = void 0);
        const i = r(45921),
          o = r(56744),
          a = r(23866),
          s = r(11043),
          n = r(11665),
          l = r(51269),
          d = r(21915),
          h = r(86127),
          u = r(91380),
          c = r(84736),
          p = r(28677);
        var g;
        !(function (e) {
          (e.End = "End"), (e.Start = "Start"), (e.StartEnd = "StartEnd");
        })((g = t.EArrowHeadPosition || (t.EArrowHeadPosition = {})));
        const y = "transparent";
        class f extends p.LineAnnotation {
          constructor(e) {
            var t, r, o, a, n, l, d, h, u, p, f, v, m, S, P, C;
            super(e),
              (this.type = c.EAnnotationType.RenderContextLineArrowAnnotation),
              (this.arrowHeadPositionProperty = g.End),
              (this.isArrowHeadScalableProperty = !1),
              (this.getArrowStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r), this.notifyPropertyChanged("arrowStyle"), !0
                  ),
                })),
              (this.arrowHeadPositionProperty =
                null !== (t = null == e ? void 0 : e.arrowHeadPosition) &&
                void 0 !== t
                  ? t
                  : g.End),
              (this.isArrowHeadScalable =
                null !== (r = null == e ? void 0 : e.isArrowHeadScalable) &&
                void 0 !== r &&
                r),
              (this.arrowStyleProperty = this.getArrowStyleProxy({
                headLength:
                  null !==
                    (a =
                      null === (o = null == e ? void 0 : e.arrowStyle) ||
                      void 0 === o
                        ? void 0
                        : o.headLength) && void 0 !== a
                    ? a
                    : 10,
                headWidth:
                  null !==
                    (l =
                      null === (n = null == e ? void 0 : e.arrowStyle) ||
                      void 0 === n
                        ? void 0
                        : n.headWidth) && void 0 !== l
                    ? l
                    : 8,
                headDepth:
                  null !==
                    (h =
                      null === (d = null == e ? void 0 : e.arrowStyle) ||
                      void 0 === d
                        ? void 0
                        : d.headDepth) && void 0 !== h
                    ? h
                    : 0,
                fill:
                  null !==
                    (p =
                      null === (u = null == e ? void 0 : e.arrowStyle) ||
                      void 0 === u
                        ? void 0
                        : u.fill) && void 0 !== p
                    ? p
                    : y,
                stroke:
                  null !==
                    (m =
                      null !==
                        (v =
                          null === (f = null == e ? void 0 : e.arrowStyle) ||
                          void 0 === f
                            ? void 0
                            : f.stroke) && void 0 !== v
                        ? v
                        : this.stroke) && void 0 !== m
                    ? m
                    : "#FFFFFF",
                strokeThickness:
                  null !==
                    (C =
                      null !==
                        (P =
                          null === (S = null == e ? void 0 : e.arrowStyle) ||
                          void 0 === S
                            ? void 0
                            : S.strokeThickness) && void 0 !== P
                        ? P
                        : this.strokeThickness) && void 0 !== C
                    ? C
                    : 1,
              })),
              (null == e ? void 0 : e.onArrowHeadSizeChanged) &&
                ("string" == typeof e.onArrowHeadSizeChanged
                  ? (this.typeMap.set(
                      "onArrowHeadSizeChanged",
                      e.onArrowHeadSizeChanged
                    ),
                    (this.onArrowHeadSizeChangedCallback = (0, i.getFunction)(
                      s.EBaseType.OptionFunction,
                      e.onArrowHeadSizeChanged
                    )))
                  : (this.onArrowHeadSizeChangedCallback =
                      e.onArrowHeadSizeChanged));
          }
          get arrowStyle() {
            return this.arrowStyleProperty;
          }
          set arrowStyle(e) {
            const t = Object.assign(Object.assign({}, this.arrowStyle), e);
            (this.arrowStyleProperty = this.getArrowStyleProxy(t)),
              this.notifyPropertyChanged("arrowStyle");
          }
          get arrowHeadPosition() {
            return this.arrowHeadPositionProperty;
          }
          set arrowHeadPosition(e) {
            (this.arrowHeadPositionProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.ARROW_HEAD_POSITION);
          }
          get isArrowHeadScalable() {
            return this.isArrowHeadScalableProperty;
          }
          set isArrowHeadScalable(e) {
            (this.isArrowHeadScalableProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.IS_ARROW_HEAD_RELATIVE);
          }
          onAttach(e) {
            super.onAttach(e), this.updateArrowheadBrushes(e);
          }
          updateArrowheadBrushes(e) {
            this.arrowheadStrokePenCache ||
              (this.arrowheadStrokePenCache = new d.Pen2DCache(
                e.webAssemblyContext2D
              )),
              (0, d.createPenInCache)(
                this.arrowheadStrokePenCache,
                this.arrowStyle.stroke,
                this.arrowStyle.strokeThickness,
                this.opacity
              ),
              this.arrowStyle.fill &&
                this.arrowStyle.fill !== y &&
                (this.arrowheadFillBrushCache ||
                  (this.arrowheadFillBrushCache = new l.BrushCache(
                    e.webAssemblyContext2D
                  )),
                (0, l.createBrushInCache)(
                  this.arrowheadFillBrushCache,
                  this.arrowStyle.fill,
                  this.opacity
                ));
          }
          delete() {
            super.delete(),
              (this.arrowheadFillBrushCache = (0, o.deleteSafe)(
                this.arrowheadFillBrushCache
              )),
              (this.arrowheadStrokePenCache = (0, o.deleteSafe)(
                this.arrowheadStrokePenCache
              ));
          }
          drawWithContext(e, t, r, i, o, s) {
            a.Guard.notNull(e, "renderContext"),
              a.Guard.notNull(t, "xCalc"),
              a.Guard.notNull(r, "yCalc");
            const { x: l, y: d } = this.convertPolarToCartesian(
                this.getX1Coordinate(t, r),
                this.getY1Coordinate(t, r)
              ),
              { x: u, y: c } = this.convertPolarToCartesian(
                this.getX2Coordinate(t, r),
                this.getY2Coordinate(t, r)
              );
            this.setAnnotationBorders(l, u, d, c);
            const p = this.getClippingRect(this.clipping, i, o, s),
              { x1: y, x2: f, y1: v, y2: m } = this.getAnnotationBorders(),
              S = f - y,
              P = m - v;
            if (0 === S && 0 === P) return;
            const C = Math.atan2(P, S);
            let b, x;
            if (this.isArrowHeadScalable) {
              const e =
                  this.xAxis.visibleRange.max - this.xAxis.visibleRange.min,
                t = this.yAxis.visibleRange.max - this.yAxis.visibleRange.min;
              (this.storedXRange && this.storedYRange) ||
                ((this.storedXRange = e), (this.storedYRange = t));
              const r = (e / this.storedXRange + t / this.storedYRange) / 2;
              (b = (this.arrowStyle.headLength / r) * h.DpiHelper.PIXEL_RATIO),
                (x = (this.arrowStyle.headWidth / r) * h.DpiHelper.PIXEL_RATIO);
            } else
              (b = this.arrowStyle.headLength * h.DpiHelper.PIXEL_RATIO),
                (x = this.arrowStyle.headWidth * h.DpiHelper.PIXEL_RATIO);
            let A = this.arrowStyle.headDepth * b;
            if (this.onArrowHeadSizeChangedCallback) {
              const e = {
                  headLength: this.arrowStyle.headLength,
                  headWidth: this.arrowStyle.headWidth,
                  headDepth: this.arrowStyle.headDepth,
                  angle: C,
                  x1: y,
                  y1: v,
                  x2: f,
                  y2: m,
                },
                t = this.onArrowHeadSizeChangedCallback(e);
              t &&
                (void 0 !== t.headLength &&
                  (b = t.headLength * h.DpiHelper.PIXEL_RATIO),
                void 0 !== t.headWidth &&
                  (x = t.headWidth * h.DpiHelper.PIXEL_RATIO),
                void 0 !== t.headDepth && (A = t.headDepth * b));
            }
            const {
                baseMidX: T,
                baseMidY: E,
                leftX: R,
                leftY: D,
                rightX: w,
                rightY: M,
              } = n.geometryHelpers.calcArrowHeadParameters(
                y,
                v,
                C + Math.PI,
                b,
                x,
                A
              ),
              {
                baseMidX: L,
                baseMidY: O,
                leftX: I,
                leftY: k,
                rightX: _,
                rightY: V,
              } = n.geometryHelpers.calcArrowHeadParameters(f, m, C, b, x, A);
            let N = y,
              B = v,
              F = f,
              H = m;
            this.arrowStyle.headWidth > 0 &&
              this.arrowStyle.headLength > 0 &&
              ([g.Start, g.StartEnd].includes(this.arrowHeadPosition) &&
                ((N = T),
                (B = E),
                this.drawArrowHead(e, y, v, 0 === A, T, E, R, D, w, M, i, p)),
              [g.End, g.StartEnd].includes(this.arrowHeadPosition) &&
                ((F = L),
                (H = O),
                this.drawArrowHead(e, f, m, 0 === A, L, O, I, k, _, V, i, p))),
              this.drawLine(e, N, B, F, H, i, o, s);
          }
          drawLine(e, t, r, i, o, a, s, n) {
            const l =
              this.stroke && this.strokeThickness && this.strokePenCache
                ? (0, d.getWebGlPenFromCache)(this.strokePenCache)
                : void 0;
            if (l) {
              const d = this.getClippingRect(this.clipping, a, s, n);
              e.drawLine(t, r, i, o, l, a, d);
            }
            this.updateAdornerInner();
          }
          drawArrowHead(e, t, r, i, o, a, s, n, h, u, c, p) {
            const g = (0, d.getWebGlPenFromCache)(this.arrowheadStrokePenCache);
            if (!g) return;
            const f = this.arrowStyle.fill && this.arrowStyle.fill !== y,
              v = f
                ? (0, l.getWebGlBrushFromCache)(this.arrowheadFillBrushCache)
                : void 0;
            i
              ? e.drawLines([s, n, t, r, h, u], g, c, p)
              : (f && e.drawTriangleStrip([s, o, t, h], [n, a, r, u], c, p, v),
                e.drawLines([o, a, s, n, t, r, h, u, o, a], g, c, p));
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              ("arrowStyle" !== e && e !== u.PROPERTY.OPACITY) ||
                this.updateArrowheadBrushes(this.parentSurface);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                arrowStyle: {
                  headLength: this.arrowStyle.headLength,
                  headWidth: this.arrowStyle.headWidth,
                  headDepth: this.arrowStyle.headDepth,
                  fill: this.arrowStyle.fill,
                  stroke: this.arrowStyle.stroke,
                  strokeThickness: this.arrowStyle.strokeThickness,
                },
                arrowHeadPosition: this.arrowHeadPosition,
                isArrowHeadScalable: this.isArrowHeadScalable,
                onArrowHeadSizeChanged: this.typeMap.get(
                  "onArrowHeadSizeChanged"
                ),
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.LineArrowAnnotation = f;
      },
      74370: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NativeTextAnnotation = t.EWrapTo = void 0);
        const i = r(56744),
          o = r(23866),
          a = r(75772),
          s = r(87459),
          n = r(60986),
          l = r(36420),
          d = r(86699),
          h = r(22950),
          u = r(48008),
          c = r(21670),
          p = r(87092),
          g = r(32873),
          y = r(98353),
          f = r(86127),
          v = r(31306),
          m = r(92415),
          S = r(91380),
          P = r(84736),
          C = r(29530),
          b = r(51269),
          x = r(87108),
          A = r(19145),
          T = r(52578);
        var E;
        !(function (e) {
          (e.ViewRect = "ViewRect"), (e.Annotation = "Annotation");
        })((E = t.EWrapTo || (t.EWrapTo = {})));
        class R extends C.RenderContextAnnotationBase {
          constructor(e) {
            var t, r, i, o, a, s, d, h, u, c, p, g, y, f, v;
            super(e),
              (this.type = P.EAnnotationType.RenderContextNativeTextAnnotation),
              (this.surfaceTypes = [
                A.ESurfaceType.SciChartSurfaceType,
                A.ESurfaceType.SciChartPolarSurfaceType,
              ]),
              (this.scaleOnResize = !1),
              (this.fontSizeProperty = 14),
              (this.fontFamilyProperty = T.DEFAULT_FONT_FAMILY),
              (this.textColorProperty = "#ffffff"),
              (this.rotationProperty = 0),
              (this.textProperty = ""),
              (this.verticalAnchorPointProperty = n.EVerticalAnchorPoint.Top),
              (this.horizontalAnchorPointProperty =
                n.EHorizontalAnchorPoint.Left),
              (this.multiLineAlignmentProperty = l.EMultiLineAlignment.Center),
              (this.lineSpacingProperty = 3),
              (this.scaleProperty = 1),
              (this.paddingProperty = x.Thickness.fromNumber(2)),
              (this.drawImmediate = !1),
              (this.textColorProperty =
                null !== (t = null == e ? void 0 : e.textColor) && void 0 !== t
                  ? t
                  : this.textColorProperty),
              (this.fontSizeProperty =
                null !== (r = null == e ? void 0 : e.fontSize) && void 0 !== r
                  ? r
                  : this.fontSizeProperty),
              (this.fontFamilyProperty =
                null !== (i = null == e ? void 0 : e.fontFamily) && void 0 !== i
                  ? i
                  : this.fontFamilyProperty),
              (this.rotationProperty =
                null !== (o = null == e ? void 0 : e.rotation) && void 0 !== o
                  ? o
                  : this.rotationProperty),
              (this.textProperty =
                null !== (a = null == e ? void 0 : e.text) && void 0 !== a
                  ? a
                  : this.textProperty),
              (this.verticalAnchorPointProperty =
                null !== (s = null == e ? void 0 : e.verticalAnchorPoint) &&
                void 0 !== s
                  ? s
                  : this.verticalAnchorPointProperty),
              (this.horizontalAnchorPointProperty =
                null !== (d = null == e ? void 0 : e.horizontalAnchorPoint) &&
                void 0 !== d
                  ? d
                  : this.horizontalAnchorPointProperty),
              (this.multiLineAlignmentProperty =
                null !== (h = null == e ? void 0 : e.multiLineAlignment) &&
                void 0 !== h
                  ? h
                  : this.multiLineAlignmentProperty),
              (this.wrapToProperty =
                null !== (u = null == e ? void 0 : e.wrapTo) && void 0 !== u
                  ? u
                  : this.wrapToProperty),
              (this.lineSpacingProperty =
                null !== (c = null == e ? void 0 : e.lineSpacing) &&
                void 0 !== c
                  ? c
                  : this.lineSpacingProperty),
              (this.scaleProperty =
                null !== (p = null == e ? void 0 : e.scale) && void 0 !== p
                  ? p
                  : this.scaleProperty),
              (this.initialWidth = Math.abs(this.x2 - this.x1)),
              (this.scaleOnResize =
                null !== (g = null == e ? void 0 : e.scaleOnResize) &&
                void 0 !== g
                  ? g
                  : this.scaleOnResize),
              (this.backgroundProperty =
                null !== (y = null == e ? void 0 : e.background) && void 0 !== y
                  ? y
                  : this.backgroundProperty),
              (this.paddingProperty =
                null !== (f = null == e ? void 0 : e.padding) && void 0 !== f
                  ? f
                  : this.paddingProperty),
              (this.drawImmediate =
                null !== (v = null == e ? void 0 : e.drawImmediate) &&
                void 0 !== v
                  ? v
                  : this.drawImmediate);
          }
          get textColor() {
            return this.textColorProperty;
          }
          set textColor(e) {
            (this.textColorProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.COLOR);
          }
          get background() {
            return this.backgroundProperty;
          }
          set background(e) {
            (this.backgroundProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.FILL);
          }
          get padding() {
            return this.paddingProperty;
          }
          set padding(e) {
            (this.paddingProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.PADDING);
          }
          get fontSize() {
            return this.fontSizeProperty;
          }
          set fontSize(e) {
            (this.fontSizeProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.AXIS_FONT_SIZE);
          }
          get fontFamily() {
            return this.fontFamilyProperty;
          }
          set fontFamily(e) {
            (this.fontFamilyProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.AXIS_FONT_FAMILY);
          }
          get rotation() {
            return this.rotationProperty;
          }
          set rotation(e) {
            (this.rotationProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.ROTATION);
          }
          get text() {
            return this.textProperty;
          }
          set text(e) {
            (this.textProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.TEXT);
          }
          get verticalAnchorPoint() {
            return this.verticalAnchorPointProperty;
          }
          set verticalAnchorPoint(e) {
            this.verticalAnchorPointProperty !== e &&
              ((this.verticalAnchorPointProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.VERTICAL_ANCHOR_POINT));
          }
          get horizontalAnchorPoint() {
            return this.horizontalAnchorPointProperty;
          }
          set horizontalAnchorPoint(e) {
            this.horizontalAnchorPointProperty !== e &&
              ((this.horizontalAnchorPointProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.HORIZONTAL_ANCHOR_POINT));
          }
          get multiLineAlignment() {
            return this.multiLineAlignmentProperty;
          }
          set multiLineAlignment(e) {
            this.multiLineAlignmentProperty !== e &&
              ((this.multiLineAlignmentProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.MULTILINE_ALIGNMENT));
          }
          get wrapTo() {
            return this.wrapToProperty;
          }
          set wrapTo(e) {
            this.wrapToProperty !== e &&
              ((this.wrapToProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.WRAP_TO));
          }
          get lineSpacing() {
            return this.lineSpacingProperty;
          }
          set lineSpacing(e) {
            (this.lineSpacingProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.LINE_SPACING);
          }
          get scale() {
            return this.scaleProperty;
          }
          set scale(e) {
            e !== this.scaleProperty &&
              ((this.scaleProperty = e),
              this.notifyPropertyChanged(S.PROPERTY.SCALE));
          }
          delete() {
            this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache);
          }
          onAttach(e) {
            super.onAttach(e),
              this.background &&
                (this.fillBrushCache ||
                  (this.fillBrushCache = new b.BrushCache(
                    e.webAssemblyContext2D
                  )),
                (0, b.createBrushInCache)(
                  this.fillBrushCache,
                  this.background,
                  this.opacity
                ));
          }
          getRotationCenter(e, t, r) {
            return new a.Point(e, t);
          }
          drawWithContext(e, t, r, i, a, s) {
            o.Guard.notNull(e, "renderContext"),
              o.Guard.notNull(t, "xCalc"),
              o.Guard.notNull(r, "yCalc");
            const d = e.getNativeContext(),
              { x: c, y: g } = this.convertPolarToCartesian(
                this.getX1Coordinate(t, r),
                this.getY1Coordinate(t, r)
              ),
              v = {
                fontFamily: this.fontFamily,
                fontSize: Math.round(this.fontSize * f.DpiHelper.PIXEL_RATIO),
              };
            let m,
              S,
              C = (0, u.parseColorToUIntArgb)(this.textColor);
            C = (0, h.uintArgbColorOverrideOpacity)(C, this.opacity);
            const b = (-this.rotation * Math.PI) / 180,
              x = 0 !== this.rotation || 1 !== this.scale;
            m = e.getFont(v, x, !1);
            const A = (0, y.getTextBounds)(
              this.parentSurface.webAssemblyContext2D
            );
            let T = this.text;
            if (this.wrapTo) {
              let e = 1 / 0;
              if ("number" == typeof this.wrapTo) e = this.wrapTo;
              else if (this.wrapTo === E.ViewRect)
                this.horizontalAnchorPoint === n.EHorizontalAnchorPoint.Left
                  ? (e = this.parentSurface.seriesViewRect.width - c)
                  : this.horizontalAnchorPoint ===
                    n.EHorizontalAnchorPoint.Center
                  ? (e =
                      2 *
                      Math.min(c, this.parentSurface.seriesViewRect.width - c))
                  : this.horizontalAnchorPoint ===
                      n.EHorizontalAnchorPoint.Right && (e = c);
              else if (this.wrapTo === E.Annotation) {
                let i = this.getX2Coordinate(t, r);
                i > c && (e = i - c);
              }
              T = (0, p.wrapNativeText)(this.text, e, m, A);
            }
            let R = this.lineSpacing;
            m.CalculateStringBounds(null != T ? T : "", A, R),
              R < 1 &&
                ((R =
                  this.lineSpacing *
                  (A.GetLineBounds(0).m_fHeight -
                    A.GetLineBounds(0).m_fOffsetY)),
                m.CalculateStringBounds(null != T ? T : "", A, R));
            const D = this.getRotationCenter(c + i.x, g + i.y, A);
            S = (0, y.getVector4)(
              this.parentSurface.webAssemblyContext2D,
              D.x,
              D.y,
              b,
              0
            );
            const { x1: w, y1: M } = (() => {
                let e = c,
                  t = g;
                return (
                  this.horizontalAnchorPointProperty ===
                  n.EHorizontalAnchorPoint.Center
                    ? (e -= A.m_fWidth / 2)
                    : this.horizontalAnchorPointProperty ===
                        n.EHorizontalAnchorPoint.Right && (e -= A.m_fWidth),
                  this.verticalAnchorPointProperty ===
                  n.EVerticalAnchorPoint.Center
                    ? (t -= A.m_fHeight / 2 - A.GetLineBounds(0).m_fHeight)
                    : this.verticalAnchorPointProperty ===
                      n.EVerticalAnchorPoint.Top
                    ? (t += A.GetLineBounds(0).m_fHeight)
                    : A.GetLinesCount() > 1 &&
                      ((t += A.GetLineBounds(0).m_fOffsetY),
                      (t -=
                        (A.GetLineBounds(0).m_fHeight -
                          A.GetLineBounds(0).m_fOffsetY) *
                        (A.GetLinesCount() - 1))),
                  { x1: e, y1: t }
                );
              })(),
              L = A.m_fWidth,
              O = A.GetLineBounds(0).m_fHeight,
              I = A.m_fHeight;
            let k = w,
              _ = M - O,
              V = w + L,
              N = _ + I;
            if (0 !== this.rotation) {
              const e = Math.sin(b),
                t = Math.cos(b),
                r = this.getRotationCenter(c, g, A),
                i = (i, o) => ({
                  x: (i - r.x) * t + (o - r.y) * e,
                  y: (o - r.y) * t - (i - r.x) * e,
                }),
                o = i(k, _),
                a = i(V, _),
                s = i(k, N),
                n = i(V, N);
              (k = Math.min(o.x, a.x, s.x, n.x) + r.x),
                (V = Math.max(o.x, a.x, s.x, n.x) + r.x),
                (_ = Math.min(o.y, a.y, s.y, n.y) + r.y),
                (N = Math.max(o.y, a.y, s.y, n.y) + r.y);
            }
            const B = (0, l.convertMultiLineAlignment)(
              this.multiLineAlignment,
              this.parentSurface.webAssemblyContext2D
            );
            let F = m.GetScale(),
              H = !1;
            F !== this.scale && (m.SetScale(this.scale), (H = !0)),
              this.setAnnotationBorders(
                k,
                k + (V - k) * this.scale,
                _,
                _ + (N - _) * this.scale
              );
            const Y = w + i.x,
              z = M + i.y;
            m.DrawStringAdvanced(T, C, Math.round(Y), Math.round(z), S, B, R),
              H && m.SetScale(F);
            const j = this.getClippingRect(this.clipping, i, a, s);
            this.background && this.drawBackground(e, L, I, D, j),
              (this.drawImmediate ||
                this.annotationLayer !== P.EAnnotationLayer.AboveChart) &&
                (d.PushState(),
                d.SetClipRect(j.x, j.y, j.width, j.height),
                m.End(),
                d.PopState()),
              this.updateAdornerInner();
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const {
                x1: t,
                x2: r,
                y1: i,
                y2: o,
              } = this.getAnnotationBorders(!1, !0),
              {
                x1y1: s,
                x2y1: n,
                x1y2: l,
                x2y2: d,
              } = m.annotationHelpers.calcNewApex(
                t,
                i,
                r,
                o,
                this.isVerticalChart
              ),
              h = (0, g.translateFromCanvasToSeriesViewRect)(
                new a.Point(e.mousePoint.x, e.mousePoint.y),
                this.parentSurface.seriesViewRect,
                !0
              );
            return s &&
              this.canDragPoint(v.EDraggingGripPoint.x1y1) &&
              (0, c.calcDistance)(s.x, s.y, h.x, h.y) <
                this.annotationsGripsRadius * f.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = v.EDraggingGripPoint.x1y1), !0)
              : n &&
                this.canDragPoint(v.EDraggingGripPoint.x2y1) &&
                (0, c.calcDistance)(n.x, n.y, h.x, h.y) <
                  this.annotationsGripsRadius * f.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = v.EDraggingGripPoint.x2y1), !0)
              : l &&
                this.canDragPoint(v.EDraggingGripPoint.x1y2) &&
                (0, c.calcDistance)(l.x, l.y, h.x, h.y) <
                  this.annotationsGripsRadius * f.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = v.EDraggingGripPoint.x1y2), !0)
              : d &&
                this.canDragPoint(v.EDraggingGripPoint.x2y2) &&
                (0, c.calcDistance)(d.x, d.y, h.x, h.y) <
                  this.annotationsGripsRadius * f.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = v.EDraggingGripPoint.x2y2), !0)
              : !!(
                  h &&
                  this.canDragPoint(v.EDraggingGripPoint.Body) &&
                  this.clickToSelect(e)
                ) &&
                ((this.adornerDraggingPoint = v.EDraggingGripPoint.Body), !0);
          }
          calcDragDistance(e) {
            if (!this.prevValue) return void (this.prevValue = e);
            this.adornerDraggingPoint === v.EDraggingGripPoint.Body
              ? ((this.x1 += this.applyPixelRatioToDragDist(
                  e.x - this.prevValue.x
                )),
                (this.x2 += this.applyPixelRatioToDragDist(
                  e.x - this.prevValue.x
                )),
                (this.y1 += e.y - this.prevValue.y),
                (this.y2 += e.y - this.prevValue.y))
              : this.adornerDraggingPoint === v.EDraggingGripPoint.x1y1
              ? this.resizeDirections === d.EXyDirection.XDirection
                ? (this.x1 += this.applyPixelRatioToDragDist(
                    e.x - this.prevValue.x
                  ))
                : (this.resizeDirections === d.EXyDirection.YDirection ||
                    (this.x1 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    )),
                  (this.y1 += e.y - this.prevValue.y))
              : this.adornerDraggingPoint === v.EDraggingGripPoint.x2y2
              ? this.resizeDirections === d.EXyDirection.XDirection
                ? (this.x2 += this.applyPixelRatioToDragDist(
                    e.x - this.prevValue.x
                  ))
                : (this.resizeDirections === d.EXyDirection.YDirection ||
                    (this.x2 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    )),
                  (this.y2 += e.y - this.prevValue.y))
              : this.adornerDraggingPoint === v.EDraggingGripPoint.x2y1
              ? this.resizeDirections === d.EXyDirection.XDirection
                ? (this.x2 += this.applyPixelRatioToDragDist(
                    e.x - this.prevValue.x
                  ))
                : (this.resizeDirections === d.EXyDirection.YDirection ||
                    (this.x2 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    )),
                  (this.y1 += e.y - this.prevValue.y))
              : this.adornerDraggingPoint === v.EDraggingGripPoint.x1y2 &&
                (this.resizeDirections === d.EXyDirection.XDirection
                  ? (this.x1 += this.applyPixelRatioToDragDist(
                      e.x - this.prevValue.x
                    ))
                  : (this.resizeDirections === d.EXyDirection.YDirection ||
                      (this.x1 += this.applyPixelRatioToDragDist(
                        e.x - this.prevValue.x
                      )),
                    (this.y2 += e.y - this.prevValue.y)));
            const t = Math.abs(this.x2 - this.x1) / this.initialWidth;
            this.scaleOnResize && t && (this.scale = t), (this.prevValue = e);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(S.PROPERTY.STROKE);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                drawImmediate: this.drawImmediate,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                textColor: this.textColor,
                padding: this.padding,
                verticalAnchorPoint: this.verticalAnchorPoint,
                horizontalAnchorPoint: this.horizontalAnchorPoint,
                wrapTo: this.wrapTo,
                scale: this.scale,
                scaleOnResize: this.scaleOnResize,
                multiLineAlignment: this.multiLineAlignment,
                lineSpacing: this.lineSpacing,
                background: this.background,
                rotation: this.rotation,
                text: this.text,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
              x1: r,
              x2: i,
              y1: o,
              y2: a,
            } = this.getAnnotationBorders(!0);
            return (0, c.testIsInBounds)(e, t, r, a, i, o);
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              [S.PROPERTY.FILL, S.PROPERTY.OPACITY].includes(e) &&
                this.background &&
                this.fillBrushCache &&
                (0, b.createBrushInCache)(
                  this.fillBrushCache,
                  this.background,
                  this.opacity
                );
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.isSelected)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(),
                o = this.svgStringAdornerTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = m.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          drawBackground(e, t, r, i, o) {
            const l = e.getNativeContext();
            let d, h, u, c;
            switch (
              (l.PushMatrix(),
              l.Translate(i.x, i.y),
              l.Rotate(this.rotation),
              this.verticalAnchorPoint)
            ) {
              case n.EVerticalAnchorPoint.Bottom:
                (d = r + this.padding.top), (h = this.padding.bottom);
                break;
              case n.EVerticalAnchorPoint.Top:
                (d = this.padding.top), (h = r + this.padding.bottom);
                break;
              default:
                (d = r / 2 + this.padding.top),
                  (h = r / 2 + this.padding.bottom);
            }
            switch (this.horizontalAnchorPoint) {
              case n.EHorizontalAnchorPoint.Right:
                (u = t + this.padding.left), (c = this.padding.right);
                break;
              case n.EHorizontalAnchorPoint.Left:
                (u = this.padding.left), (c = t + this.padding.right);
                break;
              default:
                (u = t / 2 + this.padding.left),
                  (c = t / 2 + this.padding.right);
            }
            const p = s.Rect.createWithPoints(
                new a.Point(-u, -d),
                new a.Point(c, h)
              ),
              g = (0, b.getWebGlBrushFromCache)(this.fillBrushCache),
              y = new s.Rect(
                0,
                0,
                this.parentSurface.domCanvas2D.width,
                this.parentSurface.domCanvas2D.height
              );
            e.drawRect(p, y, o, void 0, g, !1, 0), l.PopMatrix();
          }
          svgStringAdornerTemplate(e, t, r, i) {
            let o = `<svg xmlns="http://www.w3.org/2000/svg">\n        <rect x="${e}" y="${t}" width="${
              r - e
            }" height="${i - t}" stroke="${
              this.selectionBoxStroke
            }" stroke-width="${
              this.selectionBoxThickness
            }px" fill="none" />\n        `;
            const a = this.getAdornerAnnotationBorders(!1, !0);
            return (
              this.canDragPoint(v.EDraggingGripPoint.x1y1) &&
                (o += this.getAnnotationGripSvg(a.x1, a.y1)),
              this.canDragPoint(v.EDraggingGripPoint.x2y2) &&
                (o += this.getAnnotationGripSvg(a.x2, a.y2)),
              this.canDragPoint(v.EDraggingGripPoint.x2y1) &&
                (o += this.getAnnotationGripSvg(a.x2, a.y1)),
              this.canDragPoint(v.EDraggingGripPoint.x1y2) &&
                (o += this.getAnnotationGripSvg(a.x1, a.y2)),
              (o += "</svg>"),
              o
            );
          }
        }
        t.NativeTextAnnotation = R;
      },
      12021: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OverviewCustomResizableAnnotation = void 0);
        const i = r(75772),
          o = r(86699),
          a = r(21670),
          s = r(32873),
          n = r(86127),
          l = r(31306),
          d = r(92415),
          h = r(91380),
          u = r(48882);
        class c extends u.CustomAnnotation {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.minWidthProperty = 10),
              (this.minHeightProperty = 10),
              (this.adornerSvgStringTemplateProperty =
                null !==
                  (t = null == e ? void 0 : e.adornerSvgStringTemplate) &&
                void 0 !== t
                  ? t
                  : this.adornerSvgStringTemplateProperty),
              (this.minWidthProperty =
                null !== (r = null == e ? void 0 : e.minWidth) && void 0 !== r
                  ? r
                  : this.minWidthProperty),
              (this.minHeightProperty =
                null !== (i = null == e ? void 0 : e.minHeight) && void 0 !== i
                  ? i
                  : this.minHeightProperty);
          }
          set minWidth(e) {
            (this.minWidthProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.MINIMUM_WIDTH);
          }
          get minWidth() {
            return this.minWidthProperty;
          }
          set minHeight(e) {
            (this.minHeightProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.MINIMUM_HEIGHT);
          }
          get minHeight() {
            return this.minHeightProperty;
          }
          set adornerSvgStringTemplate(e) {
            (this.adornerSvgStringTemplateProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.ADORNER_TEMPLATE);
          }
          get adornerSvgStringTemplate() {
            return this.adornerSvgStringTemplateProperty;
          }
          setCoordinates(e) {
            if (!this.parentSurface) return;
            const {
                x1: t = this.x1,
                x2: r = this.x2,
                y1: o = this.y1,
                y2: a = this.y2,
              } = e,
              s = this.getAbsoluteCoordinates(new i.Point(t, o)),
              n = this.getAbsoluteCoordinates(new i.Point(r, a)),
              l = this.xAxis,
              d = l.getCurrentCoordinateCalculator(),
              h = this.yAxis,
              u = h.getCurrentCoordinateCalculator(),
              c = l.isHorizontalAxis ? d : u,
              p = h.isHorizontalAxis ? d : u,
              g = c.hasFlippedCoordinates ? t : r,
              y = c.hasFlippedCoordinates ? r : t,
              f = p.hasFlippedCoordinates ? t : r,
              v = p.hasFlippedCoordinates ? r : t,
              m = this.isVerticalChart ? new i.Point(f, g) : new i.Point(g, f),
              S = this.isVerticalChart ? new i.Point(v, y) : new i.Point(y, v);
            l.isHorizontalAxis
              ? t - this.x1 >= this.x2 - r
                ? ((this.x2 = null != r ? r : this.x2),
                  d.hasFlippedCoordinates
                    ? this.adjustLeftSideToLimits(n.x, m, d)
                    : this.adjustRightSideToLimits(n.x, S, d))
                : ((this.x1 = null != t ? t : this.x1),
                  d.hasFlippedCoordinates
                    ? this.adjustRightSideToLimits(s.x, S, d)
                    : this.adjustLeftSideToLimits(s.x, m, d))
              : t - this.x1 >= this.x2 - r
              ? ((this.x2 = null != r ? r : this.x2),
                d.hasFlippedCoordinates
                  ? this.adjustTopSideToLimits(n.y, m, d)
                  : this.adjustBottomSideToLimits(n.y, S, d))
              : ((this.x1 = null != t ? t : this.x1),
                d.hasFlippedCoordinates
                  ? this.adjustBottomSideToLimits(s.y, S, d)
                  : this.adjustTopSideToLimits(s.y, m, d));
          }
          onDragStarted(e) {
            var t;
            e.nativeEvent.preventDefault(),
              null === (t = this.dragStarted) || void 0 === t || t.raiseEvent();
            const {
                x1: r,
                x2: n,
                y1: d,
                y2: u,
              } = this.getAnnotationBorders(!0),
              c = (0, s.translateFromCanvasToSeriesViewRect)(
                new i.Point(e.mousePoint.x, e.mousePoint.y),
                this.parentSurface.seriesViewRect,
                !0
              );
            if (!c) return !1;
            const p = (0, s.translateToNotScaled)(c.x),
              g = (0, s.translateToNotScaled)(c.y),
              y = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.XDirection
                : this.resizeDirections !== o.EXyDirection.YDirection,
              f = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.YDirection
                : this.resizeDirections !== o.EXyDirection.XDirection;
            if (y) {
              if (
                (0, a.testIsInBounds)(
                  p,
                  g,
                  r - h.ADORNER_GRIP_RADIUS,
                  u,
                  r + h.ADORNER_GRIP_RADIUS,
                  d
                )
              )
                return (
                  (this.adornerDraggingPoint = l.EDraggingGripPoint.x1y1), !0
                );
              if (
                (0, a.testIsInBounds)(
                  p,
                  g,
                  n - h.ADORNER_GRIP_RADIUS,
                  u,
                  n + h.ADORNER_GRIP_RADIUS,
                  d
                )
              )
                return (
                  (this.adornerDraggingPoint = l.EDraggingGripPoint.x2y2), !0
                );
            }
            if (f) {
              if (
                (0, a.testIsInBounds)(
                  p,
                  g,
                  r,
                  d + h.ADORNER_GRIP_RADIUS,
                  n,
                  d - h.ADORNER_GRIP_RADIUS
                )
              )
                return (
                  (this.adornerDraggingPoint = l.EDraggingGripPoint.x2y1), !0
                );
              if (
                (0, a.testIsInBounds)(
                  p,
                  g,
                  r,
                  u + h.ADORNER_GRIP_RADIUS,
                  n,
                  u - h.ADORNER_GRIP_RADIUS
                )
              )
                return (
                  (this.adornerDraggingPoint = l.EDraggingGripPoint.x1y2), !0
                );
            }
            return (
              !!this.clickToSelect(e) &&
              ((this.adornerDraggingPoint = l.EDraggingGripPoint.Body), !0)
            );
          }
          update(e, t, r, i) {
            this.create(e, t, r, i),
              (this.svg.style.display = this.isHidden ? "none" : "block"),
              (this.svg.style.opacity = this.opacity.toString());
            const o = this.getX1Coordinate(e, t),
              a = this.getY1Coordinate(e, t),
              s = this.getX2Coordinate(e, t),
              n = this.getY2Coordinate(e, t);
            if (
              (this.setAnnotationBorders(o, s, a, n),
              isNaN(o) ||
                isNaN(a) ||
                !isFinite(o) ||
                !isFinite(a) ||
                isNaN(s) ||
                isNaN(n) ||
                !isFinite(s) ||
                !isFinite(n))
            )
              this.svg.style.display = "none";
            else {
              const e = Math.abs(s - o),
                t = Math.abs(n - a),
                l = (o < s ? o : s) + r,
                d = (a < n ? a : n) + i;
              this.setSvgAttribute("x", l),
                this.setSvgAttribute("y", d),
                this.setSvgAttribute("width", e),
                this.setSvgAttribute("height", t),
                (this.svgDOMRect = this.svg.getBoundingClientRect());
            }
            this.updateAdornerInner();
          }
          calcDragDistance(e) {
            const t = this.xAxis,
              r = t.getCurrentCoordinateCalculator(),
              i = this.yAxis,
              a = i.getCurrentCoordinateCalculator(),
              s = t.isHorizontalAxis ? r : a,
              n = i.isHorizontalAxis ? r : a,
              d = this.getX1Coordinate(r, a),
              h = this.getY1Coordinate(r, a),
              u = this.getX2Coordinate(r, a),
              c = this.getY2Coordinate(r, a),
              p = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.XDirection
                : this.resizeDirections !== o.EXyDirection.YDirection,
              g = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.YDirection
                : this.resizeDirections !== o.EXyDirection.XDirection;
            switch (this.adornerDraggingPoint) {
              case l.EDraggingGripPoint.Body: {
                if (!this.prevValue) return void (this.prevValue = e);
                const r = this.x1 - (this.prevValue.x - e.x),
                  a = this.x2 - (this.prevValue.x - e.x),
                  s = this.y1 - (this.prevValue.y - e.y),
                  n = this.y2 - (this.prevValue.y - e.y);
                if (this.resizeDirections !== o.EXyDirection.YDirection)
                  if (r < t.visibleRange.min) {
                    const e = this.x1 - t.visibleRange.min;
                    (this.x1 = t.visibleRange.min), (this.x2 = this.x2 - e);
                  } else if (a > t.visibleRange.max) {
                    const e = t.visibleRange.max - this.x2;
                    (this.x1 = this.x1 + e), (this.x2 = t.visibleRange.max);
                  } else (this.x1 = r), (this.x2 = a);
                if (this.resizeDirections !== o.EXyDirection.XDirection)
                  if (n > i.visibleRange.max) {
                    const e = this.y2 - i.visibleRange.max;
                    (this.y2 = i.visibleRange.max), (this.y1 = this.y1 + e);
                  } else if (s < i.visibleRange.min) {
                    const e = this.y1 - i.visibleRange.min;
                    (this.y2 = this.y2 - e), (this.y1 = i.visibleRange.min);
                  } else (this.y1 = s), (this.y2 = n);
                this.prevValue = e;
                break;
              }
              case l.EDraggingGripPoint.x1y1:
                p &&
                  (s.hasFlippedCoordinates
                    ? this.adjustLeftSideToLimits(u, e, s)
                    : this.adjustLeftSideToLimits(d, e, s));
                break;
              case l.EDraggingGripPoint.x2y2:
                p &&
                  (s.hasFlippedCoordinates
                    ? this.adjustRightSideToLimits(d, e, s)
                    : this.adjustRightSideToLimits(u, e, s));
                break;
              case l.EDraggingGripPoint.x2y1:
                g &&
                  (n.hasFlippedCoordinates
                    ? this.adjustTopSideToLimits(c, e, n)
                    : this.adjustTopSideToLimits(h, e, n));
                break;
              case l.EDraggingGripPoint.x1y2:
                g &&
                  (n.hasFlippedCoordinates
                    ? this.adjustBottomSideToLimits(h, e, n)
                    : this.adjustBottomSideToLimits(c, e, n));
                break;
              default:
                throw new Error(
                  `Unexpected adornerDraggingPoint value ${this.adornerDraggingPoint}`
                );
            }
          }
          create(e, t, r, i) {
            if (this.svg) return;
            const o = this.applyClipping(this.svgString, this.clipping);
            this.setSvg(
              d.annotationHelpers.createSvg(o, this.svgRoot, this.nextSibling)
            );
            const a = this.svg.getBBox(),
              s = this.getX1Coordinate(e, t),
              n = this.getY1Coordinate(e, t);
            this.isVerticalChart
              ? (void 0 === this.x2 &&
                  (this.x2 = this.getValue(
                    s + a.width,
                    e,
                    l.ECoordinateMode.Pixel
                  )),
                void 0 === this.y2 &&
                  (this.y2 = this.getValue(
                    n + a.height,
                    t,
                    l.ECoordinateMode.Pixel
                  )))
              : (void 0 === this.x2 &&
                  (this.x2 = this.getValue(
                    n + a.height,
                    e,
                    l.ECoordinateMode.Pixel
                  )),
                void 0 === this.y2 &&
                  (this.y2 = this.getValue(
                    s + a.width,
                    t,
                    l.ECoordinateMode.Pixel
                  )));
            const h = this.getX2Coordinate(e, t),
              u = this.getY2Coordinate(e, t),
              c = Math.abs(h - s),
              p = Math.abs(u - n);
            if (this.isVerticalChart) {
              if (c < this.minWidth) {
                const r = this.isVerticalChart ? t : e;
                this.y2 = this.getValue(
                  s + this.minWidth,
                  r,
                  l.ECoordinateMode.Pixel
                );
              }
              if (p < this.minHeight) {
                const r = this.isVerticalChart ? e : t;
                this.x2 = this.getValue(
                  n + this.minHeight,
                  r,
                  l.ECoordinateMode.Pixel
                );
              }
            } else {
              if (c < this.minWidth) {
                const r = this.isVerticalChart ? t : e;
                this.x2 = this.getValue(
                  s + this.minWidth,
                  r,
                  l.ECoordinateMode.Pixel
                );
              }
              if (p < this.minHeight) {
                const r = this.isVerticalChart ? e : t;
                this.y2 = this.getValue(
                  n + this.minHeight,
                  r,
                  l.ECoordinateMode.Pixel
                );
              }
            }
          }
          updateAdornerInner() {
            if ((this.deleteAdorner(), this.adornerSvgStringTemplate)) {
              const {
                  x1: e,
                  x2: t,
                  y1: r,
                  y2: i,
                } = this.getAdornerAnnotationBorders(!0),
                o = this.adornerSvgStringTemplate(e, r, t, i),
                a = this.applySvgClipping(o, this.adornerClipping);
              this.svgAdorner = d.annotationHelpers.createSvg(
                a,
                this.svgAdornerRoot
              );
            }
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
                x1: r,
                x2: i,
                y1: n,
                y2: l,
              } = this.getAnnotationBorders(!0),
              d = (0, s.translateToNotScaled)(e),
              u = (0, s.translateToNotScaled)(t);
            if ((0, a.testIsInBounds)(d, u, r, l, i, n)) return !0;
            const c = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.XDirection
                : this.resizeDirections !== o.EXyDirection.YDirection,
              p = this.isVerticalChart
                ? this.resizeDirections !== o.EXyDirection.YDirection
                : this.resizeDirections !== o.EXyDirection.XDirection;
            if (c) {
              if (
                (0, a.testIsInBounds)(
                  d,
                  u,
                  r - h.ADORNER_GRIP_RADIUS,
                  l,
                  r + h.ADORNER_GRIP_RADIUS,
                  n
                )
              )
                return !0;
              if (
                (0, a.testIsInBounds)(
                  d,
                  u,
                  i - h.ADORNER_GRIP_RADIUS,
                  l,
                  i + h.ADORNER_GRIP_RADIUS,
                  n
                )
              )
                return !0;
            }
            if (p) {
              if (
                (0, a.testIsInBounds)(
                  d,
                  u,
                  r,
                  n + h.ADORNER_GRIP_RADIUS,
                  i,
                  n - h.ADORNER_GRIP_RADIUS
                )
              )
                return !0;
              if (
                (0, a.testIsInBounds)(
                  d,
                  u,
                  r,
                  l + h.ADORNER_GRIP_RADIUS,
                  i,
                  l - h.ADORNER_GRIP_RADIUS
                )
              )
                return !0;
            }
            return !1;
          }
          adjustLeftSideToLimits(e, t, r) {
            const i = this.getAbsoluteHorizontalCoordinate(
                this.isVerticalChart ? t.y : t.x
              ),
              o = p(i, r),
              a = e - o >= this.minWidth ? o : e - this.minWidth,
              s = this.convertFromCoordinate(
                a * n.DpiHelper.PIXEL_RATIO,
                r,
                this.isVerticalChart
                  ? this.yCoordinateMode
                  : this.xCoordinateMode
              );
            this.isVerticalChart
              ? r.hasFlippedCoordinates
                ? (this.y1 = s)
                : (this.y2 = s)
              : r.hasFlippedCoordinates
              ? (this.x1 = s)
              : (this.x2 = s);
          }
          adjustRightSideToLimits(e, t, r) {
            const i = this.getAbsoluteHorizontalCoordinate(
                this.isVerticalChart ? t.y : t.x
              ),
              o = p(i, r),
              a = o - e >= this.minWidth ? o : e + this.minWidth,
              s = this.convertFromCoordinate(
                a * n.DpiHelper.PIXEL_RATIO,
                r,
                this.isVerticalChart
                  ? this.yCoordinateMode
                  : this.xCoordinateMode
              );
            this.isVerticalChart
              ? r.hasFlippedCoordinates
                ? (this.y2 = s)
                : (this.y1 = s)
              : r.hasFlippedCoordinates
              ? (this.x2 = s)
              : (this.x1 = s);
          }
          adjustTopSideToLimits(e, t, r) {
            const i = this.getAbsoluteVerticalCoordinate(
                this.isVerticalChart ? t.x : t.y
              ),
              o = p(i, r),
              a = e - o >= this.minHeight ? o : e - this.minHeight,
              s = this.convertFromCoordinate(
                a * n.DpiHelper.PIXEL_RATIO,
                r,
                this.isVerticalChart
                  ? this.xCoordinateMode
                  : this.yCoordinateMode
              );
            this.isVerticalChart
              ? r.hasFlippedCoordinates
                ? (this.x1 = s)
                : (this.x2 = s)
              : r.hasFlippedCoordinates
              ? (this.y1 = s)
              : (this.y2 = s);
          }
          adjustBottomSideToLimits(e, t, r) {
            const i = this.getAbsoluteVerticalCoordinate(
                this.isVerticalChart ? t.x : t.y
              ),
              o = p(i, r),
              a = o - e >= this.minHeight ? o : e + this.minHeight,
              s = this.convertFromCoordinate(
                a * n.DpiHelper.PIXEL_RATIO,
                r,
                this.isVerticalChart
                  ? this.xCoordinateMode
                  : this.yCoordinateMode
              );
            this.isVerticalChart
              ? r.hasFlippedCoordinates
                ? (this.x2 = s)
                : (this.x1 = s)
              : r.hasFlippedCoordinates
              ? (this.y2 = s)
              : (this.y1 = s);
          }
        }
        t.OverviewCustomResizableAnnotation = c;
        const p = (e, t) =>
          e <= 0
            ? 0
            : e >= t.viewportDimension / n.DpiHelper.PIXEL_RATIO
            ? t.viewportDimension / n.DpiHelper.PIXEL_RATIO
            : e;
      },
      11396: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarArcAnnotation = void 0);
        const i = r(23866),
          o = r(19145),
          a = r(86699),
          s = r(21670),
          n = r(21915),
          l = r(98353),
          d = r(86127),
          h = r(31306),
          u = r(68955),
          c = r(91380),
          p = r(84736);
        class g extends u.ArcAnnotationBase {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = p.EAnnotationType.RenderContextPolarArcAnnotation),
              (this.surfaceTypes = [o.ESurfaceType.SciChartPolarSurfaceType]),
              (this.centerXProperty = 0),
              (this.centerYProperty = 0),
              (this.centerXProperty =
                null !== (t = null == e ? void 0 : e.centerX) && void 0 !== t
                  ? t
                  : this.centerXProperty),
              (this.centerYProperty =
                null !== (r = null == e ? void 0 : e.centerY) && void 0 !== r
                  ? r
                  : this.centerYProperty);
          }
          get centerX() {
            return this.centerXProperty;
          }
          set centerX(e) {
            (this.centerXProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.CENTER_X);
          }
          get centerY() {
            return this.centerYProperty;
          }
          set centerY(e) {
            (this.centerYProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.CENTER_Y);
          }
          drawWithContext(e, t, r, o, a, s) {
            var h, u, c, p, g, y, f, v;
            i.Guard.notNull(e, "renderContext"),
              i.Guard.notNull(t, "xCalc"),
              i.Guard.notNull(r, "yCalc");
            const m =
              this.stroke && void 0 !== this.strokeThickness
                ? (0, n.getWebGlPenFromCache)(this.strokePenCache)
                : void 0;
            let S = 0;
            const P = this.getAngleSign() * this.getX1Coordinate(t, r),
              C = this.getAngleSign() * this.getX2Coordinate(t, r),
              b = this.getY1Coordinate(t, r),
              x = this.convertPolarToCartesian(P, b, !1),
              A = this.convertPolarToCartesian(C, b, !1),
              T = this.getResolvedCoordinate(t, r, 0, 0, !0),
              E = this.getResolvedCoordinate(t, r, 0, 0, !1),
              R = this.convertPolarToCartesian(T, E, !1),
              D = this.getResolvedCoordinate(
                t,
                r,
                null !== (h = this.centerX) && void 0 !== h ? h : 0,
                null !== (u = this.centerY) && void 0 !== u ? u : 0,
                !0
              ),
              w = this.getResolvedCoordinate(
                t,
                r,
                null !== (c = this.centerX) && void 0 !== c ? c : 0,
                null !== (p = this.centerY) && void 0 !== p ? p : 0,
                !1
              ),
              M = this.convertPolarToCartesian(D, w, !1),
              L = M.x - R.x,
              O = M.y - R.y;
            S = this.isVerticalChart
              ? this.yAxis.startAngle
              : this.xAxis.startAngle;
            const I = e.webAssemblyContext,
              k = (0, l.getVectorArcVertex)(I),
              _ = (0, l.getArcVertex)(I),
              V =
                (null !==
                  (y =
                    null === (g = this.parentSurface.padding) || void 0 === g
                      ? void 0
                      : g.left) && void 0 !== y
                  ? y
                  : 0) * d.DpiHelper.PIXEL_RATIO,
              N =
                (null !==
                  (v =
                    null === (f = this.parentSurface.padding) || void 0 === f
                      ? void 0
                      : f.top) && void 0 !== v
                  ? v
                  : 0) * d.DpiHelper.PIXEL_RATIO,
              B = this.transformAngles(
                P,
                C,
                this.isVerticalChart,
                t.isFlipped,
                r.isFlipped
              ),
              { startAngle: F, endAngle: H } = this.normalizeAnglesAndHitTest(
                B.startAngle,
                B.endAngle
              ),
              Y = M.x,
              z = this.getViewportHeight() - M.y;
            _.MakeCircularArc(
              Y,
              z,
              F,
              H,
              this.getRadius(t, r),
              this.getInnerRadius(t, r),
              this.getDrawMode() ? 1 : 0,
              1
            ),
              k.push_back(_);
            const j = this.getClippingRect(this.clipping, o, a, s);
            e.drawArcs(k, Y, z, S, j, m.scrtPen, this.getBrush(), V, N),
              this.setArcAnnotationBorders(
                x.x + L,
                A.x + L,
                M.x,
                x.y + O,
                A.y + O,
                M.y
              ),
              this.updateAdornerInner();
          }
          calcDragDistance(e) {
            const t = this.xAxis,
              r = this.yAxis;
            this.prevValue
              ? (this.adornerDraggingPoint === h.EDraggingGripPoint.Body
                  ? (this.resizeDirections !== a.EXyDirection.YDirection &&
                      ((this.x1 =
                        this.x1 -
                        this.multByPixelRatio(this.prevValue.x - e.x, t)),
                      (this.x2 =
                        this.x2 -
                        this.multByPixelRatio(this.prevValue.x - e.x, t))),
                    this.resizeDirections !== a.EXyDirection.XDirection &&
                      ((this.y1 =
                        this.y1 -
                        this.multByPixelRatio(this.prevValue.y - e.y, r)),
                      (this.y2 =
                        this.y2 -
                        this.multByPixelRatio(this.prevValue.y - e.y, r))))
                  : this.adornerDraggingPoint === h.EDraggingGripPoint.x1y1
                  ? (this.resizeDirections !== a.EXyDirection.YDirection &&
                      (this.x1 -= this.multByPixelRatio(
                        this.prevValue.x - e.x,
                        t
                      )),
                    this.resizeDirections !== a.EXyDirection.XDirection &&
                      (this.y1 -= this.multByPixelRatio(
                        this.prevValue.y - e.y,
                        r
                      )))
                  : this.adornerDraggingPoint === h.EDraggingGripPoint.x2y2 &&
                    (this.resizeDirections !== a.EXyDirection.YDirection &&
                      (this.x2 -= this.multByPixelRatio(
                        this.prevValue.x - e.x,
                        t
                      )),
                    this.resizeDirections !== a.EXyDirection.XDirection &&
                      (this.y2 -= this.multByPixelRatio(
                        this.prevValue.y - e.y,
                        r
                      ))),
                this.adornerDraggingPoint === h.EDraggingGripPoint.x3y3 &&
                  ((this.centerX = this.multByPixelRatio(e.x, t, !0)),
                  (this.centerY = this.multByPixelRatio(e.y, r, !0))),
                this.validateInnerRadius(),
                (this.prevValue = e))
              : (this.prevValue = e);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { centerX: this.centerX, centerY: this.centerY };
            return Object.assign(e.options, t), e;
          }
          onDragStarted(e) {
            super.onDragStarted(e);
            const {
                x1: t,
                x2: r,
                xCenter: i,
                y1: o,
                y2: a,
                yCenter: n,
              } = this.getArcAnnotationBorders(!0),
              l = e.mousePoint.x,
              u = e.mousePoint.y;
            if (
              this.canDragPoint(h.EDraggingGripPoint.x1y1) &&
              (0, s.calcDistance)(t, o, l, u) <
                this.annotationsGripsRadius * d.DpiHelper.PIXEL_RATIO
            )
              return (
                (this.adornerDraggingPoint = h.EDraggingGripPoint.x1y1), !0
              );
            if (this.canDragPoint(h.EDraggingGripPoint.x2y2)) {
              const e = (r + i) / 2,
                t = (a + n) / 2;
              if (
                (0, s.calcDistance)(e, t, l, u) <
                this.annotationsGripsRadius * d.DpiHelper.PIXEL_RATIO
              )
                return (
                  (this.adornerDraggingPoint = h.EDraggingGripPoint.x2y2), !0
                );
            }
            return this.canDragPoint(h.EDraggingGripPoint.x3y3) &&
              (0, s.calcDistance)(i, n, l, u) <
                this.annotationsGripsRadius * d.DpiHelper.PIXEL_RATIO
              ? ((this.adornerDraggingPoint = h.EDraggingGripPoint.x3y3), !0)
              : !(
                  !this.canDragPoint(h.EDraggingGripPoint.Body) ||
                  !this.clickToSelect(e) ||
                  ((this.adornerDraggingPoint = h.EDraggingGripPoint.Body), 0)
                );
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            const {
              x1: r,
              x2: i,
              y1: o,
              y2: a,
              xCenter: n,
              yCenter: l,
            } = this.getArcAnnotationBorders();
            if (
              (0, s.calcDistance)(e, t, r, o) <=
              c.DISTANCE_TO_LINE * d.DpiHelper.PIXEL_RATIO
            )
              return !0;
            if (
              (0, s.calcDistance)(e, t, i, a) <=
              c.DISTANCE_TO_LINE * d.DpiHelper.PIXEL_RATIO
            )
              return !0;
            if ((0, s.calcDistance)(e, t, n, l) <= c.DISTANCE_TO_LINE)
              return !0;
            const h = (0, s.calcDistance)(r, o, n, l),
              u = (0, s.calcDistance)(e, t, n, l) < h,
              { startAngle: p, endAngle: g } = this.transformAngles(
                this.calcAngleFromCoordinates(n, l, r, o),
                this.calcAngleFromCoordinates(n, l, i, a),
                this.isVerticalChart,
                this.xAxis.getCurrentCoordinateCalculator().isFlipped,
                this.yAxis.getCurrentCoordinateCalculator().isFlipped
              ),
              y = this.calcAngleFromCoordinates(n, l, e, t),
              { isHit: f } = this.normalizeAnglesAndHitTest(p, g, y),
              v = u && f,
              m = (0, s.testPointInTriangle)(e, t, r, o, i, a, n, l);
            return v || m;
          }
          svgStringArcAdornerTemplate(e, t, r, i, o, a) {
            const s = this.selectionBoxStroke,
              n = (r + o) / 2,
              l = (i + a) / 2;
            return `<svg xmlns="http://www.w3.org/2000/svg">\n    <line x1="${e}" y1="${t}" x2="${r}" y2="${i}" stroke="${s}" stroke-width="6" />\n    <line x1="${e}" y1="${t}" x2="${o}" y2="${a}" stroke="${s}" stroke-width="6" />\n    <line x1="${o}" y1="${a}" x2="${r}" y2="${i}" stroke="${s}" stroke-width="6" />\n    ${
              this.canDragPoint(h.EDraggingGripPoint.x1y1)
                ? this.getAnnotationGripSvg(e, t)
                : ""
            }\n    ${
              this.canDragPoint(h.EDraggingGripPoint.x2y2)
                ? this.getAnnotationGripSvg(n, l)
                : ""
            }\n    ${this.getAnnotationGripSvg(o, a)}\n    </svg>`;
          }
          getRadius(e, t) {
            return this.getY1Coordinate(e, t);
          }
          getInnerRadius(e, t) {
            return this.isLineMode ? 0 : this.getY2Coordinate(e, t);
          }
          calcAngleFromCoordinates(e, t, r, i) {
            return -Math.atan2(i - t, r - e);
          }
          transformAngles(e, t, r, i, o) {
            const a = this.isDataValueMode() ? e : e / d.DpiHelper.PIXEL_RATIO,
              s = this.isDataValueMode() ? t : t / d.DpiHelper.PIXEL_RATIO;
            if (r) {
              if (o) return { startAngle: s, endAngle: a };
            } else if (i) return { startAngle: s, endAngle: a };
            return { startAngle: a, endAngle: s };
          }
          multByPixelRatio(e, t, r = !1) {
            if (t.isAngular && !this.isDataValueMode()) {
              let i = 1;
              return (
                !r && t.getCurrentCoordinateCalculator().isFlipped && (i = -1),
                i * d.DpiHelper.PIXEL_RATIO * e
              );
            }
            return e;
          }
          validateInnerRadius() {
            this.isVerticalChart
              ? this.x1 < this.x2 && (this.x2 = this.x1)
              : this.y1 < this.y2 && (this.y2 = this.y1);
          }
          getAngleSign() {
            if (this.isDataValueMode()) return 1;
            {
              const e = this.xAxis;
              return e.isAngular
                ? e.getCurrentCoordinateCalculator().isFlipped
                  ? -1
                  : 1
                : this.yAxis.getCurrentCoordinateCalculator().isFlipped
                ? -1
                : 1;
            }
          }
        }
        t.PolarArcAnnotation = g;
      },
      26977: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarPointerAnnotation = void 0);
        const i = r(60986),
          o = r(44431),
          a = r(19145),
          s = r(86127),
          n = r(31306),
          l = r(92415),
          d = r(91380),
          h = r(84736),
          u = r(84690);
        class c extends u.SvgAnnotationBase {
          constructor(e) {
            var t,
              r,
              i,
              s,
              n,
              l,
              d,
              u,
              c,
              p,
              g,
              y,
              f,
              v,
              m,
              S,
              P,
              C,
              b,
              x,
              A,
              T,
              E,
              R,
              D,
              w,
              M,
              L,
              O,
              I,
              k,
              _;
            super(e),
              (this.type = h.EAnnotationType.SVGPolarPointerAnnotation),
              (this.surfaceTypes = [a.ESurfaceType.SciChartPolarSurfaceType]),
              (this.isDirty = !0),
              (this.isStrokeAboveCenterProperty = !1),
              (this.strokeLineJoinProperty = o.EStrokeLineJoin.Round),
              (this.getPointerStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r),
                    (this.isDirty = !0),
                    this.notifyPropertyChanged("pointerStyle"),
                    !0
                  ),
                })),
              (this.getPointerCenterStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r),
                    (this.isDirty = !0),
                    this.notifyPropertyChanged("pointerCenterStyle"),
                    !0
                  ),
                })),
              (this.getPointerArrowStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r),
                    (this.isDirty = !0),
                    this.notifyPropertyChanged("pointerArrowStyle"),
                    !0
                  ),
                })),
              (this.strokeLineJoinProperty =
                null !== (t = null == e ? void 0 : e.strokeLineJoin) &&
                void 0 !== t
                  ? t
                  : this.strokeLineJoinProperty),
              (this.isStrokeAboveCenterProperty =
                null !== (r = null == e ? void 0 : e.isStrokeAboveCenter) &&
                void 0 !== r
                  ? r
                  : this.isStrokeAboveCenterProperty),
              (this.pointerStyleProperty = this.getPointerStyleProxy({
                baseSize:
                  null !==
                    (s =
                      null === (i = null == e ? void 0 : e.pointerStyle) ||
                      void 0 === i
                        ? void 0
                        : i.baseSize) && void 0 !== s
                    ? s
                    : 0.1,
                stroke:
                  null !==
                    (l =
                      null === (n = null == e ? void 0 : e.pointerStyle) ||
                      void 0 === n
                        ? void 0
                        : n.stroke) && void 0 !== l
                    ? l
                    : "black",
                strokeWidth:
                  null !==
                    (u =
                      null === (d = null == e ? void 0 : e.pointerStyle) ||
                      void 0 === d
                        ? void 0
                        : d.strokeWidth) && void 0 !== u
                    ? u
                    : 3,
                fill:
                  null !==
                    (p =
                      null === (c = null == e ? void 0 : e.pointerStyle) ||
                      void 0 === c
                        ? void 0
                        : c.fill) && void 0 !== p
                    ? p
                    : "gray",
                backExtensionSize:
                  null !==
                    (y =
                      null === (g = null == e ? void 0 : e.pointerStyle) ||
                      void 0 === g
                        ? void 0
                        : g.backExtensionSize) && void 0 !== y
                    ? y
                    : 0,
              })),
              (this.pointerCenterStyleProperty =
                this.getPointerCenterStyleProxy({
                  size:
                    null !==
                      (v =
                        null ===
                          (f = null == e ? void 0 : e.pointerCenterStyle) ||
                        void 0 === f
                          ? void 0
                          : f.size) && void 0 !== v
                      ? v
                      : 0,
                  stroke:
                    null !==
                      (S =
                        null ===
                          (m = null == e ? void 0 : e.pointerCenterStyle) ||
                        void 0 === m
                          ? void 0
                          : m.stroke) && void 0 !== S
                      ? S
                      : "black",
                  strokeWidth:
                    null !==
                      (C =
                        null ===
                          (P = null == e ? void 0 : e.pointerCenterStyle) ||
                        void 0 === P
                          ? void 0
                          : P.strokeWidth) && void 0 !== C
                      ? C
                      : 3,
                  fill:
                    null !==
                      (x =
                        null ===
                          (b = null == e ? void 0 : e.pointerCenterStyle) ||
                        void 0 === b
                          ? void 0
                          : b.fill) && void 0 !== x
                      ? x
                      : "gray",
                })),
              (this.pointerArrowStyleProperty = this.getPointerArrowStyleProxy({
                height:
                  null !==
                    (T =
                      null === (A = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === A
                        ? void 0
                        : A.height) && void 0 !== T
                    ? T
                    : 0,
                width:
                  null !==
                    (R =
                      null === (E = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === E
                        ? void 0
                        : E.width) && void 0 !== R
                    ? R
                    : 0,
                headDepth:
                  null !==
                    (w =
                      null === (D = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === D
                        ? void 0
                        : D.headDepth) && void 0 !== w
                    ? w
                    : 1,
                stroke:
                  null !==
                    (L =
                      null === (M = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === M
                        ? void 0
                        : M.stroke) && void 0 !== L
                    ? L
                    : "black",
                strokeWidth:
                  null !==
                    (I =
                      null === (O = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === O
                        ? void 0
                        : O.strokeWidth) && void 0 !== I
                    ? I
                    : 3,
                fill:
                  null !==
                    (_ =
                      null === (k = null == e ? void 0 : e.pointerArrowStyle) ||
                      void 0 === k
                        ? void 0
                        : k.fill) && void 0 !== _
                    ? _
                    : "none",
              }));
          }
          get pointerStyle() {
            return this.pointerStyleProperty;
          }
          set pointerStyle(e) {
            const t = Object.assign(Object.assign({}, this.pointerStyle), e);
            (this.pointerStyleProperty = this.getPointerStyleProxy(t)),
              (this.isDirty = !0),
              this.notifyPropertyChanged("pointerStyle");
          }
          get pointerCenterStyle() {
            return this.pointerCenterStyleProperty;
          }
          set pointerCenterStyle(e) {
            const t = Object.assign(
              Object.assign({}, this.pointerCenterStyle),
              e
            );
            (this.pointerCenterStyleProperty =
              this.getPointerCenterStyleProxy(t)),
              (this.isDirty = !0),
              this.notifyPropertyChanged("pointerCenterStyle");
          }
          get pointerArrowStyle() {
            return this.pointerArrowStyleProperty;
          }
          set pointerArrowStyle(e) {
            const t = Object.assign(
              Object.assign({}, this.pointerArrowStyle),
              e
            );
            (this.pointerArrowStyleProperty =
              this.getPointerArrowStyleProxy(t)),
              (this.isDirty = !0),
              this.notifyPropertyChanged("pointerArrowStyle");
          }
          get horizontalAnchorPoint() {
            return i.EHorizontalAnchorPoint.Center;
          }
          get verticalAnchorPoint() {
            return i.EVerticalAnchorPoint.Center;
          }
          get isStrokeAboveCenter() {
            return this.isStrokeAboveCenterProperty;
          }
          set isStrokeAboveCenter(e) {
            this.isStrokeAboveCenterProperty !== e &&
              ((this.isStrokeAboveCenterProperty = e),
              (this.isDirty = !0),
              this.notifyPropertyChanged("isStrokeAboveCenter"));
          }
          get strokeLineJoin() {
            return this.strokeLineJoinProperty;
          }
          set strokeLineJoin(e) {
            this.strokeLineJoinProperty !== e &&
              ((this.strokeLineJoinProperty = e),
              (this.isDirty = !0),
              this.notifyPropertyChanged("strokeLineJoin"));
          }
          getAngularAxis() {
            const e = this.xAxis,
              t = this.yAxis;
            return e.isAngular ? e : t;
          }
          getRadialAxis() {
            const e = this.xAxis,
              t = this.yAxis;
            return e.isAngular ? t : e;
          }
          getSvgString(e) {
            const t = this.getAngularAxis(),
              r = this.getRadialAxis(),
              { axisSize: i, startAngle: o, direction: a } = this.getState();
            let d, h;
            (d =
              this.yCoordinateMode === n.ECoordinateMode.Relative
                ? this.y1 * i
                : this.yCoordinateMode === n.ECoordinateMode.DataValue
                ? r.getCurrentCoordinateCalculator().getCoordinate(this.y1) /
                  s.DpiHelper.PIXEL_RATIO
                : this.y1),
              (h =
                this.xCoordinateMode === n.ECoordinateMode.DataValue
                  ? o +
                    t.getCurrentCoordinateCalculator().getCoordinate(this.x1)
                  : o + a * this.x1);
            const u = this.parentSurface,
              c = l.annotationHelpers.convertPolarToCartesian(
                t,
                !0,
                u.webAssemblyContext2D,
                n.ECoordinateMode.DataValue,
                0,
                0
              );
            this.state = {
              axisSize: i,
              startAngle: o,
              direction: a,
              seriesViewRect: u.seriesViewRect,
            };
            const p = (-180 * h) / Math.PI,
              g = this.pointerStyleProperty.baseSize * d,
              y = this.pointerCenterStyleProperty.size * d,
              f = this.pointerArrowStyleProperty.height * d,
              v = this.pointerArrowStyleProperty.width * d,
              m = this.getPointerStickSvg(
                d,
                g,
                this.pointerStyleProperty.backExtensionSize
              ),
              S = this.getPointerCenterSvg(d, y),
              P = this.getPointerArrowSvg(
                d,
                f,
                v,
                this.pointerArrowStyleProperty.headDepth
              ),
              C = this.isStrokeAboveCenterProperty ? S + m + P : m + P + S,
              b = c.x + u.seriesViewRect.left / s.DpiHelper.PIXEL_RATIO - d,
              x = c.y + u.seriesViewRect.top / s.DpiHelper.PIXEL_RATIO - d,
              { width: A, height: T } = u.viewRect,
              E = A / s.DpiHelper.PIXEL_RATIO,
              R = T / s.DpiHelper.PIXEL_RATIO;
            return `<svg height="${R}" width="${E}" viewBox="0 0 ${E} ${R}">\n            <g id="pointer" style="padding:100;" transform="translate(${b} ${x}) rotate(${p} ${d} ${d})">\n                ${C}\n            </g>\n        </svg>`;
          }
          getPointerStickSvg(e, t, r) {
            const i = 2 * e;
            return `<path stroke-linejoin=${
              this.strokeLineJoinProperty
            }\n            d="\n                M${
              i - 7
            } ${e}\n                L${e - e * r} ${
              e - t / 2
            }\n                l0 ${t}\n                L${
              i - 7
            } ${e}Z\n            " \n            fill="${
              this.pointerStyleProperty.fill
            }"\n            stroke="${
              this.pointerStyleProperty.stroke
            }"  \n            stroke-width="${
              this.pointerStyleProperty.strokeWidth
            }"\n        />`;
          }
          getPointerCenterSvg(e, t) {
            return `<rect\n            x="${e - t / 2}" \n            y="${
              e - t / 2
            }"\n            width=${t} \n            height=${t}\n            rx=${
              t / 2
            }\n            ry=${t / 2}\n            stroke=${
              this.pointerCenterStyleProperty.stroke
            }\n            stroke-width=${
              this.pointerCenterStyleProperty.strokeWidth
            }\n            fill=${
              this.pointerCenterStyleProperty.fill
            }\n        />`;
          }
          getPointerArrowSvg(e, t, r, i) {
            const o = 2 * e;
            return `<path \n            stroke="${
              this.pointerArrowStyleProperty.stroke
            }"\n            stroke-width="${
              this.pointerArrowStyleProperty.strokeWidth
            }"\n            fill="${
              this.pointerArrowStyleProperty.fill
            }"\n            stroke-linejoin=${
              this.strokeLineJoinProperty
            }\n            d="\n                M${o - t / 2 - 5} ${
              e - r / 2
            }\n                l${t / 2} ${r / 2}\n                l-${t / 2} ${
              r / 2
            }\n                ${
              0 === i
                ? ""
                : `\n                    l${((1 - i) * t) / 2} ${
                    -r / 2
                  }\n                    l${(-(1 - i) * t) / 2} ${
                    -r / 2
                  }Z\n                `
            }\n            " \n        />`;
          }
          notifyPropertyChanged(e) {
            (e !== d.PROPERTY.X_COORDINATE_MODE &&
              e !== d.PROPERTY.Y_COORDINATE_MODE &&
              e !== d.PROPERTY.X1 &&
              e !== d.PROPERTY.Y1) ||
              (this.isDirty = !0),
              super.notifyPropertyChanged(e);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                isStrokeAboveCenter: this.isStrokeAboveCenter,
                pointerArrowStyle: this.pointerArrowStyle,
                pointerCenterStyle: this.pointerCenterStyle,
                pointerStyle: this.pointerStyle,
                strokeLineJoin: this.strokeLineJoin,
              };
            return Object.assign(e.options, t), e;
          }
          getX1Coordinate(e, t) {
            return 0;
          }
          getY1Coordinate(e, t) {
            return 0;
          }
          getState() {
            const e = this.getAngularAxis(),
              t = this.getRadialAxis().getAxisSize(),
              r = e.flippedCoordinates ? -1 : 1;
            return {
              axisSize: t,
              startAngle: e.startAngle,
              direction: r,
              seriesViewRect: this.parentSurface.seriesViewRect,
            };
          }
          create(e, t, r, i) {
            const {
              axisSize: o,
              startAngle: a,
              direction: s,
              seriesViewRect: n,
            } = this.getState();
            if (
              ((this.state &&
                o === this.state.axisSize &&
                a === this.state.startAngle &&
                s === this.state.direction &&
                n === this.state.seriesViewRect) ||
                (this.isDirty = !0),
              !this.svg || this.isEditable || this.isDirty)
            ) {
              if (this.isDirty || !this.svg || (this.svg && this.isSelected)) {
                this.svg && this.clear();
                let r = l.annotationHelpers.createSvg(
                  this.getSvgString(this),
                  this.svgRoot,
                  this.nextSibling
                );
                this.setSvg(r),
                  this.calcAndSetAnnotationBorders(e, t),
                  this.updateAdornerInner(),
                  (this.prevIsSelected = this.isSelected),
                  (this.isDirty = !1);
              } else this.calcAndSetAnnotationBorders(e, t);
              this.prevIsSelected !== this.isSelected &&
                this.svg &&
                this.isEditable &&
                (this.updateAdornerInner(),
                (this.prevIsSelected = this.isSelected));
            } else this.calcAndSetAnnotationBorders(e, t);
          }
        }
        t.PolarPointerAnnotation = c;
      },
      29530: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RenderContextAnnotationBase = void 0);
        const i = r(31306),
          o = r(91380);
        class a extends i.AnnotationBase {
          constructor(e) {
            super(e), (this.isSvgAnnotation = !1), (this.isDomAnnotation = !1);
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          set parentSurface(e) {
            this.parentSurfaceProperty !== e &&
              ((this.parentSurfaceProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.PARENT_SURFACE));
          }
        }
        t.RenderContextAnnotationBase = a;
      },
      69302: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RolloverLegendSvgAnnotation = void 0);
        const i = r(92415),
          o = r(91380),
          a = r(84736),
          s = r(84690);
        class n extends s.SvgAnnotationBase {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type = a.EAnnotationType.SVG),
              (this.seriesInfosProperty = []),
              (this.tooltipLegendTemplateProperty =
                null !== (t = null == e ? void 0 : e.tooltipLegendTemplate) &&
                void 0 !== t
                  ? t
                  : this.tooltipLegendTemplateProperty),
              (this.tooltipLegendOffsetXProperty =
                null !== (r = null == e ? void 0 : e.tooltipLegendOffsetX) &&
                void 0 !== r
                  ? r
                  : this.tooltipLegendOffsetXProperty),
              (this.tooltipLegendOffsetYProperty =
                null !== (i = null == e ? void 0 : e.tooltipLegendOffsetY) &&
                void 0 !== i
                  ? i
                  : this.tooltipLegendOffsetYProperty);
          }
          get seriesInfos() {
            return this.seriesInfosProperty;
          }
          set seriesInfos(e) {
            this.seriesInfosProperty &&
              e &&
              (e.length !== this.seriesInfosProperty.length ||
                this.seriesInfosProperty
                  .map((t) =>
                    t.equals(
                      e.find(
                        (e) => e.renderableSeries.id === t.renderableSeries.id
                      )
                    )
                  )
                  .some((e) => !1 === e)) &&
              ((this.seriesInfosProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.SERIES_INFOS));
          }
          get tooltipLegendTemplate() {
            return this.tooltipLegendTemplateProperty;
          }
          set tooltipLegendTemplate(e) {
            (this.tooltipLegendTemplateProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.TOOLTIP_LEGEND_TEMPLATE);
          }
          get tooltipLegendOffsetX() {
            return this.tooltipLegendOffsetXProperty;
          }
          set tooltipLegendOffsetX(e) {
            (this.tooltipLegendOffsetXProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.TOOLTIP_LEGEND_OFFSET_X);
          }
          get tooltipLegendOffsetY() {
            return this.tooltipLegendOffsetYProperty;
          }
          set tooltipLegendOffsetY(e) {
            (this.tooltipLegendOffsetYProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.TOOLTIP_LEGEND_OFFSET_Y);
          }
          update(e, t, r, i) {
            this.tooltipLegendTemplate &&
              (this.svg && this.delete(), this.create(e, t, r, i));
          }
          create(e, t, r, o) {
            const a = this.tooltipLegendTemplate(this.seriesInfos, this),
              s = this.applyClipping(a, this.clipping),
              n = i.annotationHelpers.createSvg(
                s,
                this.svgRoot,
                this.nextSibling
              );
            this.setSvg(n),
              this.setSvgAttribute("x", this.tooltipLegendOffsetX + r),
              this.setSvgAttribute("y", this.tooltipLegendOffsetY + o);
          }
        }
        t.RolloverLegendSvgAnnotation = n;
      },
      66443: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RolloverMarkerSvgAnnotation = void 0);
        const i = r(57935),
          o = r(92415),
          a = r(84736),
          s = r(84690);
        class n extends s.SvgAnnotationBase {
          constructor(e) {
            super(),
              (this.type = a.EAnnotationType.SVG),
              (this.tooltipProps = e),
              (this.isHiddenProperty = !0),
              (this.x1 = 0),
              (this.y1 = 0),
              (this.xCoordShift = -4),
              (this.yCoordShift = -4);
          }
          update(e, t, r, o) {
            const a = this.tooltipProps.rolloverModifier.getMousePosition();
            (this.previousMousePosition === a &&
              a !== i.EMousePosition.SeriesArea) ||
              ((this.previousMousePosition =
                this.tooltipProps.rolloverModifier.getMousePosition()),
              super.update(e, t, r, o));
          }
          create(e, t, r, i) {
            const { tooltipColor: a, markerColor: s } = this.tooltipProps,
              n = null != s ? s : a;
            if (
              (this.svg && this.currentColor !== n && this.clear(), !this.svg)
            ) {
              this.currentColor;
              const e = l(n),
                t = this.applyClipping(e, this.clipping),
                r = o.annotationHelpers.createSvg(
                  t,
                  this.svgRoot,
                  this.nextSibling
                );
              this.setSvg(r);
            }
          }
        }
        t.RolloverMarkerSvgAnnotation = n;
        const l = (e) =>
          `<svg width="8" height="8"><circle cx="50%" cy="50%" r="4" fill="${e}"/></svg>`;
      },
      60915: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RolloverTooltipSvgAnnotation = void 0);
        const i = r(57935),
          o = r(31306),
          a = r(92415),
          s = r(91380),
          n = r(84736),
          l = r(84690),
          d = r(48008);
        class h extends l.SvgAnnotationBase {
          constructor(e, t) {
            var r, i;
            super(t),
              (this.type = n.EAnnotationType.SVG),
              (this.width = 0),
              (this.height = 0),
              (this.tooltipProps = e),
              (this.height =
                null !== (r = null == t ? void 0 : t.height) && void 0 !== r
                  ? r
                  : this.height),
              (this.xCoordinateMode = o.ECoordinateMode.DataValue),
              (this.yCoordinateMode = o.ECoordinateMode.DataValue),
              (this.isHidden = !0),
              (this.updateSize = this.updateSize.bind(this)),
              (this.placementDivIdProperty =
                null !== (i = null == t ? void 0 : t.placementDivId) &&
                void 0 !== i
                  ? i
                  : this.placementDivIdProperty);
          }
          get seriesInfo() {
            return this.seriesInfoProperty;
          }
          set seriesInfo(e) {
            ((e && !this.seriesInfoProperty) ||
              !this.seriesInfoProperty.equals(e)) &&
              ((this.seriesInfoProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.SERIES_INFO));
          }
          update(e, t, r, o) {
            const a = this.tooltipProps.rolloverModifier.getMousePosition();
            (this.previousMousePosition === a &&
              a !== i.EMousePosition.SeriesArea) ||
              ((this.previousMousePosition =
                this.tooltipProps.rolloverModifier.getMousePosition()),
              this.svg && this.clear(),
              this.placementDivId
                ? this.updateExternalLegendTooltip()
                : (super.update(e, t, r, o), this.updateLegendTooltip(r, o)));
          }
          updateSize(e, t) {
            (this.width = e), (this.height = t);
          }
          clear() {
            var e, t, r, i;
            if (this.parentSurface && !this.parentSurface.isDeleted) {
              if (this.svg) {
                if (this.placementDivId)
                  return void (
                    null ===
                      (t =
                        null === (e = this.svg) || void 0 === e
                          ? void 0
                          : e.parentNode) ||
                    void 0 === t ||
                    t.removeChild(this.svg)
                  );
                null === (r = this.svgRoot) ||
                  void 0 === r ||
                  r.removeChild(this.svg);
              }
              this.svgLegend &&
                (null === (i = this.svgLegend.parentNode) ||
                  void 0 === i ||
                  i.removeChild(this.svgLegend));
            }
          }
          create(e, t, r, i) {
            let o;
            o = this.seriesInfo ? this.generateSvgString() : "<svg></svg>";
            const s = this.applyClipping(o, this.clipping),
              n = a.annotationHelpers.createSvg(
                s,
                this.svgRoot,
                this.nextSibling
              );
            this.setSvg(n);
          }
          generateSvgString() {
            var e;
            const { tooltipTitle: t } = this.tooltipProps,
              r = ("" + t).replace(/\s/g, ""),
              i = `id${Math.floor(this.y1)}_${r}_${Date.now()}`;
            return (
              null !== (e = this.tooltipProps.tooltipTemplate) && void 0 !== e
                ? e
                : c
            )(i, this.seriesInfo, this);
          }
          updateLegendTooltip(e, t) {
            if (this.tooltipProps.tooltipLegendTemplate) {
              const r = this.seriesInfo
                  ? this.tooltipProps.tooltipLegendTemplate(
                      this.tooltipProps,
                      this.seriesInfo
                    )
                  : "<svg></svg>",
                i = this.applyClipping(r, this.clipping),
                o = a.annotationHelpers.createSvg(
                  i,
                  this.svgRoot,
                  this.nextSibling
                );
              (this.svgLegend = o),
                this.svgLegend.setAttribute(
                  "x",
                  this.tooltipProps.tooltipLegendOffsetX.toString() + e
                ),
                this.svgLegend.setAttribute(
                  "y",
                  this.tooltipProps.tooltipLegendOffsetY.toString() + t
                );
            }
          }
          updateExternalLegendTooltip() {
            let e;
            (e = this.seriesInfo
              ? this.generateSvgString()
              : "<svg style='display: none;'></svg>"),
              (this.svgDivRoot = document.querySelector(
                `[id='${this.placementDivId}']`
              ));
            const t = this.applyClipping(e, this.clipping),
              r = a.annotationHelpers.createSvg(
                t,
                this.svgDivRoot,
                this.nextSibling
              );
            this.setSvg(r);
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.placementDivIdProperty !== e &&
              ((this.placementDivIdProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.PLACEMENT_DIV_ID));
          }
        }
        t.RolloverTooltipSvgAnnotation = h;
        const u = (e, t, r, i) => e.getValuesWithLabels(t, r, i, !0),
          c = (e, t, r) => {
            var i, o, a, s, n;
            let l = "";
            const h = r.tooltipProps,
              {
                tooltipTitle: c,
                tooltipColor: y,
                tooltipTextColor: f,
                tooltipLabelX: v,
                tooltipLabelY: m,
                shadowColor: S,
              } = h,
              P = (
                null !==
                  (a =
                    null !== (i = r.tooltipProps.tooltipDataTemplate) &&
                    void 0 !== i
                      ? i
                      : null === (o = r.tooltipProps.rolloverModifier) ||
                        void 0 === o
                      ? void 0
                      : o.tooltipDataTemplate) && void 0 !== a
                  ? a
                  : u
              )(t, c, v, m),
              C =
                null !== (s = h.width) && void 0 !== s
                  ? s
                  : p(P.reduce((e, t) => (t.length > e ? t.length : e), 0)),
              b = null !== (n = h.height) && void 0 !== n ? n : g(P.length);
            r.updateSize(C, b),
              P.forEach((e, t) => {
                l += `<tspan x="8" dy="1.2em">${e}</tspan>`;
              });
            let x =
              '<feGaussianBlur result="blurOut" in="offOut" stdDeviation="3" />';
            if (void 0 !== S) {
              const e = (0, d.parseColorToTArgb)(S);
              x = `<feColorMatrix result="matrixOut" in="offOut" type="matrix"\n        values="0 0 0 0 ${
                e.red / 255
              }\n                0 0 0 0 ${
                e.green / 255
              }\n                0 0 0 0 ${
                e.blue / 255
              }\n                0 0 0 ${
                e.opacity / 255
              } 0" />\n        <feGaussianBlur result="blurOut" in="matrixOut" stdDeviation="3" />`;
            }
            return `<svg class="scichart__rollover-tooltip" width="${C}" height="${b}">\n        <defs>\n            <filter id="${e}" x="0" y="0" width="200%" height="200%">\n                <feOffset result="offOut" in="SourceAlpha" dx="3" dy="3" />\n                ${x}\n                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />\n            </filter>\n        </defs>\n        <rect rx="4" ry="4" width="90%" height="90%" fill="${y}" filter="url(#${e})" />\n        <svg width="100%">\n            <text x="8" y="3" font-size="13" font-family="Verdana" dy="0" fill="${f}">${l}</text>\n        </svg>\n    </svg>`;
          },
          p = (e = 20, t = 13) => 8 * e + 20,
          g = (e = 2, t = 13) => 17 * e + 16;
      },
      84690: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SvgAnnotationBase = void 0);
        const i = r(60986),
          o = r(91380),
          a = r(75704),
          s = r(84736);
        class n extends a.DomAnnotationBase {
          constructor(e) {
            super(e), (this.isSvgAnnotation = !0);
          }
          onDetach() {
            super.onDetach(), this.delete();
          }
          update(e, t, r, o) {
            var a, s;
            this.create(e, t, r, o);
            let n = null !== (a = this.xCoordShift) && void 0 !== a ? a : 0,
              l = null !== (s = this.yCoordShift) && void 0 !== s ? s : 0;
            const { width: d, height: h } = this.getSvgDomRect();
            this.horizontalAnchorPointProperty ===
            i.EHorizontalAnchorPoint.Center
              ? (n -= d / 2)
              : this.horizontalAnchorPointProperty ===
                  i.EHorizontalAnchorPoint.Right && (n -= d),
              this.verticalAnchorPointProperty === i.EVerticalAnchorPoint.Center
                ? (l -= h / 2)
                : this.verticalAnchorPointProperty ===
                    i.EVerticalAnchorPoint.Bottom && (l -= h),
              (this.svg.style.visibility = this.isHidden
                ? "hidden"
                : "visible"),
              (this.svg.style.opacity = this.opacity.toString());
            const { x: u, y: c } = this.convertPolarToCartesian(
                this.getX1Coordinate(e, t),
                this.getY1Coordinate(e, t),
                !0
              ),
              p = n + u + r,
              g = l + c + o;
            isNaN(p) || isNaN(g) || !isFinite(p) || !isFinite(g)
              ? (this.svg.style.display = "none")
              : (this.setSvgAttribute("x", p), this.setSvgAttribute("y", g));
          }
          delete() {
            this.clear(), super.delete();
          }
          get svg() {
            return this.svgProperty;
          }
          getSvgDomRect() {
            var e, t, r;
            return (
              this.svgDOMRect ||
                (this.svgDOMRect =
                  null !==
                    (r =
                      null ===
                        (t =
                          null === (e = this.svg.firstChild) || void 0 === e
                            ? void 0
                            : e.getBBox) || void 0 === t
                        ? void 0
                        : t.call(e)) && void 0 !== r
                    ? r
                    : this.svg.getBBox()),
              this.svgDOMRect
            );
          }
          clear() {
            this.parentSurface &&
              !this.parentSurface.isDeleted &&
              this.svg &&
              ((this.nextSibling = this.svg.nextElementSibling),
              this.svg.parentNode.removeChild(this.svg),
              (this.svgDOMRect = void 0),
              this.setSvg(void 0));
          }
          get svgRoot() {
            return this.svgRootProperty;
          }
          selectLayerRoot() {
            if (this.annotationLayer === s.EAnnotationLayer.AboveChart)
              this.svgRootProperty = this.parentSurface.domSvgContainer;
            else if (this.annotationLayer === s.EAnnotationLayer.BelowChart)
              this.svgRootProperty = this.parentSurface.domSvgContainer;
            else {
              if (this.annotationLayer !== s.EAnnotationLayer.Background)
                throw new Error(
                  `Unexpected annotationLayer value: "${this.annotationLayer}!"`
                );
              this.svgRootProperty =
                this.parentSurface.domBackgroundSvgContainer;
            }
          }
          setSvgAttribute(e, t) {
            const r = t.toString(10);
            this.svg.firstElementChild.setAttribute(e, r);
          }
          setSvg(e) {
            this.svgProperty = e;
          }
          applyClipping(e, t) {
            return this.applySvgClipping(e, t);
          }
          notifyPropertyChanged(e) {
            e === o.PROPERTY.ANNOTATION_CANVAS &&
              (this.clear(), (this.nextSibling = void 0)),
              super.notifyPropertyChanged(e);
          }
          getSize() {
            if (!this.svg) return;
            const { width: e, height: t } = this.getSvgDomRect();
            return { width: e, height: t };
          }
        }
        t.SvgAnnotationBase = n;
      },
      49617: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TextAnnotation = void 0);
        const i = r(87108),
          o = r(19145),
          a = r(52578),
          s = r(92415),
          n = r(91380),
          l = r(84736),
          d = r(84690);
        class h extends d.SvgAnnotationBase {
          constructor(e) {
            var t, r, s, n, d, h, u, c;
            super(e),
              (this.type = l.EAnnotationType.SVGTextAnnotation),
              (this.surfaceTypes = [
                o.ESurfaceType.SciChartSurfaceType,
                o.ESurfaceType.SciChartPolarSurfaceType,
              ]),
              (this.textProperty = "DEFAULT TEXT"),
              (this.textColorProperty = "#ffffff"),
              (this.fontSizeProperty = 14),
              (this.fontFamilyProperty = a.DEFAULT_FONT_FAMILY),
              (this.fontWeightProperty = "Normal"),
              (this.paddingProperty = i.Thickness.fromNumber(0)),
              (this.classNameProperty = "scichart__text-annotation"),
              (this.isDirty = !0),
              (this.textProperty =
                null !== (t = null == e ? void 0 : e.text) && void 0 !== t
                  ? t
                  : this.textProperty),
              (this.textColorProperty =
                null !== (r = null == e ? void 0 : e.textColor) && void 0 !== r
                  ? r
                  : this.textColorProperty),
              (this.fontSizeProperty =
                null !== (s = null == e ? void 0 : e.fontSize) && void 0 !== s
                  ? s
                  : this.fontSizeProperty),
              (this.fontFamilyProperty =
                null !== (n = null == e ? void 0 : e.fontFamily) && void 0 !== n
                  ? n
                  : this.fontFamilyProperty),
              (this.backgroundProperty =
                null !== (d = null == e ? void 0 : e.background) && void 0 !== d
                  ? d
                  : this.backgroundProperty),
              (this.paddingProperty =
                null !== (h = null == e ? void 0 : e.padding) && void 0 !== h
                  ? h
                  : this.paddingProperty),
              (this.classNameProperty =
                null !== (u = null == e ? void 0 : e.className) && void 0 !== u
                  ? u
                  : this.classNameProperty),
              (this.fontWeight =
                null !== (c = null == e ? void 0 : e.fontWeight) && void 0 !== c
                  ? c
                  : this.fontWeight);
          }
          get text() {
            return this.textProperty;
          }
          set text(e) {
            this.textProperty !== e &&
              ((this.textProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.TEXT));
          }
          get background() {
            return this.backgroundProperty;
          }
          set background(e) {
            this.backgroundProperty !== e &&
              ((this.backgroundProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.BACKGROUND_COLOR));
          }
          get padding() {
            return this.paddingProperty;
          }
          set padding(e) {
            this.paddingProperty !== e &&
              ((this.paddingProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.PADDING));
          }
          get className() {
            return this.classNameProperty;
          }
          set className(e) {
            this.classNameProperty !== e &&
              ((this.classNameProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.CLASS_NAME));
          }
          get textColor() {
            return this.textColorProperty;
          }
          set textColor(e) {
            this.textColorProperty !== e &&
              ((this.textColorProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.TEXT_STROKE));
          }
          get fontSize() {
            return this.fontSizeProperty;
          }
          set fontSize(e) {
            this.fontSizeProperty !== e &&
              ((this.fontSizeProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.FONT_SIZE));
          }
          get fontFamily() {
            return this.fontFamilyProperty;
          }
          set fontFamily(e) {
            this.fontFamilyProperty !== e &&
              ((this.fontFamilyProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.FONT_FAMILY));
          }
          get fontWeight() {
            return this.fontWeightProperty;
          }
          set fontWeight(e) {
            this.fontWeightProperty !== e &&
              ((this.fontWeightProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.FONT_WEIGHT));
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontWeight: this.fontWeight,
                text: this.text,
                textColor: this.textColor,
                background: this.background,
                className: this.className,
                padding: this.padding,
              };
            return Object.assign(e.options, t), e;
          }
          notifyPropertyChanged(e) {
            e !== n.PROPERTY.IS_HIDDEN &&
              e !== n.PROPERTY.X_COORD_SHIFT &&
              e !== n.PROPERTY.Y_COORD_SHIFT &&
              e !== n.PROPERTY.HORIZONTAL_ANCHOR_POINT &&
              e !== n.PROPERTY.VERTICAL_ANCHOR_POINT &&
              e !== n.PROPERTY.X1 &&
              e !== n.PROPERTY.X2 &&
              e !== n.PROPERTY.Y1 &&
              e !== n.PROPERTY.Y2 &&
              (this.isDirty = !0),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          create(e, t, r, i) {
            if (this.svg && !this.isDirty)
              return (
                this.calcAndSetAnnotationBorders(e, t),
                void (
                  (this.isSelected ||
                    this.prevIsSelected !== this.isSelected) &&
                  (this.updateAdornerInner(),
                  (this.prevIsSelected = this.isSelected))
                )
              );
            this.svg && this.clear(),
              this.setSvg(this.createSvg()),
              this.calcAndSetAnnotationBorders(e, t),
              this.updateAdornerInner(),
              (this.isDirty = !1);
          }
          createSvg() {
            const e = this.padding.left;
            let t = this.fontSize + this.padding.top;
            const r = (0, a.getFontFamily)(this.fontFamily, !1),
              i = `<svg id="scichart__text-annotation-${this.id}" class="${this.className}">\n            <text x="${e}" y="${t}" fill="${this.textColor}"  font-size="${this.fontSize}" font-family="${r}" font-weight="${this.fontWeight}">${this.text}</text>\n        </svg>`,
              o = this.applyClipping(i, this.clipping),
              n = s.annotationHelpers.createSvg(
                o,
                this.svgRoot,
                this.nextSibling
              );
            return (
              this.background &&
                this.attachSvgBackgroundRect(n, this.background, this.padding),
              n
            );
          }
          getSize() {
            const e = super.getSize();
            return e && !this.background
              ? {
                  width: e.width + this.padding.left + this.padding.right,
                  height: e.height + this.padding.top + this.padding.bottom,
                }
              : e;
          }
          attachSvgBackgroundRect(e, t, r) {
            const i = e.getBBox(),
              o = i.width + r.left + r.right,
              a = i.height + r.top + r.bottom,
              s = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
            s.setAttribute("x", "0"),
              s.setAttribute("y", "0"),
              s.setAttribute("width", `${o}`),
              s.setAttribute("height", `${a}`),
              s.setAttribute("fill", `${t}`),
              e.firstChild.insertBefore(s, e.firstChild.firstChild);
          }
        }
        t.TextAnnotation = h;
      },
      98409: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VerticalLineAnnotation = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(87459),
          s = r(87108),
          n = r(38215),
          l = r(19145),
          d = r(21670),
          h = r(32873),
          u = r(21915),
          c = r(3441),
          p = r(86127),
          g = r(31306),
          y = r(84736),
          f = r(28677);
        class v extends f.LineAnnotation {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type =
                y.EAnnotationType.RenderContextVerticalLineAnnotation),
              (this.surfaceTypes = [l.ESurfaceType.SciChartSurfaceType]),
              (this.dragOnLine = !0),
              (this.dragOnLabel = !0),
              (null == e ? void 0 : e.x2) && (this.x2 = e.x2),
              (null == e ? void 0 : e.y2) && (this.y2 = e.y2),
              (this.dragOnLine =
                null !== (t = null == e ? void 0 : e.dragOnLine) && void 0 !== t
                  ? t
                  : this.dragOnLine),
              (this.dragOnLabel =
                null !== (r = null == e ? void 0 : e.dragOnLabel) &&
                void 0 !== r
                  ? r
                  : this.dragOnLabel),
              (this.verticalAlignment =
                null !== (i = null == e ? void 0 : e.verticalAlignment) &&
                void 0 !== i
                  ? i
                  : this.verticalAlignment);
          }
          get y2() {
            throw Error(
              "y2 property is not supported for VerticalLineAnnotation"
            );
          }
          set y2(e) {
            throw Error(
              "y2 property is not supported for VerticalLineAnnotation"
            );
          }
          get x2() {
            throw Error(
              "x2 property is not supported for VerticalLineAnnotation"
            );
          }
          set x2(e) {
            throw Error(
              "x2 property is not supported for VerticalLineAnnotation"
            );
          }
          drawWithContext(e, t, r, n, l, d) {
            i.Guard.notNull(e, "renderContext"),
              i.Guard.notNull(t, "xCalc"),
              i.Guard.notNull(r, "yCalc");
            const g = (0, u.getWebGlPenFromCache)(this.strokePenCache),
              {
                annotationCoord: y,
                lineAnnotationEdgeCoord: f,
                horizontalAxis: v,
                verticalAxis: m,
                horizontalAxisCoordinateMode: S,
                verticalAxisCoordinateMode: P,
                horizontalCoordinateCalculator: C,
                verticalCoordinateCalculator: b,
                isAlignmentTop: x,
              } = this.getDrawConfig(t, r);
            if (!v || !m) return;
            let A = n.height,
              T = 0;
            x && ((A = A = 0), (T = T = n.height));
            const E = this.getValue(f, b, P),
              R = E || 0 === E;
            R && (T = T = this.getY1Coordinate(t, r));
            const D = this.getX1Coordinate(t, r),
              w = D;
            this.setAnnotationBorders(D, w, A, T);
            const M = this.getCoordinate(f, b, P),
              L = this.getCoordinate(y, C, S),
              O = L >= 0 && L <= v.parentSurface.seriesViewRect.width,
              I = x ? M >= 0 : M <= m.parentSurface.seriesViewRect.height;
            if (O && (!R || I)) {
              const t = Object.assign(Object.assign({}, m.labelStyle), {
                  padding: new s.Thickness(2, 2, 2, 2),
                  color: this.axisLabelStroke,
                  fontSize: this.axisFontSize * p.DpiHelper.PIXEL_RATIO,
                  fontFamily: this.axisFontFamily,
                }),
                r = (0, c.drawLineAnnotation)(
                  v,
                  e,
                  this.labelPlacement,
                  this.labelValue,
                  D,
                  w,
                  A,
                  T,
                  t,
                  this.axisLabelFill,
                  g,
                  n,
                  this.showLabel,
                  this.opacity,
                  null,
                  this.verticalAlignment
                );
              if (r) {
                const e = (0, h.translateFromCanvasToSeriesViewRect)(
                    new o.Point(r.left, r.top),
                    n,
                    !0
                  ),
                  t = (0, h.translateFromCanvasToSeriesViewRect)(
                    new o.Point(r.right, r.bottom),
                    n,
                    !0
                  );
                this.labelRect = a.Rect.createWithPoints(e, t);
              }
            }
            this.dragOnLine && this.updateAdornerInner();
          }
          onDragStarted(e) {
            return this.dragOnLine
              ? super.onDragStarted(e)
              : !!(
                  this.dragOnLabel &&
                  this.labelRect &&
                  this.clickToSelect(e)
                ) &&
                  ((this.adornerDraggingPoint = g.EDraggingGripPoint.Body), !0);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                dragOnLabel: this.dragOnLabel,
                dragOnLine: this.dragOnLine,
                horizontalAlignment: void 0,
                verticalAlignment: this.verticalAlignment,
              };
            return Object.assign(e.options, t), e;
          }
          checkIsClickedOnAnnotationInternal(e, t) {
            if (
              this.dragOnLine &&
              super.checkIsClickedOnAnnotationInternal(e, t)
            )
              return !0;
            if (this.dragOnLabel && this.labelRect) {
              const { left: r, top: i, right: o, bottom: a } = this.labelRect;
              if ((0, d.testIsInBounds)(e, t, r, a, o, i)) return !0;
            }
            return !1;
          }
          getDrawConfig(e, t) {
            const r = this.xAxis,
              i = this.yAxis,
              o = {
                annotationCoord: this.x1,
                lineAnnotationEdgeCoord: this.y1,
                horizontalAxis: r,
                verticalAxis: i,
                horizontalAxisCoordinateMode: this.xCoordinateMode,
                verticalAxisCoordinateMode: this.yCoordinateMode,
                horizontalCoordinateCalculator: e,
                verticalCoordinateCalculator: t,
                isAlignmentTop:
                  (null == r ? void 0 : r.axisAlignment) ===
                  n.EAxisAlignment.Top,
              },
              a = {
                annotationCoord: this.y1,
                lineAnnotationEdgeCoord: this.x1,
                horizontalAxis: i,
                verticalAxis: r,
                horizontalAxisCoordinateMode: this.yCoordinateMode,
                verticalAxisCoordinateMode: this.xCoordinateMode,
                horizontalCoordinateCalculator: t,
                verticalCoordinateCalculator: e,
                isAlignmentTop:
                  (null == i ? void 0 : i.axisAlignment) ===
                  n.EAxisAlignment.Top,
              };
            return this.isVerticalChart ? a : o;
          }
        }
        t.VerticalLineAnnotation = v;
      },
      92415: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.annotationHelpers = void 0);
        const i = r(98353),
          o = r(86127),
          a = r(31306);
        t.annotationHelpers = {
          createSvg: (e, t, r) => {
            const i = document.createRange().createContextualFragment(e);
            return r
              ? (t.insertBefore(i, r), r.previousElementSibling)
              : (t.appendChild(i), t.lastChild);
          },
          calcNewApex: (e, t, r, i, o) => ({
            x1y1: { x: e, y: t },
            x2y1: o ? { x: e, y: i } : { x: r, y: t },
            x1y2: o ? { x: r, y: t } : { x: e, y: i },
            x2y2: { x: r, y: i },
          }),
          convertPolarToCartesian: (e, t, r, s, n, l) => {
            const d = e.getTransform(t),
              h = (0, i.getVector2)(r);
            if (t) {
              const e =
                s !== a.ECoordinateMode.Pixel ? n * o.DpiHelper.PIXEL_RATIO : n;
              d.TransformPoint(l, e, h);
            } else {
              const e =
                s !== a.ECoordinateMode.Pixel ? n : n / o.DpiHelper.PIXEL_RATIO;
              d.TransformPoint(l, e, h);
            }
            return { x: h.x, y: h.y };
          },
        };
      },
      91380: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DISTANCE_TO_LINE = t.ADORNER_GRIP_RADIUS = t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).ADORNER_TEMPLATE =
            "ADORNER_TEMPLATE"),
          (r.ANNOTATION_CANVAS = "ANNOTATION_CANVAS"),
          (r.RESIZE_DIRECTIONS = "RESIZE_DIRECTIONS"),
          (r.AXIS_LABELS_FILL = "AXIS_LABELS_FILL"),
          (r.AXIS_LABELS_STROKE = "AXIS_LABELS_STROKE"),
          (r.AXIS_FONT_FAMILY = "AXIS_FONT_FAMILY"),
          (r.AXIS_FONT_SIZE = "AXIS_FONT_SIZE"),
          (r.BACKGROUND_COLOR = "BACKGROUND_COLOR"),
          (r.CENTER_X = "CENTER_X"),
          (r.CENTER_Y = "CENTER_Y"),
          (r.CLASS_NAME = "CLASS_NAME"),
          (r.COLOR = "COLOR"),
          (r.CONTAINER_BACKGROUND = "CONTAINER_BACKGROUND"),
          (r.CLIPPING = "CLIPPING"),
          (r.FILL = "FILL"),
          (r.FONT_FAMILY = "FONT_FAMILY"),
          (r.FONT_SIZE = "FONT_SIZE"),
          (r.FONT_STYLE = "FONT_STYLE"),
          (r.FONT_WEIGHT = "FONT_WEIGHT"),
          (r.FORMATTED_VALUE = "FORMATTED_VALUE"),
          (r.HEIGHT = "HEIGHT"),
          (r.HORIZONTAL_ANCHOR_POINT = "HORIZONTAL_ANCHOR_POINT"),
          (r.IMAGE = "IMAGE"),
          (r.IMAGE_HEIGHT = "IMAGE_HEIGHT"),
          (r.IMAGE_WIDTH = "IMAGE_WIDTH"),
          (r.IS_EDITABLE = "IS_EDITABLE"),
          (r.IS_LINE_MODE = "IS_LINE_MODE"),
          (r.IS_HIDDEN = "IS_HIDDEN"),
          (r.IS_SELECTED = "IS_SELECTED"),
          (r.IS_HOVERED = "IS_HOVERED"),
          (r.LABEL_PLACEMENT = "LABEL_PLACEMENT"),
          (r.LABEL_VALUE = "LABEL_VALUE"),
          (r.MINIMUM_WIDTH = "MINIMUM_WIDTH"),
          (r.MINIMUM_HEIGHT = "MINIMUM_HEIGHT"),
          (r.OPACITY = "OPACITY"),
          (r.PADDING = "PADDING"),
          (r.PARENT_SURFACE = "PARENT_SURFACE"),
          (r.SERIES_INFO = "SERIES_INFO"),
          (r.SERIES_INFOS = "SERIES_INFOS"),
          (r.STROKE = "STROKE"),
          (r.STROKE_THICKNESS = "STROKE_THICKNESS"),
          (r.STROKE_DASH_ARRAY = "STROKE_DASH_ARRAY"),
          (r.SHOW_LABEL = "SHOW_LABEL"),
          (r.TEXT = "TEXT"),
          (r.TEXT_STROKE = "TEXT_STROKE"),
          (r.TEXT_STYLE = "TEXT_STYLE"),
          (r.TITLE = "TITLE"),
          (r.TOOLTIP_LEGEND_OFFSET_X = "TOOLTIP_LEGEND_OFFSET_X"),
          (r.TOOLTIP_LEGEND_OFFSET_Y = "TOOLTIP_LEGEND_OFFSET_Y"),
          (r.TOOLTIP_LEGEND_TEMPLATE = "TOOLTIP_LEGEND_TEMPLATE"),
          (r.TOOLTIP_DATA_TEMPLATE = "TOOLTIP_DATA_TEMPLATE"),
          (r.TOOLTIP_SVG_TEMPLATE = "TOOLTIP_SVG_TEMPLATE"),
          (r.VERTICAL_ANCHOR_POINT = "VERTICAL_ANCHOR_POINT"),
          (r.X1 = "X1"),
          (r.X2 = "X2"),
          (r.XAXIS_ID = "XAXIS_ID"),
          (r.X_COORDINATE_MODE = "X_COORDINATE_MODE"),
          (r.X_COORD_SHIFT = "X_COORD_SHIFT"),
          (r.Y1 = "Y1"),
          (r.Y2 = "Y2"),
          (r.YAXIS_ID = "YAXIS_ID"),
          (r.Y_COORDINATE_MODE = "Y_COORDINATE_MODE"),
          (r.Y_COORD_SHIFT = "Y_COORD_SHIFT"),
          (r.PLACEMENT_DIV_ID = "PLACEMENT_DIV_ID"),
          (r.ROTATION = "ROTATION"),
          (r.ADORNER_STROKE = "ADORNER_STROKE"),
          (r.ADORNER_FILL = "ADORNER_FILL"),
          (r.ADORNER_RADIUS = "ADORNER_RADIUS"),
          (r.SELECTION_STROKE = "SELECTION_STROKE"),
          (r.SELECTION_DELTA = "SELECTION_DELTA"),
          (r.SELECTION_THICKNESS = "SELECTION_THICKNESS"),
          (r.DRAGPOINTS = "DRAGPOINTS"),
          (r.MULTILINE_ALIGNMENT = "MULTILINE_ALIGNMENT"),
          (r.WRAP_TO = "WRAP_TO"),
          (r.LINE_SPACING = "LINE_SPACING"),
          (r.SCALE = "SCALE"),
          (r.OUTLINE = "OUTLINE"),
          (r.RADIUS = "RADIUS"),
          (r.INNER_RADIUS = "INNER_RADIUS"),
          (r.ARC_COORDINATE_MODE = "ARC_COORDINATE_MODE"),
          (r.VIEW_BOX_SIZE = "VIEW_BOX_SIZE"),
          (r.SVG_STRING = "SVG_STRING"),
          (r.ARROW_HEAD_LENGTH = "ARROW_HEAD_LENGTH"),
          (r.ARROW_HEAD_WIDTH = "ARROW_HEAD_WIDTH"),
          (r.ARROW_HEAD_DEPTH = "ARROW_HEAD_DEPTH"),
          (r.ARROW_HEAD_STROKE_THICKNESS = "ARROW_HEAD_STROKE_THICKNESS"),
          (r.ARROW_HEAD_COLOR = "ARROW_HEAD_COLOR"),
          (r.ARROW_HEAD_POSITION = "ARROW_HEAD_POSITION"),
          (r.IS_ARROW_HEAD_RELATIVE = "IS_ARROW_HEAD_RELATIVE"),
          (r.SURFACE_RENDER_ORDER = "SURFACE_RENDER_ORDER"),
          (r.RENDER_LAYER = "RENDER_LAYER"),
          (t.ADORNER_GRIP_RADIUS = 10),
          (t.DISTANCE_TO_LINE = 10);
      },
      57397: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisBase2D = t.EClipMode = void 0);
        const i = r(45921),
          o = r(10276),
          a = r(31194),
          s = r(56744),
          n = r(98140),
          l = r(87108),
          d = r(38215),
          h = r(11043),
          u = r(3777),
          c = r(63415),
          p = r(86699),
          g = r(52578),
          y = r(48008),
          f = r(16602),
          v = r(21915),
          m = r(78623),
          S = r(16185),
          P = r(65707),
          C = r(22019),
          b = r(63458),
          x = r(94389),
          A = r(98353),
          T = r(14184),
          E = r(86127),
          R = r(42241),
          D = r(87673),
          w = r(74736),
          M = r(14790),
          L = r(8900);
        var O;
        ((O = t.EClipMode || (t.EClipMode = {})).None = "None"),
          (O.StretchAtExtents = "StretchAtExtents"),
          (O.ClipAtMin = "ClipAtMin"),
          (O.ClipAtMax = "ClipAtMax"),
          (O.ClipAtExtents = "ClipAtExtents");
        class I extends R.AxisCore {
          constructor(e, t) {
            var r, o, a, s, d, u, p, y, f, S, P, C;
            super(t),
              (this.axisLayoutState = new D.AxisLayoutState()),
              (this.isPolarAxis = !1),
              (this.getlabelStyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    (e[t] = r),
                    this.notifyPropertyChanged(L.PROPERTY.TEXT_STYLE),
                    (this.dpiAdjustedLabelStyleCache = void 0),
                    !0
                  ),
                })),
              (this.labelStyleProperty = this.getlabelStyleProxy({
                fontSize: 14,
                fontFamily: g.DEFAULT_FONT_FAMILY,
                color: T.SciChartSurfaceBase.DEFAULT_THEME.tickTextBrush,
                fontWeight: "normal",
                fontStyle: "normal",
                padding: l.Thickness.fromString("2 4 2 4"),
                alignment: c.ELabelAlignment.Auto,
              })),
              (this.isInnerAxisProperty = !1),
              (this.isPrimaryAxisProperty = !1),
              (this.axisBorderProperty = {
                borderBottom: 0,
                borderLeft: 0,
                borderRight: 0,
                borderTop: 0,
                color: T.SciChartSurfaceBase.DEFAULT_THEME.axisBorder,
                border: 0,
              }),
              (this.offsetProperty = 0),
              (this.offsetOverrideProperty = void 0),
              (this.tickCache = void 0),
              (this.clipToXRangeProperty = !0),
              (this.isStaticAxisProperty = !1),
              (this.webAssemblyContext2D = e),
              (this.penCacheForMajorGridLines = new v.Pen2DCache(e)),
              (this.penCacheForMinorGridLines = new v.Pen2DCache(e)),
              (this.penCacheForMajorTickLines = new v.Pen2DCache(e)),
              (this.penCacheForMinorTickLines = new v.Pen2DCache(e)),
              (this.solidBrushCacheAxisBands = new m.SolidBrushCache(e)),
              (this.solidBrushCacheAxisBackground = new m.SolidBrushCache(e)),
              (this.axisRenderer = new w.AxisRenderer(e)),
              (this.axisRenderer.keepLabelsWithinAxis =
                null !== (r = null == t ? void 0 : t.keepLabelsWithinAxis) &&
                void 0 !== r
                  ? r
                  : this.axisRenderer.keepLabelsWithinAxis),
              (this.axisRenderer.hideOverlappingLabels =
                null !== (o = null == t ? void 0 : t.hideOverlappingLabels) &&
                void 0 !== o
                  ? o
                  : this.axisRenderer.hideOverlappingLabels),
              (this.axisRenderer.axisThickness =
                null !== (a = null == t ? void 0 : t.axisThickness) &&
                void 0 !== a
                  ? a
                  : this.axisRenderer.axisThickness),
              (this.axisTitleRenderer = new M.AxisTitleRenderer(e)),
              (this.isStaticAxis =
                null !== (s = null == t ? void 0 : t.isStaticAxis) &&
                void 0 !== s
                  ? s
                  : this.isStaticAxisProperty),
              (this.visibleRangeLimit =
                null !==
                  (d = n.NumberRange.hydrate(
                    null == t ? void 0 : t.visibleRangeLimit
                  )) && void 0 !== d
                  ? d
                  : this.visibleRangeLimit),
              (this.visibleRangeSizeLimit =
                null !==
                  (u = n.NumberRange.hydrate(
                    null == t ? void 0 : t.visibleRangeSizeLimit
                  )) && void 0 !== u
                  ? u
                  : this.visibleRangeSizeLimit),
              (this.zoomExtentsRange = (
                null == t ? void 0 : t.zoomExtentsToInitialRange
              )
                ? this.visibleRange
                : n.NumberRange.hydrate(
                    null == t ? void 0 : t.zoomExtentsRange
                  )),
              (this.axisAlignment =
                null !== (p = null == t ? void 0 : t.axisAlignment) &&
                void 0 !== p
                  ? p
                  : this.axisAlignment),
              (this.axisTitle =
                null !== (y = null == t ? void 0 : t.axisTitle) && void 0 !== y
                  ? y
                  : this.axisTitle),
              (this.labelStyle = this.getlabelStyleProxy(
                Object.assign(
                  Object.assign({}, this.labelStyle),
                  null == t ? void 0 : t.labelStyle
                )
              )),
              (this.axisBorder = null == t ? void 0 : t.axisBorder),
              (this.isInnerAxis =
                null !== (f = null == t ? void 0 : t.isInnerAxis) &&
                void 0 !== f
                  ? f
                  : this.isInnerAxis),
              (this.stackedAxisLength =
                null !== (S = null == t ? void 0 : t.stackedAxisLength) &&
                void 0 !== S
                  ? S
                  : this.stackedAxisLength),
              (this.solidBrushCacheBorder = new m.SolidBrushCache(e)),
              (null == t ? void 0 : t.labelProvider) &&
                ("getLabels" in (null == t ? void 0 : t.labelProvider) ||
                  (t.labelProvider = (0, i.createType)(
                    h.EBaseType.LabelProvider,
                    t.labelProvider.type,
                    e,
                    t.labelProvider.options
                  ))),
              (this.autoRangeAnimationProperty =
                null == t ? void 0 : t.autoRangeAnimation),
              (this.backgroundColor =
                null !== (P = null == t ? void 0 : t.backgroundColor) &&
                void 0 !== P
                  ? P
                  : this.backgroundColor),
              (this.offsetOverrideProperty =
                null == t ? void 0 : t.overrideOffset),
              (this.clipToXRangeProperty =
                null !== (C = null == t ? void 0 : t.clipToXRange) &&
                void 0 !== C
                  ? C
                  : this.clipToXRange);
          }
          get labelProvider() {
            return this.labelProviderProperty;
          }
          set labelProvider(e) {
            var t;
            null === (t = this.labelProviderProperty) ||
              void 0 === t ||
              t.detachedFromAxis(),
              (this.labelProviderProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.LABEL_PROVIDER);
          }
          get axisRenderer() {
            return this.axisRendererProperty;
          }
          set axisRenderer(e) {
            (this.axisRendererProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.AXIS_RENDERER);
          }
          get isHorizontalAxis() {
            return (0, d.getIsHorizontal)(this.axisAlignment);
          }
          get isAxisFlipped() {
            return !this.isXAxis;
          }
          get axisAlignment() {
            return this.axisAlignmentProperty;
          }
          set axisAlignment(e) {
            this.axisAlignmentProperty !== e &&
              ((this.axisAlignmentProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.AXIS_ALIGNMENT));
          }
          get visibleRangeLimit() {
            return this.visibleRangeLimitProperty;
          }
          set visibleRangeLimit(e) {
            n.NumberRange.areEqual(this.visibleRangeLimitProperty, e) ||
              ((this.visibleRangeLimitProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.VISIBLE_RANGE_LIMIT));
          }
          get visibleRangeSizeLimit() {
            return this.visibleRangeSizeLimitProperty;
          }
          set visibleRangeSizeLimit(e) {
            if (
              !n.NumberRange.areEqual(this.visibleRangeSizeLimitProperty, e)
            ) {
              if (e.min < 0)
                throw Error(
                  "visibleRangeSizeLimit min value must be more or equal 0"
                );
              if (e.min >= e.max)
                throw Error(
                  "visibleRangeSizeLimit min value must be less than max value"
                );
              (this.visibleRangeSizeLimitProperty = e),
                this.notifyPropertyChanged(L.PROPERTY.VISIBLE_RANGE_SIZE_LIMIT);
            }
          }
          get zoomExtentsRange() {
            return this.zoomExtentsRangeProperty;
          }
          set zoomExtentsRange(e) {
            n.NumberRange.areEqual(this.zoomExtentsRangeProperty, e) ||
              ((this.zoomExtentsRangeProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.ZOOMEXTENTS_RANGE));
          }
          get isInnerAxis() {
            return this.isInnerAxisProperty;
          }
          set isInnerAxis(e) {
            this.isInnerAxisProperty !== e &&
              ((this.isInnerAxisProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.IS_INNER_AXIS));
          }
          get isPrimaryAxis() {
            return this.isPrimaryAxisProperty;
          }
          set isPrimaryAxis(e) {
            this.isPrimaryAxisProperty !== e &&
              ((this.isPrimaryAxisProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.IS_PRIMARY_AXIS)),
              e &&
                !this.isStackedAxis &&
                (this.isXAxis
                  ? this.parentSurface.xAxes
                  : this.parentSurface.yAxes
                )
                  .asArray()
                  .forEach((e) => {
                    e === this || e.isStackedAxis || (e.isPrimaryAxis = !1);
                  });
          }
          get isStackedAxis() {
            return this.parentSurface.layoutManager.getAxisLayoutStrategy(this)
              .isStacked;
          }
          get backgroundColor() {
            return this.backgroundColorProperty;
          }
          set backgroundColor(e) {
            (this.backgroundColorProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          get stackedAxisLength() {
            return this.stackedAxisLengthProperty;
          }
          set stackedAxisLength(e) {
            this.stackedAxisLengthProperty !== e &&
              ((this.stackedAxisLengthProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.AXIS_LENGTH));
          }
          get axisLength() {
            var e, t;
            const { seriesViewRect: r } = this.parentSurface;
            if (!r)
              return null !== (e = this.axisLengthProperty) && void 0 !== e
                ? e
                : 0;
            const i = this.isHorizontalAxis ? r.width : r.height;
            return null !== (t = this.axisLengthProperty) && void 0 !== t
              ? t
              : i;
          }
          set axisLength(e) {
            this.axisLengthProperty !== e &&
              ((this.axisLengthProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.AXIS_LENGTH));
          }
          get offset() {
            var e;
            return null !== (e = this.offsetOverrideProperty) && void 0 !== e
              ? e
              : this.offsetProperty;
          }
          overrideOffset(e) {
            this.offsetOverrideProperty !== e &&
              ((this.offsetOverrideProperty = e),
              this.clearCoordCalcCache(),
              this.notifyPropertyChanged(L.PROPERTY.OFFSET));
          }
          set offset(e) {
            this.offsetProperty !== e &&
              ((this.offsetProperty = e),
              void 0 === this.offsetOverrideProperty &&
                (this.clearCoordCalcCache(),
                this.notifyPropertyChanged(L.PROPERTY.OFFSET)));
          }
          get isVerticalChart() {
            return this.isXAxis
              ? !![d.EAxisAlignment.Left, d.EAxisAlignment.Right].includes(
                  this.axisAlignment
                )
              : !![d.EAxisAlignment.Top, d.EAxisAlignment.Bottom].includes(
                  this.axisAlignment
                );
          }
          get dpiAdjustedLabelStyle() {
            return (
              this.dpiAdjustedLabelStyleCache ||
                (this.dpiAdjustedLabelStyleCache = E.DpiHelper.adjustTextStyle(
                  this.labelStyleProperty
                )),
              this.dpiAdjustedLabelStyleCache
            );
          }
          get labelStyle() {
            return this.labelStyleProperty;
          }
          set labelStyle(e) {
            const t = Object.assign(Object.assign({}, this.labelStyle), e);
            (this.labelStyleProperty = this.getlabelStyleProxy(t)),
              this.notifyPropertyChanged(L.PROPERTY.TEXT_STYLE),
              (this.dpiAdjustedLabelStyleCache = void 0);
          }
          get axisBorder() {
            return this.axisBorderProperty;
          }
          set axisBorder(e) {
            var t, r, i, o, a, s, n, l, d, h;
            (this.axisBorder.borderTop =
              null !==
                (r =
                  null !== (t = null == e ? void 0 : e.borderTop) &&
                  void 0 !== t
                    ? t
                    : null == e
                    ? void 0
                    : e.border) && void 0 !== r
                ? r
                : this.axisBorder.borderTop),
              (this.axisBorder.borderLeft =
                null !==
                  (o =
                    null !== (i = null == e ? void 0 : e.borderLeft) &&
                    void 0 !== i
                      ? i
                      : null == e
                      ? void 0
                      : e.border) && void 0 !== o
                  ? o
                  : this.axisBorder.borderLeft),
              (this.axisBorder.borderBottom =
                null !==
                  (s =
                    null !== (a = null == e ? void 0 : e.borderBottom) &&
                    void 0 !== a
                      ? a
                      : null == e
                      ? void 0
                      : e.border) && void 0 !== s
                  ? s
                  : this.axisBorder.borderBottom),
              (this.axisBorder.borderRight =
                null !==
                  (l =
                    null !== (n = null == e ? void 0 : e.borderRight) &&
                    void 0 !== n
                      ? n
                      : null == e
                      ? void 0
                      : e.border) && void 0 !== l
                  ? l
                  : this.axisBorder.borderRight),
              (this.axisBorder.border =
                null !== (d = null == e ? void 0 : e.border) && void 0 !== d
                  ? d
                  : this.axisBorder.border),
              (this.axisBorder.color =
                null !== (h = null == e ? void 0 : e.color) && void 0 !== h
                  ? h
                  : this.axisBorder.color),
              this.notifyPropertyChanged(L.PROPERTY.BORDER);
          }
          get autoRangeAnimation() {
            return this.autoRangeAnimationProperty;
          }
          set autoRangeAnimation(e) {
            this.autoRangeAnimationProperty = Object.assign(
              Object.assign({}, this.autoRangeAnimation),
              e
            );
          }
          get clipToXRange() {
            return this.clipToXRangeProperty;
          }
          set clipToXRange(e) {
            this.clipToXRangeProperty !== e &&
              ((this.clipToXRangeProperty = e),
              this.notifyPropertyChanged(L.PROPERTY.DRAW_ONLY_WITHIN_XRANGE));
          }
          get isStaticAxis() {
            return this.isStaticAxisProperty;
          }
          set isStaticAxis(e) {
            (this.isStaticAxisProperty = e),
              (this.tickCoordinatesProvider = e
                ? new C.StaticTickCoordinatesProvider()
                : new P.DefaultTickCoordinatesProvider());
          }
          applyTheme(e) {
            const t = this.parentSurface.previousThemeProvider;
            this.axisBandsFill === t.axisBandsFill &&
              (this.axisBandsFill = e.axisBandsFill),
              this.labelStyle.color === t.tickTextBrush &&
                (this.labelStyle = { color: e.tickTextBrush }),
              this.minorGridLineStyle.color === t.minorGridLineBrush &&
                (this.minorGridLineStyle = { color: e.minorGridLineBrush }),
              this.majorGridLineStyle.color === t.majorGridLineBrush &&
                (this.majorGridLineStyle = { color: e.majorGridLineBrush }),
              this.minorTickLineStyle.color === t.minorGridLineBrush &&
                (this.minorTickLineStyle = { color: e.minorGridLineBrush }),
              this.majorTickLineStyle.color === t.majorGridLineBrush &&
                (this.majorTickLineStyle = { color: e.majorGridLineBrush }),
              this.axisTitleStyle.color === t.axisTitleColor &&
                (this.axisTitleStyle = { color: e.axisTitleColor });
          }
          setParentSurface(e) {
            (this.parentSurface = e),
              (this.axisTitleRenderer.parentSurface = e);
          }
          onAttach(e, t, r) {
            this.setParentSurface(e),
              this.setIsXAxis(t),
              (this.isPrimaryAxisProperty = r);
          }
          onDetach() {
            (this.parentSurface = void 0),
              (this.isPrimaryAxisProperty = !1),
              (this.invalidateParentCallback = void 0);
          }
          measure() {
            if (this.isVisible) {
              const { majorTickLabels: e } = this.getTicks(!0),
                t = this.drawMinorTickLines || this.drawMajorTickLines;
              T.DebugForDpi &&
                console.log(
                  `Measure. fontSize: ${this.labelStyle.fontSize}, dpiAdjusted: ${this.dpiAdjustedLabelStyle.fontSize}`
                ),
                this.axisRenderer.measure(
                  this.isHorizontalAxis,
                  this.dpiAdjustedLabelStyle,
                  e,
                  this.getTicksMaxSize(),
                  this.labelProvider,
                  this.drawLabels,
                  t
                ),
                this.axisTitleRenderer.measure(
                  this.axisTitle,
                  this.dpiAdjustedAxisTitleStyle,
                  this.axisAlignment
                );
            } else
              (this.axisRenderer.desiredHeight = 0),
                (this.axisRenderer.desiredWidth = 0),
                (this.axisTitleRenderer.desiredHeight = 0),
                (this.axisTitleRenderer.desiredWidth = 0);
            this.isMeasured = !0;
          }
          onDpiChanged() {
            this.dpiAdjustedLabelStyleCache = void 0;
          }
          prepareRenderData() {
            this.getCurrentCoordinateCalculator();
          }
          getCurrentCoordinateCalculator() {
            return super.getCurrentCoordinateCalculator();
          }
          draw(e) {
            var t, r, i;
            if (!this.getIsValidForDrawing()) return;
            const o = this.parentSurface.clipRect,
              a = (0, S.calculateAbsoluteRenderLayer)(
                this.parentSurface.getSurfaceRenderOrder(),
                this.parentSurface.stepBetweenLayers,
                u.EDefaultRenderLayer.AxisBordersLayer
              );
            e.enqueueLayeredDraw(() => {
              var t, r, i;
              const a = f.PerformanceDebugHelper.mark(
                f.EPerformanceMarkType.DrawAxisBorderStart,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (t = this.parentSurface) || void 0 === t
                      ? void 0
                      : t.id,
                  level: f.EPerformanceDebugLevel.Verbose,
                }
              );
              (0, x.drawBorder)(
                e,
                this.webAssemblyContext2D,
                this.solidBrushCacheBorder,
                this.viewRect,
                o,
                this.axisBorder.borderLeft || this.axisBorder.border,
                this.axisBorder.borderTop || this.axisBorder.border,
                this.axisBorder.borderRight || this.axisBorder.border,
                this.axisBorder.borderBottom || this.axisBorder.border,
                this.axisBorder.color
              ),
                f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawAxisBorderEnd,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (r = this.parentSurface) || void 0 === r
                        ? void 0
                        : r.id,
                    relatedId:
                      null === (i = null == a ? void 0 : a.detail) ||
                      void 0 === i
                        ? void 0
                        : i.relatedId,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
            }, a);
            const s = f.PerformanceDebugHelper.mark(
                f.EPerformanceMarkType.GetTicksStart,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (t = this.parentSurface) || void 0 === t
                      ? void 0
                      : t.id,
                  level: f.EPerformanceDebugLevel.Verbose,
                }
              ),
              n = this.getTicksWithCoords();
            f.PerformanceDebugHelper.mark(f.EPerformanceMarkType.GetTicksEnd, {
              contextId: this.id,
              parentContextId:
                null === (r = this.parentSurface) || void 0 === r
                  ? void 0
                  : r.id,
              relatedId:
                null === (i = null == s ? void 0 : s.detail) || void 0 === i
                  ? void 0
                  : i.relatedId,
              level: f.EPerformanceDebugLevel.Verbose,
            });
            const l = this.minorGridLineStyle,
              d = this.majorGridLineStyle,
              h = this.minorTickLineStyle,
              c = this.majorTickLineStyle,
              p = this.getPenForLines(
                this.penCacheForMinorGridLines,
                l.color,
                l.strokeThickness,
                l.strokeDashArray
              ),
              g = this.getPenForLines(
                this.penCacheForMajorGridLines,
                d.color,
                d.strokeThickness,
                d.strokeDashArray
              ),
              y = this.getPenForLines(
                this.penCacheForMinorTickLines,
                h.color,
                h.strokeThickness
              ),
              v = this.getPenForLines(
                this.penCacheForMajorTickLines,
                c.color,
                c.strokeThickness
              );
            this.isPrimaryAxis && this.drawAxisBandsAndGridLines(e, n, p, g);
            const m = (0, S.calculateAbsoluteRenderLayer)(
              this.parentSurface.getSurfaceRenderOrder(),
              this.parentSurface.stepBetweenLayers,
              u.EDefaultRenderLayer.AxesLayer
            );
            e.enqueueLayeredDraw(() => {
              var t, r, i, a, s, l, d, u, p, g, m, S;
              if (this.backgroundColorProperty) {
                const a = f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawAxisBackgroundStart,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (t = this.parentSurface) || void 0 === t
                          ? void 0
                          : t.id,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  ),
                  s =
                    (this.axisRenderer.viewRect,
                    this.axisTitleRenderer.viewRect,
                    this.solidBrushCacheAxisBackground.newBrush(
                      this.backgroundColorProperty,
                      !1
                    ));
                let n;
                if (
                  ((n = (0, b.createNativeRect)(
                    this.webAssemblyContext2D,
                    0,
                    0,
                    this.viewRect.width,
                    this.viewRect.height
                  )),
                  n)
                ) {
                  const t = (0, A.getVectorRectVertex)(
                    this.webAssemblyContext2D
                  );
                  t.push_back(n),
                    e.drawRects(t, s, o, this.viewRect.x, this.viewRect.y);
                }
                f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawAxisBackgroundEnd,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (r = this.parentSurface) || void 0 === r
                        ? void 0
                        : r.id,
                    relatedId:
                      null === (i = null == a ? void 0 : a.detail) ||
                      void 0 === i
                        ? void 0
                        : i.relatedId,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
              }
              if (this.drawLabels) {
                T.DebugForDpi &&
                  console.log(
                    `Draw. fontSize: ${this.labelStyle.fontSize}, dpiAdjusted: ${this.dpiAdjustedLabelStyle.fontSize}`
                  );
                const t = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawAxisLabelsStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (a = this.parentSurface) || void 0 === a
                        ? void 0
                        : a.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.axisRenderer.drawLabels(
                  e,
                  this.axisAlignment,
                  this.isInnerAxis,
                  n.majorTickLabels,
                  n.majorTickCoords,
                  this.offset,
                  this.dpiAdjustedLabelStyle,
                  this.isVerticalChart,
                  this.flippedCoordinates,
                  this.labelProvider
                ),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawAxisLabelsEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (s = this.parentSurface) || void 0 === s
                          ? void 0
                          : s.id,
                      relatedId:
                        null === (l = null == t ? void 0 : t.detail) ||
                        void 0 === l
                          ? void 0
                          : l.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }
              if (this.drawMinorTickLines) {
                const t = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawMinorTicksStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (d = this.parentSurface) || void 0 === d
                        ? void 0
                        : d.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.axisRenderer.drawTicks(
                  e,
                  this.axisAlignment,
                  this.isInnerAxis,
                  n.minorTickCoords,
                  this.offset,
                  y,
                  h
                ),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawMinorTicksEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (u = this.parentSurface) || void 0 === u
                          ? void 0
                          : u.id,
                      relatedId:
                        null === (p = null == t ? void 0 : t.detail) ||
                        void 0 === p
                          ? void 0
                          : p.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }
              if (this.drawMajorTickLines) {
                const t = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawMajorTicksStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (g = this.parentSurface) || void 0 === g
                        ? void 0
                        : g.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.axisRenderer.drawTicks(
                  e,
                  this.axisAlignment,
                  this.isInnerAxis,
                  n.majorTickCoords,
                  this.offset,
                  v,
                  c
                ),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawMajorTicksEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (m = this.parentSurface) || void 0 === m
                          ? void 0
                          : m.id,
                      relatedId:
                        null === (S = null == t ? void 0 : t.detail) ||
                        void 0 === S
                          ? void 0
                          : S.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }
              if (
                (this.axisTitleRenderer.draw(e),
                this.labelProvider.useNativeText &&
                  this.parentSurface.renderNativeAxisLabelsImmediately)
              ) {
                const t = e.getNativeContext();
                t.PushMatrix(),
                  t.PushState(),
                  t.SetClipRect(o.x, o.y, o.width, o.height),
                  e.endFonts(!0),
                  t.PopState(),
                  t.PopMatrix();
              }
            }, m);
          }
          drawDebug(e) {
            this.axisRenderer.drawDebug = !0;
            const t = this.parentSurface.chartViewRect;
            (() => {
              const r = this.axisRenderer.viewRect,
                i = (0, A.getVectorRectVertex)(this.webAssemblyContext2D),
                o = new this.webAssemblyContext2D.SCRTSolidBrush(
                  (0, y.parseColorToUIntArgb)("rgba(255,0,0,0.7)"),
                  !1
                ),
                a = (0, b.createNativeRect)(
                  this.webAssemblyContext2D,
                  0,
                  0,
                  r.width,
                  r.height
                );
              i.push_back(a), e.drawRects(i, o, t, r.left, r.top), o.delete();
            })(),
              (() => {
                const r = this.axisTitleRenderer.viewRect,
                  i = (0, A.getVectorRectVertex)(this.webAssemblyContext2D),
                  o = new this.webAssemblyContext2D.SCRTSolidBrush(
                    (0, y.parseColorToUIntArgb)("rgba(0,255,0,0.7)"),
                    !1
                  ),
                  a = (0, b.createNativeRect)(
                    this.webAssemblyContext2D,
                    0,
                    0,
                    r.width,
                    r.height
                  );
                i.push_back(a), e.drawRects(i, o, t, r.left, r.top), o.delete();
              })();
          }
          getDefaultNonZeroRange() {
            return new n.NumberRange(0, 10);
          }
          getMaximumRange() {
            if (this.zoomExtentsRange) return this.zoomExtentsRange;
            let e;
            this.parentSurface &&
              this.parentSurface.renderableSeries.size() > 0 &&
              (e = this.isXAxis
                ? this.getMaxXRange()
                : this.getWindowedYRange(void 0));
            const t = this.visibleRange || this.getDefaultNonZeroRange();
            return e || t;
          }
          getWindowedYRange(e) {
            if (this.zoomExtentsRange) return this.zoomExtentsRange;
            let t;
            return (
              this.parentSurface &&
                this.getVisibleRenderableSeriesByYAxis().forEach((r) => {
                  const i = r.xAxisId,
                    o = (null == e ? void 0 : e.containsKey(i))
                      ? e.item(i)
                      : this.getXVisibleRange(i),
                    a = this.getIsXCategoryAxis(i);
                  if (o) {
                    const e = r.getYRange(o, a);
                    e && (t = t ? t.union(e) : e);
                  }
                }),
              (null == t ? void 0 : t.isZero()) &&
                (t = this.coerceZeroVisibleRange(t)),
              this.growBy && t && (t = t.growBy(this.growBy)),
              (t = this.applyVisibleRangeLimit(t)),
              (t = this.applyVisibleRangeSizeLimit(t)),
              t || new n.NumberRange()
            );
          }
          scroll(e, t) {
            const r = this.visibleRange;
            if (void 0 === r) return !1;
            let i = this.getCurrentCoordinateCalculator().translateBy(e, r);
            if (this.visibleRangeLimit) {
              let e = 0;
              i.min < this.visibleRangeLimit.min
                ? (e = this.visibleRangeLimit.min - i.min)
                : this.visibleRangeLimit.max < i.max &&
                  (e = this.visibleRangeLimit.max - i.max),
                e && (i = new n.NumberRange(i.min + e, i.max + e));
            }
            return (this.visibleRange = this.applyVisibleRangeSizeLimit(i)), !0;
          }
          setVisibleRangeWithLimits(e) {
            let t = this.applyVisibleRangeLimit(e);
            this.visibleRange = this.applyVisibleRangeSizeLimit(t);
          }
          zoomBy(e, t) {
            const r = this.getCurrentCoordinateCalculator().zoomTranslateBy(
              e,
              t,
              this.visibleRange
            );
            if (r.max < r.min) return;
            const i = this.applyVisibleRangeLimit(r);
            this.visibleRange = this.applyVisibleRangeSizeLimit(i);
          }
          zoom(e, t, r = 0, i = o.easing.outExpo) {
            const a = this.getCurrentCoordinateCalculator(),
              s = a.getDataValue(e),
              l = a.getDataValue(t),
              d = s < l ? s : l,
              h = s < l ? l : s,
              u = this.applyVisibleRangeLimit(new n.NumberRange(d, h)),
              c = this.applyVisibleRangeSizeLimit(u);
            this.animateVisibleRange(c, r, i);
          }
          scale(e, t, r) {
            const i = e.max - e.min;
            let o, a;
            const s = this.flippedCoordinates ? !r : r,
              l = this.flippedCoordinates ? -t : t;
            s
              ? ((o = e.min),
                (a = l > 0 ? o + i / (1 + l) : o + i * (1 + Math.abs(l))))
              : ((a = e.max),
                (o = l > 0 ? a - i * (1 + l) : a - i / (1 + Math.abs(l))));
            const d = this.applyVisibleRangeLimit(new n.NumberRange(o, a));
            this.visibleRange = this.applyVisibleRangeSizeLimit(d);
          }
          animateVisibleRange(e, t, r = o.easing.outCubic, i = () => {}) {
            var s;
            return t <= 0
              ? ((this.visibleRange = e || this.visibleRange), void i())
              : (null === (s = this.visibleRangeAnimationToken) ||
                  void 0 === s ||
                  s.cancel(),
                (this.visibleRangeAnimationToken =
                  a.NumberRangeAnimator.animate(
                    this.visibleRange,
                    e,
                    t,
                    (e) => {
                      this.visibleRange = e;
                    },
                    () => {
                      (this.visibleRangeAnimationToken = void 0), i();
                    },
                    r
                  )),
                this.parentSurface.addAnimation(
                  this.visibleRangeAnimationToken
                ),
                this.visibleRangeAnimationToken);
          }
          getVisibleRenderableSeriesByXAxis() {
            return this.parentSurface
              ? this.parentSurface.renderableSeries
                  .asArray()
                  .filter(
                    (e) =>
                      e.xAxis === this && e.isVisible && e.hasDataSeriesValues()
                  )
              : [];
          }
          getVisibleRenderableSeriesByYAxis() {
            return this.parentSurface
              ? this.parentSurface.renderableSeries
                  .asArray()
                  .filter(
                    (e) => (
                      e.linkAxes(),
                      e.yAxis === this && e.isVisible && e.hasDataSeriesValues()
                    )
                  )
              : [];
          }
          delete() {
            (this.penCacheForMajorGridLines = (0, s.deleteSafe)(
              this.penCacheForMajorGridLines
            )),
              (this.penCacheForMinorGridLines = (0, s.deleteSafe)(
                this.penCacheForMinorGridLines
              )),
              (this.penCacheForMajorTickLines = (0, s.deleteSafe)(
                this.penCacheForMajorTickLines
              )),
              (this.penCacheForMinorTickLines = (0, s.deleteSafe)(
                this.penCacheForMinorTickLines
              )),
              (this.solidBrushCacheBorder = (0, s.deleteSafe)(
                this.solidBrushCacheBorder
              )),
              (this.solidBrushCacheAxisBands = (0, s.deleteSafe)(
                this.solidBrushCacheAxisBands
              )),
              (this.solidBrushCacheAxisBackground = (0, s.deleteSafe)(
                this.solidBrushCacheAxisBackground
              )),
              (this.axisRendererProperty = (0, s.deleteSafe)(
                this.axisRenderer
              )),
              (this.axisTitleRenderer = (0, s.deleteSafe)(
                this.axisTitleRenderer
              )),
              (this.webAssemblyContext2D = void 0),
              (this.parentSurface = void 0),
              super.delete();
          }
          toJSON() {
            const e = {
              autoRange: this.autoRange,
              autoTicks: this.autoTicks,
              axisAlignment: this.axisAlignment,
              axisBandsFill: this.axisBandsFill,
              axisBorder: this.axisBorder,
              axisTitle: this.axisTitle,
              axisTitleStyle: this.axisTitleStyle,
              drawLabels: this.drawLabels,
              drawMajorBands: this.drawMajorBands,
              drawMajorGridLines: this.drawMajorGridLines,
              drawMajorTickLines: this.drawMajorTickLines,
              drawMinorGridLines: this.drawMinorGridLines,
              drawMinorTickLines: this.drawMinorTickLines,
              flippedCoordinates: this.flippedCoordinates,
              growBy: this.growBy,
              id: this.id,
              isInnerAxis: this.isInnerAxis,
              isVisible: this.isVisible,
              labelStyle: this.labelStyle,
              majorGridLineStyle: this.majorGridLineStyle,
              majorTickLineStyle: this.majorTickLineStyle,
              maxAutoTicks: this.maxAutoTicks,
              minorGridLineStyle: this.minorGridLineStyle,
              minorTickLineStyle: this.minorTickLineStyle,
              visibleRange: this.hasDefaultVisibleRange()
                ? void 0
                : this.visibleRange,
              visibleRangeLimit: this.visibleRangeLimit,
              zoomExtentsRange: this.zoomExtentsRange,
              minorsPerMajor: this.minorsPerMajor,
              majorDelta: this.majorDelta,
              minorDelta: this.minorDelta,
              labelProvider: this.labelProvider.toJSON(),
              keepLabelsWithinAxis: this.axisRenderer.keepLabelsWithinAxis,
              clipToXRange: this.clipToXRange,
              isStaticAxis: this.isStaticAxis,
            };
            return { type: this.type, options: e };
          }
          getTicksMaxSize() {
            var e, t;
            const r = (
                null === (e = this.majorTickLineStyle) || void 0 === e
                  ? void 0
                  : e.tickSize
              )
                ? this.majorTickLineStyle.tickSize * E.DpiHelper.PIXEL_RATIO
                : 0,
              i = (
                null === (t = this.minorTickLineStyle) || void 0 === t
                  ? void 0
                  : t.tickSize
              )
                ? this.minorTickLineStyle.tickSize * E.DpiHelper.PIXEL_RATIO
                : 0;
            return Math.max(r, i);
          }
          getIsValidForDrawing() {
            return this.isVisible;
          }
          drawAxisBandsAndGridLines(e, t, r, i) {
            if (this.drawMajorBands) {
              const r = this.solidBrushCacheAxisBands.newBrush(
                  this.axisBandsFill,
                  !0
                ),
                i = (0, S.calculateAbsoluteRenderLayer)(
                  this.parentSurface.getSurfaceRenderOrder(),
                  this.parentSurface.stepBetweenLayers,
                  u.EDefaultRenderLayer.AxisBandsLayer
                );
              e.enqueueLayeredDraw(() => {
                var i, o, a;
                const s = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawAxisBandsStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (i = this.parentSurface) || void 0 === i
                        ? void 0
                        : i.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.drawAxisBands(e, t.majorTicks, t.majorTickCoords, r),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawAxisBandsEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (o = this.parentSurface) || void 0 === o
                          ? void 0
                          : o.id,
                      relatedId:
                        null === (a = null == s ? void 0 : s.detail) ||
                        void 0 === a
                          ? void 0
                          : a.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }, i);
            }
            if (this.drawMinorGridLines) {
              const i = (0, S.calculateAbsoluteRenderLayer)(
                this.parentSurface.getSurfaceRenderOrder(),
                this.parentSurface.stepBetweenLayers,
                u.EDefaultRenderLayer.MinorGridLinesLayer
              );
              e.enqueueLayeredDraw(() => {
                var i, o, a;
                const s = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawMinorGridLinesStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (i = this.parentSurface) || void 0 === i
                        ? void 0
                        : i.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.drawGridLines(e, t.minorTickCoords, r, !1),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawMinorGridLinesEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (o = this.parentSurface) || void 0 === o
                          ? void 0
                          : o.id,
                      relatedId:
                        null === (a = null == s ? void 0 : s.detail) ||
                        void 0 === a
                          ? void 0
                          : a.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }, i);
            }
            if (this.drawMajorGridLines) {
              const r = (0, S.calculateAbsoluteRenderLayer)(
                this.parentSurface.getSurfaceRenderOrder(),
                this.parentSurface.stepBetweenLayers,
                u.EDefaultRenderLayer.MajorGridLinesLayer
              );
              e.enqueueLayeredDraw(() => {
                var r, o, a;
                const s = f.PerformanceDebugHelper.mark(
                  f.EPerformanceMarkType.DrawMajorGridLinesStart,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (r = this.parentSurface) || void 0 === r
                        ? void 0
                        : r.id,
                    level: f.EPerformanceDebugLevel.Verbose,
                  }
                );
                this.drawGridLines(e, t.majorTickCoords, i, !0),
                  f.PerformanceDebugHelper.mark(
                    f.EPerformanceMarkType.DrawMajorGridLinesEnd,
                    {
                      contextId: this.id,
                      parentContextId:
                        null === (o = this.parentSurface) || void 0 === o
                          ? void 0
                          : o.id,
                      relatedId:
                        null === (a = null == s ? void 0 : s.detail) ||
                        void 0 === a
                          ? void 0
                          : a.relatedId,
                      level: f.EPerformanceDebugLevel.Verbose,
                    }
                  );
              }, r);
            }
          }
          drawAxisBands(e, t, r, i) {
            if (!t || 0 === t.length) return;
            const { seriesViewRect: o } = this.parentSurface,
              a = this.isHorizontalAxis
                ? p.EXyDirection.XDirection
                : p.EXyDirection.YDirection;
            let s = this.offset,
              n = this.axisLength + this.offset;
            if (this.isAxisFlipped !== this.flippedCoordinates) {
              const e = n;
              (n = s), (s = e);
            }
            let l = this.getMajorTickIndex(t[0]) % 2 == 0;
            const d = (0, A.getVectorRectVertex)(this.webAssemblyContext2D),
              h = (e, t, r) => {
                if (!r) return;
                const i = (0, b.createNativeRect)(
                  this.webAssemblyContext2D,
                  a === p.EXyDirection.YDirection ? 0 : e,
                  a === p.EXyDirection.YDirection ? e : 0,
                  a === p.EXyDirection.YDirection ? o.width : t,
                  a === p.EXyDirection.YDirection ? t : o.height
                );
                d.push_back(i);
              };
            t.forEach((e, t) => {
              const i = 0 === t ? s : r[t - 1],
                o = r[t];
              h(i, o, l), (l = !l);
            }),
              h(n, r[t.length - 1], l),
              e.drawRects(d, i, this.parentSurface.clipRect, o.left, o.top);
          }
          drawGridLines(e, t, r, i) {
            if (!t || 0 === t.length) return;
            const { seriesViewRect: o } = this.parentSurface,
              a = (0, A.getVectorColorVertex)(this.webAssemblyContext2D),
              s = (0, A.getVertex)(this.webAssemblyContext2D, 0, 0);
            t.forEach((e) => {
              const t = this.isHorizontalAxis ? e : 0,
                r = this.isHorizontalAxis ? e : o.width,
                i = this.isHorizontalAxis ? 0 : e,
                n = this.isHorizontalAxis ? o.height : e;
              s.SetPosition(t, i),
                a.push_back(s),
                s.SetPosition(r, n),
                a.push_back(s);
            }),
              e.drawLinesNative(
                a,
                r,
                S.ELineDrawMode.DiscontinuousLine,
                this.parentSurface.clipRect,
                o.left,
                o.top
              );
          }
          getXVisibleRange(e) {
            return this.parentSurface.getXAxisById(e).visibleRange;
          }
          getIsXCategoryAxis(e) {
            return this.parentSurface.getXAxisById(e).isCategoryAxis;
          }
          getLabels(e) {
            return this.labelProvider.getLabels(e);
          }
          getXDataRange() {
            let e;
            return (
              this.parentSurface &&
                this.getVisibleRenderableSeriesByXAxis().forEach((t) => {
                  const r = t.getXRange();
                  r && (e = e ? e.union(r) : r);
                }),
              e
            );
          }
          notifyPropertyChanged(e) {
            e === L.PROPERTY.IS_XAXIS &&
              void 0 === this.axisAlignmentProperty &&
              (this.axisAlignmentProperty = this.isXAxisProperty
                ? d.EAxisAlignment.Bottom
                : d.EAxisAlignment.Right),
              e === L.PROPERTY.AXIS_RENDERER &&
                this.axisRendererProperty.attachedToAxis(this),
              super.notifyPropertyChanged(e);
          }
          getMaxXRange() {
            let e = this.getXDataRange();
            if (e)
              return (
                this.growBy && (e = e.growBy(this.growBy)),
                (e = this.applyVisibleRangeLimit(
                  null != e ? e : this.visibleRange
                )),
                (e = this.applyVisibleRangeSizeLimit(e)),
                e
              );
          }
          getAxisSize() {
            return this.axisLength;
          }
          getMajorTickIndex(e) {
            const t = e / this.majorDeltaProperty;
            return Math.round(t);
          }
          getTicks(e) {
            var t, r;
            if (e || !this.tickCache) {
              const e = this.getMaxAutoTicks();
              if (this.autoTicks) {
                const t = this.deltaCalculator.getDeltaFromRange(
                  this.visibleRange.min,
                  this.visibleRange.max,
                  this.minorsPerMajor,
                  e
                );
                (this.minorDeltaProperty = t.min),
                  (this.majorDeltaProperty = t.max);
              }
              let {
                  majorTickCoords: i,
                  minorTickCoords: o,
                  majorTickOverrides: a,
                  minorTickOverRides: s,
                } = this.tickCoordinatesProvider.getTickCoordinates(
                  void 0,
                  void 0
                ),
                n =
                  this.drawLabels ||
                  this.drawMajorGridLines ||
                  this.drawMajorTickLines
                    ? null != a
                      ? a
                      : this.tickProvider.getMajorTicks(
                          null !== (t = this.minorDeltaProperty) && void 0 !== t
                            ? t
                            : this.majorDeltaProperty / this.minorsPerMajor,
                          this.majorDeltaProperty,
                          this.visibleRange
                        )
                    : [],
                l =
                  this.drawMinorGridLines || this.drawMinorTickLines
                    ? null != s
                      ? s
                      : this.tickProvider.getMinorTicks(
                          null !== (r = this.minorDeltaProperty) && void 0 !== r
                            ? r
                            : this.majorDeltaProperty / this.minorsPerMajor,
                          this.majorDeltaProperty,
                          this.visibleRange
                        )
                    : [];
              const { min: d, max: h } = this.visibleRange;
              (n = n.filter((e) => e >= d && e <= h)),
                (l = l.filter((e) => e >= d && e <= h));
              let u = [];
              n.length > 1e3 && this.drawLabels
                ? console.warn(
                    "Axis settings result in more than 1000 labels.  Label drawing is disabled.  If using autoTicks: false, check that you have set sensible deltas."
                  )
                : (u = this.drawLabels ? this.getLabels(n) : []),
                (this.tickCache = {
                  majorTicks: n,
                  majorTickLabels: u,
                  majorTickCoords: i,
                  minorTicks: l,
                  minorTickCoords: o,
                });
            }
            return this.tickCache;
          }
          getTicksWithCoords() {
            if (
              (this.tickCache || this.getTicks(!0),
              void 0 === this.tickCache.majorTickCoords)
            ) {
              const { majorTickCoords: e, minorTickCoords: t } =
                this.tickCoordinatesProvider.getTickCoordinates(
                  this.tickCache.majorTicks,
                  this.tickCache.minorTicks
                );
              (this.tickCache.majorTickCoords = e),
                (this.tickCache.minorTickCoords = t);
            }
            return this.tickCache;
          }
          getPenForLines(e, t, r, i) {
            return (0, v.createPenInCache)(e, t, r, 1, i, !1);
          }
          applyVisibleRangeLimit(e) {
            if (!e) return;
            if (!this.visibleRangeLimit) return e;
            const t = e.clip(this.visibleRangeLimit);
            return t.min >= t.max
              ? (console.warn(
                  `Can not apply visibleRangeLimit for the ${
                    this.isXAxis ? "xAxis" : "yAxis"
                  } with ID ${this.id}`
                ),
                e)
              : t;
          }
          applyVisibleRangeSizeLimit(e) {
            if (!e) return;
            const t = Math.abs(e.min) / Math.pow(10, 14),
              r = e.diff;
            if (r < t) {
              const i = e.min + r / 2;
              return new n.NumberRange(i - t / 2, i + t / 2);
            }
            if (!this.visibleRangeSizeLimit) return e;
            if (r < 0)
              return (
                console.warn(
                  `Can not apply visibleRangeSizeLimit for the ${
                    this.isXAxis ? "xAxis" : "yAxis"
                  } with ID ${this.id}`
                ),
                e
              );
            {
              let t = e;
              const { min: i, max: o } = this.visibleRangeSizeLimit,
                a = e.min + r / 2;
              return (
                r < i
                  ? (t = new n.NumberRange(a - i / 2, a + i / 2))
                  : r > o && (t = new n.NumberRange(a - o / 2, a + o / 2)),
                t
              );
            }
          }
        }
        t.AxisBase2D = I;
      },
      42241: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisCore = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(3214),
          s = r(23866),
          n = r(98140),
          l = r(87108),
          d = r(12785),
          h = r(63415),
          u = r(52578),
          c = r(73538),
          p = r(72934),
          g = r(14184),
          y = r(86127),
          f = r(8900),
          v = r(83989);
        class m extends i.DeletableEntity {
          constructor(e) {
            var t, r, i, o, s, p, y, f, v, m, S, P, C, b, x, A, T, E, R;
            super(),
              (this.visibleRangeChanged = new a.EventHandler()),
              (this.isMeasured = !1),
              (this.ZeroRangeGrowBy = 0.01),
              (this.isXAxisProperty = !0),
              (this.minorsPerMajorProperty = 5),
              (this.drawMajorGridLinesProperty = !0),
              (this.drawMinorGridLinesProperty = !0),
              (this.drawMajorTickLinesProperty = !0),
              (this.drawMinorTickLinesProperty = !0),
              (this.drawMajorBandsProperty = !0),
              (this.drawLabelsProperty = !0),
              (this.flippedCoordinatesProperty = !1),
              (this.tickTextBrushProperty =
                g.SciChartSurfaceBase.DEFAULT_THEME.tickTextBrush),
              (this.axisBandsFillProperty =
                g.SciChartSurfaceBase.DEFAULT_THEME.axisBandsFill),
              (this.autoRangeProperty = d.EAutoRange.Once),
              (this.majorTickLineStyleProperty = {
                tickSize: 5,
                strokeThickness: 1,
                color: g.SciChartSurfaceBase.DEFAULT_THEME.majorGridLineBrush,
              }),
              (this.minorTickLineStyleProperty = {
                tickSize: 3,
                strokeThickness: 1,
                color: g.SciChartSurfaceBase.DEFAULT_THEME.minorGridLineBrush,
              }),
              (this.majorGridLineStyleProperty = {
                strokeThickness: 1,
                color: g.SciChartSurfaceBase.DEFAULT_THEME.majorGridLineBrush,
                strokeDashArray: void 0,
              }),
              (this.minorGridLineStyleProperty = {
                strokeThickness: 1,
                color: g.SciChartSurfaceBase.DEFAULT_THEME.minorGridLineBrush,
                strokeDashArray: void 0,
              }),
              (this.axisTitleStyleProperty = {
                fontSize: 24,
                fontFamily: u.DEFAULT_FONT_FAMILY,
                color: g.SciChartSurfaceBase.DEFAULT_THEME.axisTitleColor,
                fontStyle: "normal",
                fontWeight: "normal",
                padding: l.Thickness.fromNumber(6),
                alignment: h.ELabelAlignment.Center,
              }),
              (this.isVisibleProperty = !0),
              (this.autoTicksProperty = !0),
              (this.maxAutoTicksProperty = 10),
              (this.defaultVisibleRange = new n.NumberRange(0, 10)),
              (this.allowFastMathProperty = !1),
              (this.hasVisibleRangeSet = !1),
              (this.visibleRange =
                n.NumberRange.hydrate(null == e ? void 0 : e.visibleRange) ||
                this.defaultVisibleRange),
              (null == e ? void 0 : e.visibleRange) ||
                (this.hasVisibleRangeSet = !1),
              (this.id =
                null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                  ? t
                  : (0, c.generateGuid)()),
              (this.growBy =
                null !==
                  (r = n.NumberRange.hydrate(null == e ? void 0 : e.growBy)) &&
                void 0 !== r
                  ? r
                  : this.growBy),
              (this.autoRange =
                null !== (i = null == e ? void 0 : e.autoRange) && void 0 !== i
                  ? i
                  : this.autoRange),
              (this.isVisible =
                null !== (o = null == e ? void 0 : e.isVisible) && void 0 !== o
                  ? o
                  : this.isVisible),
              (this.axisTitle =
                null !== (s = null == e ? void 0 : e.axisTitle) && void 0 !== s
                  ? s
                  : this.axisTitle),
              (this.axisTitleStyle = null == e ? void 0 : e.axisTitleStyle),
              (this.allowFastMath =
                null !== (p = null == e ? void 0 : e.allowFastMath) &&
                void 0 !== p
                  ? p
                  : this.allowFastMathProperty),
              (this.autoTicksProperty =
                null !== (y = null == e ? void 0 : e.autoTicks) && void 0 !== y
                  ? y
                  : this.autoTicksProperty),
              (this.maxAutoTicksProperty =
                null !== (f = null == e ? void 0 : e.maxAutoTicks) &&
                void 0 !== f
                  ? f
                  : this.maxAutoTicksProperty),
              (this.minorsPerMajorProperty =
                null !== (v = null == e ? void 0 : e.minorsPerMajor) &&
                void 0 !== v
                  ? v
                  : this.minorsPerMajorProperty),
              (this.majorDeltaProperty =
                null !== (m = null == e ? void 0 : e.majorDelta) && void 0 !== m
                  ? m
                  : this.majorDeltaProperty),
              (this.minorDeltaProperty =
                null !== (S = null == e ? void 0 : e.minorDelta) && void 0 !== S
                  ? S
                  : this.minorDeltaProperty),
              (this.drawLabelsProperty =
                null !== (P = null == e ? void 0 : e.drawLabels) && void 0 !== P
                  ? P
                  : this.drawLabelsProperty),
              (this.drawMajorTickLinesProperty =
                null !== (C = null == e ? void 0 : e.drawMajorTickLines) &&
                void 0 !== C
                  ? C
                  : this.drawMajorTickLinesProperty),
              (this.drawMinorTickLinesProperty =
                null !== (b = null == e ? void 0 : e.drawMinorTickLines) &&
                void 0 !== b
                  ? b
                  : this.drawMinorTickLinesProperty),
              (this.drawMinorGridLinesProperty =
                null !== (x = null == e ? void 0 : e.drawMinorGridLines) &&
                void 0 !== x
                  ? x
                  : this.drawMinorGridLinesProperty),
              (this.drawMajorGridLinesProperty =
                null !== (A = null == e ? void 0 : e.drawMajorGridLines) &&
                void 0 !== A
                  ? A
                  : this.drawMajorGridLinesProperty),
              (this.majorGridLineStyle =
                null == e ? void 0 : e.majorGridLineStyle),
              (this.minorGridLineStyle =
                null == e ? void 0 : e.minorGridLineStyle),
              (this.majorTickLineStyle =
                null == e ? void 0 : e.majorTickLineStyle),
              (this.minorTickLineStyle =
                null == e ? void 0 : e.minorTickLineStyle),
              (this.drawMajorBandsProperty =
                null !== (T = null == e ? void 0 : e.drawMajorBands) &&
                void 0 !== T
                  ? T
                  : this.drawMajorBandsProperty),
              (this.axisBandsFillProperty =
                null !== (E = null == e ? void 0 : e.axisBandsFill) &&
                void 0 !== E
                  ? E
                  : this.axisBandsFillProperty),
              (this.flippedCoordinatesProperty =
                null !== (R = null == e ? void 0 : e.flippedCoordinates) &&
                void 0 !== R
                  ? R
                  : this.flippedCoordinatesProperty),
              (this.getCurrentCoordinateCalculator =
                this.getCurrentCoordinateCalculator.bind(this));
          }
          get isCategoryAxis() {
            return !1;
          }
          get isXAxis() {
            return this.isXAxisProperty;
          }
          get allowFastMath() {
            return this.allowFastMathProperty;
          }
          set allowFastMath(e) {
            (this.allowFastMathProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.ALLOW_FAST_MATH);
          }
          hasValidVisibleRange() {
            return (
              void 0 !== this.visibleRange &&
              !(0 === this.visibleRange.diff) &&
              (0, p.isRealNumber)(this.visibleRange.max) &&
              (0, p.isRealNumber)(this.visibleRange.min)
            );
          }
          hasDefaultVisibleRange() {
            return !this.hasVisibleRangeSet;
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            (this.isVisibleProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.IS_VISIBLE);
          }
          get growBy() {
            return this.growByProperty;
          }
          set growBy(e) {
            (this.growByProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.GROW_BY);
          }
          get visibleRange() {
            return this.visibleRangeProperty;
          }
          set visibleRange(e) {
            var t;
            (this.hasVisibleRangeSet = !0),
              (null === (t = this.visibleRangeProperty) || void 0 === t
                ? void 0
                : t.equals(e)) ||
                ((this.visibleRangeProperty = e),
                this.clearCoordCalcCache(),
                this.visibleRangeChanged.raiseEvent(
                  new v.VisibleRangeChangedArgs(e)
                ),
                this.notifyPropertyChanged(f.PROPERTY.VISIBLE_RANGE));
          }
          get animatedVisibleRange() {
            return this.visibleRangeAnimationToken
              ? this.visibleRangeAnimationToken.to
              : this.visibleRange;
          }
          get majorDelta() {
            return this.majorDeltaProperty;
          }
          set majorDelta(e) {
            (this.majorDeltaProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.MAJOR_DELTA);
          }
          get minorDelta() {
            return this.minorDeltaProperty;
          }
          set minorDelta(e) {
            (this.minorDeltaProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.MINOR_DELTA);
          }
          get minorsPerMajor() {
            return this.minorsPerMajorProperty;
          }
          set minorsPerMajor(e) {
            (this.minorsPerMajorProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.MINORS_PER_MAJOR);
          }
          get textFormatting() {
            return this.textFormattingProperty;
          }
          set textFormatting(e) {
            (this.textFormattingProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.TEXT_FORMATTING);
          }
          get cursorTextFormatting() {
            return this.cursorTextFormattingProperty;
          }
          set cursorTextFormatting(e) {
            (this.cursorTextFormattingProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.CURSOR_TEXT_FORMATTING);
          }
          get drawMajorGridLines() {
            return this.drawMajorGridLinesProperty;
          }
          set drawMajorGridLines(e) {
            (this.drawMajorGridLinesProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_MAJOR_GRID_LINES);
          }
          get drawMinorGridLines() {
            return this.drawMinorGridLinesProperty;
          }
          set drawMinorGridLines(e) {
            (this.drawMinorGridLinesProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_MINOR_GRID_LINES);
          }
          get drawMajorTickLines() {
            return this.drawMajorTickLinesProperty;
          }
          set drawMajorTickLines(e) {
            (this.drawMajorTickLinesProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_MAJOR_TICK_LINES);
          }
          get drawMinorTickLines() {
            return this.drawMinorTickLinesProperty;
          }
          set drawMinorTickLines(e) {
            (this.drawMinorTickLinesProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_MINOR_TICK_LINES);
          }
          get drawMajorBands() {
            return this.drawMajorBandsProperty;
          }
          set drawMajorBands(e) {
            (this.drawMajorBandsProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_MAJOR_BANDS);
          }
          get drawLabels() {
            return this.drawLabelsProperty;
          }
          set drawLabels(e) {
            (this.drawLabelsProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DRAW_LABELS);
          }
          get flippedCoordinates() {
            return this.flippedCoordinatesProperty;
          }
          set flippedCoordinates(e) {
            this.flippedCoordinatesProperty !== e &&
              ((this.flippedCoordinatesProperty = e),
              this.clearCoordCalcCache(),
              this.notifyPropertyChanged(f.PROPERTY.FLIPPED_COORDINATES));
          }
          get axisBandsFill() {
            return this.axisBandsFillProperty;
          }
          set axisBandsFill(e) {
            (this.axisBandsFillProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_BANDS_FILL);
          }
          get autoRange() {
            return this.autoRangeProperty;
          }
          set autoRange(e) {
            (this.autoRangeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AUTO_RANGE);
          }
          get majorTickLineStyle() {
            return this.majorTickLineStyleProperty;
          }
          set majorTickLineStyle(e) {
            (this.majorTickLineStyleProperty = Object.assign(
              Object.assign({}, this.majorTickLineStyle),
              e
            )),
              this.notifyPropertyChanged(f.PROPERTY.MAJOR_TICK_LINE_STYLE);
          }
          get minorTickLineStyle() {
            return this.minorTickLineStyleProperty;
          }
          set minorTickLineStyle(e) {
            (this.minorTickLineStyleProperty = Object.assign(
              Object.assign({}, this.minorTickLineStyle),
              e
            )),
              this.notifyPropertyChanged(f.PROPERTY.MINOR_TICK_LINE_STYLE);
          }
          get majorGridLineStyle() {
            return this.majorGridLineStyleProperty;
          }
          set majorGridLineStyle(e) {
            (this.majorGridLineStyleProperty = Object.assign(
              Object.assign({}, this.majorGridLineStyle),
              e
            )),
              this.notifyPropertyChanged(f.PROPERTY.MAJOR_GRID_LINE_STYLE);
          }
          get minorGridLineStyle() {
            return this.minorGridLineStyleProperty;
          }
          set minorGridLineStyle(e) {
            (this.minorGridLineStyleProperty = Object.assign(
              Object.assign({}, this.minorGridLineStyle),
              e
            )),
              this.notifyPropertyChanged(f.PROPERTY.MINOR_GRID_LINE_STYLE);
          }
          get dpiAdjustedAxisTitleStyle() {
            return y.DpiHelper.adjustTextStyle(this.axisTitleStyleProperty);
          }
          get axisTitleStyle() {
            return this.axisTitleStyleProperty;
          }
          set axisTitleStyle(e) {
            (this.axisTitleStyleProperty = Object.assign(
              Object.assign({}, this.axisTitleStyle),
              e
            )),
              this.notifyPropertyChanged(f.PROPERTY.TEXT_STYLE);
          }
          get axisTitle() {
            return this.axisTitleProperty;
          }
          set axisTitle(e) {
            (this.axisTitleProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AXIS_TITLE);
          }
          get tickProvider() {
            return this.tickProviderProperty;
          }
          set tickProvider(e) {
            var t;
            null === (t = this.tickProviderProperty) ||
              void 0 === t ||
              t.detachedFromAxis(),
              (this.tickProviderProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.TICK_PROVIDER);
          }
          get labelProvider() {
            return this.labelProviderProperty;
          }
          set labelProvider(e) {
            var t;
            null === (t = this.labelProviderProperty) ||
              void 0 === t ||
              t.detachedFromAxis(),
              (this.labelProviderProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.LABEL_PROVIDER);
          }
          get deltaCalculator() {
            return this.deltaCalculatorProperty;
          }
          set deltaCalculator(e) {
            var t;
            null === (t = this.deltaCalculator) ||
              void 0 === t ||
              t.detachedFromAxis(),
              (this.deltaCalculatorProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DELTA_CALCULATOR);
          }
          get tickCoordinatesProvider() {
            return this.tickCoordinatesProviderProperty;
          }
          set tickCoordinatesProvider(e) {
            var t;
            null === (t = this.tickCoordinatesProviderProperty) ||
              void 0 === t ||
              t.detachedFromAxis(),
              (this.tickCoordinatesProviderProperty = e),
              this.notifyPropertyChanged(
                f.PROPERTY.TICK_COORDINATES_CALCULATOR
              );
          }
          get maxAutoTicks() {
            return this.maxAutoTicksProperty;
          }
          set maxAutoTicks(e) {
            (this.maxAutoTicksProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.MAX_AUTO_TICKS);
          }
          get autoTicks() {
            return this.autoTicksProperty;
          }
          set autoTicks(e) {
            (this.autoTicksProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.AUTO_TICKS);
          }
          getCurrentCoordinateCalculator() {
            return (
              this.coordCalcCache &&
                this.coordCalcCache.viewportDimension !== this.getAxisSize() &&
                this.clearCoordCalcCache(),
              this.coordCalcCache ||
                (this.coordCalcCache =
                  this.getCurrentCoordinateCalculatorInternal()),
              this.coordCalcCache
            );
          }
          clearCoordCalcCache() {
            this.coordCalcCache = (0, o.deleteSafe)(this.coordCalcCache);
          }
          delete() {
            (this.deltaCalculator = void 0),
              (this.tickProvider = void 0),
              (this.tickCoordinatesProvider = void 0),
              (this.labelProviderProperty = (0, o.deleteSafe)(
                this.labelProvider
              )),
              (this.coordCalcCache = (0, o.deleteSafe)(this.coordCalcCache));
          }
          isValidRange(e) {
            return !(!e || !e.isDefined() || e.min > e.max);
          }
          get isVerticalChart() {
            return !1;
          }
          get isHorizontalAxis() {
            return this.isXAxis;
          }
          setIsXAxis(e) {
            (this.isXAxisProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.IS_XAXIS);
          }
          coerceZeroVisibleRange(e) {
            return (
              s.Guard.notNull(e, "range"),
              e.isZero()
                ? 0 === e.min
                  ? new n.NumberRange(-1, 1)
                  : e.growBy(
                      new n.NumberRange(
                        this.ZeroRangeGrowBy,
                        this.ZeroRangeGrowBy
                      )
                    )
                : e
            );
          }
          notifyPropertyChanged(e) {
            var t, r, i, o;
            e === f.PROPERTY.DELTA_CALCULATOR &&
              (null === (t = this.deltaCalculator) ||
                void 0 === t ||
                t.attachedToAxis(this)),
              e === f.PROPERTY.TICK_PROVIDER &&
                (null === (r = this.tickProvider) ||
                  void 0 === r ||
                  r.attachedToAxis(this)),
              e === f.PROPERTY.LABEL_PROVIDER &&
                (null === (i = this.labelProvider) ||
                  void 0 === i ||
                  i.attachedToAxis(this)),
              e === f.PROPERTY.TICK_COORDINATES_CALCULATOR &&
                (null === (o = this.tickCoordinatesProvider) ||
                  void 0 === o ||
                  o.attachedToAxis(this)),
              this.isMeasured &&
                this.invalidateParentCallback &&
                this.invalidateParentCallback();
          }
          getMaxAutoTicks() {
            return Math.max(1, this.maxAutoTicks);
          }
        }
        t.AxisCore = m;
      },
      87673: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarAxisLayoutState = t.AxisLayoutState = void 0);
        class r {
          constructor() {
            (this.axisSize = 0),
              (this.additionalLeftSize = 0),
              (this.additionalRightSize = 0),
              (this.additionalTopSize = 0),
              (this.additionalBottomSize = 0);
          }
          clear() {
            (this.axisSize = 0),
              (this.additionalLeftSize = 0),
              (this.additionalRightSize = 0),
              (this.additionalTopSize = 0),
              (this.additionalBottomSize = 0);
          }
        }
        (t.AxisLayoutState = r),
          (t.PolarAxisLayoutState = class extends r {
            constructor() {
              super(...arguments),
                (this.leftScale = -1),
                (this.rightScale = 1),
                (this.topScale = 1),
                (this.bottomScale = -1);
            }
            clear() {
              (this.leftScale = -1),
                (this.rightScale = 1),
                (this.topScale = 1),
                (this.bottomScale = -1);
            }
          });
      },
      74736: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.layoutLabelsHelper = t.AxisRenderer = void 0);
        const i = r(84745),
          o = r(55023),
          a = r(56744),
          s = r(87459),
          n = r(87108),
          l = r(38215),
          d = r(63415),
          h = r(36420),
          u = r(9254),
          c = r(48008),
          p = r(16185),
          g = r(63458),
          y = r(98353),
          f = r(14184),
          v = r(86127),
          m = r(76829);
        class S extends o.DeletableEntity {
          constructor(e) {
            super(),
              (this.viewRect = s.Rect.createZero()),
              (this.drawDebug = !1),
              (this.desiredLabelsSize = 0),
              (this.desiredTicksSize = 0),
              (this.desiredHeightProperty = 0),
              (this.desiredWidthProperty = 0),
              (this.axisThicknessProperty = 0),
              (this.keepLabelsWithinAxisProperty = !0),
              (this.hideOverlappingLabelsProperty = !0),
              (this.webAssemblyContext = e),
              (this.textureManager = new m.TextureManager(e)),
              i.IS_TEST_ENV ||
                ((this.measureTextCanvas = document.createElement("canvas")),
                (this.measureTextCanvas.width = 1),
                (this.measureTextCanvas.height = 1));
          }
          delete() {
            (this.webAssemblyContext = void 0),
              (this.measureTextCanvas = void 0),
              (this.parentAxis = void 0),
              (this.textureManager = (0, a.deleteSafe)(this.textureManager));
          }
          attachedToAxis(e) {
            this.parentAxis = e;
          }
          measure(e, t, r, i, o, a, s) {
            f.DebugForDpi &&
              console.log(`AxisRenderer.measure. fontSize: ${t.fontSize}`),
              (this.desiredLabelsSize = a
                ? this.calcDesiredLabelsSize(e, o, t, r)
                : 0),
              (this.desiredTicksSize = s ? i : 0);
            const n =
              Math.max(
                this.desiredLabelsSize,
                this.axisThicknessProperty * v.DpiHelper.PIXEL_RATIO
              ) + this.desiredTicksSize;
            e
              ? (this.desiredHeightProperty = n)
              : (this.desiredWidthProperty = n);
          }
          calcDesiredLabelsSize(e, t, r, o) {
            if (i.IS_TEST_ENV) return 0;
            let a;
            const s = this.measureTextCanvas.getContext("2d");
            return (
              (a = e
                ? t.getMaxLabelHeightForHorizontalAxis(o, s, r)
                : t.getMaxLabelWidthForVerticalAxis(o, s, r)),
              a
            );
          }
          get desiredHeight() {
            return this.desiredHeightProperty;
          }
          set desiredHeight(e) {
            this.desiredHeightProperty = e;
          }
          get desiredWidth() {
            return this.desiredWidthProperty;
          }
          set desiredWidth(e) {
            this.desiredWidthProperty = e;
          }
          get keepLabelsWithinAxis() {
            return this.keepLabelsWithinAxisProperty;
          }
          set keepLabelsWithinAxis(e) {
            (this.keepLabelsWithinAxisProperty = e), this.invalidateParent();
          }
          get hideOverlappingLabels() {
            return this.hideOverlappingLabelsProperty;
          }
          set hideOverlappingLabels(e) {
            (this.hideOverlappingLabelsProperty = e), this.invalidateParent();
          }
          get axisThickness() {
            return this.axisThicknessProperty;
          }
          set axisThickness(e) {
            (this.axisThicknessProperty = e), this.invalidateParent();
          }
          layout(e) {
            this.viewRect = e;
          }
          getClipRect() {
            return this.parentAxis.parentSurface.clipRect;
          }
          drawLabels(e, t, r, i, o, a, n, d, p, g) {
            f.DebugForDpi &&
              console.log(`AxisRenderer.drawLabels. fontSize: ${n.fontSize}`);
            const { viewRect: v, textureManager: m } = this,
              S = e.getNativeContext(),
              P = d ? (0, l.getIsHorizontal)(t) : (0, l.getIsVertical)(t),
              C = Math.floor(v.width),
              b = Math.floor(v.height),
              x = this.desiredTicksSize;
            let A;
            const { padding: T, alignment: E, multilineAlignment: R } = n;
            P && ((o = o.reverse()), (i = i.reverse()));
            const D = [],
              w = (0, c.parseColorToUIntArgb)(n.color),
              M = g.useNativeText ? e.getFont(n, 0 !== g.rotation) : null,
              L = g.useNativeText
                ? (0, y.getTextBounds)(this.webAssemblyContext)
                : null;
            M || (A = m.getTextureContext(C, b));
            let O = g.rotation;
            O > 90 ? (O -= 180) : O < -90 && (O += 180);
            const I = (-O * Math.PI) / 180;
            o = o.map((e) => e - a);
            const k = (0, h.convertMultiLineAlignment)(
                R,
                this.webAssemblyContext
              ),
              _ = g.lineSpacing;
            let V = 0;
            M &&
              (M.CalculateStringBounds("Ag", L, 0),
              (V = L.GetLineBounds(0).m_fHeight));
            const N = this.getClipRect();
            if ((0, l.getIsHorizontal)(t)) {
              let e = [],
                a = [];
              if (!g.useCache && g.useNativeText)
                for (const t of i)
                  M.CalculateStringBounds(null != t ? t : "", L, 2),
                    e.push(L.m_fHeight + n.padding.top + n.padding.bottom),
                    a.push(L.m_fWidth + n.padding.left + n.padding.right);
              else
                (e = i.map((e) => g.getLabelHeight(A, e, n))),
                  (a = i.map((e) => g.getLabelWidth(A, e, n)));
              const { labelCoords: d, labelIndexes: h } = this.layoutLabels(
                C,
                o,
                a,
                p,
                null == T ? void 0 : T.top,
                null == T ? void 0 : T.bottom
              );
              for (let c = 0; c < h.length; c++) {
                const p = d[c];
                let f = i[h[c]];
                const P = e[h[c]],
                  C = a[h[c]];
                let A = 0;
                (t === l.EAxisAlignment.Bottom && !r) ||
                (t === l.EAxisAlignment.Top && r)
                  ? (A += x)
                  : (A += b - P - x),
                  this.drawDebug && D.push(s.Rect.create(p, A, C, P));
                try {
                  if (M) {
                    let e = p + v.left + T.left,
                      t = A + v.top + V + T.top,
                      r = e,
                      i = t - V;
                    if (0 !== I) {
                      const { textWidth: t, textHeight: i } =
                        g.getNativeLabelInfo(f);
                      (e = o[h[c]] + v.left - (i * Math.sin(I)) / 2),
                        (r = e),
                        I > 0 && (e -= t);
                    }
                    const {
                      text: a,
                      x: s,
                      y: n,
                      rx: l,
                      ry: d,
                      rotationRadians: u,
                      color: m,
                    } = g.adjustLabel(c, f, C, P, e, t, r, i, I);
                    M.DrawStringAdvanced(
                      null != a ? a : "",
                      null != m ? m : w,
                      Math.round(s),
                      Math.round(n),
                      (0, y.getVector4)(this.webAssemblyContext, l, d, u, 0),
                      k,
                      _
                    );
                  } else {
                    const {
                      bitmapTexture: e,
                      textureHeight: t,
                      textureWidth: r,
                    } = g.getCachedLabelTexture(f, m, n);
                    if (e) {
                      S.PushState(), S.SetClipRect(N.x, N.y, N.width, N.height);
                      const { x: i, y: o } = g.adjustLabel(
                        c,
                        f,
                        C,
                        P,
                        p + v.left,
                        A + v.top,
                        0,
                        0,
                        0
                      );
                      S.DrawTexture(e, Math.round(i), Math.round(o), r, t),
                        S.PopState(),
                        g.useCache || e.delete();
                    }
                  }
                } catch (e) {
                  u.Logger.debug(e), g.delete();
                }
              }
            } else {
              let e = [],
                a = [];
              if (!g.useCache && g.useNativeText)
                for (const t of i)
                  M.CalculateStringBounds(null != t ? t : "", L, 2),
                    e.push(L.m_fHeight + n.padding.top + n.padding.bottom),
                    a.push(L.m_fWidth + n.padding.left + n.padding.right);
              else
                (e = i.map((e) => g.getLabelHeight(A, e, n))),
                  (a = i.map((e) => g.getLabelWidth(A, e, n)));
              const { labelCoords: l, labelIndexes: d } = this.layoutLabels(
                b,
                o,
                e,
                p,
                null == T ? void 0 : T.left,
                null == T ? void 0 : T.right
              );
              for (let o = 0; o < d.length; o++) {
                let h = 0;
                const c = i[d[o]],
                  p = a[d[o]],
                  f = e[d[o]];
                h = this.adjustForLabelAlignment(h, p, E, t, r, C, x);
                const P = l[o];
                this.drawDebug && D.push(s.Rect.create(h, P, p, f));
                try {
                  if (M) {
                    const e = h + v.left + T.left,
                      t = P + v.top + V + T.top,
                      {
                        text: r,
                        x: i,
                        y: a,
                        rx: s,
                        ry: n,
                        rotationRadians: l,
                        color: d,
                      } = g.adjustLabel(o, c, p, f, e, t, e, t, I);
                    M.DrawStringAdvanced(
                      null != r ? r : "",
                      null != d ? d : w,
                      Math.round(i),
                      Math.round(a),
                      (0, y.getVector4)(this.webAssemblyContext, s, n, l, 0),
                      k,
                      _
                    );
                  } else {
                    const {
                      bitmapTexture: e,
                      textureHeight: t,
                      textureWidth: r,
                    } = g.getCachedLabelTexture(c, m, n);
                    if (e) {
                      S.PushState(), S.SetClipRect(N.x, N.y, N.width, N.height);
                      const { x: i, y: a } = g.adjustLabel(
                        o,
                        c,
                        p,
                        f,
                        h + v.left,
                        P + v.top,
                        0,
                        0,
                        0
                      );
                      S.DrawTexture(e, Math.round(i), Math.round(a), r, t),
                        S.PopState(),
                        g.useCache || e.delete();
                    }
                  }
                } catch (e) {
                  u.Logger.debug(e), g.delete();
                }
              }
            }
            this.drawDebug && this.drawLabelViewRects(e, v, D);
          }
          adjustForLabelAlignment(e, t, r, i, o, a, s) {
            const n = a - s - t;
            return (
              (i === l.EAxisAlignment.Left && !o) ||
              (i === l.EAxisAlignment.Right && o)
                ? r === d.ELabelAlignment.Right || r === d.ELabelAlignment.Auto
                  ? (e += n)
                  : r === d.ELabelAlignment.Center && (e += n / 2)
                : r === d.ELabelAlignment.Left || r === d.ELabelAlignment.Auto
                ? (e += s)
                : r === d.ELabelAlignment.Center
                ? (e += s + n / 2)
                : (e += a - t),
              e
            );
          }
          layoutLabels(e, r, i, o, a, s) {
            return (0, t.layoutLabelsHelper)(
              this.keepLabelsWithinAxis,
              this.hideOverlappingLabels,
              e,
              r,
              i,
              o
            );
          }
          drawTicks(e, t, r, i, o, a, s) {
            if (!i || 0 === i.length) return;
            const { viewRect: n } = this,
              { tickSize: d } = s,
              h = (0, y.getVectorColorVertex)(this.webAssemblyContext),
              u = (0, l.getIsHorizontal)(t),
              c = (0, y.getVertex)(this.webAssemblyContext, 0, 0);
            if (void 0 === u) return;
            i.forEach((e) => {
              let i, o, a, s;
              r
                ? u
                  ? ((i = e),
                    (o = e),
                    (a = t === l.EAxisAlignment.Top ? 0 : n.height),
                    (s = t === l.EAxisAlignment.Top ? d : n.height - d))
                  : ((i = t === l.EAxisAlignment.Left ? 0 : n.width),
                    (o = t === l.EAxisAlignment.Left ? d : n.width - d),
                    (a = e),
                    (s = e))
                : u
                ? ((i = e),
                  (o = e),
                  (a = t === l.EAxisAlignment.Bottom ? 0 : n.height),
                  (s = t === l.EAxisAlignment.Bottom ? d : n.height - d))
                : ((i = t === l.EAxisAlignment.Right ? 0 : n.width),
                  (o = t === l.EAxisAlignment.Right ? d : n.width - d),
                  (a = e),
                  (s = e)),
                c.SetPosition(i, a),
                h.push_back(c),
                c.SetPosition(o, s),
                h.push_back(c);
            });
            const g = n.left - (u ? o : 0),
              f = n.top - (u ? 0 : o);
            e.drawLinesNative(
              h,
              a,
              p.ELineDrawMode.DiscontinuousLine,
              this.getClipRect(),
              g,
              f
            );
          }
          drawModifiersAxisLabel(e, t, r, i, o, a) {
            if (!t) return;
            const d = e.getNativeContext(),
              {
                bitmapTexture: h,
                textureHeight: u,
                textureWidth: c,
              } = this.textureManager.createSimpleTextTexture(
                t,
                Object.assign(Object.assign({}, o), {
                  padding: new n.Thickness(2, 2, 2, 2),
                }),
                a
              ),
              p = {
                height: this.parentAxis.parentSurface.domCanvas2D.height,
                width: this.parentAxis.parentSurface.domCanvas2D.width,
              },
              g = (e, t, r, i) =>
                e + t < i / 2 ? 0 : e + t > r - i / 2 ? r - i : e + t - i / 2,
              y = this.parentAxis.offset;
            let f, v;
            return (
              i === l.EAxisAlignment.Bottom
                ? ((f = g(this.viewRect.x - y, r, p.width, c)),
                  (v = this.viewRect.y),
                  p.height - v < u && (v = p.height - u))
                : i === l.EAxisAlignment.Top
                ? ((f = g(this.viewRect.x - y, r, p.width, c)),
                  (v = this.viewRect.y + this.viewRect.height - u),
                  this.parentAxis.axisLayoutState.axisSize - this.viewRect.y <
                    u && (v = 0))
                : i === l.EAxisAlignment.Left
                ? ((f = this.viewRect.x + this.viewRect.width - c),
                  (v = g(this.viewRect.y - y, r, p.height, u)),
                  this.parentAxis.axisLayoutState.axisSize + this.viewRect.x <
                    c && (f = 0))
                : i === l.EAxisAlignment.Right &&
                  ((f = this.viewRect.x),
                  (v = g(this.viewRect.y - y, r, p.height, u)),
                  p.width - f < c && (f = p.width - c)),
              d.DrawTexture(h, Math.round(f), Math.round(v), c, u),
              h.delete(),
              new s.Rect(f, v, c, u)
            );
          }
          createAxisMarker(e, t, r, i, o) {
            const {
              fontStyle: a,
              fontWeight: s,
              fontSize: n,
              fontFamily: l,
              color: d,
            } = r;
            return this.textureManager.createAxisMarkerTexture(
              e,
              t,
              a,
              s,
              n,
              l,
              d,
              2 * v.DpiHelper.PIXEL_RATIO,
              i,
              o
            );
          }
          createAxisMarkerFromImage(e, t, r) {
            return this.textureManager.createTextureFromImage(e, t, r);
          }
          createAnnotationLabelTexture(e, t, r, i, o, a) {
            return this.textureManager.createSimpleTextTexture(
              e,
              t,
              r,
              i,
              o,
              a
            );
          }
          invalidateParent() {
            this.parentAxis &&
              this.parentAxis.invalidateParentCallback &&
              this.parentAxis.invalidateParentCallback();
          }
          drawLabelViewRects(e, t, r) {
            const i = (0, y.getVectorRectVertex)(this.webAssemblyContext),
              o = new this.webAssemblyContext.SCRTSolidBrush(
                (0, c.parseColorToUIntArgb)("rgba(30,30,255,0.7)"),
                !1
              );
            for (const e of r) {
              const t = (0, g.createNativeRect)(
                this.webAssemblyContext,
                e.left,
                e.top,
                e.right,
                e.bottom
              );
              i.push_back(t);
            }
            e.drawRects(i, o, this.getClipRect(), t.left, t.top), o.delete();
          }
        }
        (t.AxisRenderer = S),
          (t.layoutLabelsHelper = (e, t, r, i, o, a) => {
            const s = [],
              n = [],
              l = o.length,
              d = (e) => (a ? i[l - 1 - e] : i[e]),
              h = (e) => (a ? o[l - 1 - e] : o[e]);
            let u = 0;
            for (let i = 0; i < l; i++) {
              const o = 0 === i,
                p = i === l - 1,
                g = h(i),
                y = Math.ceil(g / 2);
              let f = d(i),
                v = 0;
              if (e && o) {
                f > y ? ((v = f + y), (f -= y)) : ((f = 0), (v = f + g));
                const e = d(1),
                  r = h(1) / 2;
                if (t && v >= e - r - 0) continue;
              } else
                e && p
                  ? (f = f + y < r ? f - y : r - g)
                  : ((v = f + y), (f -= y));
              (t && i > 0 && f < u + 0) ||
                ((u = v),
                s.push(f),
                (c = i),
                a ? n.push(l - 1 - c) : n.push(c));
            }
            var c;
            return { labelCoords: s, labelIndexes: n };
          });
      },
      14790: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AxisTitleRenderer = void 0);
        const i = r(87108),
          o = r(63415),
          a = r(71238),
          s = r(24156);
        class n extends s.TitleRendererBase {
          constructor() {
            super(...arguments), (this.lineSpacing = 1.1);
          }
          measure(e = "", t, r) {
            if (
              ((this.text = e),
              !this.useCache ||
                (!this.texture && !this.useNativeText) ||
                this.text !== this.previousText ||
                this.lineSpacing !== this.previousLineSpacing ||
                r !== this.previousAxisAlignment ||
                this.previousNativeTextMode !== this.useNativeText ||
                !l(t, this.textStyle))
            ) {
              this.invalidateCache(),
                (this.previousLineSpacing = this.lineSpacing),
                (this.previousNativeTextMode = this.useNativeText),
                (this.previousAxisAlignment = r),
                (this.previousText = e),
                (this.textStyle = t),
                (this.titlePosition = a.ETitlePosition[r]),
                (this.textStyle = t),
                (this.textStyle.lineSpacing = this.lineSpacing);
              const i = this.parentSurface.currentWebGlRenderContext;
              this.getTextSize(e, this.textStyle, i);
            }
          }
          get useNativeText() {
            return this.useNativeTextProperty;
          }
          set useNativeText(e) {
            this.useNativeTextProperty = e;
          }
          get desiredHeight() {
            return this.desiredHeightProperty;
          }
          set desiredHeight(e) {
            this.desiredWidthProperty !== e && this.invalidateCache(),
              (this.desiredHeightProperty = e);
          }
          get desiredWidth() {
            return this.desiredWidthProperty;
          }
          set desiredWidth(e) {
            this.desiredWidthProperty !== e && this.invalidateCache(),
              (this.desiredWidthProperty = e);
          }
          layout(e) {
            if (!this.text) return void (this.viewRectProperty = e);
            const t = d(this.textStyle.alignment);
            this.viewRectProperty = this.getViewRect(
              this.text,
              e,
              this.titlePosition,
              t
            );
          }
          getTitleTexture() {
            const e = this.titlePosition;
            let t = (0, s.getAdjustedRotation)(this.textStyle.rotation, e);
            const r = Array.isArray(this.text)
              ? this.text
              : this.text.split("\n");
            return this.textureManager.createTextTexture(
              r,
              this.textStyle,
              t,
              this.lineSpacing
            );
          }
          draw(e) {
            return (
              this.drawDebug && this.drawTitleDebugViewRect(e),
              this.drawInternal(
                e,
                this.useNativeText,
                this.titlePosition,
                this.parentSurface.clipRect
              )
            );
          }
          delete() {
            (this.parentSurface = void 0), super.delete();
          }
        }
        t.AxisTitleRenderer = n;
        const l = (e, t) =>
            !(!e || !t) &&
            e.color === t.color &&
            e.fontFamily === t.fontFamily &&
            e.fontSize === t.fontSize &&
            e.fontStyle === t.fontStyle &&
            e.fontWeight === t.fontWeight &&
            e.alignment === t.alignment &&
            e.rotation === t.rotation &&
            e.multilineAlignment === t.multilineAlignment &&
            ((void 0 === e.padding && void 0 === t.padding) ||
              i.Thickness.areEqual(e.padding, t.padding)),
          d = (e) =>
            e === o.ELabelAlignment.Auto
              ? a.ETextAlignment.Center
              : a.ETextAlignment[e];
      },
      59516: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CategoryAxis = void 0);
        const i = r(2192),
          o = r(99269),
          a = r(78471),
          s = r(18184);
        class n extends o.CategoryAxisBase {
          constructor(e, t) {
            super(e, t),
              (this.type = i.EAxisType.CategoryAxis),
              (null == t ? void 0 : t.labelProvider)
                ? (this.labelProvider = null == t ? void 0 : t.labelProvider)
                : (null == t ? void 0 : t.labels)
                ? (this.labelProvider = new s.TextLabelProvider(t))
                : (this.labelProvider = new a.DateLabelProvider(t));
          }
        }
        t.CategoryAxis = n;
      },
      99269: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CategoryAxisBase = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(5337),
          s = r(27699),
          n = r(48804),
          l = r(25762),
          d = r(3346),
          h = r(57397),
          u = r(4220);
        class c extends h.AxisBase2D {
          constructor(e, t) {
            var r, i, o;
            super(e, t),
              (this.defaultXValuesProperty = []),
              (this.defaultXStartProperty = 0),
              (this.defaultXStepProperty = 1),
              (this.defaultXValuesProperty =
                null !== (r = null == t ? void 0 : t.defaultXValues) &&
                void 0 !== r
                  ? r
                  : this.defaultXValuesProperty),
              (this.defaultXStartProperty =
                null !== (i = null == t ? void 0 : t.defaultXStart) &&
                void 0 !== i
                  ? i
                  : this.defaultXStartProperty),
              (this.defaultXStepProperty =
                null !== (o = null == t ? void 0 : t.defaultXStep) &&
                void 0 !== o
                  ? o
                  : this.defaultXStepProperty),
              (this.tickProvider = new d.NumericTickProvider(
                this.webAssemblyContext2D
              )),
              (this.deltaCalculator = new u.CategoryDeltaCalculator(
                this.webAssemblyContext2D
              )),
              (this.defaultBaseXValues =
                new this.webAssemblyContext2D.SCRTDoubleVector());
          }
          get isCategoryAxis() {
            return !0;
          }
          get defaultXValues() {
            return this.defaultXValuesProperty;
          }
          set defaultXValues(e) {
            (this.defaultXValuesProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          get defaultXStart() {
            return this.defaultXStartProperty;
          }
          set defaultXStart(e) {
            (this.defaultXStartProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          get defaultXStep() {
            return this.defaultXStepProperty;
          }
          set defaultXStep(e) {
            (this.defaultXStepProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          prepareRenderData() {
            (0, i.deleteSafe)(this.coordCalcCache);
            const e = this.getCurrentCoordinateCalculatorInternal(),
              t = this.parentSurface.renderableSeries
                .asArray()
                .find((e) => e.xAxisId === this.id);
            this.setBaseXValues(e, t), (this.coordCalcCache = e);
          }
          delete() {
            (this.defaultBaseXValues = (0, i.deleteSafe)(
              this.defaultBaseXValues
            )),
              super.delete();
          }
          getCurrentCoordinateCalculatorInternal() {
            const e = this.visibleRange.min,
              t = this.visibleRange.max,
              r = this.axisLength,
              i = this.parentSurface.renderableSeries
                .asArray()
                .find((e) => e.xAxisId === this.id),
              o =
                this.isXAxis !== this.flippedCoordinates
                  ? new n.CategoryCoordinateCalculator(
                      this.webAssemblyContext2D,
                      r,
                      e,
                      t,
                      this.offset
                    )
                  : new l.FlippedCategoryCoordinateCalculator(
                      this.webAssemblyContext2D,
                      r,
                      e,
                      t,
                      this.offset
                    );
            return this.setBaseXValues(o, i), o;
          }
          getXDataRange() {
            let e;
            return (
              this.parentSurface &&
                this.getVisibleRenderableSeriesByXAxis().forEach((t) => {
                  const r = t.getDataSeriesValuesCount(),
                    i = new o.NumberRange(-0.5, r - 1 + 0.5);
                  i && (e = e ? e.union(i) : i);
                }),
              e
            );
          }
          getMaxAutoTicks() {
            const e = this.getCurrentCoordinateCalculator();
            return Math.min(
              Math.max(1, this.maxAutoTicks),
              e.baseXValues.size()
            );
          }
          generateDefaultXValuesForCategoryAxis(e, t) {
            if (
              (this.defaultBaseXValues.clear(),
              this.defaultXValues && this.defaultXValues.length > 0)
            )
              (0, s.appendDoubleVectorFromJsArray)(
                this.webAssemblyContext2D,
                this.defaultBaseXValues,
                this.defaultXValues
              );
            else {
              const r = [],
                i = 10;
              for (let o = 0; o < i; o++) r.push(e + o * t);
              (0, s.appendDoubleVectorFromJsArray)(
                this.webAssemblyContext2D,
                this.defaultBaseXValues,
                r
              );
            }
            return this.defaultBaseXValues;
          }
          setBaseXValues(e, t) {
            if (
              (null == t ? void 0 : t.type) ===
              a.ESeriesType.UniformHeatmapSeries
            )
              throw Error(
                "Category Axis is not supported for UniformHeatmapRenderableSeries"
              );
            if (null == t ? void 0 : t.isStacked) {
              const r = t;
              if (0 === r.size())
                throw Error(
                  "BaseStackedCollection should have at least one BaseStackedRenderableSeries"
                );
              const i = r.get(0);
              if (!(null == i ? void 0 : i.dataSeries))
                return void (
                  e.baseXValues ||
                  (e.baseXValues = this.generateDefaultXValuesForCategoryAxis(
                    this.defaultXStart,
                    this.defaultXStep
                  ))
                );
              e.baseXValues = i.dataSeries.getNativeXValues();
            } else {
              if (
                !(null == t ? void 0 : t.dataSeries) ||
                t.dataSeries.count() < 10
              ) {
                let r = this.defaultXStart,
                  i = this.defaultXStep;
                if (
                  (null == t ? void 0 : t.dataSeries) &&
                  (null == t ? void 0 : t.dataSeries.count()) > 0
                ) {
                  const e = t.dataSeries.getNativeXValues();
                  (r = e.get(0)),
                    t.dataSeries.count() > 0 && (i = e.get(1) - e.get(0));
                }
                return void (
                  e.baseXValues ||
                  (e.baseXValues = this.generateDefaultXValuesForCategoryAxis(
                    r,
                    i
                  ))
                );
              }
              e.baseXValues = t.dataSeries.getNativeXValues();
            }
          }
        }
        t.CategoryAxisBase = c;
      },
      2296: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DateTimeNumericAxis = void 0);
        const i = r(7899),
          o = r(68695),
          a = r(54948);
        class s extends a.NumericAxis {
          constructor(e, t) {
            (null == t ? void 0 : t.labelProvider) ||
              ((t = null != t ? t : {}).labelProvider =
                new o.SmartDateLabelProvider(t)),
              super(e, t),
              (this.deltaCalculator = new i.DateTimeDeltaCalculator(e, {
                possibleDeltas: null == t ? void 0 : t.possibleDeltas,
                minTicks: null == t ? void 0 : t.minTicks,
              }));
          }
        }
        t.DateTimeNumericAxis = s;
      },
      4220: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CategoryDeltaCalculator = void 0);
        const i = r(23866),
          o = r(98140),
          a = r(40059);
        class s extends a.NumericDeltaCalculator {
          constructor(e) {
            super(e);
          }
          getDeltaFromRange(e, t, r, a) {
            return (
              i.Guard.argumentIsRealNumber(e, "min"),
              i.Guard.argumentIsRealNumber(t, "max"),
              t <= a
                ? new o.NumberRange(1 / r, 1)
                : super.getDeltaFromRange(e, t, r, a)
            );
          }
        }
        t.CategoryDeltaCalculator = s;
      },
      7899: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DateTimeDeltaCalculator = void 0);
        const i = r(41493),
          o = r(98140),
          a = r(40059);
        class s extends a.NumericDeltaCalculator {
          constructor(e, t) {
            var r;
            super(e),
              (this.possibleDeltasProperty = [
                1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200,
                10800, 21600, 43200, 86400, 172800, 259200, 432e3, 864e3,
                1296e3, 1728e3, 2592e3, 5184e3, 10368e3, 15552e3, 31557600,
              ]),
              (this.currIndex = 1),
              (this.possibleDeltasProperty =
                null !== (r = null == t ? void 0 : t.possibleDeltas) &&
                void 0 !== r
                  ? r
                  : this.possibleDeltasProperty),
              (this.minTicks = null == t ? void 0 : t.minTicks),
              (this.currIndex = Math.floor(this.possibleDeltas.length / 2));
          }
          get possibleDeltas() {
            return this.possibleDeltasProperty;
          }
          set possibleDeltas(e) {
            this.possibleDeltasProperty !== e &&
              ((this.possibleDeltasProperty = e),
              (this.currIndex = Math.floor(this.possibleDeltas.length / 2)));
          }
          get minTicks() {
            return this.minTicksProperty;
          }
          set minTicks(e) {
            this.minTicksProperty !== e && (this.minTicksProperty = e);
          }
          getDeltaFromRange(e, t, r, a) {
            const s = t - e;
            (this.prevIndex = void 0),
              this.currIndex >= this.possibleDeltas.length &&
                (this.currIndex = Math.floor(this.possibleDeltas.length / 2));
            let n = 0;
            const l = (o) => {
                var d, h;
                let u = this.possibleDeltasProperty[o];
                if ((n++, n > this.possibleDeltas.length + 1))
                  return (
                    i.performanceWarnings.dateTimeDeltaCalculatorBadDelta.warn(),
                    u
                  );
                const c = Math.floor(s / u);
                return c <
                  (null !== (d = this.minTicks) && void 0 !== d ? d : a / 3) &&
                  0 === o &&
                  o !== this.prevIndex
                  ? (this.prevIndex || (this.prevIndex = o),
                    super.getDeltaFromRange(e, t, r, a).max)
                  : c <
                      (null !== (h = this.minTicks) && void 0 !== h
                        ? h
                        : a / 3) &&
                    o > 0 &&
                    o !== this.prevIndex
                  ? (this.prevIndex || (this.prevIndex = o), l(o - 1))
                  : c > a &&
                    o < this.possibleDeltasProperty.length - 1 &&
                    o !== this.prevIndex
                  ? (this.prevIndex || (this.prevIndex = o), l(o + 1))
                  : c > a && o === this.possibleDeltasProperty.length - 1
                  ? super.getDeltaFromRange(e / u, t / u, r, a).max * u
                  : (this.currIndex !== o && (this.currIndex = o), u);
              },
              d = l(this.currIndex);
            return new o.NumberRange(d / r, d);
          }
        }
        t.DateTimeDeltaCalculator = s;
      },
      69738: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DeltaCalculator = void 0),
          (t.DeltaCalculator = class {
            attachedToAxis(e) {
              this.parentAxis = e;
            }
            detachedFromAxis() {
              this.parentAxis = void 0;
            }
          });
      },
      19643: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogarithmicDeltaCalculator = void 0);
        const i = r(23866),
          o = r(98140),
          a = r(69738);
        class s extends a.DeltaCalculator {
          constructor(e) {
            super(),
              (this.logarithmicBase = 10),
              (this.isHighPrecisionTicks = !0),
              (this.webAssemblyContext = e);
          }
          getDeltaFromRange(e, t, r, a) {
            if (
              (i.Guard.argumentIsRealNumber(e, "min"),
              i.Guard.argumentIsRealNumber(t, "max"),
              (e = Math.abs(e)) > (t = Math.abs(t)))
            ) {
              const r = e;
              (e = t), (t = r);
            }
            if (this.isHighPrecisionTicks) {
              const i =
                  this.webAssemblyContext.NiceLogScale.CalculateTickSpacing(
                    e,
                    t,
                    this.logarithmicBase,
                    r,
                    a
                  ),
                s = new o.NumberRange(i.minD, i.maxD);
              return i.delete(), s;
            }
            {
              const i =
                  this.webAssemblyContext.NiceLogScale.CalculateLowPrecisionTickSpacing(
                    e,
                    t,
                    this.logarithmicBase,
                    r,
                    a
                  ),
                s = new o.NumberRange(i.minD, i.maxD);
              return i.delete(), s;
            }
          }
        }
        t.LogarithmicDeltaCalculator = s;
      },
      40059: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericDeltaCalculator = void 0);
        const i = r(23866),
          o = r(98140),
          a = r(69738);
        class s extends a.DeltaCalculator {
          constructor(e) {
            super(), (this.webAssemblyContext = e);
          }
          getDeltaFromRange(e, t, r, a) {
            i.Guard.argumentIsRealNumber(e, "min"),
              i.Guard.argumentIsRealNumber(t, "max");
            const s =
                this.webAssemblyContext.NiceDoubleScale.CalculateTickSpacing(
                  e,
                  t,
                  r,
                  a
                ),
              n = new o.NumberRange(s.minD, s.maxD);
            return s.delete(), n;
          }
        }
        t.NumericDeltaCalculator = s;
      },
      78471: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DateLabelProvider = void 0);
        const i = r(40359),
          o = r(96528),
          a = r(8591),
          s = r(19833);
        class n extends s.LabelProviderBase2D {
          constructor(e) {
            var t, r;
            super(
              Object.assign(
                {
                  labelFormat:
                    null !== (t = null == e ? void 0 : e.labelFormat) &&
                    void 0 !== t
                      ? t
                      : o.ENumericFormat.Date_DDMMYYYY,
                  cursorLabelFormat:
                    null !== (r = null == e ? void 0 : e.cursorLabelFormat) &&
                    void 0 !== r
                      ? r
                      : o.ENumericFormat.Date_DDMMYYYY,
                },
                e
              )
            ),
              (this.type = i.ELabelProviderType.Date),
              (this.formatLabelProperty = (e) =>
                this.applyFormat(
                  (0, a.formatNumber)(e, this.numericFormat, this.precision)
                )),
              (this.formatCursorLabelProperty = (e) => {
                var t, r;
                return this.applyFormat(
                  (0, a.formatNumber)(
                    e,
                    null !== (t = this.cursorNumericFormat) && void 0 !== t
                      ? t
                      : this.numericFormat,
                    null !== (r = this.cursorPrecision) && void 0 !== r
                      ? r
                      : this.precision
                  )
                );
              });
          }
          onBeginAxisDraw() {}
        }
        t.DateLabelProvider = n;
      },
      16155: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.labelCache = void 0);
        const i = r(56744),
          o = r(87108),
          a = r(9254),
          s = new Map(),
          n = {};
        let l = 0;
        const d = (e, t) => `${e}|:|${t}`,
          h = (e) => {
            const t = e.indexOf("|:|");
            return { text: e.substring(0, t - 1), styleId: e.substring(t + 3) };
          };
        let u = 200,
          c = 6e4;
        const p = (e, t) =>
          e.alignment === t.alignment &&
          e.multilineAlignment === t.multilineAlignment &&
          e.color === t.color &&
          e.fontFamily === t.fontFamily &&
          e.fontSize === t.fontSize &&
          e.fontStyle === t.fontStyle &&
          e.fontWeight === t.fontWeight &&
          ((void 0 === e.padding && void 0 === t.padding) ||
            o.Thickness.areEqual(e.padding, t.padding)) &&
          e.extras === t.extras &&
          e.rotation === t.rotation &&
          e.providerId === t.providerId;
        t.labelCache = {
          getStyleId: (e) => {
            for (const t in n)
              if (n.hasOwnProperty(t)) {
                const r = n[t];
                if (r && p(e, r.style)) return r.uses++, t;
              }
            l++;
            const t = l.toString();
            return (n[t] = { style: e, uses: 1 }), t;
          },
          freeStyle: (e) => {
            const t = n[e];
            t &&
              (t.uses--,
              setTimeout(() => {
                const t = n[e];
                t &&
                  0 === t.uses &&
                  ((e) => {
                    for (const t of Array.from(s.keys())) {
                      const { text: r, styleId: o } = h(t);
                      if (o === e) {
                        const e = s.get(t);
                        s.delete(t);
                        try {
                          (0, i.deleteSafe)(e.bitmapTexture);
                        } catch (e) {
                          a.Logger.debug(e);
                        }
                      }
                    }
                  })(e);
              }, c));
          },
          getLabel: (e, t) => {
            const r = d(e, t),
              i = s.get(r);
            return i && (i.lastUsed = Date.now()), i;
          },
          setLabel: (e, t, r) => {
            const i = d(e, t);
            s.set(i, r);
          },
          checkStyle: (e, t) => {
            const r = n[e.toString()];
            return !!r && p(r.style, t);
          },
          getMaxSize: () => u,
          setMaxSize: (e) => {
            u = e;
          },
          getSize: () => s.size,
          getMinAge: () => c,
          setMinAge: (e) => {
            c = e;
          },
          pruneCache: () => {
            if (s.size > u)
              try {
                const e = Math.min(Math.floor(s.size / 2), 2 * (s.size - u)),
                  t = Array.from(s.entries());
                t.sort((e, t) => e[1].lastUsed - t[1].lastUsed);
                for (let r = 0; r < e; r++) {
                  const [e, o] = t[r];
                  (o.bitmapTexture = (0, i.deleteSafe)(o.bitmapTexture)),
                    s.delete(e);
                }
              } catch (e) {
                console.warn(e);
              }
          },
          resetCache: () => {
            s.clear();
            for (const e in n) delete n[e];
          },
        };
      },
      50687: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LabelProvider = void 0);
        const i = r(55023);
        class o extends i.DeletableEntity {
          constructor(e) {
            super(),
              (this.numericFormatProperty = null == e ? void 0 : e.labelFormat),
              (this.precisionProperty = null == e ? void 0 : e.labelPrecision),
              (this.cursorNumericFormatProperty =
                null == e ? void 0 : e.cursorLabelFormat),
              (this.cursorPrecisionProperty =
                null == e ? void 0 : e.cursorLabelPrecision),
              (this.prefixProperty = null == e ? void 0 : e.labelPrefix),
              (this.postfixProperty = null == e ? void 0 : e.labelPostfix);
          }
          attachedToAxis(e) {
            this.parentAxis = e;
          }
          detachedFromAxis() {
            this.parentAxis = void 0;
          }
          get numericFormat() {
            return this.numericFormatProperty;
          }
          set numericFormat(e) {
            (this.numericFormatProperty = e), this.invalidateParent();
          }
          get precision() {
            return this.precisionProperty;
          }
          set precision(e) {
            (this.precisionProperty = e), this.invalidateParent();
          }
          get cursorNumericFormat() {
            return this.cursorNumericFormatProperty;
          }
          set cursorNumericFormat(e) {
            (this.cursorNumericFormatProperty = e), this.invalidateParent();
          }
          get cursorPrecision() {
            return this.cursorPrecisionProperty;
          }
          set cursorPrecision(e) {
            (this.cursorPrecisionProperty = e), this.invalidateParent();
          }
          get prefix() {
            return this.prefixProperty;
          }
          set prefix(e) {
            (this.prefixProperty = e), this.invalidateParent();
          }
          get postfix() {
            return this.postfixProperty;
          }
          set postfix(e) {
            (this.postfixProperty = e), this.invalidateParent();
          }
          get formatLabel() {
            return this.formatLabelProperty;
          }
          set formatLabel(e) {
            (this.formatLabelProperty = e), this.invalidateParent();
          }
          get formatCursorLabel() {
            return this.formatCursorLabelProperty;
          }
          set formatCursorLabel(e) {
            (this.formatCursorLabelProperty = e), this.invalidateParent();
          }
          applyFormat(e) {
            var t, r;
            return (
              (null !== (t = this.prefix) && void 0 !== t ? t : "") +
              e +
              (null !== (r = this.postfix) && void 0 !== r ? r : "")
            );
          }
          toJSON() {
            const e = {
              cursorLabelFormat: this.cursorNumericFormat,
              cursorLabelPrecision: this.cursorPrecision,
              labelFormat: this.numericFormat,
              labelPrecision: this.precision,
              labelPrefix: this.prefix,
              labelPostfix: this.postfix,
            };
            return { type: this.type, options: e };
          }
          invalidateParent() {
            this.parentAxis &&
              this.parentAxis.invalidateParentCallback &&
              this.parentAxis.invalidateParentCallback();
          }
        }
        t.LabelProvider = o;
      },
      19833: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LabelProviderBase2D = t.LabelInfo = void 0);
        const o = r(84745),
          a = r(73538),
          s = r(98353),
          n = r(85479),
          l = r(76829),
          d = r(16155),
          h = r(50687);
        class u {
          constructor(e, t, r, i, o) {
            (this.tick = e),
              (this.text = t),
              (this.bitmapTexture = r),
              (this.textureHeight = i),
              (this.textureWidth = o),
              (this.lastUsed = Date.now());
          }
        }
        t.LabelInfo = u;
        class c extends h.LabelProvider {
          constructor(e) {
            var t, r, i, s;
            super(e),
              (this.useCache = !o.IS_TEST_ENV),
              (this.tickToText = new Map()),
              (this.textVariesForSameTick = !1),
              (this.rotationProperty = 0),
              (this.lineSpacingProperty = 1.1),
              (this.providerId = (0, a.generateGuid)()),
              (this.rotationProperty =
                null !== (t = null == e ? void 0 : e.rotation) && void 0 !== t
                  ? t
                  : this.rotationProperty),
              (this.lineSpacing =
                null !== (r = null == e ? void 0 : e.lineSpacing) &&
                void 0 !== r
                  ? r
                  : this.lineSpacing),
              (this.useSharedCache =
                null !== (i = null == e ? void 0 : e.useSharedCache) &&
                void 0 !== i
                  ? i
                  : n.SciChartDefaults.useSharedCache),
              (this.useNativeText =
                null !== (s = null == e ? void 0 : e.useNativeText) &&
                void 0 !== s
                  ? s
                  : n.SciChartDefaults.useNativeText);
          }
          get rotation() {
            return this.rotationProperty;
          }
          set rotation(e) {
            this.rotationProperty !== e &&
              ((this.rotationProperty = e), this.invalidateParent());
          }
          get lineSpacing() {
            return this.useNativeText && 1.1 === this.lineSpacingProperty
              ? 2
              : this.lineSpacingProperty;
          }
          set lineSpacing(e) {
            (this.lineSpacingProperty = e), this.invalidateParent();
          }
          getLabels(e) {
            const t = this.parentAxis;
            this.useCache &&
              (this.styleId
                ? d.labelCache.checkStyle(
                    this.styleId,
                    this.getCachedStyle()
                  ) ||
                  (this.resetCache(),
                  (this.styleId = d.labelCache.getStyleId(
                    this.getCachedStyle()
                  )))
                : (this.styleId = d.labelCache.getStyleId(
                    this.getCachedStyle()
                  )));
            let r = e;
            if (this.parentAxis.isCategoryAxis) {
              const t = this.parentAxis.getCurrentCoordinateCalculator();
              r = e.map((e) => t.transformIndexToData(e));
            }
            let i = [];
            if (this.useCache) {
              if (this.useNativeText) {
                const e = [];
                for (const t of r) {
                  const r = this.tickToText.get(t);
                  if (this.textVariesForSameTick) {
                    const o = this.formatLabel(t);
                    r && r === o
                      ? i.push(r)
                      : (this.tickToText.set(t, o), e.push(o), i.push(o));
                  } else if (r)
                    i.push(r),
                      d.labelCache.getLabel(r, this.styleId) || e.push(r);
                  else {
                    const r = this.formatLabel(t);
                    this.tickToText.set(t, r), e.push(r), i.push(r);
                  }
                }
                this.getLabelSizesNative(e, t.dpiAdjustedLabelStyle);
              } else
                for (const e of r) {
                  let r, o;
                  const a = this.tickToText.get(e);
                  if (
                    (this.textVariesForSameTick
                      ? ((o = this.formatLabel(e)),
                        a && a === o
                          ? ((r = d.labelCache.getLabel(a, this.styleId)),
                            r && i.push(a))
                          : this.tickToText.set(e, o))
                      : a
                      ? ((o = a),
                        (r = d.labelCache.getLabel(a, this.styleId)),
                        r && i.push(a))
                      : ((o = this.formatLabel(e)), this.tickToText.set(e, o)),
                    !r)
                  ) {
                    const a = this.getCachedLabelTexture(
                      o,
                      t.axisRenderer.textureManager,
                      t.dpiAdjustedLabelStyle
                    );
                    null !== a.textureWidth &&
                      ((r = new u(
                        e,
                        o,
                        a.bitmapTexture,
                        a.textureHeight,
                        a.textureWidth
                      )),
                      d.labelCache.setLabel(o, this.styleId, r)),
                      i.push(o);
                  }
                }
              d.labelCache.pruneCache(), this.pruneTickTextCache();
            } else i = r.map((e) => this.formatLabel(e));
            return i;
          }
          getLabelHeight(e, t, r) {
            if (
              this.rotationProperty % 90 == 0 ||
              this.parentAxis.isHorizontalAxis
            ) {
              const i = this.useCache
                ? d.labelCache.getLabel(t, this.styleId)
                : void 0;
              if (!i || !i.textureHeight) {
                const { fontSize: t, padding: i } = r;
                if (!e) {
                  const { viewRect: t, textureManager: r } =
                    this.parentAxis.axisRenderer;
                  e = r.getTextureContext(
                    Math.floor(t.width),
                    Math.floor(t.height)
                  );
                }
                return (
                  (0, l.measureTextHeight)(t) +
                  (null == i ? void 0 : i.top) +
                  (null == i ? void 0 : i.bottom)
                );
              }
              return i.textureHeight;
            }
            return r.fontSize + r.padding.top + r.padding.bottom;
          }
          getLabelWidth(e, t, r) {
            if (
              this.rotationProperty % 90 != 0 &&
              this.parentAxis.isHorizontalAxis
            )
              return r.fontSize + r.padding.left + r.padding.right;
            {
              const i = this.useCache
                ? d.labelCache.getLabel(t, this.styleId)
                : void 0;
              if (!i || !i.textureWidth) {
                const { padding: i } = r;
                return (0, l.measureTextWidth)(e, t) + i.left + i.right;
              }
              return i.textureWidth;
            }
          }
          getMaxLabelHeightForHorizontalAxis(e, t, r) {
            let i = 0;
            return (
              e.forEach((e) => {
                const o = this.getLabelHeight(t, e, r);
                i = o > i ? o : i;
              }),
              i
            );
          }
          getMaxLabelWidthForVerticalAxis(e, t, r) {
            let i = 0;
            return (
              e.forEach((e) => {
                const o = this.getLabelWidth(t, e, r);
                i = o > i ? o : i;
              }),
              i
            );
          }
          getCachedLabelTexture(e, t, r) {
            var i;
            const o = d.labelCache.getLabel(e, this.styleId);
            return o
              ? {
                  textureWidth:
                    null !== (i = o.textureWidth) && void 0 !== i ? i : null,
                  textureHeight: o.textureHeight,
                  bitmapTexture: o.bitmapTexture,
                }
              : this.getLabelTexture(e, t, r);
          }
          getLabelTextureAsync(e, t, r) {
            return i(this, void 0, void 0, function* () {
              return this.getLabelTexture(e, t, r);
            });
          }
          getLabelTexture(e, t, r) {
            return t.createTextTexture([e], r, this.rotationProperty);
          }
          getNativeLabelInfo(e) {
            return d.labelCache.getLabel(e, this.styleId);
          }
          invalidateCache() {
            this.styleId && d.labelCache.freeStyle(this.styleId),
              this.tickToText.clear(),
              (this.styleId = null);
          }
          resetCache() {
            this.invalidateCache();
          }
          delete() {
            this.resetCache();
          }
          adjustLabel(e, t, r, i, o, a, s, n, l) {
            return {
              text: t,
              x: o,
              y: a,
              rx: s,
              ry: n,
              rotationRadians: l,
              color: void 0,
            };
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                rotation: this.rotation,
                lineSpacing: this.lineSpacing,
                asyncLabels: !1,
                useSharedCache: this.useSharedCache,
                useNativeText: this.useNativeText,
              };
            return Object.assign(e.options, t), e;
          }
          getLabelSizesNative(e, t) {
            if (!e || 0 === e.length || o.IS_TEST_ENV) return;
            let r = "";
            const i = [],
              a = this.parentAxis.parentSurface.webAssemblyContext2D,
              n = (0, s.getTextBounds)(a),
              l = a.SCRTGetMainRenderContext2D(),
              h = (0, s.getFontKey)(a, this.getCachedStyle(), !1),
              c = l.AquireFont(h),
              p = this.rotation * (Math.PI / 180),
              g = Math.abs(Math.sin(p)),
              y = Math.abs(Math.cos(p)),
              f = (e, r, i) => {
                var o, a;
                let s = e,
                  n = r;
                0 !== this.rotation &&
                  ((n = e * g + r * y), (s = e * y + r * g));
                const l = new u(
                  void 0,
                  i,
                  void 0,
                  n +
                    (null === (o = t.padding) || void 0 === o
                      ? void 0
                      : o.top) +
                    (null == t ? void 0 : t.padding.bottom),
                  s +
                    (null === (a = t.padding) || void 0 === a
                      ? void 0
                      : a.left) +
                    (null == t ? void 0 : t.padding.right)
                );
                (l.textWidth = e),
                  (l.textHeight = r),
                  d.labelCache.setLabel(i, this.styleId, l);
              };
            if (
              (e.forEach((e) => {
                e && !e.includes("\n")
                  ? (i.push(e), (r += e + "\n"))
                  : (c.CalculateStringBounds(null != e ? e : "", n, 0),
                    f(n.m_fWidth, n.m_fHeight, e));
              }),
              i.length > 0)
            ) {
              c.CalculateStringBounds(null != r ? r : "", n, 2);
              for (let e = 0; e < i.length; e++) {
                const t = i[e],
                  r = n.GetLineBounds(e);
                f(r.m_fWidth, r.m_fHeight - r.m_fOffsetY, t);
              }
            }
          }
          pruneTickTextCache() {
            this.tickToText.size > 1e3 && this.tickToText.clear();
          }
          getCachedStyle() {
            const e = this.parentAxis;
            return Object.assign(Object.assign({}, e.dpiAdjustedLabelStyle), {
              rotation: this.rotation,
              providerId: this.useSharedCache
                ? this.useNativeText
                  ? "native"
                  : void 0
                : this.providerId,
            });
          }
          clearCache() {
            this.useCache &&
              this.styleId &&
              (d.labelCache.freeStyle(this.styleId), (this.styleId = void 0)),
              this.tickToText.clear();
          }
          invalidateParent() {
            this.clearCache(), super.invalidateParent();
          }
        }
        t.LabelProviderBase2D = c;
      },
      48767: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogarithmicLabelProvider = void 0);
        const i = r(96528),
          o = r(8591),
          a = r(39920);
        class s extends a.NumericLabelProvider {
          constructor(e) {
            var t, r;
            super(
              Object.assign(
                {
                  labelFormat:
                    null !== (t = null == e ? void 0 : e.labelFormat) &&
                    void 0 !== t
                      ? t
                      : i.ENumericFormat.Scientific,
                  labelPrecision:
                    null !== (r = null == e ? void 0 : e.labelPrecision) &&
                    void 0 !== r
                      ? r
                      : 1,
                },
                e
              )
            ),
              (this.formatLabelProperty = (e) =>
                this.numericFormat === i.ENumericFormat.Scientific
                  ? this.applyFormat(
                      (0, o.toScientific)(
                        e,
                        this.precision,
                        this.logarithmicBase
                      )
                    )
                  : this.applyFormat(
                      (0, o.formatNumber)(
                        e,
                        this.numericFormat,
                        this.precision,
                        this.engineeringPrefix
                      )
                    ));
          }
        }
        t.LogarithmicLabelProvider = s;
      },
      39920: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericLabelProvider = void 0);
        const i = r(40359),
          o = r(96528),
          a = r(8591),
          s = r(19833);
        class n extends s.LabelProviderBase2D {
          constructor(e) {
            var t, r;
            super(
              Object.assign(
                {
                  labelFormat:
                    null !== (t = null == e ? void 0 : e.labelFormat) &&
                    void 0 !== t
                      ? t
                      : o.ENumericFormat.Decimal,
                  labelPrecision:
                    null !== (r = null == e ? void 0 : e.labelPrecision) &&
                    void 0 !== r
                      ? r
                      : 1,
                },
                e
              )
            ),
              (this.type = i.ELabelProviderType.Numeric),
              (this.formatLabelProperty = (e) =>
                this.applyFormat(
                  (0, a.formatNumber)(
                    e,
                    this.numericFormat,
                    this.precision,
                    this.engineeringPrefix
                  )
                )),
              (this.formatCursorLabelProperty = (e) => {
                var t, r;
                return this.applyFormat(
                  (0, a.formatNumber)(
                    e,
                    null !== (t = this.cursorNumericFormat) && void 0 !== t
                      ? t
                      : this.numericFormat,
                    null !== (r = this.cursorPrecision) && void 0 !== r
                      ? r
                      : this.precision,
                    this.engineeringPrefix
                  )
                );
              });
          }
          get engineeringPrefix() {
            return this.engineeringPrefixProperty;
          }
          set engineeringPrefix(e) {
            (this.engineeringPrefixProperty = e), this.invalidateParent();
          }
          onBeginAxisDraw() {}
        }
        t.NumericLabelProvider = n;
      },
      92596: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PieLabelProvider = void 0);
        const i = r(40359),
          o = r(96528),
          a = r(8591),
          s = r(79548),
          n = r(50687);
        class l extends n.LabelProvider {
          constructor(e) {
            var t, r;
            super(
              Object.assign(
                {
                  labelFormat:
                    null !== (t = null == e ? void 0 : e.labelFormat) &&
                    void 0 !== t
                      ? t
                      : o.ENumericFormat.Decimal,
                  labelPrecision:
                    null !== (r = null == e ? void 0 : e.labelPrecision) &&
                    void 0 !== r
                      ? r
                      : 2,
                },
                e
              )
            ),
              (this.type = i.ELabelProviderType.Pie),
              (this.formatLabelProperty = (e) =>
                this.applyFormat(
                  (0, a.formatNumber)(e, this.numericFormat, this.precision)
                ) +
                (this.parentSurface.valueMode === s.EPieValueMode.Percentage
                  ? " %"
                  : ""));
          }
          delete() {}
          getSegmentText(e, t) {
            const r =
              this.parentSurface.valueMode === s.EPieValueMode.Percentage
                ? e.getPercentage(t)
                : e.value;
            return this.formatLabel(r);
          }
          attachedToSurface(e) {
            this.parentSurface = e;
          }
          onBeginAxisDraw() {}
          invalidateParent() {
            this.parentSurface &&
              this.parentSurface.invalidateElement &&
              this.parentSurface.invalidateElement();
          }
        }
        t.PieLabelProvider = l;
      },
      20268: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RadianLabelProvider = void 0);
        const i = r(39920);
        class o extends i.NumericLabelProvider {
          constructor(e = {}) {
            var t, r;
            super(e),
              (this.maxDenominatorProperty = 12),
              (this.errorToleranceProperty = 1e-4),
              (this.maxDenominatorProperty =
                null !== (t = e.maxDenominator) && void 0 !== t
                  ? t
                  : this.maxDenominatorProperty),
              (this.errorToleranceProperty =
                null !== (r = e.errorTolerance) && void 0 !== r
                  ? r
                  : this.errorToleranceProperty);
          }
          get maxDenominator() {
            return this.maxDenominatorProperty;
          }
          set maxDenominator(e) {
            this.maxDenominatorProperty = e;
          }
          get errorTolerance() {
            return this.errorToleranceProperty;
          }
          set errorTolerance(e) {
            this.errorToleranceProperty = e;
          }
          getGCD(e, t) {
            for (; 0 !== t; ) t = e % (e = t);
            return Math.abs(e);
          }
          findFraction(e) {
            let t = 0,
              r = 1,
              i = 1 / 0;
            for (let o = 1; o <= this.maxDenominatorProperty; o++) {
              const a = Math.round(e * o),
                s = Math.abs(e - a / o);
              s < i && ((i = s), (t = a), (r = o));
            }
            if (i < this.errorToleranceProperty) {
              const e = this.getGCD(t, r);
              return { numerator: t / e, denominator: r / e };
            }
            return null;
          }
          get formatLabel() {
            return (e) => {
              var t;
              if (0 === e) return "0";
              const r = e / Math.PI,
                i = this.findFraction(r);
              if (i) {
                if (!i) return e.toString();
                const { numerator: t, denominator: r } = i;
                return 1 === r
                  ? 1 === t
                    ? "π"
                    : `${t}π`
                  : 1 === t
                  ? `π/${r}`
                  : `${t}π/${r}`;
              }
              return e.toFixed(
                null !== (t = null == this ? void 0 : this.precision) &&
                  void 0 !== t
                  ? t
                  : 1
              );
            };
          }
        }
        t.RadianLabelProvider = o;
      },
      68695: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SmartDateLabelProvider = t.ETradeChartLabelFormat = void 0);
        const i = r(40359),
          o = r(96528),
          a = r(72633),
          s = r(8591),
          n = r(19833);
        var l;
        !(function (e) {
          (e.MilliSeconds = "MilliSeconds"),
            (e.Seconds = "Seconds"),
            (e.Minutes = "Minutes"),
            (e.Days = "Days"),
            (e.Months = "Months");
        })((l = t.ETradeChartLabelFormat || (t.ETradeChartLabelFormat = {})));
        class d extends n.LabelProviderBase2D {
          constructor(e) {
            var t, r, a, n, l;
            super(
              Object.assign(
                {
                  labelFormat:
                    null !== (t = null == e ? void 0 : e.labelFormat) &&
                    void 0 !== t
                      ? t
                      : o.ENumericFormat.Date_DDMMYYYY,
                  cursorLabelFormat:
                    null !== (r = null == e ? void 0 : e.cursorLabelFormat) &&
                    void 0 !== r
                      ? r
                      : o.ENumericFormat.Date_DDMMYYYY,
                },
                e
              )
            ),
              (this.type = i.ELabelProviderType.SmartDate),
              (this.textVariesForSameTick = !0),
              (this.showWiderDateOnFirstLabelProperty = !0),
              (this.showYearOnWiderDateProperty = !1),
              (this.dateOffsetProperty = 0),
              (this.firstLabel = !0),
              (this.showWiderDateOnFirstLabelProperty =
                null !==
                  (a = null == e ? void 0 : e.showWiderDateOnFirstLabel) &&
                void 0 !== a
                  ? a
                  : this.showWiderDateOnFirstLabel),
              (this.showYearOnWiderDateProperty =
                null !== (n = null == e ? void 0 : e.showYearOnWiderDate) &&
                void 0 !== n
                  ? n
                  : this.showYearOnWiderDate),
              (this.dateOffsetProperty =
                null !== (l = null == e ? void 0 : e.dateOffset) && void 0 !== l
                  ? l
                  : this.dateOffset),
              (this.formatCursorLabelProperty = (e) => {
                var t, r;
                return this.applyFormat(
                  (0, s.formatNumber)(
                    e + this.dateOffset,
                    null !== (t = this.cursorNumericFormat) && void 0 !== t
                      ? t
                      : this.numericFormat,
                    null !== (r = this.cursorPrecision) && void 0 !== r
                      ? r
                      : this.precision
                  )
                );
              }),
              (this.doFormat = this.doFormat.bind(this)),
              (this.formatLabelProperty = this.doFormat);
          }
          get showWiderDateOnFirstLabel() {
            return this.showWiderDateOnFirstLabelProperty;
          }
          set showWiderDateOnFirstLabel(e) {
            this.showWiderDateOnFirstLabelProperty !== e &&
              ((this.showWiderDateOnFirstLabelProperty = e),
              this.invalidateParent());
          }
          get dateOffset() {
            var e;
            return null !== (e = this.dateOffsetProperty) && void 0 !== e
              ? e
              : 0;
          }
          set dateOffset(e) {
            this.dateOffsetProperty !== e &&
              ((this.dateOffsetProperty = e), this.invalidateParent());
          }
          get showYearOnWiderDate() {
            return this.showYearOnWiderDateProperty;
          }
          set showYearOnWiderDate(e) {
            this.showYearOnWiderDateProperty !== e &&
              ((this.showYearOnWiderDateProperty = e), this.invalidateParent());
          }
          onBeginAxisDraw() {}
          getLabels(e) {
            let t = e[0];
            const r = e.length;
            let i = e[r - 1];
            if (this.parentAxis.isCategoryAxis) {
              const e = this.parentAxis.getCurrentCoordinateCalculator();
              (t = e.transformIndexToData(t)), (i = e.transformIndexToData(i));
            }
            (this.prevPrevValue = void 0), (this.prevValue = void 0);
            const o = i - t;
            (this.firstLabel = !0), (this.format = this.getLabelRange(o, r));
            const a = super.getLabels(e);
            return (this.format = void 0), a;
          }
          get numericFormat() {}
          set numericFormat(e) {}
          formatDateWide(e, t) {
            return e === l.MilliSeconds
              ? (this.showYearOnWiderDate
                  ? (0, a.formatUnixDateToHumanString)(t) + " "
                  : "") + (0, a.formatUnixDateToHumanStringHHMM)(t)
              : e === l.Seconds || e === l.Minutes
              ? (0, a.formatUnixDateToHumanStringMMMDD)(t) +
                (this.showYearOnWiderDate
                  ? " " + (0, a.formatUnixDateToHumanStringYYYY)(t)
                  : "")
              : e === l.Days
              ? (0, a.formatUnixDateToHumanStringMMM)(t) +
                (this.showYearOnWiderDate
                  ? " " + (0, a.formatUnixDateToHumanStringYYYY)(t)
                  : "")
              : (0, a.formatUnixDateToHumanStringYYYY)(t);
          }
          formatDatePrecise(e, t) {
            return e === l.MilliSeconds
              ? (0, a.formatUnixDateToHumanStringSSms)(t)
              : e === l.Seconds
              ? (0, a.formatUnixDateToHumanStringHHMMSS)(t)
              : e === l.Minutes
              ? (0, a.formatUnixDateToHumanStringHHMM)(t)
              : e === l.Days || e === l.Months
              ? (0, a.formatUnixDateToHumanStringDD)(t)
              : (0, s.formatNumber)(t, o.ENumericFormat.Date_DDMMYYYY, 0);
          }
          doFormat(e) {
            var t, r;
            const i = e + this.dateOffset;
            if (this.format) {
              const t = this.formatSmartLabel(
                this.format,
                i,
                this.prevValue,
                this.prevPrevValue,
                e
              );
              return (
                (this.prevPrevValue = this.prevValue), (this.prevValue = i), t
              );
            }
            return this.applyFormat(
              (0, s.formatNumber)(
                i,
                null !== (t = this.cursorNumericFormat) && void 0 !== t
                  ? t
                  : this.numericFormat,
                null !== (r = this.cursorPrecision) && void 0 !== r
                  ? r
                  : this.precision
              )
            );
          }
          getLabelRange(e, t) {
            return e <= 10
              ? l.MilliSeconds
              : e <= 3600
              ? l.Seconds
              : e <= 432e3
              ? l.Minutes
              : e <= 432e4
              ? l.Days
              : l.Months;
          }
          formatSmartLabel(e, t, r, i, o) {
            const s = !this.firstLabel || this.showWiderDateOnFirstLabel;
            this.firstLabel = !1;
            const n = this.formatDateWide(e, t);
            return e !== l.Months
              ? (void 0 !== r && n === this.formatDateWide(e, r)) || !s
                ? this.formatDatePrecise(e, t)
                : n
              : (void 0 !== r && n === this.formatDateWide(e, r)) || !s
              ? void 0 === i ||
                this.formatDateWide(e, r) !== this.formatDateWide(e, i) ||
                (0, a.formatUnixDateToHumanStringMMM)(t) !==
                  (0, a.formatUnixDateToHumanStringMMM)(r)
                ? (0, a.formatUnixDateToHumanStringMMM)(t)
                : this.formatDatePrecise(e, t)
              : n;
          }
        }
        t.SmartDateLabelProvider = d;
      },
      18184: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.wrapText = t.TextLabelProvider = void 0);
        const i = r(40359),
          o = r(76829),
          a = r(16155),
          s = r(19833);
        class n extends s.LabelProviderBase2D {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.ELabelProviderType.Text),
              (this.maxLengthProperty = 0),
              (this.labelsProperty =
                null !== (t = null == e ? void 0 : e.labels) && void 0 !== t
                  ? t
                  : []),
              (this.maxLength =
                null !== (r = null == e ? void 0 : e.maxLength) && void 0 !== r
                  ? r
                  : this.maxLength),
              (this.formatLabelProperty = (e) => {
                var t, r;
                if (
                  this.parentAxis.isCategoryAxis &&
                  Array.isArray(this.labels)
                ) {
                  const r = this.parentAxis
                    .getCurrentCoordinateCalculator()
                    .transformDataToIndex(e);
                  return this.wrapText(
                    null !== (t = this.labels[r]) && void 0 !== t ? t : ""
                  );
                }
                return this.wrapText(
                  null !== (r = this.labels[e]) && void 0 !== r ? r : ""
                );
              }),
              (this.formatCursorLabelProperty = this.formatLabelProperty);
          }
          get labels() {
            return this.labelsProperty;
          }
          set labels(e) {
            (this.labelsProperty = e), this.invalidateParent();
          }
          get maxLength() {
            return this.maxLengthProperty;
          }
          set maxLength(e) {
            (this.maxLengthProperty = e), this.invalidateParent();
          }
          onBeginAxisDraw() {}
          getLabelWidth(e, t, r) {
            if (
              this.useNativeText ||
              this.rotation % 90 == 0 ||
              !this.parentAxis.isHorizontalAxis
            ) {
              const i = a.labelCache.getLabel(t, this.styleId);
              if (!i) {
                const { padding: i } = r;
                return (0, o.measureTextWidth)(e, t) + i.left + i.right;
              }
              return i.textureWidth;
            }
            return (
              (Array.isArray(t) ? t : t.split("\n")).length *
                this.lineSpacing *
                r.fontSize +
              r.padding.left +
              r.padding.right
            );
          }
          getLabelTexture(e, t, r) {
            const i = e.split("\n");
            return t.createTextTexture(i, r, this.rotation, this.lineSpacing);
          }
          wrapText(e) {
            return e && Array.isArray(e)
              ? e.join("\n")
              : (0, t.wrapText)(e, this.maxLength).join("\n");
          }
          toJSON() {
            const e = super.toJSON(),
              t = { labels: this.labels, maxLength: this.maxLength };
            return Object.assign(e.options, t), e;
          }
          getCachedStyle() {
            const e = this.parentAxis;
            return Object.assign(Object.assign({}, e.dpiAdjustedLabelStyle), {
              rotation: this.rotation,
              extras: `ls${this.lineSpacing},ml${this.maxLength}`,
              providerId: this.useSharedCache ? void 0 : this.providerId,
            });
          }
        }
        (t.TextLabelProvider = n),
          (t.wrapText = (e, t) => {
            if (0 === t) return [e];
            const r = [];
            if (!e) return r;
            const i = e.split(" ");
            let o = "";
            for (const e of i) {
              const i = o + ("" !== o ? " " : "") + e;
              i.length > t
                ? "" === o
                  ? r.push(e)
                  : (r.push(o), (o = e))
                : (o = i);
            }
            return r.push(o), r;
          });
      },
      51392: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogarithmicAxis = t.MIN_LOG_AXIS_VALUE = void 0);
        const i = r(10276),
          o = r(31194),
          a = r(98140),
          s = r(2192),
          n = r(86699),
          l = r(46650),
          d = r(98172),
          h = r(57397),
          u = r(8900),
          c = r(19643),
          p = r(48767);
        t.MIN_LOG_AXIS_VALUE = 1e-10;
        class g extends h.AxisBase2D {
          constructor(e, r) {
            var i, o, n, l, h;
            super(e, r),
              (this.type = s.EAxisType.LogarithmicAxis),
              (this.logBaseProperty = 10),
              (this.isHighPrecisionTicksProperty = !0),
              (this.tickProvider = new d.LogarithmicTickProvider(e)),
              (this.deltaCalculator = new c.LogarithmicDeltaCalculator(e)),
              (this.labelProvider =
                null !== (i = null == r ? void 0 : r.labelProvider) &&
                void 0 !== i
                  ? i
                  : new p.LogarithmicLabelProvider(r)),
              (this.logBase =
                null !== (o = null == r ? void 0 : r.logBase) && void 0 !== o
                  ? o
                  : this.logBaseProperty),
              (this.isNegativeProperty =
                null !== (n = null == r ? void 0 : r.isNegative) &&
                void 0 !== n &&
                n),
              (this.visibleRange =
                a.NumberRange.hydrate(null == r ? void 0 : r.visibleRange) ||
                this.getDefaultNonZeroRange()),
              (null == r ? void 0 : r.visibleRange) ||
                (this.hasVisibleRangeSet = !1),
              (this.majorTickMode =
                (null == r ? void 0 : r.majorTickMode) || this.majorTickMode),
              (this.minorTickMode =
                (null == r ? void 0 : r.minorTickMode) || this.minorTickMode),
              (this.isHighPrecisionTicks =
                null !== (l = null == r ? void 0 : r.isHighPrecisionTicks) &&
                void 0 !== l
                  ? l
                  : this.isHighPrecisionTicksProperty),
              (null == r ? void 0 : r.visibleRangeLimit)
                ? (this.visibleRangeLimit =
                    null !==
                      (h = a.NumberRange.hydrate(
                        null == r ? void 0 : r.visibleRangeLimit
                      )) && void 0 !== h
                      ? h
                      : r.visibleRangeLimit)
                : this.isNegativeProperty
                ? (this.visibleRangeLimit = new a.NumberRange(
                    -1 / 0,
                    -t.MIN_LOG_AXIS_VALUE
                  ))
                : (this.visibleRangeLimit = new a.NumberRange(
                    t.MIN_LOG_AXIS_VALUE,
                    1 / 0
                  ));
          }
          get logBase() {
            return this.logBaseProperty;
          }
          set logBase(e) {
            this.logBaseProperty !== e &&
              ((this.logBaseProperty = e),
              this.clearCoordCalcCache(),
              this.updateProviders(),
              this.notifyPropertyChanged(u.PROPERTY.LOG_BASE));
          }
          get isNegative() {
            return this.isNegativeProperty;
          }
          set isNegative(e) {
            (this.isNegativeProperty = e),
              this.isNegativeProperty
                ? (this.visibleRangeLimit = new a.NumberRange(-1 / 0, -1e-10))
                : (this.visibleRangeLimit = new a.NumberRange(1e-10, 1 / 0)),
              this.notifyPropertyChanged(u.PROPERTY.IS_NEGATIVE);
          }
          get isHighPrecisionTicks() {
            return this.isHighPrecisionTicksProperty;
          }
          set isHighPrecisionTicks(e) {
            (this.isHighPrecisionTicksProperty = e),
              this.updateProviders(),
              this.notifyPropertyChanged(u.PROPERTY.HIGH_PRECISION_TICKS);
          }
          getDefaultNonZeroRange() {
            const e = this.isNegativeProperty ? -1 : 1;
            return new a.NumberRange(
              e * Math.pow(this.logBase, -1),
              e * Math.pow(this.logBase, 2)
            );
          }
          hasValidVisibleRange() {
            return (
              super.hasValidVisibleRange() &&
              this.visibleRange.min * this.visibleRange.max > 0
            );
          }
          get tickProvider() {
            return this.tickProviderProperty;
          }
          set tickProvider(e) {
            (this.tickProviderProperty = e),
              this.updateProviders(),
              this.notifyPropertyChanged(u.PROPERTY.TICK_PROVIDER);
          }
          get deltaCalculator() {
            return this.deltaCalculatorProperty;
          }
          set deltaCalculator(e) {
            (this.deltaCalculatorProperty = e),
              this.updateProviders(),
              this.notifyPropertyChanged(u.PROPERTY.DELTA_CALCULATOR);
          }
          get labelProvider() {
            return this.labelProviderProperty;
          }
          set labelProvider(e) {
            (this.labelProviderProperty = e),
              this.updateProviders(),
              this.notifyPropertyChanged(u.PROPERTY.LABEL_PROVIDER);
          }
          get majorTickMode() {
            return this.logTickProvider.majorTickMode;
          }
          set majorTickMode(e) {
            this.logTickProvider.majorTickMode = e;
          }
          get minorTickMode() {
            return this.logTickProvider.minorTickMode;
          }
          set minorTickMode(e) {
            this.logTickProvider.minorTickMode = e;
          }
          getWindowedYRange(e) {
            let t;
            return (
              this.parentSurface &&
                this.getVisibleRenderableSeriesByYAxis().forEach((r) => {
                  const i = r.xAxisId,
                    o = (null == e ? void 0 : e.containsKey(i))
                      ? e.item(i)
                      : this.getXVisibleRange(i),
                    a = this.getIsXCategoryAxis(i);
                  if (o) {
                    const e = r.getYRange(o, a);
                    e && (t = t ? t.union(e) : e);
                  }
                }),
              (null == t ? void 0 : t.isZero()) &&
                (t = this.coerceZeroVisibleRange(t)),
              this.growBy && t && (t = t.growByLog(this.growBy, this.logBase)),
              this.visibleRangeLimit &&
                t &&
                (t = t.clip(this.visibleRangeLimit)),
              t
            );
          }
          animateVisibleRange(e, t, r = i.easing.outCubic, a = () => {}) {
            var s;
            return t <= 0
              ? ((this.visibleRange = e || this.visibleRange), void a())
              : (null === (s = this.visibleRangeAnimationToken) ||
                  void 0 === s ||
                  s.cancel(),
                (this.visibleRangeAnimationToken =
                  o.NumberRangeAnimator.animate(
                    this.visibleRange,
                    e,
                    t,
                    (e) => {
                      this.visibleRange = e;
                    },
                    a,
                    r,
                    !0
                  )),
                this.parentSurface.addAnimation(
                  this.visibleRangeAnimationToken
                ),
                this.visibleRangeAnimationToken);
          }
          scale(e, t, r) {
            const i = e.max / e.min;
            let o, s;
            const n = this.flippedCoordinates ? !r : r,
              l = this.flippedCoordinates ? -t : t;
            n
              ? ((o = e.min),
                (s =
                  (l > 0 ? Math.pow(i, 1 - l) : Math.pow(i, 1 + Math.abs(l))) *
                  o))
              : ((s = e.max), (o = s / Math.pow(i, 1 + l))),
              (this.visibleRange = new a.NumberRange(o, s));
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                logBase: this.logBase,
                isNegative: this.isNegative,
                majorTickMode: this.majorTickMode,
                minorTickMode: this.minorTickMode,
                isHighPrecisionTicks: this.isHighPrecisionTicks,
              };
            return Object.assign(e.options, t), e;
          }
          getCurrentCoordinateCalculatorInternal() {
            const e = this.visibleRange.min,
              t = this.visibleRange.max,
              r = this.axisLength,
              i = this.isXAxis
                ? n.EXyDirection.XDirection
                : n.EXyDirection.YDirection;
            return new l.LogarithmicCoordinateCalculator(
              this.webAssemblyContext2D,
              r,
              e,
              t,
              i,
              this.logBase,
              this.isXAxis !== this.flippedCoordinates,
              this.offset
            );
          }
          getMaxXRange() {
            let e = this.getXDataRange();
            if (e)
              return (
                this.growBy &&
                  e &&
                  (e = e.growByLog(this.growBy, this.logBase)),
                this.visibleRangeLimit &&
                  e &&
                  (e = e.clip(this.visibleRangeLimit)),
                e
              );
          }
          get logTickProvider() {
            return this.tickProvider;
          }
          updateProviders() {
            const e = this.tickProvider;
            e &&
              ((e.logarithmicBase = this.logBase),
              (e.isHighPrecisionTicks = this.isHighPrecisionTicks));
            const t = this.deltaCalculator;
            t &&
              ((t.logarithmicBase = this.logBase),
              (t.isHighPrecisionTicks = this.isHighPrecisionTicks));
            const r = this.labelProvider;
            r && (r.logarithmicBase = this.logBase);
          }
        }
        t.LogarithmicAxis = g;
      },
      54948: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumericAxis = void 0);
        const i = r(2192),
          o = r(33166),
          a = r(40194),
          s = r(3346),
          n = r(57397),
          l = r(40059),
          d = r(39920);
        class h extends n.AxisBase2D {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.type = i.EAxisType.NumericAxis),
              (this.tickProvider = new s.NumericTickProvider(
                this.webAssemblyContext2D
              )),
              (this.labelProvider =
                null !== (r = null == t ? void 0 : t.labelProvider) &&
                void 0 !== r
                  ? r
                  : new d.NumericLabelProvider(t)),
              (this.deltaCalculator = new l.NumericDeltaCalculator(
                this.webAssemblyContext2D
              ));
          }
          getCurrentCoordinateCalculatorInternal() {
            const e = this.visibleRange.min,
              t = this.visibleRange.max,
              r = this.offset,
              i = this.axisLength;
            return this.isXAxis !== this.flippedCoordinates
              ? new o.FlippedNumericCoordinateCalculator(
                  this.webAssemblyContext2D,
                  i,
                  e,
                  t,
                  r,
                  this.allowFastMath
                )
              : new a.NumericCoordinateCalculator(
                  this.webAssemblyContext2D,
                  i,
                  e,
                  t,
                  r,
                  this.allowFastMath
                );
          }
        }
        t.NumericAxis = h;
      },
      52320: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarAxisBase = void 0);
        const i = r(56744),
          o = r(75772),
          a = r(87459),
          s = r(21915),
          n = r(16185),
          l = r(98353),
          d = r(14184),
          h = r(86127),
          u = r(57397),
          c = r(87673),
          p = r(8900),
          g = r(16989),
          y = r(80574),
          f = r(8827);
        class v extends u.AxisBase2D {
          constructor(e, t) {
            var r, i, o, a, s, n, l, d, h;
            super(e, t),
              (this.isPolarAxis = !0),
              (this.axisLayoutState = new c.PolarAxisLayoutState()),
              (this.polarAxisModeProperty = g.EPolarAxisMode.Angular),
              (this.startAngleProperty = 0),
              (this.totalAngleProperty = 2 * Math.PI),
              (this.xCenterOffsetProperty = 0),
              (this.yCenterOffsetProperty = 0),
              (this.lengthScaleProperty = 1),
              (this.gridlineModeProperty = y.EPolarGridlineMode.Circles),
              (this.polarLabelModeProperty = f.EPolarLabelMode.Horizontal),
              (this.innerRadiusProperty = 0),
              (this.polarAxisModeProperty =
                null !== (r = null == t ? void 0 : t.polarAxisMode) &&
                void 0 !== r
                  ? r
                  : this.polarAxisModeProperty),
              (this.gridlineMode =
                null !== (i = null == t ? void 0 : t.gridlineMode) &&
                void 0 !== i
                  ? i
                  : this.gridlineModeProperty),
              (this.coordTransform = new e.SCRTPolarCoordinateTransform(
                0,
                0,
                0
              )),
              (this.drawMajorBandsProperty = !1),
              (this.innerRadius =
                null !== (o = null == t ? void 0 : t.innerRadius) &&
                void 0 !== o
                  ? o
                  : this.innerRadiusProperty),
              (this.xCenterOffset =
                null !== (a = null == t ? void 0 : t.xCenterOffset) &&
                void 0 !== a
                  ? a
                  : this.xCenterOffsetProperty),
              (this.yCenterOffset =
                null !== (s = null == t ? void 0 : t.yCenterOffset) &&
                void 0 !== s
                  ? s
                  : this.yCenterOffsetProperty),
              (this.lengthScaleProperty =
                null !== (n = null == t ? void 0 : t.lengthScale) &&
                void 0 !== n
                  ? n
                  : this.lengthScaleProperty),
              (this.polarLabelMode =
                null !== (l = null == t ? void 0 : t.polarLabelMode) &&
                void 0 !== l
                  ? l
                  : this.polarLabelModeProperty),
              (this.startAngleProperty =
                null !== (d = null == t ? void 0 : t.startAngle) && void 0 !== d
                  ? d
                  : void 0 !== (null == t ? void 0 : t.startAngleDegrees)
                  ? this.toRadians(t.startAngleDegrees)
                  : this.startAngleProperty),
              (this.totalAngleProperty =
                null !== (h = null == t ? void 0 : t.totalAngle) && void 0 !== h
                  ? h
                  : void 0 !== (null == t ? void 0 : t.totalAngleDegrees)
                  ? this.toRadians(t.totalAngleDegrees)
                  : this.totalAngleProperty);
          }
          get isAngular() {
            return this.polarAxisModeProperty === g.EPolarAxisMode.Angular;
          }
          get polarAxisMode() {
            return this.polarAxisModeProperty;
          }
          set polarAxisMode(e) {
            this.polarAxisMode !== e &&
              ((this.polarAxisModeProperty = e),
              this.notifyPropertyChanged("polarAxisMode"));
          }
          get gridlineMode() {
            return this.gridlineModeProperty;
          }
          set gridlineMode(e) {
            if (this.gridlineMode !== e) {
              if (this.isAngular)
                return void console.warn(
                  "PolarAxisBase.gridlineMode property is ignored for the angular axis"
                );
              (this.gridlineModeProperty = e),
                this.notifyPropertyChanged("gridlineMode");
            }
          }
          get startAngle() {
            return this.startAngleProperty;
          }
          set startAngle(e) {
            this.startAngleProperty !== e &&
              ((this.startAngleProperty = e),
              this.notifyPropertyChanged("startAngle"));
          }
          get totalAngle() {
            return this.totalAngleProperty;
          }
          set totalAngle(e) {
            if (this.totalAngleProperty !== e) {
              if (!this.isAngular)
                return void console.warn(
                  "PolarAxisBase.totalAngle property is ignored for the radial axis"
                );
              0 === e &&
                console.warn("PolarAxisBase.totalAngle can not be zero"),
                (this.totalAngleProperty = e),
                this.notifyPropertyChanged("totalAngle");
            }
          }
          get startAngleDegrees() {
            return (
              Math.round(((180 * this.startAngleProperty) / Math.PI) * 10) / 10
            );
          }
          set startAngleDegrees(e) {
            void 0 !== e &&
              ((this.startAngleProperty = this.toRadians(e)),
              this.notifyPropertyChanged("startAngle"));
          }
          get totalAngleDegrees() {
            return (
              Math.round(((180 * this.totalAngleProperty) / Math.PI) * 10) / 10
            );
          }
          set totalAngleDegrees(e) {
            if (void 0 !== e) {
              if (!this.isAngular)
                return void console.warn(
                  "PolarAxisBase.totalAngleDegrees property is ignored for the radial axis"
                );
              0 === e &&
                console.warn("PolarAxisBase.totalAngleDegrees can not be zero"),
                (this.totalAngleProperty = this.toRadians(e)),
                this.notifyPropertyChanged("totalAngle");
            }
          }
          get xCenterOffset() {
            return this.xCenterOffsetProperty;
          }
          set xCenterOffset(e) {
            if (this.xCenterOffsetProperty !== e) {
              if (!this.isAngular)
                return void console.warn(
                  "PolarAxisBase.xCenterOffset property is ignored for the radial axis"
                );
              (this.xCenterOffsetProperty = e),
                this.notifyPropertyChanged("xCenterOffset");
            }
          }
          get yCenterOffset() {
            return this.yCenterOffsetProperty;
          }
          set yCenterOffset(e) {
            if (this.yCenterOffsetProperty !== e) {
              if (!this.isAngular)
                return void console.warn(
                  "PolarAxisBase.yCenterOffset property is ignored for the radial axis"
                );
              (this.yCenterOffsetProperty = e),
                this.notifyPropertyChanged("yCenterOffset");
            }
          }
          get lengthScale() {
            return this.lengthScaleProperty;
          }
          set lengthScale(e) {
            this.lengthScaleProperty !== e &&
              ((this.lengthScaleProperty = e),
              this.notifyPropertyChanged("lengthScale"));
          }
          get axisLength() {
            var e;
            return (
              (null !== (e = this.axisLengthProperty) && void 0 !== e ? e : 1) *
                this.lengthScale -
              this.offset
            );
          }
          set axisLength(e) {
            this.axisLengthProperty !== e &&
              ((this.axisLengthProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.AXIS_LENGTH));
          }
          get maxRadius() {
            var e;
            return null !== (e = this.axisLengthProperty) && void 0 !== e
              ? e
              : 1;
          }
          get polarLabelMode() {
            return this.polarLabelModeProperty;
          }
          set polarLabelMode(e) {
            if (this.polarLabelMode !== e) {
              if (!this.isAngular)
                return void console.warn(
                  "PolarAxisBase.polarLabelMode property is ignored for the radial axis"
                );
              (this.polarLabelModeProperty = e),
                this.notifyPropertyChanged("polarLabelMode");
            }
          }
          get offset() {
            var e;
            let t = this.offsetProperty;
            return (
              this.offsetOverrideProperty
                ? (t = this.offsetOverrideProperty)
                : void 0 !== this.innerRadius &&
                  (t =
                    this.innerRadius *
                    (null !== (e = this.axisLengthProperty) && void 0 !== e
                      ? e
                      : 1)),
              t * this.lengthScale
            );
          }
          set offset(e) {
            this.offsetProperty !== e &&
              ((this.offsetProperty = e),
              void 0 === this.innerRadius &&
                (this.clearCoordCalcCache(),
                this.notifyPropertyChanged(p.PROPERTY.OFFSET)));
          }
          get innerRadius() {
            return this.innerRadiusProperty;
          }
          set innerRadius(e) {
            if (this.innerRadius !== e) {
              if (this.isAngular)
                return void console.warn(
                  "PolarAxisBase.innerRadius property is ignored for the angular axis"
                );
              if (e < 0 || e > 1)
                throw Error("innerRadius must be between 0 and 1");
              (this.innerRadiusProperty = e),
                this.clearCoordCalcCache(),
                this.notifyPropertyChanged("innerRadius");
            }
          }
          get otherAxis() {
            return this.otherAxisProperty;
          }
          measure() {
            if (this.isXAxis) {
              const e = this.parentSurface.yAxes
                .asArray()
                .find((e) => e.isPolarAxis && e.isAngular !== this.isAngular);
              if (!e)
                throw new Error(
                  `Could not find a polar y axis with isAngluar: ${!this
                    .isAngular}`
                );
              (this.otherAxisProperty = e),
                this.isAngular ||
                  ((this.xCenterOffsetProperty = e.xCenterOffset),
                  (this.yCenterOffsetProperty = e.yCenterOffset));
            } else {
              const e = this.parentSurface.xAxes
                .asArray()
                .find((e) => e.isPolarAxis && e.isAngular !== this.isAngular);
              if (!e)
                throw new Error(
                  `Could not find a polar x axis with isAngluar: ${!this
                    .isAngular}`
                );
              (this.otherAxisProperty = e),
                this.isAngular ||
                  ((this.xCenterOffsetProperty = e.xCenterOffset),
                  (this.yCenterOffsetProperty = e.yCenterOffset));
            }
            super.measure();
          }
          zoomBy(e, t) {
            return this.isAngular
              ? super.zoomBy(e, t)
              : super.zoomBy(0, t / 10);
          }
          scroll(e, t) {
            return this.isAngular
              ? super.scroll(
                  (e / this.otherAxis.axisLength) * this.axisLength,
                  t
                )
              : super.scroll(e, u.EClipMode.ClipAtMin);
          }
          getTransform(e = !1) {
            const { x: t, y: r } = this.viewRect;
            this.coordTransform.yIsPolar =
              this.isAngular && !this.isXAxisProperty;
            const i = e ? h.DpiHelper.PIXEL_RATIO : 1;
            return (
              (this.coordTransform.XCenter =
                (t - this.parentSurface.seriesViewRect.left) / i),
              (this.coordTransform.YCenter =
                (r - this.parentSurface.seriesViewRect.top) / i),
              (this.coordTransform.StartAngle = this.startAngle),
              this.coordTransform
            );
          }
          get isHorizontalAxis() {
            return this.isAngular;
          }
          get isVerticalChart() {
            return this.isXAxis && !this.isAngular;
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                gridlineMode: this.gridlineMode,
                innerRadius: this.innerRadius,
                lengthScale: this.lengthScale,
                polarAxisMode: this.polarAxisMode,
                polarLabelMode: this.polarLabelMode,
                startAngle: this.startAngle,
                totalAngle: this.totalAngle,
                xCenterOffset: this.xCenterOffset,
                yCenterOffset: this.yCenterOffset,
              };
            return Object.assign(Object.assign({}, e), {
              options: Object.assign(Object.assign({}, e.options), t),
            });
          }
          delete() {
            (this.coordTransform = (0, i.deleteSafe)(this.coordTransform)),
              super.delete();
          }
          drawAxisBands(e, t, r, i) {}
          getPenForLines(e, t, r, i) {
            if (
              (e === this.penCacheForMajorGridLines ||
                e === this.penCacheForMinorGridLines) &&
              !this.isAngular &&
              this.gridlineMode === y.EPolarGridlineMode.Circles
            ) {
              const o = r > 0 ? r + 2 : 0;
              return (0, s.createPenInCache)(e, t, o, 1, i, !1);
            }
            const o = r > 0 ? r + 1 : 0;
            return (0, s.createPenInCache)(e, t, o, 1, i, !0);
          }
          drawGridLines(e, t, r, i) {
            var o, s, u, c;
            const p = e.getNativeContext(),
              g = this.parentSurface.seriesViewRect;
            if (!t || 0 === t.length) return;
            const f =
                (null !==
                  (s =
                    null === (o = this.parentSurface.padding) || void 0 === o
                      ? void 0
                      : o.left) && void 0 !== s
                  ? s
                  : 0) * h.DpiHelper.PIXEL_RATIO,
              v =
                (null !==
                  (c =
                    null === (u = this.parentSurface.padding) || void 0 === u
                      ? void 0
                      : u.top) && void 0 !== c
                  ? c
                  : 0) * h.DpiHelper.PIXEL_RATIO;
            let { x: m, y: S, width: P } = this.viewRect;
            const C = this.getTransform();
            P *= this.otherAxis.lengthScale;
            const b = a.Rect.intersect(
              this.parentSurface.viewRect,
              this.parentSurface.clipRect
            );
            if (this.isAngular) {
              p.PushMatrix(),
                p.PushState(),
                p.SetClipRect(g.x, g.y, g.width, g.height);
              const o = (0, l.getVectorColorVertex)(this.webAssemblyContext2D),
                a = new this.webAssemblyContext2D.TSRVector2();
              let s = (0, l.getVertex)(this.webAssemblyContext2D, 0, 0);
              const d = 15;
              t.forEach((e, t) => {
                C.TransformPoint(P, e, a),
                  s.SetPosition(a.x, a.y),
                  o.push_back(s),
                  this.otherAxis.offset > 0
                    ? (C.TransformPoint(this.otherAxis.offset, e, a),
                      s.SetPosition(a.x, a.y),
                      o.push_back(s))
                    : i
                    ? (s.SetPosition(C.XCenter, C.YCenter), o.push_back(s))
                    : (C.TransformPoint(d, e, a),
                      s.SetPosition(a.x, a.y),
                      o.push_back(s));
              }),
                e.drawLinesNative(
                  o,
                  r,
                  n.ELineDrawMode.DiscontinuousLine,
                  b,
                  f,
                  v
                ),
                p.PopMatrix(),
                p.PopState();
            } else if (this.gridlineMode === y.EPolarGridlineMode.Polygons) {
              p.PushMatrix(),
                p.PushState(),
                p.SetClipRect(g.x, g.y, g.width, g.height);
              const i = this.otherAxis.getTicksWithCoords().majorTickCoords,
                o = (0, l.getVectorColorVertex)(this.webAssemblyContext2D),
                a = new this.webAssemblyContext2D.TSRVector2();
              let s = (0, l.getVertex)(this.webAssemblyContext2D, 0, 0);
              t.forEach((e) => {
                i.forEach((t, r) => {
                  C.TransformPoint(e, t, a),
                    s.SetPosition(a.x, a.y),
                    o.push_back(s),
                    r > 0 && r < i.length - 1 && o.push_back(s);
                });
              }),
                a.delete(),
                e.drawLinesNative(
                  o,
                  r,
                  n.ELineDrawMode.DiscontinuousLine,
                  b,
                  f,
                  v
                ),
                p.PopMatrix(),
                p.PopState();
            } else {
              const i = (0, l.getVectorArcVertex)(this.webAssemblyContext2D),
                o = (0, l.getArcVertex)(this.webAssemblyContext2D);
              let a = 0;
              a = this.parentSurface.isCopyCanvasSurface
                ? d.SciChartSurfaceBase.domMasterCanvas.height
                : this.parentSurface.renderSurface.viewportSize.height;
              const s = this.otherAxis.startAngle,
                n = this.otherAxis.axisLength;
              t.forEach((e) => {
                o.MakeCircularArc(C.XCenter, a - C.YCenter, 0, n, e, 0, 1, 1),
                  i.push_back(o);
              });
              const h = this.parentSurface.seriesViewRect;
              e.drawArcs(i, C.XCenter, a - C.YCenter, s, h, r, void 0, f, v);
            }
          }
          toRadians(e) {
            return (e * Math.PI) / 180;
          }
          reverseTransform(e, t) {
            const r = this.getTransform(),
              i = new this.webAssemblyContext2D.TSRVector2();
            let a;
            return (
              r.ReverseTransformPoint(e, t, i),
              (a =
                this.isAngular && this.isXAxis
                  ? new o.Point(-i.y, i.x)
                  : new o.Point(i.x, -i.y)),
              i.delete(),
              a
            );
          }
        }
        t.PolarAxisBase = v;
      },
      31951: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarAxisRenderer = void 0);
        const i = r(87459),
          o = r(36420),
          a = r(9254),
          s = r(48008),
          n = r(16185),
          l = r(10572),
          d = r(98353),
          h = r(62288),
          u = r(14184),
          c = r(86127),
          p = r(74736),
          g = r(8827);
        class y extends p.AxisRenderer {
          layout(e) {
            this.outerRadius = e.width;
          }
          measure(e, t, r, i, o, a, s) {
            const n = this.parentAxis,
              l = this.measureTextCanvas.getContext("2d");
            (this.desiredTicksSize = s ? i : 0),
              a &&
                n.isAngular &&
                (n.isInnerAxis
                  ? ((this.desiredHeight = 0), (this.desiredWidth = 0))
                  : n.polarLabelMode === g.EPolarLabelMode.Parallel
                  ? ((this.desiredHeight =
                      o.getMaxLabelHeightForHorizontalAxis(r, l, t) +
                      this.desiredTicksSize),
                    (this.desiredWidth = this.desiredHeight))
                  : n.polarLabelMode === g.EPolarLabelMode.Perpendicular
                  ? ((this.desiredHeight =
                      o.getMaxLabelWidthForVerticalAxis(r, l, t) +
                      this.desiredTicksSize),
                    (this.desiredWidth = this.desiredHeight))
                  : ((this.desiredHeight =
                      o.getMaxLabelHeightForHorizontalAxis(r, l, t) +
                      this.desiredTicksSize),
                    (this.desiredWidth =
                      o.getMaxLabelWidthForVerticalAxis(r, l, t) +
                      this.desiredTicksSize)));
          }
          drawLabels(e, t, r, n, c, p, y, f, v, m) {
            u.DebugForDpi &&
              console.log(`AxisRenderer.drawLabels. fontSize: ${y.fontSize}`);
            const { viewRect: S, textureManager: P } = this,
              C = e.getNativeContext();
            let b;
            const { padding: x, alignment: A, multilineAlignment: T } = y,
              E = this.parentAxis,
              R = E.parentSurface.seriesViewRect;
            C.PushMatrix(),
              C.PushState(),
              C.SetClipRect(R.x, R.y, R.width, R.height);
            const D = [],
              w = (0, s.parseColorToUIntArgb)(y.color),
              M = m.useNativeText ? e.getFont(y, !0) : null,
              L = m.useNativeText
                ? (0, d.getTextBounds)(this.webAssemblyContext)
                : null;
            if (
              !M &&
              ((b = P.getTextureContext(R.width, R.height)),
              E.polarLabelMode !== g.EPolarLabelMode.Horizontal)
            )
              throw new Error(
                "Original text drawing only supports EPolarLabelMode.Horizontal.  To use rotated labels, set useNativeText: true"
              );
            c = c.map((e) => e - p);
            const O = (0, o.convertMultiLineAlignment)(
                T,
                this.webAssemblyContext
              ),
              I = m.lineSpacing;
            let k = 0;
            M &&
              (M.CalculateStringBounds("Ag", L, 0),
              (k = L.GetLineBounds(0).m_fHeight));
            const _ = new this.webAssemblyContext.TSRVector2();
            if (E.isAngular) {
              const e = (y.padding.left + y.padding.right) / 2;
              let t = [],
                o = [];
              if (!m.useCache && m.useNativeText)
                for (const e of n)
                  M.CalculateStringBounds(null != e ? e : "", L, 2),
                    t.push(L.m_fHeight),
                    o.push(L.m_fWidth);
              else if (m.useNativeText) {
                const r = (y.padding.top + y.padding.bottom) / 2;
                (t = n.map((e) => m.getLabelHeight(b, e, y) - 2 * r)),
                  (o = n.map((t) => m.getLabelWidth(b, t, y) - 2 * e));
              } else
                (t = n.map((e) => m.getLabelHeight(b, e, y))),
                  (o = n.map((e) => m.getLabelWidth(b, e, y)));
              const s = r
                  ? this.outerRadius * Math.min(E.otherAxis.lengthScale, 1) -
                    this.desiredTicksSize
                  : this.outerRadius * Math.min(E.otherAxis.lengthScale, 1) +
                    this.desiredTicksSize,
                h = E.getTransform(),
                u = 10,
                p = E.totalAngle < 2 * Math.PI ? c.length : c.length - 1;
              for (let f = 0; f < p; f++) {
                let p = c[f],
                  v = n[f];
                const S = t[f],
                  b = o[f];
                let x = s;
                E.polarLabelMode === g.EPolarLabelMode.Parallel
                  ? (x =
                      s +
                      0.5 * (r ? -1 : 1) * S +
                      (r ? -y.padding.top : y.padding.bottom))
                  : E.polarLabelMode === g.EPolarLabelMode.Perpendicular
                  ? (x =
                      s +
                      (Math.cos(p + E.startAngle) < 0
                        ? r
                          ? 0
                          : 1
                        : r
                        ? -1
                        : 0) *
                        b +
                      (r ? -1 : 1) * e)
                  : E.polarLabelMode === g.EPolarLabelMode.Horizontal &&
                    m.useNativeText &&
                    (x = s + (r ? -y.padding.top : y.padding.bottom)),
                  h.TransformPoint(x, p, _),
                  (p += E.startAngle);
                let A = _.x,
                  T = _.y,
                  L = 0,
                  V = 0;
                if (E.polarLabelMode === g.EPolarLabelMode.Horizontal) {
                  r && (p += Math.PI);
                  const e = Math.round((180 * p) / Math.PI),
                    t = ((((e + u) / 90) % 4) + 4) % 4;
                  Math.abs(e) % 90 < u || Math.abs(e) % 90 > 90 - u
                    ? t < 1
                      ? (T -= S / 2)
                      : t < 2
                      ? ((A -= b / 2), (T -= S))
                      : t < 3
                      ? ((A -= b), (T -= S / 2))
                      : (A -= b / 2)
                    : (Math.cos(p) < 0 && (A -= b),
                      Math.sin(p) > 0 && (T -= S));
                } else
                  E.polarLabelMode === g.EPolarLabelMode.Parallel
                    ? ((L = A + R.left),
                      (V = T + R.top),
                      (A -= b / 2),
                      Math.sin(p) >= 0 ? (T -= S / 2) : (T += S / 2 - k))
                    : E.polarLabelMode === g.EPolarLabelMode.Perpendicular &&
                      ((L = A + R.left), (V = T + R.top), (T -= S / 2));
                const N = l.labelHelper.getPolarLabelRotation(
                  E.polarLabelMode,
                  p
                );
                try {
                  if (M) {
                    let e = A + R.left,
                      t = T + R.top + k;
                    const {
                      text: r,
                      x: o,
                      y: a,
                      rx: s,
                      ry: n,
                      rotationRadians: l,
                      color: h,
                    } = m.adjustLabel(f, v, b, S, e, t, L, V, N);
                    this.drawDebug && D.push(i.Rect.create(o, a, b, S)),
                      M.DrawStringAdvanced(
                        null != r ? r : "",
                        null != h ? h : w,
                        Math.round(o),
                        Math.round(a),
                        (0, d.getVector4)(this.webAssemblyContext, s, n, l, 0),
                        O,
                        I
                      );
                  } else {
                    const {
                        bitmapTexture: e,
                        textureHeight: t,
                        textureWidth: r,
                      } = m.getCachedLabelTexture(v, P, y),
                      { x: i, y: o } = m.adjustLabel(
                        f,
                        v,
                        b,
                        S,
                        A + R.left,
                        T + R.top,
                        0,
                        0,
                        0
                      );
                    e &&
                      (C.DrawTexture(e, Math.round(i), Math.round(o), r, t),
                      m.useCache || e.delete());
                  }
                } catch (e) {
                  a.Logger.debug(e), m.delete();
                }
              }
            } else {
              const {
                isAntiClockWise: e,
                labelRotation: t,
                startAngle: o,
              } = h.polarChartHelper.calcLabelPosition(
                r,
                E.otherAxis.flippedCoordinates,
                E.startAngle,
                E.otherAxis.totalAngle
              );
              let s = o;
              const l = E.getTransform();
              let u = [],
                g = [];
              if (!m.useCache && m.useNativeText)
                for (const e of n)
                  M.CalculateStringBounds(null != e ? e : "", L, 2),
                    u.push(L.m_fHeight + y.padding.top + y.padding.bottom),
                    g.push(L.m_fWidth + y.padding.left + y.padding.right);
              else
                (u = n.map((e) => m.getLabelHeight(b, e, y))),
                  (g = n.map((e) => m.getLabelWidth(b, e, y)));
              const f = this.desiredTicksSize;
              for (let r = 0; r < c.length; r++) {
                const h = c[r] + p,
                  v = n[r],
                  S = g[r],
                  b = u[r];
                l.TransformPoint(h, t, _);
                let A = _.x,
                  T = _.y;
                e && (s = o + Math.PI),
                  (A += (Math.sin(s) / 2 - 0.5) * S),
                  (A += Math.sin(s) * f);
                const E = (s < 0 ? 2 * Math.PI - s : s) % (2 * Math.PI);
                (T -= (E < Math.PI ? E / Math.PI : 2 - E / Math.PI) * b),
                  (T += Math.cos(s) * f),
                  this.drawDebug && D.push(i.Rect.create(A, T, S, b));
                try {
                  if (M) {
                    const e = A + R.left + x.left,
                      t = T + R.top + k + x.top,
                      {
                        text: i,
                        x: o,
                        y: a,
                        rx: s,
                        ry: n,
                        rotationRadians: l,
                        color: h,
                      } = m.adjustLabel(r, v, S, b, e, t, e, t, 0);
                    M.DrawStringAdvanced(
                      null != i ? i : "",
                      null != h ? h : w,
                      Math.round(o),
                      Math.round(a),
                      (0, d.getVector4)(this.webAssemblyContext, s, n, l, 0),
                      O,
                      I
                    );
                  } else {
                    const {
                      bitmapTexture: e,
                      textureHeight: t,
                      textureWidth: i,
                    } = m.getCachedLabelTexture(v, P, y);
                    if (e) {
                      const { x: o, y: a } = m.adjustLabel(
                        r,
                        v,
                        S,
                        b,
                        A + R.left,
                        T + R.top,
                        0,
                        0,
                        0
                      );
                      C.DrawTexture(e, Math.round(o), Math.round(a), i, t),
                        m.useCache || e.delete();
                    }
                  }
                } catch (e) {
                  a.Logger.debug(e), m.delete();
                }
              }
            }
            _.delete(),
              this.drawDebug &&
                this.drawLabelViewRects(e, new i.Rect(0, 0, 0, 0), D),
              M && M.End(),
              C.PopMatrix(),
              C.PopState();
          }
          drawTicks(e, t, r, o, a, s, l) {
            var u, p, g, y;
            if (!o || 0 === o.length) return;
            const { viewRect: f } = this,
              v = e.getNativeContext();
            v.PushMatrix(),
              v.PushState(),
              v.SetClipRect(f.x, f.y, f.width, f.height);
            const m =
                c.DpiHelper.PIXEL_RATIO *
                (null !==
                  (p =
                    null === (u = this.parentAxis.parentSurface.padding) ||
                    void 0 === u
                      ? void 0
                      : u.left) && void 0 !== p
                  ? p
                  : 0),
              S =
                c.DpiHelper.PIXEL_RATIO *
                (null !==
                  (y =
                    null === (g = this.parentAxis.parentSurface.padding) ||
                    void 0 === g
                      ? void 0
                      : g.top) && void 0 !== y
                  ? y
                  : 0),
              P = this.parentAxis,
              { tickSize: C } = l,
              b = P.getTransform(),
              x = i.Rect.intersect(
                this.parentAxis.parentSurface.viewRect,
                this.parentAxis.parentSurface.clipRect
              );
            if (P.isAngular) {
              const t = P.otherAxis.offset,
                i = P.otherAxis.axisLength + t,
                a = r
                  ? i - C * c.DpiHelper.PIXEL_RATIO
                  : i + C * c.DpiHelper.PIXEL_RATIO,
                l = (0, d.getVectorColorVertex)(this.webAssemblyContext);
              let h = (0, d.getVertex)(this.webAssemblyContext, 0, 0);
              const u = new this.webAssemblyContext.TSRVector2();
              o.forEach((e) => {
                b.TransformPoint(i, e, u),
                  h.SetPosition(u.x, u.y),
                  l.push_back(h),
                  b.TransformPoint(a, e, u),
                  h.SetPosition(u.x, u.y),
                  l.push_back(h);
              }),
                e.drawLinesNative(
                  l,
                  s,
                  n.ELineDrawMode.DiscontinuousLine,
                  x,
                  m,
                  S
                );
            } else {
              const t = (0, d.getVectorColorVertex)(this.webAssemblyContext);
              let i = (0, d.getVertex)(this.webAssemblyContext, 0, 0);
              const a = (0, d.getVector2)(this.webAssemblyContext),
                {
                  direction: l,
                  tickRotation: u,
                  startAngle: c,
                } = h.polarChartHelper.calcTickDirection(
                  r,
                  P.otherAxis.flippedCoordinates,
                  P.startAngle,
                  P.otherAxis.totalAngle
                ),
                p = l * Math.sin(c) * C,
                g = l * Math.cos(c) * C;
              o.forEach((e) => {
                b.TransformPoint(e, u, a),
                  i.SetPosition(a.x, a.y),
                  t.push_back(i),
                  i.SetPosition(a.x + p, a.y + g),
                  t.push_back(i);
              }),
                e.drawLinesNative(
                  t,
                  s,
                  n.ELineDrawMode.DiscontinuousLine,
                  x,
                  m,
                  S
                );
            }
            v.PopMatrix(), v.PopState();
          }
        }
        t.PolarAxisRenderer = y;
      },
      1370: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarCategoryAxis = void 0);
        const i = r(98140),
          o = r(2192),
          a = r(21430),
          s = r(3346),
          n = r(59516),
          l = r(4220),
          d = r(78471),
          h = r(18184),
          u = r(52320),
          c = r(31951);
        class p extends u.PolarAxisBase {
          constructor(e, t) {
            var r, i, n;
            super(e, t),
              (this.type = o.EAxisType.PolarCategoryAxis),
              (this.defaultXValuesProperty = []),
              (this.defaultXStartProperty = 0),
              (this.defaultXStepProperty = 1),
              (this.defaultXValuesProperty =
                null !== (r = null == t ? void 0 : t.defaultXValues) &&
                void 0 !== r
                  ? r
                  : this.defaultXValuesProperty),
              (this.defaultXStartProperty =
                null !== (i = null == t ? void 0 : t.defaultXStart) &&
                void 0 !== i
                  ? i
                  : this.defaultXStartProperty),
              (this.defaultXStepProperty =
                null !== (n = null == t ? void 0 : t.defaultXStep) &&
                void 0 !== n
                  ? n
                  : this.defaultXStepProperty),
              (this.tickProvider = new s.NumericTickProvider(
                this.webAssemblyContext2D
              )),
              (this.deltaCalculator = new l.CategoryDeltaCalculator(
                this.webAssemblyContext2D
              )),
              (this.defaultBaseXValues =
                new this.webAssemblyContext2D.SCRTDoubleVector()),
              (this.tickCoordinatesProvider =
                new a.PolarTickCoordinatesProvider()),
              (null == t ? void 0 : t.labelProvider)
                ? (this.labelProvider = null == t ? void 0 : t.labelProvider)
                : (null == t ? void 0 : t.labels)
                ? (this.labelProvider = new h.TextLabelProvider(t))
                : (this.labelProvider = new d.DateLabelProvider(t)),
              (this.axisRenderer = new c.PolarAxisRenderer(e));
          }
          get isCategoryAxis() {
            return !0;
          }
          get defaultXValues() {
            return this.defaultXValuesProperty;
          }
          set defaultXValues(e) {
            (this.defaultXValuesProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          get defaultXStart() {
            return this.defaultXStartProperty;
          }
          set defaultXStart(e) {
            (this.defaultXStartProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          get defaultXStep() {
            return this.defaultXStepProperty;
          }
          set defaultXStep(e) {
            (this.defaultXStepProperty = e),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          prepareRenderData() {
            n.CategoryAxis.prototype.prepareRenderData.call(this);
          }
          delete() {
            super.delete(), n.CategoryAxis.prototype.delete.call(this);
          }
          getCurrentCoordinateCalculatorInternal() {
            return n.CategoryAxis.prototype.getCurrentCoordinateCalculatorInternal.call(
              this
            );
          }
          getXDataRange() {
            let e;
            return (
              this.parentSurface &&
                this.getVisibleRenderableSeriesByXAxis().forEach((t) => {
                  const r = t.getDataSeriesValuesCount(),
                    o = new i.NumberRange(0, r - 1);
                  o && (e = e ? e.union(o) : o);
                }),
              e
            );
          }
          getMaxAutoTicks() {
            return n.CategoryAxis.prototype.getMaxAutoTicks.call(this);
          }
          generateDefaultXValuesForCategoryAxis(e, t) {
            return n.CategoryAxis.prototype.generateDefaultXValuesForCategoryAxis.call(
              this,
              e,
              t
            );
          }
          setBaseXValues(e, t) {
            return n.CategoryAxis.prototype.setBaseXValues.call(this, e, t);
          }
        }
        t.PolarCategoryAxis = p;
      },
      63922: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarNumericAxis = void 0);
        const i = r(49742),
          o = r(2192),
          a = r(33166),
          s = r(40194),
          n = r(21430),
          l = r(3346),
          d = r(40059),
          h = r(39920),
          u = r(52320);
        class c extends u.PolarAxisBase {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.type = o.EAxisType.PolarNumericAxis),
              (this.tickProvider = new l.NumericTickProvider(
                this.webAssemblyContext2D
              )),
              (this.tickCoordinatesProvider =
                new n.PolarTickCoordinatesProvider()),
              (this.labelProvider =
                null !== (r = null == t ? void 0 : t.labelProvider) &&
                void 0 !== r
                  ? r
                  : new h.NumericLabelProvider(t)),
              (this.deltaCalculator = new d.NumericDeltaCalculator(
                this.webAssemblyContext2D
              )),
              (this.axisRenderer = new i.PolarAxisRenderer(e));
          }
          getCurrentCoordinateCalculatorInternal() {
            const e = this.visibleRange.min,
              t = this.visibleRange.max,
              r = this.getAxisSize(),
              i = this.offset;
            return this.flippedCoordinates
              ? new s.NumericCoordinateCalculator(
                  this.webAssemblyContext2D,
                  r,
                  e,
                  t,
                  i,
                  this.allowFastMath,
                  0,
                  0
                )
              : new a.FlippedNumericCoordinateCalculator(
                  this.webAssemblyContext2D,
                  r,
                  e,
                  t,
                  i,
                  this.allowFastMath,
                  0
                );
          }
        }
        t.PolarNumericAxis = c;
      },
      16989: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPolarAxisMode = void 0),
          ((r = t.EPolarAxisMode || (t.EPolarAxisMode = {})).Angular =
            "Angular"),
          (r.Radial = "Radial");
      },
      80574: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPolarGridlineMode = void 0),
          ((r = t.EPolarGridlineMode || (t.EPolarGridlineMode = {})).Circles =
            "Circles"),
          (r.Polygons = "Polygons");
      },
      8827: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPolarLabelMode = void 0),
          ((r = t.EPolarLabelMode || (t.EPolarLabelMode = {})).Horizontal =
            "Horizontal"),
          (r.Parallel = "Parallel"),
          (r.Perpendicular = "Perpendicular");
      },
      83989: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VisibleRangeChangedArgs = void 0),
          (t.VisibleRangeChangedArgs = class {
            constructor(e) {
              this.visibleRange = e;
            }
          });
      },
      8900: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).ALLOW_FAST_MATH =
            "ALLOW_FAST_MATH"),
          (r.AUTO_RANGE = "AUTO_RANGE"),
          (r.AUTO_TICKS = "AUTO_TICKS"),
          (r.AXIS_ALIGNMENT = "AXIS_ALIGNMENT"),
          (r.AXIS_BANDS_FILL = "AXIS_BANDS_FILL"),
          (r.AXIS_TITLE = "AXIS_TITLE"),
          (r.AXIS_LENGTH = "AXIS_LENGTH"),
          (r.BORDER = "BORDER"),
          (r.CURSOR_TEXT_FORMATTING = "CURSOR_TEXT_FORMATTING"),
          (r.DELTA_CALCULATOR = "DELTA_CALCULATOR"),
          (r.TICK_COORDINATES_CALCULATOR = "TICK_COORDINATES_CALCULATOR"),
          (r.DRAW_MAJOR_GRID_LINES = "DRAW_MAJOR_GRID_LINES"),
          (r.DRAW_MINOR_GRID_LINES = "DRAW_MINOR_GRID_LINES"),
          (r.DRAW_MAJOR_TICK_LINES = "DRAW_MAJOR_TICK_LINES"),
          (r.DRAW_MINOR_TICK_LINES = "DRAW_MINOR_TICK_LINES"),
          (r.DRAW_MAJOR_BANDS = "DRAW_MAJOR_BANDS"),
          (r.DRAW_LABELS = "DRAW_LABELS"),
          (r.FLIPPED_COORDINATES = "FLIPPED_COORDINATES"),
          (r.GROW_BY = "GROW_BY"),
          (r.ID = "ID"),
          (r.IS_AXIS_FLIPPED = "IS_AXIS_FLIPPED"),
          (r.IS_NEGATIVE = "IS_NEGATIVE"),
          (r.IS_INNER_AXIS = "IS_INNER_AXIS"),
          (r.IS_PRIMARY_AXIS = "IS_PRIMARY_AXIS"),
          (r.IS_VISIBLE = "IS_VISIBLE"),
          (r.IS_XAXIS = "IS_XAXIS"),
          (r.LABEL_PROVIDER = "LABEL_PROVIDER"),
          (r.AXIS_RENDERER = "LABEL_PROVIDER"),
          (r.LOG_BASE = "LOG_BASE"),
          (r.MAJOR_DELTA = "MAJOR_DELTA"),
          (r.MAJOR_GRID_LINE_STYLE = "MAJOR_GRID_LINE_STYLE"),
          (r.MAJOR_TICK_LINE_STYLE = "MAJOR_TICK_LINE_STYLE"),
          (r.MAX_AUTO_TICKS = "MAX_AUTO_TICKS"),
          (r.MINOR_DELTA = "MINOR_DELTA"),
          (r.MINOR_GRID_LINE_STYLE = "MINOR_GRID_LINE_STYLE"),
          (r.MINOR_TICK_LINE_STYLE = "MINOR_TICK_LINE_STYLE"),
          (r.MINORS_PER_MAJOR = "MINORS_PER_MAJOR"),
          (r.OFFSET = "OFFSET"),
          (r.TEXT_FORMATTING = "TEXT_FORMATTING"),
          (r.TEXT_STYLE = "TEXT_STYLE"),
          (r.TICK_TEXT_BRUSH = "TICK_TEXT_BRUSH"),
          (r.VISIBLE_RANGE = "VISIBLE_RANGE"),
          (r.VISIBLE_RANGE_LIMIT = "VISIBLE_RANGE_LIMIT"),
          (r.VISIBLE_RANGE_SIZE_LIMIT = "VISIBLE_RANGE_SIZE_LIMIT"),
          (r.TICK_PROVIDER = "TICK_PROVIDER"),
          (r.VIEW_RECT = "VIEW_RECT"),
          (r.ZOOMEXTENTS_RANGE = "ZOOMEXTENTS_RANGE"),
          (r.DRAW_ONLY_WITHIN_XRANGE = "DRAW_ONLY_WITHIN_XRANGE"),
          (r.HIGH_PRECISION_TICKS = "HIGH_PRECISION_TICKS");
      },
      74734: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAxis3dById = t.getAxisById = void 0);
        const i = r(23866);
        function o(e, t) {
          i.Guard.notNull(e, "axes");
          for (let r = 0; r < e.size(); r++) {
            const i = e.get(r);
            if (i.id === t) return i;
          }
          console.warn(
            `scichart getAxisGeneric(): Axis with Id '${t}' was not found`
          );
        }
        (t.getAxisById = function (e, t) {
          return o(e, t);
        }),
          (t.getAxis3dById = function (e, t) {
            return o(e, t);
          });
      },
      31858: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HeatmapLegend = void 0);
        const o = r(23866),
          a = r(98140),
          s = r(14936),
          n = r(15799),
          l = r(54948),
          d = r(60981),
          h = r(70033),
          u = r(84626),
          c = r(56744),
          p = r(55023);
        class g extends p.DeletableEntity {
          constructor(e, t) {
            var r, i, s, u, c, p, g;
            super(),
              (this.SIZE = 100),
              o.Guard.notNull(e, "sciChartSurface"),
              (this.sciChartSurface = e),
              (this.wasmContext = e.webAssemblyContext2D);
            const y =
                null !==
                  (i =
                    null === (r = null == t ? void 0 : t.colorMap) ||
                    void 0 === r
                      ? void 0
                      : r.minimum) && void 0 !== i
                  ? i
                  : 0,
              f =
                null !==
                  (u =
                    null === (s = null == t ? void 0 : t.colorMap) ||
                    void 0 === s
                      ? void 0
                      : s.maximum) && void 0 !== u
                  ? u
                  : 100,
              v =
                null !==
                  (p =
                    null === (c = null == t ? void 0 : t.colorMap) ||
                    void 0 === c
                      ? void 0
                      : c.gradientStops) && void 0 !== p
                  ? p
                  : this.getDefaultGradientStops();
            e.xAxes.add(
              new l.NumericAxis(
                this.wasmContext,
                Object.assign({}, this.getDefaultXAxisOptions())
              )
            ),
              e.yAxes.add(
                new l.NumericAxis(
                  this.wasmContext,
                  Object.assign(
                    Object.assign(
                      Object.assign({}, this.getDefaultYAxisOptions()),
                      null == t ? void 0 : t.yAxisOptions
                    ),
                    { visibleRange: new a.NumberRange(y, f) }
                  )
                )
              );
            const m = this.getZValues(y, f);
            e.renderableSeries.add(
              new h.UniformHeatmapRenderableSeries(this.wasmContext, {
                dataSeries: new n.UniformHeatmapDataSeries(this.wasmContext, {
                  xStart: 0,
                  xStep: 1,
                  yStart: y,
                  yStep: (f - y) / this.SIZE,
                  zValues: m,
                }),
                useLinearTextureFiltering: !0,
                colorMap:
                  null !== (g = null == t ? void 0 : t.colorMap) && void 0 !== g
                    ? g
                    : new d.HeatmapColorMap({
                        minimum: y,
                        maximum: f,
                        gradientStops: v,
                      }),
              })
            );
          }
          static create(e, t) {
            return i(this, void 0, void 0, function* () {
              const { sciChartSurface: r, wasmContext: i } =
                yield u.SciChartSurface.create(e, {
                  theme: null == t ? void 0 : t.theme,
                });
              return { wasmContext: i, heatmapLegend: new g(r, t) };
            });
          }
          delete() {
            (this.sciChartSurface = (0, c.deleteSafe)(this.sciChartSurface)),
              (this.wasmContext = void 0);
          }
          get innerSciChartSurface() {
            return {
              sciChartSurface: this.sciChartSurface,
              wasmContext: this.wasmContext,
            };
          }
          getDefaultGradientStops() {
            return [
              { offset: 1, color: "Red" },
              { offset: 0, color: "Blue" },
            ];
          }
          getDefaultXAxisOptions() {
            return {
              drawMajorGridLines: !1,
              drawMinorGridLines: !1,
              drawMajorTickLines: !1,
              drawMinorTickLines: !1,
              drawLabels: !1,
            };
          }
          getDefaultYAxisOptions() {
            return {
              maxAutoTicks: 5,
              drawMajorGridLines: !1,
              drawMinorGridLines: !1,
              drawLabels: !0,
              drawMajorTickLines: !0,
              drawMinorTickLines: !0,
            };
          }
          getZValues(e, t) {
            const r = (0, s.zeroArray2D)([this.SIZE, 1]),
              i = (t - e) / (this.SIZE - 1);
            for (let t = 0, o = e; t < this.SIZE; t++, o += i) r[t][0] = o;
            return r;
          }
        }
        t.HeatmapLegend = g;
      },
      98353: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAllFontKeys =
            t.getFontKey =
            t.getVector3 =
            t.getVector2 =
            t.getVector4 =
            t.getNativeRect =
            t.getTextBounds =
            t.getTextureVertex =
            t.getArcVertex =
            t.getVertex =
            t.getVectorArcVertex =
            t.getVectorColorTextureVertex =
            t.getVectorColorVertex =
            t.getVectorRectVertex =
            t.freeCache =
            t.deleteCache =
            t.FontKey =
              void 0);
        const i = r(55023),
          o = r(56744),
          a = r(52578),
          s = r(16155),
          n = r(85479);
        class l extends i.DeletableEntity {
          constructor(e) {
            super(), (this.firstLoadTime = Date.now()), (this.nativeKey = e);
          }
          delete() {
            (0, o.deleteSafe)(this.nativeKey);
          }
        }
        t.FontKey = l;
        const d = new Map(),
          h = (e) => {
            var t, r;
            const i =
              null !==
                (r =
                  null === (t = null == e ? void 0 : e.canvas) || void 0 === t
                    ? void 0
                    : t.id) && void 0 !== r
                ? r
                : "TEST";
            return (
              d.has(i) ||
                d.set(i, {
                  vecRects: void 0,
                  vecColorVertex: void 0,
                  vecColorTextureVertex: void 0,
                  vecArcVertex: void 0,
                  vertex: void 0,
                  arcVertex: void 0,
                  textureVertex: void 0,
                  rect: void 0,
                  vector4: void 0,
                  vector2: void 0,
                  vector3: void 0,
                  textBounds: void 0,
                  keyCache: new Map(),
                }),
              d.get(i)
            );
          };
        (t.deleteCache = (e) => {
          if (!e.canvas) return;
          const t = e.canvas.id,
            r = d.get(t);
          r &&
            ((0, o.deleteSafe)(r.vecRects),
            (0, o.deleteSafe)(r.vecColorVertex),
            (0, o.deleteSafe)(r.vecColorTextureVertex),
            (0, o.deleteSafe)(r.vecArcVertex),
            (0, o.deleteSafe)(r.vertex),
            (0, o.deleteSafe)(r.arcVertex),
            (0, o.deleteSafe)(r.textureVertex),
            (0, o.deleteSafe)(r.rect),
            (0, o.deleteSafe)(r.vector4),
            (0, o.deleteSafe)(r.vector2),
            (0, o.deleteSafe)(r.vector3),
            (0, o.deleteSafe)(r.textBounds),
            r.keyCache.forEach((e) => (0, o.deleteSafe)(e))),
            d.delete(t);
        }),
          (t.freeCache = (e) => ({ delete: () => (0, t.deleteCache)(e) })),
          (t.getVectorRectVertex = (e, t = 100) => {
            const r = h(e);
            if (!r) return;
            let i = r.vecRects;
            return (
              i ||
                ((i = new e.VectorRectVertex()),
                i.reserve(t),
                (r.vecRects = i)),
              i.clear(),
              i
            );
          }),
          (t.getVectorColorVertex = (e, t = 100) => {
            const r = h(e);
            if (!r) return;
            let i = r.vecColorVertex;
            return (
              i ||
                ((i = new e.VectorColorVertex()),
                i.reserve(t),
                (r.vecColorVertex = i)),
              i.clear(),
              i
            );
          }),
          (t.getVectorColorTextureVertex = (e, t = 100) => {
            const r = h(e);
            if (!r) return;
            let i = r.vecColorTextureVertex;
            return (
              i ||
                ((i = new e.VectorColorTextureVertex()),
                i.reserve(t),
                (r.vecColorTextureVertex = i)),
              i.clear(),
              i
            );
          }),
          (t.getVectorArcVertex = (e, t = 100) => {
            const r = h(e);
            if (!r) return;
            let i = r.vecArcVertex;
            return (
              i ||
                ((i = new e.VectorArcVertex()),
                i.reserve(t),
                (r.vecArcVertex = i)),
              i.clear(),
              i
            );
          }),
          (t.getVertex = (e, t, r, i) => {
            const o = h(e);
            if (!o) return;
            let a = o.vertex;
            return (
              a
                ? (a.SetPosition(t, r),
                  (a.m_uiColor = null != i ? i : 4294967295))
                : ((a = new e.SCRTColorVertex(t, r)), (o.vertex = a)),
              a
            );
          }),
          (t.getArcVertex = (e) => {
            const t = h(e);
            if (!t) return;
            let r = t.arcVertex;
            return r || ((r = new e.SCRTArcVertex()), (t.arcVertex = r)), r;
          }),
          (t.getTextureVertex = (e, t, r, i, o, a) => {
            const s = h(e);
            if (!s) return;
            let n = s.textureVertex;
            return (
              n
                ? (n.SetPosition(t, r),
                  (n.m_uiColor = null != i ? i : 4294967295))
                : ((n = new e.SCRTColorTextureVertex(t, r)),
                  (s.textureVertex = n)),
              void 0 !== o && void 0 !== a && n.SetTexCoord(o, a),
              n
            );
          }),
          (t.getTextBounds = (e) => {
            const t = h(e);
            if (!t) return;
            let r = t.textBounds;
            return r || ((r = new e.TSRTextBounds()), (t.textBounds = r)), r;
          }),
          (t.getNativeRect = (e, t, r, i, o) => {
            const a = h(e);
            let s = a.rect;
            return (
              s
                ? s.Assign(t, r, i - t, o - r)
                : ((s = new e.SCRTRectVertex(t, r, i - t, o - r)),
                  (a.rect = s)),
              s
            );
          }),
          (t.getVector4 = (e, t, r, i, o) => {
            const a = h(e);
            let s = a.vector4;
            return (
              s
                ? s.Assign(t, r, i, o)
                : ((s = new e.TSRVector4(t, r, i, o)), (a.vector4 = s)),
              s
            );
          }),
          (t.getVector2 = (e, t = 0, r = 0) => {
            const i = h(e);
            let o = i.vector2;
            return (
              o
                ? ((o.x = t), (o.y = r))
                : ((o = new e.TSRVector2(t, r)), (i.vector2 = o)),
              o
            );
          }),
          (t.getVector3 = (e, t, r, i) => {
            const o = h(e);
            let a = o.vector3;
            return (
              a
                ? a.Assign(t, r, i)
                : ((a = new e.TSRVector3(t, r, i)), (o.vector3 = a)),
              a
            );
          }),
          (t.getFontKey = (e, t, r = !1, i = !1) => {
            const o = h(e);
            if (!o) return;
            const d = o.keyCache,
              u = (0, a.getFontFamily)(t.fontFamily, !0),
              c = {
                fontFamily: u,
                fontSize: t.fontSize,
                extras: (r ? "advanced" : "") + (i ? "transformed" : ""),
                providerId: void 0,
              },
              p = s.labelCache.getStyleId(c);
            if (!d.has(p)) {
              const o = new l(new e.SCRTFontKey(u, t.fontSize, i, r));
              d.set(p, o);
            }
            const g = d.get(p);
            return (
              Date.now() - g.firstLoadTime >
                n.SciChartDefaults.nativeFontTimeout &&
                (g.nativeKey.m_reload = !1),
              g.nativeKey
            );
          }),
          (t.getAllFontKeys = (e) => {
            const t = h(e);
            return Array.from(t.keyCache.values()).map((e) => e.nativeKey);
          });
      },
      63458: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createNativeRect = void 0);
        const i = r(98353);
        t.createNativeRect = (e, t, r, o, a) =>
          (0, i.getNativeRect)(e, t, r, o, a);
      },
      47376: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createSCRTPen = void 0);
        const i = r(84745),
          o = (r(27307), r(22950)),
          a = r(48008);
        t.createSCRTPen = (e, t, r, s, n, l = !0) => {
          if (i.IS_TEST_ENV || !t) return;
          const d = (0, o.uintArgbColorMultiplyOpacity)(
            (0, a.parseColorToUIntArgb)(t),
            s
          );
          if (isNaN(d))
            throw new Error(
              `Color code ${t} cannot be converted to an ARGB integer`
            );
          if (n && n.length) {
            const t = new e.FloatVector();
            return (
              n.forEach((e) => t.push_back(e)), e.SCRTCreateDahedPen(d, r, l, t)
            );
          }
          return new e.SCRTPen(d, r, l);
        };
      },
      33841: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createSolidBrush = void 0);
        const i = r(84745),
          o = r(22950),
          a = r(48008);
        t.createSolidBrush = (e, t, r) => {
          if (i.IS_TEST_ENV || !t) return;
          const s = (0, o.uintArgbColorMultiplyOpacity)(
              (0, a.parseColorToUIntArgb)(t),
              r
            ),
            n = (0, o.uintArgbColorIsTransparent)(s);
          if (isNaN(s))
            throw new Error(
              `Color code ${t} cannot be converted to an ARGB integer`
            );
          return new e.SCRTSolidBrush(s, n);
        };
      },
      94389: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.drawBorder = void 0);
        const i = r(63458),
          o = r(98353);
        t.drawBorder = (e, t, r, a, s, n, l, d, h, u) => {
          if (0 === h && 0 === l && 0 === n && 0 === d) return;
          const c = r.newBrush(u, !0),
            p = (0, o.getVectorRectVertex)(t);
          p.push_back(
            (0, i.createNativeRect)(t, a.x, a.y - l, a.x + a.width + d, a.y)
          ),
            p.push_back(
              (0, i.createNativeRect)(
                t,
                a.x + a.width,
                a.y,
                a.x + a.width + d,
                a.y + a.height + h
              )
            ),
            p.push_back(
              (0, i.createNativeRect)(
                t,
                a.x - n,
                a.y + a.height,
                a.x + a.width,
                a.y + a.height + h
              )
            ),
            p.push_back(
              (0, i.createNativeRect)(t, a.x - n, a.y - l, a.x, a.y + a.height)
            ),
            e.drawRects(p, c, s, 0, 0);
        };
      },
      3441: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getLabelCoordinates =
            t.drawAxisMarkerAnnotation =
            t.drawLineAnnotation =
            t.drawModifiersAxisLabel =
              void 0);
        const i = r(87459),
          o = r(38215),
          a = r(11805);
        (t.drawModifiersAxisLabel = (e, t, r, i, o) => {
          if (!e.isVisible) return;
          const a = n(e, r),
            s = Object.assign(Object.assign({}, e.dpiAdjustedLabelStyle), {
              color: o,
            });
          return e.axisRenderer.drawModifiersAxisLabel(
            t,
            a,
            r,
            e.axisAlignment,
            s,
            i
          );
        }),
          (t.drawLineAnnotation = (
            e,
            r,
            l,
            d,
            h,
            u,
            c,
            p,
            g,
            y,
            f,
            v,
            m,
            S,
            P,
            C
          ) => {
            const b = r.getNativeContext(),
              { axisAlignment: x } = e,
              A =
                (x === o.EAxisAlignment.Top || x === o.EAxisAlignment.Bottom) &&
                ![
                  a.ELabelPlacement.Top,
                  a.ELabelPlacement.Bottom,
                  a.ELabelPlacement.Auto,
                  a.ELabelPlacement.Axis,
                ].includes(l),
              T = [
                a.ELabelPlacement.Right,
                a.ELabelPlacement.TopRight,
                a.ELabelPlacement.BottomRight,
              ].includes(l),
              E =
                x === o.EAxisAlignment.Top || x === o.EAxisAlignment.Bottom
                  ? h
                  : c,
              R = d || n(e, E),
              D = l === a.ELabelPlacement.Auto || l === a.ELabelPlacement.Axis,
              w = D ? y : null,
              M = D ? g : Object.assign(Object.assign({}, g), { color: y });
            let L,
              O = 0,
              I = 0;
            const {
              x1LineCoord: k,
              y1LineCoord: _,
              x2LineCoord: V,
              y2LineCoord: N,
            } = s(h, c, u, p, O, I, l, e);
            if ((f && r.drawLine(k, _, V, N, f, v, v), m)) {
              const {
                  bitmapTexture: r,
                  textureHeight: o,
                  textureWidth: a,
                } = e.axisRenderer.createAnnotationLabelTexture(
                  R,
                  M,
                  w,
                  A,
                  T,
                  S
                ),
                { xPosition: s, yPosition: n } = (0, t.getLabelCoordinates)(
                  e,
                  l,
                  h,
                  u,
                  c,
                  p,
                  o,
                  a,
                  P,
                  C
                );
              (O = o),
                (I = a),
                (L = new i.Rect(s, n, a, o)),
                b.DrawTexture(r, Math.round(s), Math.round(n), a, o),
                r.delete();
            }
            return L;
          }),
          (t.drawAxisMarkerAnnotation = (
            e,
            r,
            i,
            o,
            s,
            l,
            d,
            h,
            u,
            c,
            p,
            g
          ) => {
            const y = r.getNativeContext(),
              { axisAlignment: f } = e,
              v = i || n(e, o),
              {
                bitmapTexture: m,
                textureHeight: S,
                textureWidth: P,
              } = c
                ? e.axisRenderer.createAxisMarkerFromImage(c, p, g)
                : e.axisRenderer.createAxisMarker(f, v, d, h, u),
              { xPosition: C, yPosition: b } = (0, t.getLabelCoordinates)(
                e,
                a.ELabelPlacement.Axis,
                s,
                s,
                l,
                l,
                S,
                P
              );
            return (
              m &&
                (y.DrawTexture(m, Math.round(C), Math.round(b), P, S),
                m.delete()),
              { xPosition: C, yPosition: b, textureWidth: P, textureHeight: S }
            );
          }),
          (t.getLabelCoordinates = (e, t, r, i, s, n, l, d, h, u) => {
            const {
              axisAlignment: c,
              parentSurface: { seriesViewRect: p },
              viewRect: g,
            } = e;
            let y = 0,
              f = 0;
            const v = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                  case o.EAxisAlignment.Left:
                    f = p.top + s - l / 2;
                    break;
                  case o.EAxisAlignment.Top:
                    f = p.top + n / 2 - l / 2;
                    break;
                  case o.EAxisAlignment.Bottom:
                    f = p.top + s + (n - s) / 2 - l / 2;
                }
              },
              m = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                    y = p.left + i + (r - i) / 2 - d / 2;
                    break;
                  case o.EAxisAlignment.Left:
                    y = p.left + i / 2 - d / 2;
                    break;
                  case o.EAxisAlignment.Top:
                  case o.EAxisAlignment.Bottom:
                    y = p.left + i - d / 2;
                }
              },
              S = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                    y = p.left + r - d;
                    break;
                  case o.EAxisAlignment.Left:
                    y = p.left + i - d;
                    break;
                  case o.EAxisAlignment.Top:
                  case o.EAxisAlignment.Bottom:
                    y = p.left + r;
                }
              },
              P = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                    y = p.left + i;
                    break;
                  case o.EAxisAlignment.Left:
                    y = p.left;
                    break;
                  case o.EAxisAlignment.Top:
                  case o.EAxisAlignment.Bottom:
                    y = p.left + r - d;
                }
              },
              C = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                  case o.EAxisAlignment.Left:
                    f = p.top + s - l;
                    break;
                  case o.EAxisAlignment.Top:
                    f = p.top;
                    break;
                  case o.EAxisAlignment.Bottom:
                    f = p.top + n;
                }
              },
              b = () => {
                switch (c) {
                  case o.EAxisAlignment.Right:
                  case o.EAxisAlignment.Left:
                    f = p.top + s;
                    break;
                  case o.EAxisAlignment.Top:
                    f = p.top + n - l;
                    break;
                  case o.EAxisAlignment.Bottom:
                    f = p.top + s - l;
                }
              };
            switch (t) {
              case a.ELabelPlacement.Right:
                v(), S();
                break;
              case a.ELabelPlacement.TopRight:
                C(), S();
                break;
              case a.ELabelPlacement.BottomRight:
                b(), S();
                break;
              case a.ELabelPlacement.Bottom:
                b(), m();
                break;
              case a.ELabelPlacement.Left:
                v(), P();
                break;
              case a.ELabelPlacement.TopLeft:
                C(), P();
                break;
              case a.ELabelPlacement.BottomLeft:
                b(), P();
                break;
              case a.ELabelPlacement.Top:
                C(), m();
                break;
              case a.ELabelPlacement.Axis:
              case a.ELabelPlacement.Auto:
                (() => {
                  switch (c) {
                    case o.EAxisAlignment.Right:
                      v(),
                        (y =
                          h === a.EHorizontalAlignment.Left
                            ? p.left
                            : g.width < d
                            ? (y = g.right - d)
                            : g.left);
                      break;
                    case o.EAxisAlignment.Left:
                      v(),
                        (y =
                          h === a.EHorizontalAlignment.Right
                            ? p.left + p.width - d
                            : g.width < d
                            ? (y = g.left)
                            : g.right - d);
                      break;
                    case o.EAxisAlignment.Top:
                      (f =
                        u === a.EVerticalAlignment.Bottom
                          ? p.top + p.height - l
                          : g.height < l
                          ? g.top
                          : g.bottom - l),
                        m();
                      break;
                    case o.EAxisAlignment.Bottom:
                      (f =
                        u === a.EVerticalAlignment.Top
                          ? p.top
                          : g.height < l
                          ? g.bottom - l
                          : g.top),
                        m();
                  }
                })();
                break;
              default:
                throw Error("Unexpected LabelPlacement " + t);
            }
            return (
              t !== a.ELabelPlacement.Auto &&
                t !== a.ELabelPlacement.Axis &&
                (f < p.top && (f = p.top),
                f + l > p.bottom && (f = p.bottom - l),
                y < p.left && (y = p.left),
                y + d > p.right && (y = p.right - d)),
              { xPosition: y, yPosition: f }
            );
          });
        const s = (e, t, r, i, s, n, l, d) => {
            const {
              axisAlignment: h,
              parentSurface: { seriesViewRect: u },
              viewRect: c,
            } = d;
            let p = e,
              g = t,
              y = r,
              f = i;
            switch (l) {
              case a.ELabelPlacement.Right:
                switch (h) {
                  case o.EAxisAlignment.Right:
                    p = Math.abs(e - r) < n ? y : e - n;
                    break;
                  case o.EAxisAlignment.Left:
                    y = r > u.width ? u.width - n : r - n;
                }
                break;
              case a.ELabelPlacement.Bottom:
                switch (h) {
                  case o.EAxisAlignment.Top:
                    f = i > u.height ? u.height - s : i - s;
                    break;
                  case o.EAxisAlignment.Bottom:
                    g = Math.abs(t - i) < s ? f : t - s;
                }
                break;
              case a.ELabelPlacement.Left:
                switch (h) {
                  case o.EAxisAlignment.Right:
                    y = r < 0 ? n : r + n;
                    break;
                  case o.EAxisAlignment.Left:
                    p = Math.abs(e - r) < n ? y : e + n;
                }
                break;
              case a.ELabelPlacement.Top:
                switch (h) {
                  case o.EAxisAlignment.Top:
                    g = Math.abs(t - i) < s ? f : t + s;
                    break;
                  case o.EAxisAlignment.Bottom:
                    f = i < 0 ? s : i + s;
                }
                break;
              case a.ELabelPlacement.Auto:
              case a.ELabelPlacement.Axis:
                switch (h) {
                  case o.EAxisAlignment.Right:
                    (p = c.width < n ? u.width + c.width - n : u.width),
                      y > p && (y = p);
                    break;
                  case o.EAxisAlignment.Left:
                    (p = c.width < n ? n - c.width : 0), y < p && (y = p);
                    break;
                  case o.EAxisAlignment.Top:
                    (g = c.height < s ? s - c.height : 0), f < g && (f = g);
                    break;
                  case o.EAxisAlignment.Bottom:
                    (g = c.height < s ? c.bottom - s : u.bottom),
                      f > g && (f = g);
                }
            }
            return {
              x1LineCoord: p,
              y1LineCoord: g,
              x2LineCoord: y,
              y2LineCoord: f,
            };
          },
          n = (e, t) => {
            let r;
            const i = e.getCurrentCoordinateCalculator();
            if (e.isCategoryAxis) {
              const e = i.getDataValue(t);
              r = i.transformIndexToData(e);
            } else r = i.getDataValue(t);
            return e.labelProvider.formatCursorLabel(r);
          };
      },
      10572: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.labelHelper = void 0);
        const i = r(60986),
          o = r(11805),
          a = r(8827);
        function s(e) {
          return (180 * e) / Math.PI;
        }
        function n(e) {
          let t = e;
          for (; t < 0; ) t += 2 * Math.PI;
          return (t %= 2 * Math.PI), t;
        }
        function l(e, t) {
          return e === o.EAngularAxisLabelPlacement.Outer
            ? t
              ? i.EHorizontalAnchorPoint.Right
              : i.EHorizontalAnchorPoint.Left
            : e === o.EAngularAxisLabelPlacement.Inner
            ? t
              ? i.EHorizontalAnchorPoint.Left
              : i.EHorizontalAnchorPoint.Right
            : i.EHorizontalAnchorPoint.Center;
        }
        function d(e, t) {
          return e === o.EAngularAxisLabelPlacement.Outer
            ? t
              ? i.EVerticalAnchorPoint.Top
              : i.EVerticalAnchorPoint.Bottom
            : e === o.EAngularAxisLabelPlacement.Inner
            ? t
              ? i.EVerticalAnchorPoint.Bottom
              : i.EVerticalAnchorPoint.Top
            : i.EVerticalAnchorPoint.Center;
        }
        t.labelHelper = {
          getPolarLabelRotation: function (e, t) {
            return e === a.EPolarLabelMode.Parallel
              ? Math.round(s(n(t))) % 360 <= 180
                ? t - Math.PI / 2
                : t - (3 * Math.PI) / 2
              : e === a.EPolarLabelMode.Perpendicular
              ? Math.cos(t) > 0
                ? t
                : t - Math.PI
              : 0;
          },
          radiansToDegrees: s,
          getLabelPlacementForRadialAxis: function (e) {
            return e === o.ERadialAxisLabelPlacement.Top
              ? i.EVerticalAnchorPoint.Bottom
              : e === o.ERadialAxisLabelPlacement.Bottom
              ? i.EVerticalAnchorPoint.Top
              : i.EVerticalAnchorPoint.Center;
          },
          getLabelRotationAndPlacementForAngularAxis: function (e, r, o) {
            if (r === a.EPolarLabelMode.Parallel) {
              const r = t.labelHelper.radiansToDegrees(Math.PI / 2 - e),
                a = r < -90;
              return {
                resultAngle: a ? r + 180 : r,
                horizontalAnchorPoint: i.EHorizontalAnchorPoint.Center,
                verticalAnchorPoint: d(o, a),
              };
            }
            if (r === a.EPolarLabelMode.Perpendicular) {
              const r = t.labelHelper.radiansToDegrees(-e),
                a = r < -90 && r > -270;
              return {
                resultAngle: a ? r + 180 : r,
                horizontalAnchorPoint: l(o, a),
                verticalAnchorPoint: i.EVerticalAnchorPoint.Center,
              };
            }
            return {
              resultAngle: 0,
              horizontalAnchorPoint: i.EHorizontalAnchorPoint.Center,
              verticalAnchorPoint: i.EVerticalAnchorPoint.Center,
            };
          },
          normalizeAngle: n,
        };
      },
      62288: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.polarChartHelper = void 0),
          (t.polarChartHelper = {
            calcTickDirection: function (e, t, r, i) {
              const o = t ? r + i : r;
              return t
                ? e
                  ? { direction: 1, tickRotation: i, startAngle: o }
                  : { direction: -1, tickRotation: i, startAngle: o }
                : e
                ? { direction: -1, tickRotation: 0, startAngle: o }
                : { direction: 1, tickRotation: 0, startAngle: o };
            },
            calcLabelPosition: function (e, t, r, i) {
              return {
                isAntiClockWise: (!t && e) || (t && !e),
                labelRotation: t ? i : 0,
                startAngle: t ? r + i : r,
              };
            },
          });
      },
      97703: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ManualLegend = void 0);
        const i = r(87108),
          o = r(88266);
        class a extends o.SciChartLegendBase {
          constructor(e, t) {
            var r, i, a;
            super(e),
              (this.type = o.ELegendType.ManualLegend),
              (this.itemsProperty = []),
              (this.showCheckboxesProperty = !1),
              (this.showSeriesMarkersProperty = !0),
              (this.showCheckboxesProperty =
                null !== (r = null == e ? void 0 : e.showCheckboxes) &&
                void 0 !== r
                  ? r
                  : this.showCheckboxes),
              (this.showSeriesMarkersProperty =
                null !== (i = null == e ? void 0 : e.showSeriesMarkers) &&
                void 0 !== i
                  ? i
                  : this.showSeriesMarkers),
              (this.itemsProperty =
                null !== (a = null == e ? void 0 : e.items) && void 0 !== a
                  ? a
                  : this.items),
              (this.legendItemCheckedChangedCallback =
                null == e ? void 0 : e.isCheckedChangedCallback),
              t && this.attachTo(t);
          }
          get showCheckboxes() {
            return this.showCheckboxesProperty;
          }
          set showCheckboxes(e) {
            (this.showCheckboxesProperty = e), this.notifyPropertyChanged();
          }
          get showSeriesMarkers() {
            return this.showSeriesMarkersProperty;
          }
          set showSeriesMarkers(e) {
            (this.showSeriesMarkersProperty = e), this.notifyPropertyChanged();
          }
          get items() {
            return this.itemsProperty;
          }
          set items(e) {
            (this.itemsProperty = e), this.notifyPropertyChanged();
          }
          attachTo(e) {
            super.attachTo(e),
              e.addDeletable({
                delete: () => {
                  this.delete(),
                    this.setRootDiv(void 0),
                    this.setInvalidateParentSurface(void 0),
                    this.setParentSurface(void 0);
                },
              });
          }
          applyTheme() {}
          getInnerHTML() {
            var e, t;
            const r =
                null !== (e = this.backgroundColor) && void 0 !== e
                  ? e
                  : this.parentSurfaceProperty.themeProvider
                      .legendBackgroundBrush,
              o =
                null !== (t = this.textColor) && void 0 !== t
                  ? t
                  : this.parentSurfaceProperty.themeProvider
                      .labelForegroundBrush,
              {
                left: a,
                top: s,
                right: n,
                bottom: l,
              } = this.parentSurfaceProperty.getSeriesViewRectPadding(!1),
              d = this.isExternal()
                ? new i.Thickness(
                    this.margin,
                    this.margin,
                    this.margin,
                    this.margin
                  )
                : new i.Thickness(
                    s + this.margin,
                    n + this.margin,
                    l + this.margin,
                    a + this.margin
                  );
            return this.getLegendHTML(
              this.placement,
              o,
              r,
              d,
              this.orientation,
              this.showCheckboxes,
              this.showSeriesMarkers,
              this.items
            );
          }
          addEventListeners() {
            this.items.forEach((e) => this.addEventListenerToItem(e));
          }
          addEventListenerToItem(e) {
            const t = this.parentDiv.querySelector(`[id='${e.id}']`);
            if (t) {
              const r = (r) => {
                (e.checked = t.checked),
                  this.legendItemCheckedChangedCallback &&
                    this.legendItemCheckedChangedCallback(e, e.checked);
              };
              t.addEventListener("change", r);
              const i = {
                  element: t,
                  eventType: "change",
                  eventListener: r,
                  delete: () => t.removeEventListener("change", r),
                },
                o = this.eventListenersCollection.get(e.id);
              o ? o.push(i) : this.eventListenersCollection.set(e.id, [i]);
            }
          }
          removeEventListeners() {
            this.items.forEach((e) => this.removeEventListenerFromSeries(e.id));
          }
        }
        t.ManualLegend = a;
      },
      96260: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartLegend = void 0);
        const i = r(87108),
          o = r(88266);
        class a extends o.SciChartLegendBase {
          constructor() {
            super(...arguments),
              (this.type = o.ELegendType.SciChartLegend),
              (this.showCheckboxesProperty = !1),
              (this.showSeriesMarkersProperty = !0);
          }
          applyTheme() {}
          get showCheckboxes() {
            return this.showCheckboxesProperty;
          }
          set showCheckboxes(e) {
            (this.showCheckboxesProperty = e), this.notifyPropertyChanged();
          }
          get showSeriesMarkers() {
            return this.showSeriesMarkersProperty;
          }
          set showSeriesMarkers(e) {
            (this.showSeriesMarkersProperty = e), this.notifyPropertyChanged();
          }
          setRenderableSeriesArray(e) {
            (this.renderableSeriesArray = e), this.invalidateLegend();
          }
          addEventListeners() {
            this.renderableSeriesArray.forEach((e) =>
              this.addEventListenerToSeries(e)
            );
          }
          removeEventListeners() {
            this.renderableSeriesArray.forEach((e) =>
              this.removeEventListenerFromSeries(e.id)
            );
          }
          addEventListenerToSeries(e) {
            const t = this.parentDiv.querySelector(`[id='${e.id}']`);
            if (t) {
              const r = (t) => {
                (e.isVisible = t.target.checked),
                  this.legendItemCheckedChangedCallback &&
                    this.legendItemCheckedChangedCallback(e, e.isVisible);
              };
              t.addEventListener("change", r);
              const i = (e) => {
                this.invalidateLegend();
              };
              e.isVisibleChanged.subscribe(i);
              const o = {
                  element: t,
                  eventType: "change",
                  eventListener: r,
                  delete: () => {
                    t.removeEventListener("change", r),
                      e.isVisibleChanged.unsubscribe(i);
                  },
                },
                a = this.eventListenersCollection.get(e.id);
              a ? a.push(o) : this.eventListenersCollection.set(e.id, [o]);
            }
          }
          getInnerHTML() {
            var e, t, r, o, a, s;
            const n =
                null !== (e = this.backgroundColor) && void 0 !== e
                  ? e
                  : null ===
                      (r =
                        null === (t = this.parentSurfaceProperty) ||
                        void 0 === t
                          ? void 0
                          : t.themeProvider) || void 0 === r
                  ? void 0
                  : r.legendBackgroundBrush,
              l =
                null !== (o = this.textColor) && void 0 !== o
                  ? o
                  : null ===
                      (s =
                        null === (a = this.parentSurfaceProperty) ||
                        void 0 === a
                          ? void 0
                          : a.themeProvider) || void 0 === s
                  ? void 0
                  : s.labelForegroundBrush,
              d = this.renderableSeriesArray.map((e, t) => {
                var r;
                return {
                  id: e.id,
                  name:
                    null !== (r = e.seriesName) && void 0 !== r
                      ? r
                      : `Series ${t + 1}`,
                  color: e.isStacked ? e.fill : e.stroke,
                  checked: e.isVisible,
                  gradient: void 0,
                };
              }),
              {
                left: h,
                top: u,
                right: c,
                bottom: p,
              } = this.parentSurfaceProperty.getSeriesViewRectPadding(!1),
              g = this.isExternal()
                ? new i.Thickness(
                    this.margin,
                    this.margin,
                    this.margin,
                    this.margin
                  )
                : new i.Thickness(
                    u + this.margin,
                    c + this.margin,
                    p + this.margin,
                    h + this.margin
                  );
            return this.getLegendHTML(
              this.placement,
              l,
              n,
              g,
              this.orientation,
              this.showCheckboxes,
              this.showSeriesMarkers,
              d
            );
          }
        }
        t.SciChartLegend = a;
      },
      88266: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getLegendContainerHtml =
            t.getLegendItemHtml =
            t.SciChartLegendBase =
            t.ELegendType =
            t.ELegendPlacement =
            t.ELegendOrientation =
              void 0);
        const i = r(84745),
          o = r(55023),
          a = r(99064);
        var s, n, l;
        !(function (e) {
          (e.Vertical = "Vertical"), (e.Horizontal = "Horizontal");
        })((s = t.ELegendOrientation || (t.ELegendOrientation = {}))),
          (function (e) {
            (e.TopLeft = "TopLeft"),
              (e.TopRight = "TopRight"),
              (e.BottomLeft = "BottomLeft"),
              (e.BottomRight = "BottomRight");
          })((n = t.ELegendPlacement || (t.ELegendPlacement = {}))),
          ((l = t.ELegendType || (t.ELegendType = {})).SciChartLegend =
            "SciChartLegend"),
          (l.ManualLegend = "ManualLegend"),
          (l.SciChartPieLegend = "SciChartPieLegend");
        class d extends o.DeletableEntity {
          constructor(e) {
            var t, r, i, o, a;
            super(),
              (this.orientationProperty = s.Vertical),
              (this.showLegendProperty = !0),
              (this.placementProperty = n.TopLeft),
              (this.marginProperty = 10),
              (this.isDirty = !0),
              (this.eventListenersCollection = new Map()),
              (this.removeEventListenerFromSeries = (e) => {
                var t;
                null === (t = this.eventListenersCollection.get(e)) ||
                  void 0 === t ||
                  t.forEach(
                    ({ element: e, eventListener: t, eventType: r }) => {
                      e.removeEventListener(r, t);
                    }
                  ),
                  this.eventListenersCollection.delete(e);
              }),
              (this.orientationProperty =
                null !== (t = null == e ? void 0 : e.orientation) &&
                void 0 !== t
                  ? t
                  : this.orientationProperty),
              (this.showLegendProperty =
                null !== (r = null == e ? void 0 : e.showLegend) && void 0 !== r
                  ? r
                  : this.showLegend),
              (this.placementProperty =
                null !== (i = null == e ? void 0 : e.placement) && void 0 !== i
                  ? i
                  : this.placement),
              (this.marginProperty =
                null !== (o = null == e ? void 0 : e.margin) && void 0 !== o
                  ? o
                  : this.margin),
              (this.placementDivIdProperty =
                null !== (a = null == e ? void 0 : e.placementDivId) &&
                void 0 !== a
                  ? a
                  : this.placementDivId),
              (this.backgroundColorProperty =
                null == e ? void 0 : e.backgroundColor),
              (this.textColorProperty = null == e ? void 0 : e.textColor),
              (this.update = this.update.bind(this));
          }
          setInvalidateParentSurface(e) {
            this.invalidateParentSurface = e;
          }
          setRootDiv(e) {
            this.rootDiv = e;
          }
          setSeriesViewRect(e) {}
          setParentSurface(e) {
            this.parentSurfaceProperty = e;
          }
          attachTo(e) {
            this.setParentSurface(e),
              this.setRootDiv(e.domDivContainer),
              this.setInvalidateParentSurface(e.invalidateElement),
              e.rendered.subscribe(this.update);
          }
          detach() {
            this.setRootDiv(void 0),
              this.parentSurfaceProperty.rendered.unsubscribe(this.update),
              this.setInvalidateParentSurface(void 0),
              this.setParentSurface(void 0),
              this.delete();
          }
          update() {
            if (this.isDirty || !this.div)
              try {
                this.parentSurfaceProperty.getSeriesViewRectPadding(!0),
                  this.clear(),
                  this.showLegend && this.create(),
                  (this.isDirty = !1);
              } catch (e) {}
          }
          invalidateLegend() {
            this.isDirty = !0;
          }
          get orientation() {
            return this.orientationProperty;
          }
          set orientation(e) {
            (this.orientationProperty = e), this.notifyPropertyChanged();
          }
          get showLegend() {
            return this.showLegendProperty;
          }
          set showLegend(e) {
            (this.showLegendProperty = e), this.notifyPropertyChanged();
          }
          get placement() {
            return this.placementProperty;
          }
          set placement(e) {
            (this.placementProperty = e), this.notifyPropertyChanged();
          }
          get margin() {
            return this.marginProperty;
          }
          set margin(e) {
            (this.marginProperty = e), this.notifyPropertyChanged();
          }
          get placementDivId() {
            return this.placementDivIdProperty;
          }
          set placementDivId(e) {
            this.clear(),
              (this.placementDivIdProperty = e),
              this.notifyPropertyChanged();
          }
          get backgroundColor() {
            return this.backgroundColorProperty;
          }
          set backgroundColor(e) {
            (this.backgroundColorProperty = e), this.notifyPropertyChanged();
          }
          get textColor() {
            return this.textColorProperty;
          }
          set textColor(e) {
            (this.textColorProperty = e), this.notifyPropertyChanged();
          }
          clear() {
            var e;
            this.div &&
              (this.removeEventListeners(),
              null === (e = this.parentDiv) ||
                void 0 === e ||
                e.removeChild(this.div),
              (this.div = void 0),
              (this.parentDiv = void 0));
          }
          delete() {
            this.clear();
          }
          isExternal() {
            return !!this.placementDivId;
          }
          getLegendHTML(e, r, i, o, a, s, n, l) {
            const d = l.reduce((e, t) => {
              var r;
              return (
                e +
                this.getLegendItemHTML(
                  a,
                  s,
                  null !== (r = t.showMarker) && void 0 !== r ? r : n,
                  t
                )
              );
            }, "");
            return (0, t.getLegendContainerHtml)(
              e,
              r,
              i,
              o,
              d,
              this.isExternal()
            );
          }
          getLegendItemHTML(e, r, i, o) {
            return (0, t.getLegendItemHtml)(e, r, i, o);
          }
          notifyPropertyChanged() {
            (this.isDirty = !0),
              this.invalidateParentSurface && this.invalidateParentSurface();
          }
          create() {
            const e = this.getInnerHTML();
            if (e) {
              const t = (0, a.htmlToElement)(e);
              (this.parentDiv = this.getParentDiv()),
                this.parentDiv.appendChild(t),
                (this.div = t),
                i.IS_TEST_ENV || this.addEventListeners();
            }
          }
          getParentDiv() {
            return this.placementDivId
              ? "string" == typeof this.placementDivId
                ? document.querySelector(`[id='${this.placementDivId}']`)
                : this.placementDivId
              : this.rootDiv;
          }
        }
        (t.SciChartLegendBase = d),
          (t.getLegendItemHtml = (e, t, r, i) => {
            let o = `<span class="scichart__legend-item" style="display: ${
              e === s.Vertical ? "flex" : "inline-flex"
            }; align-items: center; margin-right: 4px; white-space: nowrap;">`;
            if (
              (t &&
                (o += `<input ${
                  i.checked ? "checked" : ""
                } type="checkbox" id="${i.id}">`),
              r)
            )
              if (i.gradient) {
                let e = "";
                i.gradient.gradientStops.forEach((t) => {
                  e += `,${t.color}`;
                }),
                  (o += `<label for="${i.id}" style="background-image: linear-gradient(to right${e}); margin: 4px; width: 30px; height: 13px;"></label>`);
              } else
                o += `<label for="${i.id}" style="background-color: ${i.color}; margin: 4px; width: 30px; height: 13px;"></label>`;
            return (
              (o += `<label for="${i.id}" style="margin-left: 4px;">${i.name}</label>`),
              (o += "</span>"),
              o
            );
          }),
          (t.getLegendContainerHtml = (e, t, r, i, o, a = !1) => {
            if (!o) return "";
            let s = "",
              l = "";
            a || (s = "position: absolute;"),
              e === n.TopLeft
                ? (l = "left: 0; top: 0;")
                : e === n.TopRight
                ? (l = "right: 0; top: 0;")
                : e === n.BottomLeft
                ? (l = "left: 0; bottom: 0;")
                : e === n.BottomRight && (l = "right: 0; bottom: 0;");
            let d = `<div class="scichart__legend" style="height: 100%; ${s} display: flex; ${l} text-align: center;">`;
            const h = [n.TopLeft, n.TopRight].includes(e)
                ? "flex-start"
                : "flex-end",
              { left: u, right: c, bottom: p, top: g } = i;
            return (
              (d += `<div style="display: block; align-self: ${h}; width: fit-content; pointer-events: auto; margin-left: ${u}px; margin-top: ${g}px; margin-right: ${c}px; margin-bottom: ${p}px; padding: 5px; border-radius: 3px; background-color: ${r}; color: ${t}">`),
              (d += o),
              (d += "</div></div>"),
              d
            );
          });
      },
      28243: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartPieLegend = void 0);
        const i = r(87108),
          o = r(79548),
          a = r(88266);
        class s extends a.SciChartLegendBase {
          constructor() {
            super(...arguments),
              (this.type = a.ELegendType.SciChartPieLegend),
              (this.animate = !0),
              (this.showCheckboxesProperty = !1),
              (this.showSeriesMarkersProperty = !0);
          }
          get showCheckboxes() {
            return this.showCheckboxesProperty;
          }
          set showCheckboxes(e) {
            (this.showCheckboxesProperty = e), this.notifyPropertyChanged();
          }
          get showSeriesMarkers() {
            return this.showSeriesMarkersProperty;
          }
          set showSeriesMarkers(e) {
            (this.showSeriesMarkersProperty = e), this.notifyPropertyChanged();
          }
          applyTheme() {}
          setPieSegmentArray(e) {
            this.pieSegmentArray = e;
          }
          update() {
            this.clear(), this.showLegend && this.create();
          }
          addEventListeners() {
            this.pieSegmentArray.forEach((e) => {
              const t = this.parentDiv.querySelector(`#${n(e.id)}`);
              if (!t) return;
              const r = (0, o.addEventListenerToPieSegment)(e, t, this.animate),
                i = this.eventListenersCollection.get(e.id);
              i ? i.push(r) : this.eventListenersCollection.set(e.id, [r]);
            });
          }
          removeEventListeners() {
            this.pieSegmentArray.forEach((e) =>
              this.removeEventListenerFromSeries(e.id)
            );
          }
          getInnerHTML() {
            const e =
                this.parentSurfaceProperty.themeProvider.legendBackgroundBrush,
              t = this.parentSurfaceProperty.themeProvider.labelForegroundBrush,
              r = this.pieSegmentArray.map((e, t) => {
                var r;
                return {
                  id: n(e.id),
                  name:
                    null !== (r = e.text) && void 0 !== r
                      ? r
                      : `Segment ${t + 1}`,
                  color: e.color,
                  checked: e.isSelected,
                  gradient: e.colorLinearGradient,
                };
              }),
              o = new i.Thickness(
                this.margin,
                this.margin,
                this.margin,
                this.margin
              );
            return this.getLegendHTML(
              this.placement,
              t,
              e,
              o,
              this.orientation,
              this.showCheckboxes,
              this.showSeriesMarkers,
              r
            );
          }
        }
        t.SciChartPieLegend = s;
        const n = (e) => `check${e}`;
      },
      27467: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePointMarker = void 0);
        const i = r(84745),
          o = r(55023),
          a = r(56744),
          s = (r(27307), r(16185)),
          n = r(84392),
          l = r(49987),
          d = r(14184),
          h = r(35992),
          u = r(86127),
          c = r(44231);
        class p extends o.DeletableEntity {
          constructor(e, t) {
            var r, i, o, a, n, l, d;
            super(),
              (this.fillProperty = "#5555FF"),
              (this.heightProperty = 5),
              (this.opacityProperty = 1),
              (this.strokeProperty = "#3333FF"),
              (this.strokeThicknessProperty = 1),
              (this.widthProperty = 5),
              (this.lastPointOnlyProperty = !1),
              (this.isUpdateSuspended = !1),
              (this.webAssemblyContext = e),
              (this.widthProperty =
                null !== (r = null == t ? void 0 : t.width) && void 0 !== r
                  ? r
                  : this.widthProperty),
              (this.heightProperty =
                null !== (i = null == t ? void 0 : t.height) && void 0 !== i
                  ? i
                  : this.heightProperty),
              (this.fillProperty =
                null !== (o = null == t ? void 0 : t.fill) && void 0 !== o
                  ? o
                  : this.fillProperty),
              (this.strokeProperty =
                null !== (a = null == t ? void 0 : t.stroke) && void 0 !== a
                  ? a
                  : this.strokeProperty),
              (this.strokeThicknessProperty =
                null !== (n = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== n
                  ? n
                  : this.strokeThicknessProperty),
              (this.opacityProperty =
                null !== (l = null == t ? void 0 : t.opacity) && void 0 !== l
                  ? l
                  : this.opacityProperty),
              (this.lastPointOnlyProperty =
                null !== (d = null == t ? void 0 : t.lastPointOnly) &&
                void 0 !== d
                  ? d
                  : this.lastPointOnlyProperty),
              s.WebGlRenderContext2D.webGlResourcesRefs.add(this);
          }
          get fill() {
            return this.fillProperty === n.AUTO_COLOR
              ? "#00000000"
              : this.fillProperty.startsWith(n.AUTO_COLOR)
              ? this.fillProperty.substring(n.AUTO_COLOR.length)
              : this.fillProperty;
          }
          set fill(e) {
            const t = this.fillProperty;
            (this.fillProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.FILL, e, t);
          }
          get stroke() {
            return this.strokeProperty === n.AUTO_COLOR
              ? "#00000000"
              : this.strokeProperty.startsWith(n.AUTO_COLOR)
              ? this.strokeProperty.substring(n.AUTO_COLOR.length)
              : this.strokeProperty;
          }
          set stroke(e) {
            const t = this.strokeProperty;
            (this.strokeProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.STROKE, e, t);
          }
          get width() {
            return this.widthProperty;
          }
          set width(e) {
            const t = this.widthProperty;
            (this.widthProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.WIDTH, e, t);
          }
          get height() {
            return this.heightProperty;
          }
          set height(e) {
            const t = this.heightProperty;
            (this.heightProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.HEIGHT, e, t);
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            const t = this.strokeThicknessProperty;
            (this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.STROKE_THICKNESS, e, t);
          }
          get opacity() {
            return this.opacityProperty;
          }
          set opacity(e) {
            const t = this.opacityProperty;
            (this.opacityProperty = e),
              this.applyOpacity(e),
              this.notifyPropertyChanged(c.PROPERTY.OPACITY, e, t);
          }
          get lastPointOnly() {
            return this.lastPointOnlyProperty;
          }
          set lastPointOnly(e) {
            const t = this.lastPointOnlyProperty;
            (this.lastPointOnlyProperty = e),
              this.notifyPropertyChanged(c.PROPERTY.LAST_POINT_ONLY, e, t);
          }
          getSprite() {
            return (
              void 0 === this.spriteTextures &&
                ((this.spriteTextures = this.createCanvasTexture()),
                this.applyOpacity(this.opacityProperty)),
              this.spriteTextures.spriteTexture
            );
          }
          getStrokeMask() {
            return (
              void 0 === this.spriteTextures &&
                ((this.spriteTextures = this.createCanvasTexture()),
                this.applyOpacity(this.opacityProperty)),
              this.spriteTextures.strokeMask
            );
          }
          getFillMask() {
            return (
              void 0 === this.spriteTextures &&
                ((this.spriteTextures = this.createCanvasTexture()),
                this.applyOpacity(this.opacityProperty)),
              this.spriteTextures.fillMask
            );
          }
          invalidateCache() {
            this.spriteTextures &&
              ((0, a.deleteSafe)(this.spriteTextures.spriteTexture),
              (0, a.deleteSafe)(this.spriteTextures.strokeMask),
              (0, a.deleteSafe)(this.spriteTextures.fillMask),
              (this.spriteTextures = void 0));
          }
          resetCache() {
            this.invalidateCache(),
              (this.widthProperty = void 0),
              (this.heightProperty = void 0),
              (this.fillProperty = void 0),
              (this.strokeProperty = void 0),
              (this.strokeThicknessProperty = void 0),
              (this.opacityProperty = void 0);
          }
          delete() {
            this.invalidateCache(),
              s.WebGlRenderContext2D.webGlResourcesRefs.delete(this);
          }
          createCanvasTexture() {
            if (i.IS_TEST_ENV)
              return {
                spriteTexture: void 0,
                strokeMask: void 0,
                fillMask: void 0,
              };
            const e =
                u.DpiHelper.PIXEL_RATIO * (this.width + this.strokeThickness) +
                1,
              t =
                u.DpiHelper.PIXEL_RATIO * (this.height + this.strokeThickness) +
                1,
              r = new h.CanvasTexture(this.webAssemblyContext, e, t);
            r.clear(),
              this.drawSprite(
                r.getContext(),
                this.width * u.DpiHelper.PIXEL_RATIO,
                this.height * u.DpiHelper.PIXEL_RATIO,
                this.stroke,
                this.strokeThickness * u.DpiHelper.PIXEL_RATIO,
                this.fill
              ),
              r.copyTexture();
            const o = new h.CanvasTexture(this.webAssemblyContext, e, t);
            o.clear(),
              this.drawSprite(
                o.getContext(),
                this.width * u.DpiHelper.PIXEL_RATIO,
                this.height * u.DpiHelper.PIXEL_RATIO,
                "#ffffffff",
                this.strokeThickness * u.DpiHelper.PIXEL_RATIO,
                "#00000000"
              ),
              o.copyTexture();
            const a = new h.CanvasTexture(this.webAssemblyContext, e, t);
            return (
              a.clear(),
              this.drawSprite(
                a.getContext(),
                this.width * u.DpiHelper.PIXEL_RATIO - 3,
                this.height * u.DpiHelper.PIXEL_RATIO - 3,
                "#00000000",
                0,
                "#ffffffff"
              ),
              a.copyTexture(),
              { spriteTexture: r, strokeMask: o, fillMask: a }
            );
          }
          getPointMarkerStyle() {
            return new l.PointMarkerStyle({
              type: this.type,
              width: this.width,
              height: this.height,
              fill: this.fill,
              stroke: this.stroke,
              strokeThickness: this.strokeThickness,
            });
          }
          toJSON() {
            const e = {
              fill: this.fill,
              height: this.height,
              opacity: this.opacity,
              stroke: this.stroke,
              strokeThickness: this.strokeThickness,
              width: this.width,
              lastPointOnly: this.lastPointOnly,
            };
            return { type: this.type, options: e };
          }
          onDpiChanged(e) {
            d.DebugForDpi &&
              console.log(
                "basePointMarker onDpiChanged Scaling factor = " + e.newValue
              ),
              this.invalidateCache();
          }
          resolveAutoColors(e, t, r) {
            if (this.strokeProperty.startsWith(n.AUTO_COLOR)) {
              const i = r.getStrokeColor(e, t, this.webAssemblyContext);
              this.stroke = n.AUTO_COLOR + this.adjustAutoColor("stroke", i);
            }
            if (this.fillProperty.startsWith(n.AUTO_COLOR)) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = n.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          adjustAutoColor(e, t) {
            return t;
          }
          resumeUpdates() {
            (this.isUpdateSuspended = !1), this.recreateSpriteTextures();
          }
          suspendUpdates() {
            this.isUpdateSuspended = !0;
          }
          notifyPropertyChanged(e, t, r) {
            t !== r &&
              e !== c.PROPERTY.OPACITY &&
              (this.isUpdateSuspended || this.recreateSpriteTextures());
          }
          recreateSpriteTextures() {
            var e, t, r;
            this.spriteTextures &&
              (null === (e = this.spriteTextures.spriteTexture) ||
                void 0 === e ||
                e.delete(),
              null === (t = this.spriteTextures.strokeMask) ||
                void 0 === t ||
                t.delete(),
              null === (r = this.spriteTextures.fillMask) ||
                void 0 === r ||
                r.delete(),
              (this.spriteTextures = void 0)),
              (this.spriteTextures = this.createCanvasTexture()),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          applyOpacity(e) {
            var t, r, i;
            this.spriteTextures &&
              (null === (t = this.spriteTextures.spriteTexture) ||
                void 0 === t ||
                t.applyOpacity(e),
              null === (r = this.spriteTextures.strokeMask) ||
                void 0 === r ||
                r.applyOpacity(e),
              null === (i = this.spriteTextures.fillMask) ||
                void 0 === i ||
                i.applyOpacity(e));
          }
        }
        t.BasePointMarker = p;
      },
      44231: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).FILL = "fill"),
          (r.HEIGHT = "height"),
          (r.IMAGE = "image"),
          (r.SIZE_TO_IMAGE = "size_to_image"),
          (r.STROKE = "stroke"),
          (r.STROKE_THICKNESS = "strokeThickness"),
          (r.WIDTH = "width"),
          (r.OPACITY = "opacity"),
          (r.LAST_POINT_ONLY = "lastPointOnly");
      },
      22745: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CrossPointMarker = void 0);
        const i = r(30323),
          o = r(27467);
        class a extends o.BasePointMarker {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarkerType.Cross);
          }
          drawSprite(e, t, r, i, o, a) {
            if (o > 0) {
              (e.strokeStyle = i), (e.lineWidth = o);
              const a = e.canvas.width / 2,
                s = e.canvas.height / 2,
                n = r / 2,
                l = t / 2;
              e.beginPath(),
                e.moveTo(a, s - n),
                e.lineTo(a, s + n),
                e.stroke(),
                e.beginPath(),
                e.moveTo(a - l, s),
                e.lineTo(a + l, s),
                e.stroke();
            }
          }
        }
        t.CrossPointMarker = a;
      },
      10749: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EllipsePointMarker = void 0);
        const i = r(30323),
          o = r(27467);
        class a extends o.BasePointMarker {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarkerType.Ellipse);
          }
          drawSprite(e, t, r, i, o, a) {
            const s = e.canvas.width / 2,
              n = e.canvas.height / 2,
              l = o / 2,
              d = t / 2 - l < 0 ? 0 : t / 2 - l,
              h = r / 2 - l < 0 ? 0 : r / 2 - l;
            (e.fillStyle = a),
              e.ellipse(s, n, d, h, 0, 0, 2 * Math.PI, !1),
              e.fill(),
              o > 0 && ((e.strokeStyle = i), (e.lineWidth = o), e.stroke());
          }
        }
        t.EllipsePointMarker = a;
      },
      21033: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SpritePointMarker = void 0);
        const i = r(30323),
          o = r(386),
          a = r(27467),
          s = r(44231);
        class n extends a.BasePointMarker {
          constructor(e, t) {
            super(e, t),
              (this.type = i.EPointMarkerType.Sprite),
              (this.image = null == t ? void 0 : t.image),
              (null == t ? void 0 : t.width) && (this.width = t.width),
              (null == t ? void 0 : t.height) && (this.height = t.height);
          }
          get image() {
            return this.imageProperty;
          }
          set image(e) {
            const t = this.imageProperty;
            (this.imageProperty = e),
              this.imageProperty &&
                ((this.width = this.imageProperty.width),
                (this.height = this.imageProperty.height)),
              this.notifyPropertyChanged(s.PROPERTY.IMAGE, e, t);
          }
          drawSprite(e, t, r, i, o, a) {
            const s = e.canvas.width / 2,
              n = e.canvas.height / 2,
              l = this.height / 2,
              d = this.width / 2;
            this.image &&
              e.drawImage(this.image, s - d, n - l, this.width, this.height);
          }
          getPointMarkerStyle() {
            return new o.CustomPointMarkerStyle({
              type: this.type,
              width: this.width,
              height: this.height,
              image: this.image,
            });
          }
          toJSON() {
            const e = super.toJSON(),
              t = { image: this.image };
            return Object.assign(e.options, t), e;
          }
        }
        t.SpritePointMarker = n;
      },
      77057: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SquarePointMarker = void 0);
        const i = r(75772),
          o = r(30323),
          a = r(27467);
        class s extends a.BasePointMarker {
          constructor(e, t) {
            super(e, t), (this.type = o.EPointMarkerType.Square);
          }
          drawSprite(e, t, r, o, a, s) {
            const n = e.canvas.width / 2,
              l = e.canvas.height / 2,
              d = r / 2,
              h = t / 2,
              u = a / 2,
              c = new i.Point(n - h + u, l - d + u),
              p = new i.Point(n + h - u, l + d - u);
            (e.fillStyle = s),
              e.beginPath(),
              e.moveTo(c.x, c.y),
              e.lineTo(p.x, c.y),
              e.lineTo(p.x, p.y),
              e.lineTo(c.x, p.y),
              e.closePath(),
              e.fill(),
              a > 0 && ((e.strokeStyle = o), (e.lineWidth = a), e.stroke());
          }
        }
        t.SquarePointMarker = s;
      },
      58229: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TrianglePointMarker = void 0);
        const i = r(75772),
          o = r(30323),
          a = r(27467);
        class s extends a.BasePointMarker {
          constructor(e, t) {
            super(e, t), (this.type = o.EPointMarkerType.Triangle);
          }
          drawSprite(e, t, r, o, a, s) {
            const n = e.canvas.width / 2,
              l = e.canvas.height / 2,
              d = r / 2,
              h = t / 2,
              u = a / 2,
              c = new i.Point(n, l - d + u),
              p = new i.Point(n + h - u, l + d - u),
              g = new i.Point(n - h + u, l + d - u);
            (e.fillStyle = s),
              e.beginPath(),
              e.moveTo(c.x, c.y),
              e.lineTo(p.x, p.y),
              e.lineTo(g.x, g.y),
              e.lineTo(c.x, c.y),
              e.closePath(),
              e.fill(),
              a > 0 && ((e.strokeStyle = o), (e.lineWidth = a), e.stroke());
          }
        }
        t.TrianglePointMarker = s;
      },
      61704: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XPointMarker = void 0);
        const i = r(30323),
          o = r(27467);
        class a extends o.BasePointMarker {
          constructor(e, t) {
            super(e, t), (this.type = i.EPointMarkerType.X);
          }
          drawSprite(e, t, r, i, o, a) {
            const s = e.canvas.width / 2,
              n = e.canvas.height / 2,
              l = r / 2,
              d = t / 2,
              h = o / 4;
            o > 0 &&
              ((e.strokeStyle = i),
              (e.lineWidth = 1.5 * o),
              e.beginPath(),
              e.moveTo(s - d + h, n - l + h),
              e.lineTo(s + d - h, n + l - h),
              e.stroke(),
              e.beginPath(),
              e.moveTo(s + d - h, n - l + h),
              e.lineTo(s - d + h, n + l - h),
              e.stroke());
          }
        }
        t.XPointMarker = a;
      },
      27501: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BandAnimation = void 0);
        const i = r(10763),
          o = r(48008),
          a = r(54580),
          s = r(25923),
          n = r(55371);
        class l extends n.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new s.BandAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
          getSeriesStyle(e) {
            var t;
            if (!e.isStacked)
              return new s.BandAnimationStyle({
                stroke: e.stroke,
                strokeY1: e.strokeY1,
                fill: e.fill,
                fillY1: e.fillY1,
                strokeThickness: e.strokeThickness,
                opacity: e.opacity,
                pointMarker:
                  null === (t = e.pointMarker) || void 0 === t
                    ? void 0
                    : t.getPointMarkerStyle(),
              });
          }
          updateSeriesProperties(e, t, r) {
            if (
              (super.updateSeriesProperties(e, t, r), this.isStyleAnimation)
            ) {
              const i = this.styles;
              if (void 0 !== i.strokeY1) {
                const s = a.animationHelpers.interpolateColor(
                  t.strokeY1ARGB,
                  i.strokeY1ARGB,
                  r
                );
                e.strokeY1 = (0, o.parseArgbToHtmlColor)(s);
              }
              if (void 0 !== i.fill) {
                const s = a.animationHelpers.interpolateColor(
                  t.fillARGB,
                  i.fillARGB,
                  r
                );
                e.fill = (0, o.parseArgbToHtmlColor)(s);
              }
              if (void 0 !== i.fillY1) {
                const s = a.animationHelpers.interpolateColor(
                  t.fillY1ARGB,
                  i.fillY1ARGB,
                  r
                );
                e.fillY1 = (0, o.parseArgbToHtmlColor)(s);
              }
            }
          }
        }
        t.BandAnimation = l;
      },
      25923: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BandAnimationStyle = void 0);
        const i = r(48008),
          o = r(63642);
        class a extends o.BaseAnimationStyle {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.strokeY1 =
                null !== (t = null == e ? void 0 : e.strokeY1) && void 0 !== t
                  ? t
                  : this.strokeY1Property),
              (this.fill =
                null !== (r = null == e ? void 0 : e.fill) && void 0 !== r
                  ? r
                  : this.fillProperty),
              (this.fillY1 =
                null !== (i = null == e ? void 0 : e.fillY1) && void 0 !== i
                  ? i
                  : this.fillY1Property);
          }
          set strokeY1(e) {
            (this.strokeY1Property = e),
              e && (this.strokeY1ARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get strokeY1() {
            return this.strokeY1Property;
          }
          get strokeY1ARGB() {
            return this.strokeY1ARGBProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              e && (this.fillARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get fill() {
            return this.fillProperty;
          }
          get fillARGB() {
            return this.fillARGBProperty;
          }
          set fillY1(e) {
            (this.fillY1Property = e),
              e && (this.fillY1ARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get fillY1() {
            return this.fillY1Property;
          }
          get fillY1ARGB() {
            return this.fillY1ARGBProperty;
          }
        }
        t.BandAnimationStyle = a;
      },
      63642: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseAnimationStyle = void 0);
        const i = r(30323),
          o = r(48008),
          a = r(386),
          s = r(49987);
        t.BaseAnimationStyle = class {
          constructor(e) {
            var t, r, o;
            (this.opacity = void 0),
              (this.strokeProperty = void 0),
              (this.strokeThickness =
                null !== (t = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== t
                  ? t
                  : this.strokeThickness),
              (this.stroke =
                null !== (r = null == e ? void 0 : e.stroke) && void 0 !== r
                  ? r
                  : this.strokeProperty),
              (null == e ? void 0 : e.pointMarker) &&
                (this.pointMarker =
                  e.pointMarker.type === i.EPointMarkerType.Sprite
                    ? new a.CustomPointMarkerStyle(e.pointMarker)
                    : new s.PointMarkerStyle(e.pointMarker)),
              (this.opacity =
                null !== (o = null == e ? void 0 : e.opacity) && void 0 !== o
                  ? o
                  : this.opacity);
          }
          set stroke(e) {
            (this.strokeProperty = e),
              e && (this.strokeARGBProperty = (0, o.parseColorToUIntArgb)(e));
          }
          get stroke() {
            return this.strokeProperty;
          }
          get strokeARGB() {
            return this.strokeARGBProperty;
          }
        };
      },
      88227: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BasePointMarkerStyle = void 0);
        const i = r(30323);
        t.BasePointMarkerStyle = class {
          constructor(e) {
            var t, r, i;
            (this.width = 0),
              (this.height = 0),
              (this.type =
                null !== (t = null == e ? void 0 : e.type) && void 0 !== t
                  ? t
                  : this.type),
              (this.width =
                null !== (r = null == e ? void 0 : e.width) && void 0 !== r
                  ? r
                  : this.width),
              (this.height =
                null !== (i = null == e ? void 0 : e.height) && void 0 !== i
                  ? i
                  : this.height);
          }
          get isCustomPointMarker() {
            return this.type === i.EPointMarkerType.Sprite;
          }
        };
      },
      61690: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BubbleAnimation = void 0);
        const i = r(10763),
          o = r(55371),
          a = r(63642);
        class s extends o.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new a.BaseAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
        }
        t.BubbleAnimation = s;
      },
      86551: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CandlestickAnimation = void 0);
        const i = r(10763),
          o = r(48008),
          a = r(54580),
          s = r(50951),
          n = r(86717);
        class l extends n.OhlcAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new s.CandlestickAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
          getSeriesStyle(e) {
            var t;
            if (!e.isStacked)
              return new s.CandlestickAnimationStyle({
                stroke: e.stroke,
                strokeThickness: e.strokeThickness,
                opacity: e.opacity,
                strokeUp: e.strokeUp,
                strokeDown: e.strokeDown,
                brushUp: e.brushUp,
                brushDown: e.brushDown,
                pointMarker:
                  null === (t = e.pointMarker) || void 0 === t
                    ? void 0
                    : t.getPointMarkerStyle(),
              });
          }
          updateSeriesProperties(e, t, r) {
            if (
              (super.updateSeriesProperties(e, t, r), this.isStyleAnimation)
            ) {
              const i = this.styles;
              if (void 0 !== i.brushUp) {
                const s = a.animationHelpers.interpolateColor(
                  t.brushUpARGB,
                  i.brushUpARGB,
                  r
                );
                e.brushUp = (0, o.parseArgbToHtmlColor)(s);
              }
              if (void 0 !== i.brushDown) {
                const s = a.animationHelpers.interpolateColor(
                  t.brushDownARGB,
                  i.brushDownARGB,
                  r
                );
                e.brushDown = (0, o.parseArgbToHtmlColor)(s);
              }
            }
          }
        }
        t.CandlestickAnimation = l;
      },
      50951: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CandlestickAnimationStyle = void 0);
        const i = r(48008),
          o = r(54938);
        class a extends o.OhlcAnimationStyle {
          constructor(e) {
            var t, r;
            super(e),
              (this.brushUp =
                null !== (t = null == e ? void 0 : e.brushUp) && void 0 !== t
                  ? t
                  : this.brushUpProperty),
              (this.brushDown =
                null !== (r = null == e ? void 0 : e.brushDown) && void 0 !== r
                  ? r
                  : this.brushDownProperty);
          }
          set brushUp(e) {
            (this.brushUpProperty = e),
              e && (this.brushUpARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get brushUp() {
            return this.brushUpProperty;
          }
          get brushUpARGB() {
            return this.brushUpARGBProperty;
          }
          set brushDown(e) {
            (this.brushDownProperty = e),
              e &&
                (this.brushDownARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get brushDown() {
            return this.brushDownProperty;
          }
          get brushDownARGB() {
            return this.brushDownARGBProperty;
          }
        }
        t.CandlestickAnimationStyle = a;
      },
      9687: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnAnimation = void 0);
        const i = r(10763),
          o = r(48008),
          a = r(54580),
          s = r(55371),
          n = r(37886),
          l = r(49987);
        class d extends s.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new n.ColumnAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
          getSeriesStyle(e) {
            var t, r;
            if (!e.isStacked)
              return new n.ColumnAnimationStyle({
                stroke: e.stroke,
                strokeThickness: e.strokeThickness,
                opacity: e.opacity,
                pointMarker:
                  null !==
                    (r =
                      null === (t = e.pointMarker) || void 0 === t
                        ? void 0
                        : t.getPointMarkerStyle()) && void 0 !== r
                    ? r
                    : new l.PointMarkerStyle(),
                fill: e.fill,
                zeroLineY: e.zeroLineY,
                dataPointWidth: e.dataPointWidth,
              });
          }
          updateSeriesProperties(e, t, r) {
            if (
              (super.updateSeriesProperties(e, t, r), this.isStyleAnimation)
            ) {
              const i = this.styles;
              if (void 0 !== i.fill) {
                const s = a.animationHelpers.interpolateColor(
                  t.fillARGB,
                  i.fillARGB,
                  r
                );
                e.fill = (0, o.parseArgbToHtmlColor)(s);
              }
              void 0 !== i.zeroLineY &&
                (e.zeroLineY = a.animationHelpers.interpolateNumber(
                  t.zeroLineY,
                  i.zeroLineY,
                  r
                )),
                void 0 !== i.dataPointWidth &&
                  (e.dataPointWidth = a.animationHelpers.interpolateNumber(
                    t.dataPointWidth,
                    i.dataPointWidth,
                    r
                  ));
            }
          }
        }
        t.ColumnAnimation = d;
      },
      37886: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnAnimationStyle = void 0);
        const i = r(48008),
          o = r(63642);
        class a extends o.BaseAnimationStyle {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.fill =
                null !== (t = null == e ? void 0 : e.fill) && void 0 !== t
                  ? t
                  : this.fillProperty),
              (this.zeroLineY =
                null !== (r = null == e ? void 0 : e.zeroLineY) && void 0 !== r
                  ? r
                  : this.zeroLineY),
              (this.dataPointWidth =
                null !== (i = null == e ? void 0 : e.dataPointWidth) &&
                void 0 !== i
                  ? i
                  : this.dataPointWidth);
          }
          set fill(e) {
            (this.fillProperty = e),
              e && (this.fillARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get fill() {
            return this.fillProperty;
          }
          get fillARGB() {
            return this.fillARGBProperty;
          }
        }
        t.ColumnAnimationStyle = a;
      },
      386: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomPointMarkerStyle = void 0);
        const i = r(88227);
        class o extends i.BasePointMarkerStyle {
          constructor(e) {
            var t;
            super(e),
              (this.image =
                null !== (t = null == e ? void 0 : e.image) && void 0 !== t
                  ? t
                  : this.image);
          }
        }
        t.CustomPointMarkerStyle = o;
      },
      62314: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FadeAnimation = void 0);
        const i = r(10763),
          o = r(55371);
        class a extends o.SeriesAnimation {
          constructor(e) {
            var t;
            super(e),
              (this.type = i.EAnimationType.Fade),
              (this.isFadeEffectAnimation =
                null === (t = null == e ? void 0 : e.fadeEffect) ||
                void 0 === t ||
                t);
          }
          calculateAnimationValues(e, t, r, i, o = !1) {
            e.SCRTAnimationHelperFade(t, i, r);
          }
        }
        t.FadeAnimation = a;
      },
      98499: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineAnimation = void 0);
        const i = r(10763),
          o = r(55371),
          a = r(63642);
        class s extends o.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new a.BaseAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
        }
        t.LineAnimation = s;
      },
      65122: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MountainAnimation = void 0);
        const i = r(10763),
          o = r(48008),
          a = r(54580),
          s = r(55371),
          n = r(3911),
          l = r(49987);
        class d extends s.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new n.MountainAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
          getSeriesStyle(e) {
            var t, r;
            if (!e.isStacked)
              return new n.MountainAnimationStyle({
                stroke: e.stroke,
                strokeThickness: e.strokeThickness,
                opacity: e.opacity,
                pointMarker:
                  null !==
                    (r =
                      null === (t = e.pointMarker) || void 0 === t
                        ? void 0
                        : t.getPointMarkerStyle()) && void 0 !== r
                    ? r
                    : new l.PointMarkerStyle(),
                fill: e.fill,
                zeroLineY: e.zeroLineY,
              });
          }
          updateSeriesProperties(e, t, r) {
            if (
              (super.updateSeriesProperties(e, t, r), this.isStyleAnimation)
            ) {
              const i = this.styles;
              if (void 0 !== i.fill) {
                const s = a.animationHelpers.interpolateColor(
                  t.fillARGB,
                  i.fillARGB,
                  r
                );
                e.fill = (0, o.parseArgbToHtmlColor)(s);
              }
              void 0 !== i.zeroLineY &&
                (e.zeroLineY = a.animationHelpers.interpolateNumber(
                  t.zeroLineY,
                  i.zeroLineY,
                  r
                ));
            }
          }
        }
        t.MountainAnimation = d;
      },
      3911: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MountainAnimationStyle = void 0);
        const i = r(48008),
          o = r(63642);
        class a extends o.BaseAnimationStyle {
          constructor(e) {
            var t, r;
            super(e),
              (this.fill =
                null !== (t = null == e ? void 0 : e.fill) && void 0 !== t
                  ? t
                  : this.fillProperty),
              (this.zeroLineY =
                null !== (r = null == e ? void 0 : e.zeroLineY) && void 0 !== r
                  ? r
                  : this.zeroLineY);
          }
          set fill(e) {
            (this.fillProperty = e),
              e && (this.fillARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get fill() {
            return this.fillProperty;
          }
          get fillARGB() {
            return this.fillARGBProperty;
          }
        }
        t.MountainAnimationStyle = a;
      },
      86717: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcAnimation = void 0);
        const i = r(10763),
          o = r(48008),
          a = r(54580),
          s = r(55371),
          n = r(54938);
        class l extends s.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new n.OhlcAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
          getSeriesStyle(e) {
            var t;
            if (!e.isStacked)
              return new n.OhlcAnimationStyle({
                stroke: e.stroke,
                strokeThickness: e.strokeThickness,
                opacity: e.opacity,
                strokeUp: e.strokeUp,
                strokeDown: e.strokeDown,
                dataPointWidth: e.dataPointWidth,
                pointMarker:
                  null === (t = e.pointMarker) || void 0 === t
                    ? void 0
                    : t.getPointMarkerStyle(),
              });
          }
          updateSeriesProperties(e, t, r) {
            if (
              (super.updateSeriesProperties(e, t, r), this.isStyleAnimation)
            ) {
              const i = this.styles;
              if (void 0 !== i.strokeUp) {
                const s = a.animationHelpers.interpolateColor(
                  t.strokeUpARGB,
                  i.strokeUpARGB,
                  r
                );
                e.strokeUp = (0, o.parseArgbToHtmlColor)(s);
              }
              if (void 0 !== i.strokeDown) {
                const s = a.animationHelpers.interpolateColor(
                  t.strokeDownARGB,
                  i.strokeDownARGB,
                  r
                );
                e.strokeDown = (0, o.parseArgbToHtmlColor)(s);
              }
              void 0 !== i.dataPointWidth &&
                (e.dataPointWidth = a.animationHelpers.interpolateNumber(
                  t.dataPointWidth,
                  i.dataPointWidth,
                  r
                ));
            }
          }
        }
        t.OhlcAnimation = l;
      },
      54938: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcAnimationStyle = void 0);
        const i = r(48008),
          o = r(63642);
        class a extends o.BaseAnimationStyle {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.strokeUp =
                null !== (t = null == e ? void 0 : e.strokeUp) && void 0 !== t
                  ? t
                  : this.strokeUpProperty),
              (this.strokeDown =
                null !== (r = null == e ? void 0 : e.strokeDown) && void 0 !== r
                  ? r
                  : this.strokeDownProperty),
              (this.dataPointWidth =
                null !== (i = null == e ? void 0 : e.dataPointWidth) &&
                void 0 !== i
                  ? i
                  : this.dataPointWidth);
          }
          set strokeUp(e) {
            (this.strokeUpProperty = e),
              e && (this.strokeUpARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get strokeUp() {
            return this.strokeUpProperty;
          }
          get strokeUpARGB() {
            return this.strokeUpARGBProperty;
          }
          set strokeDown(e) {
            (this.strokeDownProperty = e),
              e &&
                (this.strokeDownARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get strokeDown() {
            return this.strokeDownProperty;
          }
          get strokeDownARGB() {
            return this.strokeDownARGBProperty;
          }
        }
        t.OhlcAnimationStyle = a;
      },
      49987: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PointMarkerStyle = void 0);
        const i = r(48008),
          o = r(88227);
        class a extends o.BasePointMarkerStyle {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.strokeThickness = 0),
              (this.strokeThickness =
                null !== (t = null == e ? void 0 : e.strokeThickness) &&
                void 0 !== t
                  ? t
                  : this.strokeThickness),
              (this.stroke =
                null !== (r = null == e ? void 0 : e.stroke) && void 0 !== r
                  ? r
                  : "#ffffff00"),
              (this.fill =
                null !== (i = null == e ? void 0 : e.fill) && void 0 !== i
                  ? i
                  : "#ffffff00");
          }
          set stroke(e) {
            (this.strokeProperty = e),
              e && (this.strokeARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get stroke() {
            return this.strokeProperty;
          }
          get strokeARGB() {
            return this.strokeARGBProperty;
          }
          set fill(e) {
            (this.fillProperty = e),
              e && (this.fillARGBProperty = (0, i.parseColorToUIntArgb)(e));
          }
          get fill() {
            return this.fillProperty;
          }
          get fillARGB() {
            return this.fillARGBProperty;
          }
        }
        t.PointMarkerStyle = a;
      },
      56705: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ScaleAnimation = void 0);
        const i = r(10763),
          o = r(55371);
        class a extends o.SeriesAnimation {
          constructor(e) {
            var t;
            super(e),
              (this.type = i.EAnimationType.Scale),
              (this.zeroLine = 0),
              (this.isOnStartAnimation = !0),
              (this.zeroLine =
                null !== (t = null == e ? void 0 : e.zeroLine) && void 0 !== t
                  ? t
                  : this.zeroLine);
          }
          calculateAnimationValues(e, t, r, i, o = !1) {
            const a = o ? 0 : this.zeroLine;
            e.SCRTAnimationHelperScale(t, a, this.reverse ? 1 - i : i, r);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { zeroLine: this.zeroLine };
            return Object.assign(e.options, t), e;
          }
        }
        t.ScaleAnimation = a;
      },
      16911: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ScatterAnimation = void 0);
        const i = r(10763),
          o = r(55371),
          a = r(63642);
        class s extends o.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Style),
              (this.duration =
                null !== (t = null == e ? void 0 : e.duration) && void 0 !== t
                  ? t
                  : 1e3),
              (this.styles = (null == e ? void 0 : e.styles)
                ? new a.BaseAnimationStyle(e.styles)
                : this.styles),
              (this.dataSeries =
                null !== (r = null == e ? void 0 : e.dataSeries) && void 0 !== r
                  ? r
                  : this.dataSeries);
          }
        }
        t.ScatterAnimation = s;
      },
      55371: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesAnimation = void 0);
        const i = r(45921),
          o = r(10276),
          a = r(11043),
          s = r(48008),
          n = r(54580),
          l = r(63642),
          d = r(49987);
        t.SeriesAnimation = class {
          constructor(e) {
            var t, r, s, n, l;
            if (
              ((this.delay = 0),
              (this.duration = 3e3),
              (this.ease = o.easing.linear),
              (this.isFadeEffectAnimation = !1),
              (this.isOnStartAnimation = !1),
              (this.typeMap = new Map()),
              (this.delay =
                null !== (t = null == e ? void 0 : e.delay) && void 0 !== t
                  ? t
                  : this.delay),
              (this.duration =
                null !== (r = null == e ? void 0 : e.duration) && void 0 !== r
                  ? r
                  : this.duration),
              (this.isFadeEffectAnimation =
                null !== (s = null == e ? void 0 : e.fadeEffect) && void 0 !== s
                  ? s
                  : this.isFadeEffectAnimation),
              (null == e ? void 0 : e.ease) &&
                "string" == typeof e.ease &&
                (e.ease = o.easing[e.ease]),
              (this.ease =
                null !== (n = null == e ? void 0 : e.ease) && void 0 !== n
                  ? n
                  : this.ease),
              (this.reverse =
                null !== (l = null == e ? void 0 : e.reverse) && void 0 !== l
                  ? l
                  : this.reverse),
              null == e ? void 0 : e.onCompleted)
            )
              if ("string" == typeof e.onCompleted) {
                this.typeMap.set("onCompleted", e.onCompleted);
                const t = (0, i.getFunction)(
                  a.EBaseType.OptionFunction,
                  e.onCompleted
                );
                this.onCompleted = t;
              } else this.onCompleted = e.onCompleted;
          }
          toJSON() {
            const e = {
              delay: this.delay,
              duration: this.duration,
              ease: this.ease.name,
              fadeEffect: this.isFadeEffectAnimation,
              reverse: this.reverse,
              onCompleted: this.typeMap.get("onCompleted"),
            };
            return { type: this.type, options: e };
          }
          calculateAnimationValues(e, t, r, i, o = !1) {}
          calculateDataSeriesAnimationValues(e, t, r, i, o) {
            const a = t.size();
            if (a !== r.size())
              throw new Error(
                "DoubleVectors with initialValues and finalValues must have the same length"
              );
            "function" != typeof i.getRaw && i.resize(a, 0);
            for (let e = 0; e < a; e++)
              i.set(
                e,
                n.animationHelpers.interpolateNumber(t.get(e), r.get(e), o)
              );
          }
          getSeriesStyle(e) {
            var t, r;
            const i = e;
            if (!i.isStacked)
              return new l.BaseAnimationStyle({
                stroke: i.stroke,
                strokeThickness: i.strokeThickness,
                opacity: i.opacity,
                pointMarker:
                  null !==
                    (r =
                      null === (t = i.pointMarker) || void 0 === t
                        ? void 0
                        : t.getPointMarkerStyle()) && void 0 !== r
                    ? r
                    : new d.PointMarkerStyle(),
              });
          }
          updateSeriesProperties(e, t, r) {
            var i, o, a, l, d;
            this.reverse && (r = 1 - r);
            const h = e,
              u = h.pointMarker;
            if (this.isStyleAnimation) {
              if (void 0 !== this.styles.strokeThickness) {
                const e = null == t ? void 0 : t.strokeThickness,
                  i = this.styles.strokeThickness;
                h.strokeThickness = e + (i - e) * r;
              }
              if (void 0 !== this.styles.stroke) {
                const e = n.animationHelpers.interpolateColor(
                  t.strokeARGB,
                  this.styles.strokeARGB,
                  r
                );
                h.stroke = (0, s.parseArgbToHtmlColor)(e);
              }
              if (
                (void 0 !== this.styles.opacity &&
                  (h.opacity = n.animationHelpers.interpolateNumber(
                    t.opacity,
                    this.styles.opacity,
                    r
                  )),
                void 0 !== this.styles.pointMarker)
              ) {
                h.pointMarker.suspendUpdates();
                const e =
                    null !==
                      (o =
                        null === (i = t.pointMarker) || void 0 === i
                          ? void 0
                          : i.width) && void 0 !== o
                      ? o
                      : 0,
                  u =
                    null !==
                      (l =
                        null === (a = t.pointMarker) || void 0 === a
                          ? void 0
                          : a.height) && void 0 !== l
                      ? l
                      : 0;
                if (
                  ((h.pointMarker.width = n.animationHelpers.interpolateNumber(
                    e,
                    this.styles.pointMarker.width,
                    r
                  )),
                  (h.pointMarker.height = n.animationHelpers.interpolateNumber(
                    u,
                    this.styles.pointMarker.height,
                    r
                  )),
                  !this.styles.pointMarker.isCustomPointMarker)
                ) {
                  const e = t.pointMarker,
                    i = this.styles.pointMarker,
                    o =
                      null !== (d = null == e ? void 0 : e.strokeThickness) &&
                      void 0 !== d
                        ? d
                        : 0;
                  h.pointMarker.strokeThickness =
                    n.animationHelpers.interpolateNumber(
                      o,
                      i.strokeThickness,
                      r
                    );
                  const a = n.animationHelpers.interpolateColor(
                    e.fillARGB,
                    i.fillARGB,
                    r
                  );
                  h.pointMarker.fill = (0, s.parseArgbToHtmlColor)(a);
                  const l = n.animationHelpers.interpolateColor(
                    e.strokeARGB,
                    i.strokeARGB,
                    r
                  );
                  h.pointMarker.stroke = (0, s.parseArgbToHtmlColor)(l);
                }
                h.pointMarker.resumeUpdates();
              }
            }
            if (this.isFadeEffectAnimation) {
              const e = t.opacity * r;
              (h.opacity = e), u && (u.opacity = e);
            }
          }
          get isStyleAnimation() {
            return !!this.styles;
          }
          get isDataSeriesAnimation() {
            return !!this.dataSeries;
          }
        };
      },
      592: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SweepAnimation = void 0);
        const i = r(10763),
          o = r(55371);
        class a extends o.SeriesAnimation {
          constructor(e) {
            super(e),
              (this.type = i.EAnimationType.Sweep),
              (this.isOnStartAnimation = !0);
          }
          updateSeriesProperties(e, t, r) {
            super.updateSeriesProperties(e, t, r),
              0 === r
                ? (e.dataSeries.containsNaN = !0)
                : 1 === r && (e.dataSeries.containsNaN = !1);
          }
          calculateAnimationValues(e, t, r, i, o = !1) {
            e.SCRTAnimationHelperSweep(t, this.reverse ? 1 - i : i, r);
          }
        }
        t.SweepAnimation = a;
      },
      56498: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WaveAnimation = void 0);
        const i = r(10763),
          o = r(55371);
        class a extends o.SeriesAnimation {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = i.EAnimationType.Wave),
              (this.pointDurationFraction = 0.2),
              (this.zeroLine = 0),
              (this.isOnStartAnimation = !0),
              (this.pointDurationFraction =
                null !== (t = null == e ? void 0 : e.pointDurationFraction) &&
                void 0 !== t
                  ? t
                  : this.pointDurationFraction),
              (this.zeroLine =
                null !== (r = null == e ? void 0 : e.zeroLine) && void 0 !== r
                  ? r
                  : this.zeroLine);
          }
          updateSeriesProperties(e, t, r) {
            super.updateSeriesProperties(e, t, r),
              0 === r
                ? (e.dataSeries.containsNaN = !0)
                : 1 === r && (e.dataSeries.containsNaN = !1);
          }
          calculateAnimationValues(e, t, r, i, o = !1) {
            const { pointDurationFraction: a } = this,
              s = o ? 0 : this.zeroLine;
            e.SCRTAnimationHelperWave(t, a, s, this.reverse ? 1 - i : i, r);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                zeroLine: this.zeroLine,
                pointDurationFraction: this.pointDurationFraction,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.WaveAnimation = a;
      },
      54580: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__rest) ||
          function (e, t) {
            var r = {};
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) &&
                t.indexOf(i) < 0 &&
                (r[i] = e[i]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (i = Object.getOwnPropertySymbols(e); o < i.length; o++)
                t.indexOf(i[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, i[o]) &&
                  (r[i[o]] = e[i[o]]);
            }
            return r;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.animationHelpers = void 0);
        const o = r(82229),
          a = r(30323),
          s = r(22950),
          n = r(22745),
          l = r(10749),
          d = r(21033),
          h = r(77057),
          u = r(58229),
          c = r(61704);
        t.animationHelpers = {
          checkCanDraw: (e) =>
            !e ||
            e.is([o.EAnimationState.Running, o.EAnimationState.Completed]),
          checkIsAnimationRunning: (e, t) =>
            e.length > 0 || (!!t && !t.is([o.EAnimationState.Completed])),
          animationUpdate: (e, t, r, i, a) => {
            const s = e.update(t);
            e.animation.isOnStartAnimation &&
              s === o.EAnimationStateTransition.InitialState_Delayed &&
              (r(), a(0, e)),
              (s === o.EAnimationStateTransition.InitialState_Running ||
                (!e.animation.isOnStartAnimation &&
                  s === o.EAnimationStateTransition.Delayed_Running)) &&
                r(),
              e.is([o.EAnimationState.Running, o.EAnimationState.Completed]) &&
                a(e.animationProgress, e),
              [
                o.EAnimationStateTransition.Running_Completed,
                o.EAnimationStateTransition.InitialState_Completed,
              ].includes(s) &&
                e.animation.onCompleted &&
                e.animation.onCompleted(),
              s === o.EAnimationStateTransition.Running_Completed && i();
          },
          createPointMarker: (e, t) => {
            if (t) {
              if (t.type === a.EPointMarkerType.Sprite) {
                const r = t,
                  { type: o } = r,
                  a = i(r, ["type"]);
                return new d.SpritePointMarker(e, Object.assign({}, a));
              }
              {
                const r = t,
                  { type: o } = r,
                  s = i(r, ["type"]);
                switch (o) {
                  case a.EPointMarkerType.Cross:
                    return new n.CrossPointMarker(e, Object.assign({}, s));
                  case a.EPointMarkerType.Ellipse:
                    return new l.EllipsePointMarker(e, Object.assign({}, s));
                  case a.EPointMarkerType.X:
                    return new c.XPointMarker(e, Object.assign({}, s));
                  case a.EPointMarkerType.Square:
                    return new h.SquarePointMarker(e, Object.assign({}, s));
                  case a.EPointMarkerType.Triangle:
                    return new u.TrianglePointMarker(e, Object.assign({}, s));
                }
              }
            }
          },
          interpolateNumber: (e, t, r) =>
            r < 0 ? e : r > 1 ? t : e + (t - e) * r,
          interpolateColor: (e, t, r) =>
            r < 0 ? e : r > 1 ? t : (0, s.uintArgbColorLerp)(e, t, r),
          copyVector: (e, t) => {
            const r = e.size();
            t.resize(r, 0);
            for (let i = 0; i < r; i++) t.set(i, e.get(i));
          },
        };
      },
      20181: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseBandRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(24933),
          s = r(51885),
          n = r(14023),
          l = r(2354),
          d = r(75650),
          h = r(84392),
          u = r(14184),
          c = r(79961),
          p = r(20977),
          g = r(81856),
          y = r(7807),
          f = r(94707),
          v = r(72704);
        class m extends c.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, o, a;
            super(e, t),
              (this.stroke =
                null !== (r = null == t ? void 0 : t.stroke) && void 0 !== r
                  ? r
                  : u.SciChartSurfaceBase.DEFAULT_THEME
                      .downBandSeriesLineColor),
              (this.strokeY1Property =
                null !== (i = null == t ? void 0 : t.strokeY1) && void 0 !== i
                  ? i
                  : u.SciChartSurfaceBase.DEFAULT_THEME.upBandSeriesLineColor),
              (this.fillProperty =
                null !== (o = null == t ? void 0 : t.fill) && void 0 !== o
                  ? o
                  : u.SciChartSurfaceBase.DEFAULT_THEME.upBandSeriesFillColor),
              (this.fillY1Property =
                null !== (a = null == t ? void 0 : t.fillY1) && void 0 !== a
                  ? a
                  : u.SciChartSurfaceBase.DEFAULT_THEME
                      .downBandSeriesFillColor),
              (this.fillLinearGradient =
                null == t ? void 0 : t.fillLinearGradient),
              (this.fillLinearGradientY1 =
                null == t ? void 0 : t.fillLinearGradientY1),
              (this.strokeY1DashArrayProperty =
                null == t ? void 0 : t.strokeY1DashArray),
              (this.strokeDashArrayProperty =
                null == t ? void 0 : t.strokeDashArray),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new g.BandSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new y.BandSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new f.PointMarkerDrawingProvider(e, this)
              ),
              this.drawingProviders.push(
                new f.PointMarkerDrawingProvider(
                  e,
                  this,
                  (e) => e.y1Values,
                  (e) => e.y1SplineValues
                )
              );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.downBandSeriesLineColor &&
              (this.stroke = e.downBandSeriesLineColor),
              this.strokeY1 === t.upBandSeriesLineColor &&
                (this.strokeY1 = e.upBandSeriesLineColor),
              this.fill === t.upBandSeriesFillColor &&
                (this.fill = e.upBandSeriesFillColor),
              this.fillY1 === t.downBandSeriesFillColor &&
                (this.fillY1 = e.downBandSeriesFillColor);
          }
          get fill() {
            return (0, h.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            this.fillProperty !== e &&
              ((this.fillProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL));
          }
          get strokeY1() {
            return (0, h.stripAutoColor)(this.strokeY1Property);
          }
          set strokeY1(e) {
            this.strokeY1Property !== e &&
              ((this.strokeY1Property = e),
              this.notifyPropertyChanged(p.PROPERTY.STROKE_Y1));
          }
          get fillY1() {
            return (0, h.stripAutoColor)(this.fillY1Property);
          }
          set fillY1(e) {
            this.fillY1Property !== e &&
              ((this.fillY1Property = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL_Y1));
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.STROKE_DASH_ARRAY);
          }
          get strokeY1DashArray() {
            return this.strokeY1DashArrayProperty;
          }
          set strokeY1DashArray(e) {
            (this.strokeY1DashArrayProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.STROKE_Y1_DASH_ARRAY);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          get fillLinearGradientY1() {
            return this.fillLinearGradientY1Property;
          }
          set fillLinearGradientY1(e) {
            e !== this.fillLinearGradientY1Property &&
              ((this.fillLinearGradientY1Property = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL_LINEAR_GRADIENT_Y1));
          }
          getNativeY1Values() {
            return this.dataSeries.getNativeY1Values();
          }
          delete() {
            (this.xyyTempPointSeries = (0, i.deleteSafe)(
              this.xyyTempPointSeries
            )),
              super.delete();
          }
          toPointSeries(e) {
            if (e) {
              this.xyyTempPointSeries
                ? (this.xyyTempPointSeries.xRange = e.xVisibleRange)
                : (this.xyyTempPointSeries = new n.XyyPointSeriesResampled(
                    this.webAssemblyContext,
                    e.xVisibleRange
                  )),
                this.pointSeries
                  ? (this.pointSeries.xRange = e.xVisibleRange)
                  : (this.pointSeries = new n.XyyPointSeriesResampled(
                      this.webAssemblyContext,
                      e.xVisibleRange
                    ));
              const t = this.pointSeries,
                r = this.dataSeries,
                i = r.getNativeXValues(),
                o = r.getNativeYValues(),
                a = r.getNativeY1Values(),
                s = this.resamplerHelper.resampleIntoPointSeries(
                  this.webAssemblyContext,
                  e,
                  i,
                  o,
                  this.xyyTempPointSeries.intIndexes,
                  void 0,
                  this.xyyTempPointSeries.xValues,
                  this.xyyTempPointSeries.yValues,
                  !1
                );
              this.pointSeries.fifoStartIndex = s.OutputSplitIndex;
              const l = this.xyyTempPointSeries.intIndexes.size();
              this.resamplerHelper.resampleIntoPointSeries(
                this.webAssemblyContext,
                e,
                i,
                a,
                this.xyyTempPointSeries.intIndexes,
                void 0,
                this.xyyTempPointSeries.xValues,
                this.xyyTempPointSeries.y1Values
              );
              const d = this.xyyTempPointSeries.intIndexes.size() - l,
                h = this.resamplerHelper.mergeIndexes(
                  this.xyyTempPointSeries.intIndexes,
                  l,
                  d,
                  t.intIndexes
                );
              return (
                this.xyyTempPointSeries.intIndexes.clear(),
                e.dataIsFifo
                  ? t.indexes.resizeFast(h)
                  : t.indexes.resizeFast(h + 1),
                this.resamplerHelper.copyValuesByIndexes(
                  t.intIndexes,
                  i,
                  o,
                  a,
                  h,
                  e.isCategoryAxis,
                  this.dataSeries.fifoSweeping,
                  t.indexes,
                  t.xValues,
                  t.yValues,
                  t.y1Values
                ),
                t.clearIntIndexes(),
                t
              );
            }
            return new l.XyyPointSeriesWrapped(this.dataSeries);
          }
          getYRange(e, t = !1) {
            const r = this.isRunningDataAnimation
              ? s.EDataSeriesValueType.FinalAnimationValues
              : s.EDataSeriesValueType.Default;
            let i = this.getResampledPointSeries(t);
            if (
              this.renderDataTransform &&
              this.renderDataTransform.useForYRange
            )
              return (
                this.updateTransformedValues(r),
                (0, a.getWindowedYRange)(
                  this.webAssemblyContext,
                  this.transformedRenderPassData.pointSeries.xValues,
                  this.transformedRenderPassData.pointSeries.yValues,
                  e,
                  !0,
                  t,
                  this.dataSeries.dataDistributionCalculator.isSortedAscending
                )
              );
            if (i) {
              const { yValues: e, y1Values: t } = i,
                r = new o.NumberRange(0, i.count - 1);
              return (0, d.getYyYRange)(this.webAssemblyContext, r, e, t);
            }
            return this.dataSeries.getWindowedYRange(
              e,
              !0,
              t,
              r,
              this.yRangeMode
            );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                fillY1: this.fillY1,
                strokeDashArray: this.strokeDashArray,
                strokeY1: this.strokeY1,
                strokeY1DashArray: this.strokeY1DashArray,
              };
            return Object.assign(t.options, r), t;
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(h.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = h.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
            const i = (e + Math.floor(t / 2)) % t;
            if (this.strokeY1Property.startsWith(h.AUTO_COLOR)) {
              const e = r.getStrokeColor(i, t, this.webAssemblyContext);
              this.strokeY1 =
                h.AUTO_COLOR + this.adjustAutoColor("strokeY1", e);
            }
            if (this.fillY1Property.startsWith(h.AUTO_COLOR)) {
              const e = r.getFillColor(i, t, this.webAssemblyContext);
              this.fillY1 = h.AUTO_COLOR + this.adjustAutoColor("fillY1", e);
            }
          }
          newHitTestProvider() {
            return new v.BandSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.BaseBandRenderableSeries = m;
      },
      53904: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseHeatmapRenderableSeries = t.COLOR_MAP_PREFIX = void 0);
        const i = r(56744),
          o = r(39920),
          a = r(79961),
          s = r(20977),
          n = r(60981);
        t.COLOR_MAP_PREFIX = "colorMap.";
        class l extends a.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, a, s;
            super(e, t),
              (this.useLinearTextureFilteringProperty = !1),
              (this.fillValuesOutOfRangeProperty = !0),
              (this.colorMapPropertyChanged =
                this.colorMapPropertyChanged.bind(this)),
              (null == t ? void 0 : t.colorMap) &&
                ("toJSON" in t.colorMap ||
                  (t.colorMap = new n.HeatmapColorMap(t.colorMap))),
              (this.colorMap = null == t ? void 0 : t.colorMap),
              (this.xAxisId = null == t ? void 0 : t.xAxisId),
              (this.yAxisId = null == t ? void 0 : t.yAxisId),
              (this.useLinearTextureFilteringProperty =
                null !==
                  (r = null == t ? void 0 : t.useLinearTextureFiltering) &&
                void 0 !== r
                  ? r
                  : this.useLinearTextureFilteringProperty),
              (this.fillValuesOutOfRangeProperty =
                null !== (i = null == t ? void 0 : t.fillValuesOutOfRange) &&
                void 0 !== i
                  ? i
                  : this.fillValuesOutOfRangeProperty),
              (this.dataSeries = null == t ? void 0 : t.dataSeries),
              (null === (a = this.paletteProvider) || void 0 === a
                ? void 0
                : a.onAttached) &&
                (null === (s = this.paletteProvider) ||
                  void 0 === s ||
                  s.onAttached(this)),
              (this.zLabelProviderProperty = new o.NumericLabelProvider({
                labelPrecision: 2,
              }));
          }
          get colorMap() {
            return this.colorMapProperty;
          }
          set colorMap(e) {
            var t, r;
            null === (t = this.colorMapProperty) ||
              void 0 === t ||
              t.propertyChanged.unsubscribe(this.colorMapPropertyChanged),
              (this.colorMapProperty = e),
              null === (r = this.colorMapProperty) ||
                void 0 === r ||
                r.propertyChanged.subscribe(this.colorMapPropertyChanged),
              this.notifyPropertyChanged(s.PROPERTY.COLOR_MAP);
          }
          get useLinearTextureFiltering() {
            return this.useLinearTextureFilteringProperty;
          }
          set useLinearTextureFiltering(e) {
            (this.useLinearTextureFilteringProperty = e),
              this.notifyPropertyChanged(
                s.PROPERTY.USE_LINEAR_TEXTURE_FILTERING
              );
          }
          checkIsOutOfDataRange(e, t) {
            const r = this.dataSeries;
            return (
              !r ||
              e <= r.xRange.min ||
              e >= r.xRange.max ||
              t <= r.yRange.min ||
              t >= r.yRange.max
            );
          }
          get zLabelProvider() {
            return this.zLabelProviderProperty;
          }
          set zLabelProvider(e) {
            (this.zLabelProviderProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.Z_LABEL_PROVIDER);
          }
          get fillValuesOutOfRange() {
            return this.fillValuesOutOfRangeProperty;
          }
          set fillValuesOutOfRange(e) {
            (this.fillValuesOutOfRangeProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL_VALUES_OUT_OF_RANGE);
          }
          toPointSeries(e) {}
          toJSON(e = !1) {
            var t;
            const r = super.toJSON(e),
              i = {
                colorMap:
                  null === (t = this.colorMap) || void 0 === t
                    ? void 0
                    : t.toJSON(),
                fillValuesOutOfRange: this.fillValuesOutOfRange,
                useLinearTextureFiltering: this.useLinearTextureFiltering,
              };
            return Object.assign(r.options, i), r;
          }
          delete() {
            (this.zLabelProviderProperty = (0, i.deleteSafe)(
              this.zLabelProviderProperty
            )),
              super.delete();
          }
          colorMapPropertyChanged(e) {
            this.notifyPropertyChanged(t.COLOR_MAP_PREFIX + e.propertyName);
          }
        }
        t.BaseHeatmapRenderableSeries = l;
      },
      20782: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseLineRenderableSeries = t.ELineType = void 0);
        const i = r(79961),
          o = r(20977),
          a = r(36898),
          s = r(94707),
          n = r(28628);
        var l;
        !(function (e) {
          (e.Normal = "Normal"),
            (e.Digital = "Digital"),
            (e.DigitalNoEdge = "DigitalNoEdge"),
            (e.DigitalYX = "DigitalYX");
        })((l = t.ELineType || (t.ELineType = {})));
        class d extends i.BaseRenderableSeries {
          constructor(e, t) {
            var r;
            super(e, t),
              (this.strokeDashArrayProperty = []),
              (this.lineTypeProperty = l.Normal),
              (this.strokeDashArrayProperty =
                null == t ? void 0 : t.strokeDashArray),
              (this.lineTypeProperty =
                null !== (r = null == t ? void 0 : t.lineType) && void 0 !== r
                  ? r
                  : this.lineTypeProperty),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new a.LineSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new s.PointMarkerDrawingProvider(e, this)
              );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.lineSeriesColor &&
              (this.stroke = e.lineSeriesColor);
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.STROKE_DASH_ARRAY);
          }
          get lineType() {
            return this.lineTypeProperty;
          }
          set lineType(e) {
            (this.lineTypeProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.LINE_TYPE);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                strokeDashArray: this.strokeDashArray,
                lineType: this.lineTypeProperty,
              };
            return Object.assign(t.options, r), t;
          }
          newHitTestProvider() {
            return new n.LineSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.BaseLineRenderableSeries = d;
      },
      36650: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseMountainRenderableSeries = void 0);
        const i = r(84392),
          o = r(14184),
          a = r(79961),
          s = r(20977),
          n = r(36877),
          l = r(94707),
          d = r(47453);
        class h extends a.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, a, s, n;
            super(e, t),
              (this.zeroLineYProperty = 0),
              (this.fillProperty =
                o.SciChartSurfaceBase.DEFAULT_THEME.mountainAreaBrush),
              (this.strokeDashArrayProperty = []),
              (this.stroke =
                null !== (r = null == t ? void 0 : t.stroke) && void 0 !== r
                  ? r
                  : o.SciChartSurfaceBase.DEFAULT_THEME.mountainLineColor),
              (this.strokeDashArrayProperty =
                null !== (i = null == t ? void 0 : t.strokeDashArray) &&
                void 0 !== i
                  ? i
                  : this.strokeDashArrayProperty),
              (this.fillProperty =
                null !== (a = null == t ? void 0 : t.fill) && void 0 !== a
                  ? a
                  : this.fillProperty),
              (this.zeroLineYProperty =
                null !== (s = null == t ? void 0 : t.zeroLineY) && void 0 !== s
                  ? s
                  : this.zeroLineYProperty),
              (this.fillLinearGradientProperty =
                null !== (n = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== n
                  ? n
                  : this.fillLinearGradientProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new n.MountainSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new l.PointMarkerDrawingProvider(e, this)
              );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.fill === t.mountainAreaBrush &&
              (this.fill = e.mountainAreaBrush),
              this.stroke === t.mountainLineColor &&
                (this.stroke = e.mountainLineColor);
          }
          get fill() {
            return (0, i.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL);
          }
          get zeroLineY() {
            return this.zeroLineYProperty;
          }
          set zeroLineY(e) {
            (this.zeroLineYProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.ZERO_LINE_Y);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.STROKE_DASH_ARRAY);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                fillLinearGradient: this.fillLinearGradient,
                strokeDashArray: this.strokeDashArray,
                zeroLineY: this.zeroLineY,
              };
            return Object.assign(t.options, r), t;
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(i.AUTO_COLOR))
            ) {
              const o = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = i.AUTO_COLOR + this.adjustAutoColor("fill", o);
            }
          }
          newHitTestProvider() {
            return new d.MountainSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.BaseMountainRenderableSeries = h;
      },
      18790: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseOhlcRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(27970),
          s = r(24933),
          n = r(51885),
          l = r(35471),
          d = r(65052),
          h = r(6328),
          u = r(14023),
          c = r(33240),
          p = r(84392),
          g = r(14184),
          y = r(79961),
          f = r(20977),
          v = r(8535);
        class m extends y.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, o, s, n;
            super(e, t),
              (this.dataPointWidthModeProperty =
                a.EDataPointWidthMode.Relative),
              (this.strokeUp =
                null !== (r = null == t ? void 0 : t.strokeUp) && void 0 !== r
                  ? r
                  : g.SciChartSurfaceBase.DEFAULT_THEME.upWickColor),
              (this.strokeDown =
                null !== (i = null == t ? void 0 : t.strokeDown) && void 0 !== i
                  ? i
                  : g.SciChartSurfaceBase.DEFAULT_THEME.downWickColor),
              (this.dataPointWidth =
                null !== (o = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== o
                  ? o
                  : 0.5),
              (this.dataPointWidthMode =
                null !== (s = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== s
                  ? s
                  : this.dataPointWidthModeProperty),
              (this.strokeThickness =
                null !== (n = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== n
                  ? n
                  : 1),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.lineSeriesColor &&
              (this.stroke = e.lineSeriesColor),
              this.strokeUp === t.upWickColor &&
                (this.strokeUp = e.upWickColor),
              this.strokeDown === t.downWickColor &&
                (this.strokeDown = e.downWickColor);
          }
          get strokeUp() {
            return (0, p.stripAutoColor)(this.strokeUpProperty);
          }
          set strokeUp(e) {
            (this.strokeUpProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE_UP);
          }
          get strokeDown() {
            return (0, p.stripAutoColor)(this.strokeDownProperty);
          }
          set strokeDown(e) {
            (this.strokeDownProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.STROKE_DOWN);
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DATA_POINT_WIDTH);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(f.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          notifyPropertyChanged(e) {
            if (
              (super.notifyPropertyChanged(e),
              e === f.PROPERTY.DATA_SERIES &&
                void 0 !== this.dataSeries &&
                this.dataSeries.type !== n.EDataSeriesType.Ohlc)
            )
              throw new Error(
                "DataSeries for Candlestick or Ohlc series must be type OhlcDataSeries"
              );
          }
          getXRange() {
            const e = super.getXRange(),
              t = (0, y.getDataPointWidthAdjustment)(
                this.dataPointWidthMode,
                this.dataPointWidth,
                this.dataSeries.count(),
                e,
                this.xAxis.getCurrentCoordinateCalculator()
              );
            return new o.NumberRange(e.min - t, e.max + t);
          }
          delete() {
            (this.resamplerHelper = (0, i.deleteSafe)(this.resamplerHelper)),
              (this.xyyTempPointSeries = (0, i.deleteSafe)(
                this.xyyTempPointSeries
              )),
              (this.pointSeries = (0, i.deleteSafe)(this.pointSeries)),
              super.delete();
          }
          getNativeOpenValues() {
            return this.dataSeries.getNativeOpenValues();
          }
          getNativeHighValues() {
            return this.dataSeries.getNativeHighValues();
          }
          getNativeLowValues() {
            return this.dataSeries.getNativeLowValues();
          }
          getNativeCloseValues() {
            return this.dataSeries.getNativeYValues();
          }
          resolveAutoColors(e, t, r) {
            if (this.strokeUpProperty.startsWith(p.AUTO_COLOR)) {
              const i = r.getStrokeColor(e, t, this.webAssemblyContext);
              this.strokeUp =
                p.AUTO_COLOR + this.adjustAutoColor("strokeUp", i);
            }
            const i = (e + Math.floor(t / 2)) % t;
            if (this.strokeDownProperty.startsWith(p.AUTO_COLOR)) {
              const e = r.getStrokeColor(i, t, this.webAssemblyContext);
              this.strokeDown =
                p.AUTO_COLOR + this.adjustAutoColor("strokeDown", e);
            }
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                dataPointWidth: this.dataPointWidth,
                dataPointWidthMode: this.dataPointWidthMode,
                strokeDown: this.strokeDown,
                strokeUp: this.strokeUp,
              };
            return Object.assign(t.options, r), t;
          }
          getYRange(e, t = !1) {
            const r = this.isRunningDataAnimation
              ? n.EDataSeriesValueType.FinalAnimationValues
              : n.EDataSeriesValueType.Default;
            let i = this.getResampledPointSeries(t);
            if (
              this.renderDataTransform &&
              this.renderDataTransform.useForYRange
            )
              return (
                this.updateTransformedValues(r),
                (0, s.getWindowedYRange)(
                  this.webAssemblyContext,
                  this.transformedRenderPassData.pointSeries.xValues,
                  this.transformedRenderPassData.pointSeries.yValues,
                  i ? new o.NumberRange(0, i.count - 1) : e,
                  !0,
                  t,
                  this.dataSeries.dataDistributionCalculator.isSortedAscending
                )
              );
            if (i) {
              const {
                  openValues: e,
                  closeValues: t,
                  highValues: r,
                  lowValues: a,
                } = i,
                s = new o.NumberRange(0, i.count - 1);
              return (0, l.getOHLCYRange)(s, e, r, a, t);
            }
            return this.dataSeries.getWindowedYRange(
              e,
              !0,
              t,
              r,
              this.yRangeMode
            );
          }
          toPointSeries(e) {
            if (e) {
              this.xyyTempPointSeries
                ? (this.xyyTempPointSeries.xRange = e.xVisibleRange)
                : (this.xyyTempPointSeries = new u.XyyPointSeriesResampled(
                    this.webAssemblyContext,
                    e.xVisibleRange
                  )),
                this.pointSeries
                  ? (this.pointSeries.xRange = e.xVisibleRange)
                  : (this.pointSeries = new d.OhlcPointSeriesResampled(
                      this.webAssemblyContext,
                      e.xVisibleRange
                    ));
              const t = this.pointSeries,
                r = this.dataSeries,
                i = r.getNativeXValues(),
                o = r.getNativeOpenValues(),
                a = r.getNativeHighValues(),
                s = r.getNativeLowValues(),
                n = r.getNativeCloseValues(),
                l = r.getNativeIndexes(),
                h = e.clone({
                  resamplingMode:
                    e.resamplingMode === c.EResamplingMode.None
                      ? c.EResamplingMode.None
                      : c.EResamplingMode.Max,
                }),
                p = this.resamplerHelper.resampleIntoPointSeries(
                  this.webAssemblyContext,
                  h,
                  i,
                  a,
                  this.xyyTempPointSeries.intIndexes,
                  void 0,
                  this.xyyTempPointSeries.xValues,
                  t.highValues
                );
              (this.pointSeries.fifoStartIndex = p.OutputSplitIndex),
                this.xyyTempPointSeries.clearIntIndexes();
              const g = e.clone({
                resamplingMode:
                  e.resamplingMode === c.EResamplingMode.None
                    ? c.EResamplingMode.None
                    : c.EResamplingMode.Min,
              });
              this.resamplerHelper.resampleIntoPointSeries(
                this.webAssemblyContext,
                g,
                i,
                s,
                this.xyyTempPointSeries.intIndexes,
                void 0,
                this.xyyTempPointSeries.xValues,
                t.lowValues
              ),
                this.xyyTempPointSeries.clearIntIndexes(),
                this.xyyTempPointSeries.y1Values.clear();
              const y = e.clone({
                resamplingMode:
                  e.resamplingMode === c.EResamplingMode.None
                    ? c.EResamplingMode.None
                    : c.EResamplingMode.Min,
              });
              this.resamplerHelper.resampleIntoPointSeries(
                this.webAssemblyContext,
                y,
                i,
                l,
                t.intIndexes,
                void 0,
                this.xyyTempPointSeries.xValues,
                this.xyyTempPointSeries.y1Values
              );
              const f = t.intIndexes.size();
              this.xyyTempPointSeries.y1Values.clear();
              const v = t.intIndexes.get(3) - t.intIndexes.get(2) - 1;
              return (
                t.indexes.resizeFast(f + 1),
                this.resamplerHelper.copyValuesByIndexes(
                  t.intIndexes,
                  i,
                  o,
                  n,
                  f,
                  e.isCategoryAxis,
                  this.dataSeries.fifoSweeping,
                  t.indexes,
                  t.xValues,
                  t.openValues,
                  t.closeValues,
                  v
                ),
                t.clearIntIndexes(),
                t
              );
            }
            return new h.OhlcPointSeriesWrapped(this.dataSeries);
          }
          newHitTestProvider() {
            return new v.OhlcSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.BaseOhlcRenderableSeries = m;
      },
      79961: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getDataPointWidthAdjustment =
            t.adjustRangeByStrokeThickness =
            t.getDelta =
            t.getDataPointWidth =
            t.BaseRenderableSeries =
              void 0);
        const i = r(45921),
          o = r(82229),
          a = r(55023),
          s = r(56744),
          n = r(3214),
          l = r(23866),
          d = r(16819),
          h = r(98140),
          u = r(87459),
          c = r(10763),
          p = r(11043),
          g = r(60960),
          y = r(2963),
          f = r(27970),
          v = r(3777),
          m = r(28436),
          S = r(30323),
          P = r(5337),
          C = r(19145),
          b = r(9073),
          x = r(73538),
          A = r(16602),
          T = r(16185),
          E = r(24933),
          R = r(51185),
          D = r(14883),
          w = r(84754),
          M = r(97041),
          L = r(50874),
          O = r(21780),
          I = r(19581),
          k = r(51885),
          _ = r(32747),
          V = r(88915),
          N = r(78644),
          B = r(33240),
          F = r(97742),
          H = r(48570),
          Y = r(84392),
          z = r(85479),
          j = r(14184),
          X = r(86127),
          G = r(54580),
          W = r(20977),
          U = r(54962),
          $ = r(57318),
          Z = r(29593),
          q = r(72469);
        class K extends a.DeletableEntity {
          constructor(e, t) {
            var r,
              o,
              a,
              s,
              l,
              d,
              h,
              u,
              g,
              f,
              P,
              C,
              A,
              E,
              R,
              D,
              w,
              M,
              L,
              O,
              I,
              k,
              V,
              F;
            if (
              (super(),
              (this.isPolar = !1),
              (this.rolloverModifierProps =
                new U.RolloverModifierRenderableSeriesProps(this)),
              (this.rolloverModifierProps1 =
                new U.RolloverModifierRenderableSeriesProps(this, !0)),
              (this.selected = new n.EventHandler()),
              (this.hovered = new n.EventHandler()),
              (this.isVisibleChanged = new n.EventHandler()),
              (this.animationQueue = []),
              (this.paletteProviderProperty =
                _.DefaultPaletteProvider.createEmpty()),
              (this.typeMap = new Map()),
              (this.opacityProperty = 1),
              (this.drawingProvidersProperty = []),
              (this.strokeThicknessProperty = 2),
              (this.strokeProperty =
                j.SciChartSurfaceBase.DEFAULT_THEME.lineSeriesColor),
              (this.drawNaNAsProperty = T.ELineDrawMode.DiscontinuousLine),
              (this.isVisibleProperty = !0),
              (this.isDigitalLineProperty = !1),
              (this.resamplingModeProperty = B.EResamplingMode.Auto),
              (this.resamplingPrecisionProperty = 0),
              (this.clipToYRangeProperty = !1),
              (this.yRangeModeProperty = b.EYRangeMode.Drawn),
              (this.yArrayFilterProperty = void 0),
              (this.seriesNameProperty = void 0),
              (this.surfaceRenderOrderProperty = void 0),
              (this.renderLayerProperty = v.EDefaultRenderLayer.SeriesLayer),
              (this.renderOrderProperty = void 0),
              (this.isStacked = !1),
              (this.webAssemblyContext = e),
              (this.id =
                null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                  ? r
                  : (0, x.generateGuid)()),
              (this.dataSeriesDataChanged =
                this.dataSeriesDataChanged.bind(this)),
              (this.effectPropertyChanged =
                this.effectPropertyChanged.bind(this)),
              (this.invalidateParent = this.invalidateParent.bind(this)),
              (this.getDataPointWidth = this.getDataPointWidth.bind(this)),
              (this.updateAnimationProperties =
                this.updateAnimationProperties.bind(this)),
              (this.beforeAnimationStart =
                this.beforeAnimationStart.bind(this)),
              (this.afterAnimationComplete =
                this.afterAnimationComplete.bind(this)),
              (this.dataSeries =
                null !== (o = null == t ? void 0 : t.dataSeries) && void 0 !== o
                  ? o
                  : this.dataSeriesProperty),
              (null == t ? void 0 : t.pointMarker) &&
                ("drawSprite" in t.pointMarker ||
                  (t.pointMarker.type === S.EPointMarkerType.Custom
                    ? (t.pointMarker = (0, i.createType)(
                        p.EBaseType.PointMarker,
                        t.pointMarker.customType,
                        e,
                        t.pointMarker.options
                      ))
                    : (t.pointMarker = (0, i.createType)(
                        p.EBaseType.PointMarker,
                        t.pointMarker.type,
                        e,
                        t.pointMarker.options
                      )))),
              (this.pointMarkerProperty =
                null !== (a = null == t ? void 0 : t.pointMarker) &&
                void 0 !== a
                  ? a
                  : this.pointMarkerProperty),
              (this.strokeProperty =
                null !== (s = null == t ? void 0 : t.stroke) && void 0 !== s
                  ? s
                  : this.strokeProperty),
              (this.strokeThicknessProperty =
                null !== (l = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== l
                  ? l
                  : this.strokeThicknessProperty),
              (this.opacityProperty =
                null !== (d = null == t ? void 0 : t.opacity) && void 0 !== d
                  ? d
                  : this.opacityProperty),
              (this.xAxisIdProperty =
                null !== (h = null == t ? void 0 : t.xAxisId) && void 0 !== h
                  ? h
                  : this.xAxisIdProperty),
              (this.yAxisIdProperty =
                null !== (u = null == t ? void 0 : t.yAxisId) && void 0 !== u
                  ? u
                  : this.yAxisIdProperty),
              (this.isVisibleProperty =
                null !== (g = null == t ? void 0 : t.isVisible) && void 0 !== g
                  ? g
                  : this.isVisibleProperty),
              (this.isDigitalLineProperty =
                null !== (f = null == t ? void 0 : t.isDigitalLine) &&
                void 0 !== f
                  ? f
                  : this.isDigitalLineProperty),
              (this.resamplingModeProperty =
                null !== (P = null == t ? void 0 : t.resamplingMode) &&
                void 0 !== P
                  ? P
                  : this.resamplingModeProperty),
              (this.resamplingPrecisionProperty =
                null !== (C = null == t ? void 0 : t.resamplingPrecision) &&
                void 0 !== C
                  ? C
                  : this.resamplingPrecisionProperty),
              (this.surfaceRenderOrderProperty =
                null !== (A = null == t ? void 0 : t.surfaceRenderOrder) &&
                void 0 !== A
                  ? A
                  : this.surfaceRenderOrderProperty),
              (this.renderLayerProperty =
                null !== (E = null == t ? void 0 : t.renderLayer) &&
                void 0 !== E
                  ? E
                  : this.renderLayerProperty),
              (this.renderOrderProperty =
                null !== (R = null == t ? void 0 : t.renderOrder) &&
                void 0 !== R
                  ? R
                  : this.renderOrderProperty),
              (this.renderNextToProperty =
                null !== (D = null == t ? void 0 : t.renderNextTo) &&
                void 0 !== D
                  ? D
                  : this.renderNextToProperty),
              (null == t ? void 0 : t.effect) &&
                ("getNativeEffect" in t.effect ||
                  (t.effect = (0, i.createType)(
                    p.EBaseType.ShaderEffect,
                    t.effect.type,
                    e,
                    t.effect.options
                  ))),
              (this.effectProperty = null == t ? void 0 : t.effect),
              (null == t ? void 0 : t.paletteProvider) &&
                ("onAttached" in t.paletteProvider ||
                  (t.paletteProvider.type === m.EPaletteProviderType.Custom
                    ? (t.paletteProvider = (0, i.createType)(
                        p.EBaseType.PaletteProvider,
                        t.paletteProvider.customType,
                        e,
                        t.paletteProvider.options
                      ))
                    : (t.paletteProvider = (0, i.createType)(
                        p.EBaseType.PaletteProvider,
                        t.paletteProvider.type,
                        e,
                        t.paletteProvider.options
                      )))),
              (this.paletteProviderProperty =
                null !== (w = null == t ? void 0 : t.paletteProvider) &&
                void 0 !== w
                  ? w
                  : this.paletteProviderProperty),
              (this.drawNaNAsProperty =
                null !== (M = null == t ? void 0 : t.drawNaNAs) && void 0 !== M
                  ? M
                  : this.drawNaNAsProperty),
              (this.hitTestProvider = this.newHitTestProvider()),
              (this.isSelected =
                null !== (L = null == t ? void 0 : t.isSelected) &&
                void 0 !== L &&
                L),
              (this.isHovered =
                null !== (O = null == t ? void 0 : t.isHovered) &&
                void 0 !== O &&
                O),
              (this.clipToYRangeProperty =
                null !== (I = null == t ? void 0 : t.clipToYRange) &&
                void 0 !== I
                  ? I
                  : this.clipToYRangeProperty),
              (this.yRangeModeProperty =
                null !== (k = null == t ? void 0 : t.yRangeMode) && void 0 !== k
                  ? k
                  : this.yRangeModeProperty),
              (this.yArrayFilterProperty =
                null !== (V = null == t ? void 0 : t.yArrayFilter) &&
                void 0 !== V
                  ? V
                  : this.yArrayFilterProperty),
              (this.seriesNameProperty =
                null !== (F = null == t ? void 0 : t.seriesName) && void 0 !== F
                  ? F
                  : this.seriesNameProperty),
              null == t ? void 0 : t.onIsVisibleChanged)
            )
              if ("string" == typeof t.onIsVisibleChanged) {
                this.typeMap.set("onIsVisibleChanged", t.onIsVisibleChanged);
                const e = (0, i.getFunction)(
                  p.EBaseType.OptionFunction,
                  t.onIsVisibleChanged
                );
                this.isVisibleChanged.subscribe((t) =>
                  e(t.sourceSeries, t.isVisible)
                );
              } else {
                const e = null == t ? void 0 : t.onIsVisibleChanged;
                this.isVisibleChanged.subscribe((t) =>
                  e(t.sourceSeries, t.isVisible)
                );
              }
            if (null == t ? void 0 : t.onSelectedChanged)
              if ("string" == typeof t.onSelectedChanged) {
                this.typeMap.set("onSelectedChanged", t.onSelectedChanged);
                const e = (0, i.getFunction)(
                  p.EBaseType.OptionFunction,
                  t.onSelectedChanged
                );
                this.selected.subscribe((t) => e(t.sourceSeries, t.isSelected));
              } else {
                const e = null == t ? void 0 : t.onSelectedChanged;
                this.selected.subscribe((t) => e(t.sourceSeries, t.isSelected));
              }
            if (null == t ? void 0 : t.onHoveredChanged)
              if ("string" == typeof t.onHoveredChanged) {
                this.typeMap.set("onHoveredChanged", t.onHoveredChanged);
                const e = (0, i.getFunction)(
                  p.EBaseType.OptionFunction,
                  t.onHoveredChanged
                );
                this.hovered.subscribe((t) => e(t.sourceSeries, t.hovered));
              } else {
                const e = null == t ? void 0 : t.onHoveredChanged;
                this.hovered.subscribe((t) => e(t.sourceSeries, t.hovered));
              }
            (null == t ? void 0 : t.animation) &&
              ("toJSON" in t.animation ||
                (t.animation.type === c.EAnimationType.Custom
                  ? (t.animation = (0, i.createType)(
                      p.EBaseType.Animation,
                      t.animation.customType,
                      e,
                      t.animation.options
                    ))
                  : (t.animation = (0, i.createType)(
                      p.EBaseType.Animation,
                      t.animation.type,
                      e,
                      t.animation.options
                    )))),
              (this.onDpiChanged = this.onDpiChanged.bind(this)),
              (this.resamplerHelper = new N.ExtremeResamplerHelper(e)),
              (null == t ? void 0 : t.dataLabelProvider) &&
                ("draw" in t.dataLabelProvider ||
                  (t.dataLabelProvider.type === y.EDataLabelProviderType.Custom
                    ? (t.dataLabelProvider = (0, i.createType)(
                        p.EBaseType.DataLabelProvider,
                        t.dataLabelProvider.customType,
                        e,
                        t.dataLabelProvider.options
                      ))
                    : (t.dataLabelProvider = (0, i.createType)(
                        p.EBaseType.DataLabelProvider,
                        t.dataLabelProvider.type,
                        e,
                        t.dataLabelProvider.options
                      )))),
              (this.dataLabelProviderProperty =
                null == t ? void 0 : t.dataLabelProvider),
              this.dataLabelProviderProperty &&
                this.dataLabelProviderProperty.onAttach(e, this),
              this.addDrawingProviders(e, t);
          }
          applyTheme(e) {
            const t = this.parentSurface.previousThemeProvider;
            this.rolloverModifierProps.tooltipTextColor ===
              t.textAnnotationForeground &&
              (this.rolloverModifierProps.tooltipTextColor =
                e.textAnnotationForeground),
              this.rolloverModifierProps.tooltipColor ===
                t.textAnnotationBackground &&
                (this.rolloverModifierProps.tooltipColor =
                  e.textAnnotationBackground),
              this.rolloverModifierProps.markerColor ===
                t.textAnnotationBackground &&
                (this.rolloverModifierProps.markerColor =
                  e.textAnnotationBackground);
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          set parentSurface(e) {
            (this.parentSurfaceProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.PARENT_SURFACE);
          }
          get drawingProviders() {
            return this.drawingProvidersProperty;
          }
          set drawingProviders(e) {
            (this.drawingProvidersProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.DRAWING_PROVIDERS);
          }
          get isSelected() {
            return this.isSelectedProperty;
          }
          set isSelected(e) {
            var t;
            this.valueChanged(this.isSelectedProperty, e) &&
              ((this.isSelectedProperty = e),
              null === (t = this.selected) ||
                void 0 === t ||
                t.raiseEvent(new Z.SeriesSelectedArgs(this, e)),
              this.notifyPropertyChanged(W.PROPERTY.IS_SELECTED));
          }
          get isHovered() {
            return this.isHoveredProperty;
          }
          set isHovered(e) {
            var t;
            this.valueChanged(this.isHoveredProperty, e) &&
              ((this.isHoveredProperty = e),
              null === (t = this.hovered) ||
                void 0 === t ||
                t.raiseEvent(new $.SeriesHoveredArgs(this, e)),
              this.notifyPropertyChanged(W.PROPERTY.HOVERED));
          }
          get paletteProvider() {
            return this.paletteProviderProperty;
          }
          set paletteProvider(e) {
            this.setPaletteProvider(e);
          }
          get isDigitalLine() {
            return this.isDigitalLineProperty;
          }
          set isDigitalLine(e) {
            (this.isDigitalLineProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.IS_DIGITAL_LINE);
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            var t;
            this.valueChanged(this.isVisibleProperty, e) &&
              ((this.isVisibleProperty = e),
              e
                ? (this.resamplingParams = void 0)
                : (this.rolloverModifierProps.marker &&
                    this.rolloverModifierProps.tooltip &&
                    (this.rolloverModifierProps.marker.suspendInvalidate(),
                    this.rolloverModifierProps.tooltip.suspendInvalidate(),
                    (this.rolloverModifierProps.marker.isHidden = !0),
                    (this.rolloverModifierProps.tooltip.isHidden = !0),
                    (this.rolloverModifierProps.tooltip.x1 = void 0),
                    (this.rolloverModifierProps.tooltip.y1 = void 0)),
                  this.type === P.ESeriesType.BandSeries &&
                    this.rolloverModifierProps1.marker &&
                    this.rolloverModifierProps1.tooltip &&
                    (this.rolloverModifierProps1.marker.suspendInvalidate(),
                    this.rolloverModifierProps1.tooltip.suspendInvalidate(),
                    (this.rolloverModifierProps1.marker.isHidden = !0),
                    (this.rolloverModifierProps1.tooltip.isHidden = !0),
                    (this.rolloverModifierProps1.tooltip.x1 = void 0),
                    (this.rolloverModifierProps1.tooltip.y1 = void 0))),
              null === (t = this.isVisibleChanged) ||
                void 0 === t ||
                t.raiseEvent(new q.SeriesVisibleChangedArgs(this, e)),
              this.notifyPropertyChanged(W.PROPERTY.IS_VISIBLE));
          }
          get pointMarker() {
            return this.pointMarkerProperty;
          }
          set pointMarker(e) {
            this.pointMarkerProperty &&
              (this.pointMarkerProperty.invalidateParentCallback = void 0),
              (this.pointMarkerProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.POINT_MARKER),
              this.pointMarkerProperty &&
                (this.pointMarkerProperty.invalidateParentCallback =
                  this.invalidateParent);
          }
          get drawNaNAs() {
            return this.drawNaNAsProperty;
          }
          set drawNaNAs(e) {
            (this.drawNaNAsProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.DRAW_NAN_AS);
          }
          get stroke() {
            return (0, Y.stripAutoColor)(this.strokeProperty);
          }
          set stroke(e) {
            this.strokeProperty !== e &&
              ((this.strokeProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.STROKE));
          }
          get strokeThickness() {
            return this.strokeThicknessProperty;
          }
          set strokeThickness(e) {
            this.strokeThicknessProperty !== e &&
              ((this.strokeThicknessProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.STROKE_THICKNESS));
          }
          get opacity() {
            return this.opacityProperty;
          }
          set opacity(e) {
            this.opacityProperty !== e &&
              ((this.opacityProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.OPACITY));
          }
          get xAxisId() {
            return this.xAxisIdProperty;
          }
          set xAxisId(e) {
            e !== this.xAxisIdProperty &&
              ((this.xAxisIdProperty = e),
              (this.xAxisProperty = void 0),
              this.notifyPropertyChanged(W.PROPERTY.XAXIS_ID));
          }
          get xAxis() {
            return this.xAxisProperty;
          }
          get yAxis() {
            return this.yAxisProperty;
          }
          get yAxisId() {
            return this.yAxisIdProperty;
          }
          set yAxisId(e) {
            e !== this.yAxisIdProperty &&
              ((this.yAxisIdProperty = e),
              (this.yAxisProperty = void 0),
              this.notifyPropertyChanged(W.PROPERTY.YAXIS_ID));
          }
          get dataSeries() {
            return this.dataSeriesProperty;
          }
          set dataSeries(e) {
            var t, r;
            if (this.dataSeriesProperty) {
              const e = this.xAxis;
              e && e.isCategoryAxis && e.clearCoordCalcCache();
            }
            null === (t = this.dataSeriesProperty) ||
              void 0 === t ||
              t.dataChanged.unsubscribe(this.dataSeriesDataChanged),
              (this.dataSeriesProperty = e),
              null === (r = this.dataSeriesProperty) ||
                void 0 === r ||
                r.dataChanged.subscribe(this.dataSeriesDataChanged),
              this.notifyPropertyChanged(W.PROPERTY.DATA_SERIES);
          }
          get enableDrawingOptimisations() {
            return this.resamplingModeProperty !== B.EResamplingMode.None;
          }
          get effect() {
            return this.effectProperty;
          }
          set effect(e) {
            var t, r;
            null === (t = this.effectProperty) ||
              void 0 === t ||
              t.propertyChanged.unsubscribe(this.effectPropertyChanged),
              (this.effectProperty = e),
              null === (r = this.effectProperty) ||
                void 0 === r ||
                r.propertyChanged.subscribe(this.effectPropertyChanged),
              this.notifyPropertyChanged(W.PROPERTY.EFFECT);
          }
          get resamplingMode() {
            return this.resamplingModeProperty;
          }
          set resamplingMode(e) {
            (this.resamplingModeProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.RESAMPLING_MODE);
          }
          get resamplingPrecision() {
            return this.resamplingPrecisionProperty;
          }
          set resamplingPrecision(e) {
            (this.resamplingPrecisionProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.RESAMPLING_PRECISION);
          }
          get clipToYRange() {
            return this.clipToYRangeProperty;
          }
          set clipToYRange(e) {
            this.clipToYRangeProperty !== e &&
              ((this.clipToYRangeProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.CLIPTOYRANGE));
          }
          get yRangeMode() {
            return this.yRangeModeProperty;
          }
          set yRangeMode(e) {
            this.yRangeModeProperty !== e &&
              ((this.yRangeModeProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.YRANGEMODE));
          }
          get yArrayFilter() {
            return this.yArrayFilterProperty;
          }
          set yArrayFilter(e) {
            this.yArrayFilterProperty !== e &&
              ((this.yArrayFilterProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.YARRAYFILTER));
          }
          get seriesName() {
            var e;
            return null !== (e = this.seriesNameProperty) && void 0 !== e
              ? e
              : this.getDataSeriesName();
          }
          set seriesName(e) {
            this.seriesNameProperty !== e &&
              ((this.seriesNameProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.SERIES_NAME));
          }
          getSurfaceRenderOrder() {
            var e, t;
            return null !== (e = this.surfaceRenderOrderProperty) &&
              void 0 !== e
              ? e
              : null === (t = this.parentSurface) || void 0 === t
              ? void 0
              : t.getSurfaceRenderOrder();
          }
          setSurfaceRenderOrder(e) {
            this.surfaceRenderOrderProperty != e &&
              ((this.surfaceRenderOrderProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.SURFACE_RENDER_ORDER));
          }
          getRenderLayer() {
            if (
              this.renderLayerProperty === v.EDefaultRenderLayer.SeriesLayer
            ) {
              if (this.isSelected)
                return v.EDefaultRenderLayer.SelectedSeriesLayer;
              if (this.isHovered)
                return v.EDefaultRenderLayer.HoveredSeriesLayer;
            }
            return this.renderLayerProperty;
          }
          setRenderLayer(e) {
            this.renderLayerProperty != e &&
              ((this.renderLayerProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.RENDER_LAYER));
          }
          getRenderOrder() {
            return this.renderOrderProperty;
          }
          setRenderOrder(e) {
            this.renderOrderProperty != e &&
              ((this.renderOrderProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.RENDER_LAYER));
          }
          setRenderNextTo(e, t) {
            l.Guard.notNull(e, "renderable"),
              (this.renderNextToProperty = { renderable: e, offset: t });
          }
          getRenderNextTo() {
            return this.renderNextToProperty;
          }
          get isSpline() {
            return [
              P.ESeriesType.SplineBandSeries,
              P.ESeriesType.SplineLineSeries,
              P.ESeriesType.SplineMountainSeries,
            ].includes(this.type);
          }
          getResamplingParams() {
            return this.resamplingParams;
          }
          draw(e, t) {
            var r, i, o, a, s;
            const n = A.PerformanceDebugHelper.mark(
              A.EPerformanceMarkType.DrawSingleSeriesStart,
              {
                contextId: this.id,
                parentContextId:
                  null === (r = this.parentSurface) || void 0 === r
                    ? void 0
                    : r.id,
                level: A.EPerformanceDebugLevel.Verbose,
              }
            );
            if (
              ((this.currentRenderPassData = t),
              null === (i = this.hitTestProvider) ||
                void 0 === i ||
                i.update(t),
              this.canDraw)
            ) {
              const r = e.getNativeContext(),
                i =
                  null === (o = this.parentSurface) || void 0 === o
                    ? void 0
                    : o.seriesViewRect;
              try {
                if ((e.pushShaderEffect(this.effect), this.clipToYRange)) {
                  const { offset: e, viewportDimension: o } =
                      t.xCoordinateCalculator,
                    { offset: a, viewportDimension: s } =
                      t.yCoordinateCalculator;
                  if (t.isVerticalChart) {
                    const t = new u.Rect(i.x + a, i.y + e, s, o);
                    r.SetClipRect(t.x, t.y, t.width, t.height);
                  } else {
                    const t = new u.Rect(i.x + e, i.y + a, o, s);
                    r.SetClipRect(t.x, t.y, t.width, t.height);
                  }
                }
                this.drawingProviders.forEach((r) => {
                  if (
                    this.renderDataTransform &&
                    this.renderDataTransform.drawingProviders.includes(r)
                  ) {
                    const i = this.renderDataTransform.runTransform(t);
                    r.draw(e, i);
                  } else r.draw(e, t);
                });
              } finally {
                this.clipToYRange && r.SetClipRect(i.x, i.y, i.width, i.height),
                  e.popShaderEffect();
              }
              this.dataLabelProvider &&
                this.dataLabelProvider.generateDataLabels(e, t);
            }
            (this.resamplingParams = void 0),
              A.PerformanceDebugHelper.mark(
                A.EPerformanceMarkType.DrawSingleSeriesEnd,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (a = this.parentSurface) || void 0 === a
                      ? void 0
                      : a.id,
                  relatedId:
                    null === (s = null == n ? void 0 : n.detail) || void 0 === s
                      ? void 0
                      : s.relatedId,
                  level: A.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          delete() {
            this.drawingProviders.forEach((e) => e.delete()),
              (this.drawingProviders = []),
              (this.dataSeries = (0, s.deleteSafe)(this.dataSeries)),
              (this.effect = (0, s.deleteSafe)(this.effect)),
              (this.pointMarker = (0, s.deleteSafe)(this.pointMarker)),
              (this.resamplerHelper = (0, s.deleteSafe)(this.resamplerHelper)),
              (this.pointSeries = (0, s.deleteSafe)(this.pointSeries)),
              (this.dataLabelProviderProperty = (0, s.deleteSafe)(
                this.dataLabelProvider
              )),
              (this.renderDataTransformProperty = (0, s.deleteSafe)(
                this.renderDataTransform
              ));
          }
          getXRange() {
            return this.dataSeries.getXRange(k.EDataSeriesValueType.Default);
          }
          getYRange(e, t = !1) {
            const r = this.isRunningDataAnimation
              ? k.EDataSeriesValueType.FinalAnimationValues
              : k.EDataSeriesValueType.Default;
            let i = this.getResampledPointSeries(t);
            return this.renderDataTransform &&
              this.renderDataTransform.useForYRange
              ? (this.updateTransformedValues(r),
                (0, E.getWindowedYRange)(
                  this.webAssemblyContext,
                  this.transformedRenderPassData.pointSeries.xValues,
                  this.transformedRenderPassData.pointSeries.yValues,
                  i && t ? new h.NumberRange(0, i.count - 1) : e,
                  !0,
                  t,
                  this.dataSeries.dataDistributionCalculator.isSortedAscending
                ))
              : i
              ? (0, E.getWindowedYRange)(
                  this.webAssemblyContext,
                  i.xValues,
                  i.yValues,
                  t ? new h.NumberRange(0, i.count - 1) : e,
                  !0,
                  t,
                  this.dataSeries.dataDistributionCalculator.isSortedAscending
                )
              : this.dataSeries.getWindowedYRange(e, !0, t, r, this.yRangeMode);
          }
          getResampledPointSeries(e = !1) {
            var t, r;
            let i;
            if (
              (null === (t = this.parentSurface) || void 0 === t
                ? void 0
                : t.renderSurface) &&
              this.supportsResampling
            ) {
              const t = this.getCurrentRenderPassData();
              if (this.resamplingParams)
                this.resamplingParams.resampleRequired &&
                  (i = this.currentRenderPassData.pointSeries);
              else {
                const { width: o, height: a } =
                    this.parentSurface.renderSurface.viewportSize,
                  s =
                    null !== (r = this.parentSurface.seriesViewRect) &&
                    void 0 !== r
                      ? r
                      : u.Rect.create(0, 0, o, a),
                  n = this.xAxis,
                  l = new F.ResamplingParams(s, this, n);
                if (this.needsResampling(l)) {
                  const r = N.ExtremeResamplerHelper.calculateResamplingHash(
                    this,
                    l
                  );
                  (i = Boolean(t && t.resamplingHash === r)
                    ? t.pointSeries
                    : this.toPointSeries(l)),
                    (this.currentRenderPassData = new H.RenderPassData(
                      this.getIndicesRange(this.xAxis.visibleRange, e),
                      this.xAxis.getCurrentCoordinateCalculator,
                      this.yAxis.getCurrentCoordinateCalculator,
                      this.xAxis.isVerticalChart,
                      i,
                      r
                    ));
                }
              }
            }
            return i;
          }
          notifyPropertyChanged(e) {
            this.drawingProviders.forEach((t) => t.onSeriesPropertyChange(e)),
              this.invalidateParent();
          }
          getDataPointWidth(e, r, i) {
            const o = this.dataSeries.getNativeXValues(),
              a = e.viewportDimension,
              s = e.isCategoryCoordinateCalculator;
            if (i === f.EDataPointWidthMode.Range) {
              const t = e.visibleMax - e.visibleMin;
              return (e.viewportDimension / t) * r;
            }
            if (i === f.EDataPointWidthMode.Absolute) return r;
            {
              let i = Math.floor(
                (0, t.getDataPointWidth)(o, e, a, r, s, this.webAssemblyContext)
              );
              return i % 2 != 0 && (i -= 1), i <= 1 && (i = 1), i;
            }
          }
          onDetach() {
            (this.invalidateParentCallback = void 0),
              (this.parentSurface = void 0),
              this.drawingProviders.forEach((e) => e.onDetachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(void 0);
          }
          setParentSurface(e) {
            if (
              e.surfaceType === C.ESurfaceType.SciChartSurfaceType &&
              this.isPolar
            )
              throw new Error(
                `Polar renderable series can not be attached to a 2D SciChartSurface. Please check ${this.constructor.name} to match SciChartSurface.surfaceType`
              );
            if (
              e.surfaceType === C.ESurfaceType.SciChartPolarSurfaceType &&
              !this.isPolar
            )
              throw new Error(
                `Only polar renderable series can be attached to a 2D SciChartPolarSurface. Please check ${this.constructor.name} to match SciChartSurface.surfaceType`
              );
            if (((this.parentSurface = e), this.invalidateParentCallback))
              throw new Error(
                "Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            this.invalidateParentCallback = e.invalidateElement;
          }
          onAttach(e) {
            this.setParentSurface(e),
              this.linkAxes(),
              this.drawingProviders.forEach((e) => e.onAttachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(
                e.invalidateElement
              ),
              (this.resamplingParams = void 0);
          }
          hasStrokePaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideStrokeArgb);
          }
          hasFillPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideFillArgb);
          }
          hasPointMarkerPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overridePointMarkerArgb);
          }
          hasDataSeriesValues() {
            var e;
            return null === (e = this.dataSeries) || void 0 === e
              ? void 0
              : e.hasValues;
          }
          hasDataSeries() {
            return !!this.dataSeries;
          }
          getDataSeriesValuesCount() {
            return this.dataSeries.count();
          }
          getDataSeriesName() {
            var e;
            return null === (e = this.dataSeries) || void 0 === e
              ? void 0
              : e.dataSeriesName;
          }
          getNativeXValues() {
            return this.dataSeries.getNativeXValues();
          }
          getNativeYValues() {
            return this.dataSeries.getNativeYValues();
          }
          checkIsOutOfDataRange(e, t) {
            const r = this.getDataSeriesValuesCount(),
              i =
                this.xAxis.getCurrentCoordinateCalculator()
                  .isCategoryCoordinateCalculator,
              o = i ? 0 : this.getNativeXValues().get(0),
              a = i ? r - 1 : this.getNativeXValues().get(r - 1);
            return e < o || e > a;
          }
          pushPalettedColors(e, t) {
            t.palettedColors.push_back(e);
          }
          getSeriesInfo(e) {
            switch (e.dataSeriesType) {
              case k.EDataSeriesType.Ohlc:
                return new M.OhlcSeriesInfo(this, e);
              case k.EDataSeriesType.Xyy:
                return new O.XyySeriesInfo(this, e);
              case k.EDataSeriesType.Xyz:
                return new I.XyzSeriesInfo(this, e);
              case k.EDataSeriesType.HeatmapUniform:
              case k.EDataSeriesType.HeatmapNonUniform:
                return new D.HeatmapSeriesInfo(this, e);
              case k.EDataSeriesType.Hlc:
                return new w.HlcSeriesInfo(this, e);
              case k.EDataSeriesType.BoxPlot:
                return new R.BoxPlotSeriesInfo(this, e);
              default:
                return new L.XySeriesInfo(this, e);
            }
          }
          onDpiChanged(e) {
            var t, r;
            null === (t = this.drawingProviders) ||
              void 0 === t ||
              t.forEach((t) => {
                t.onDpiChanged(e);
              }),
              null === (r = this.pointMarker) ||
                void 0 === r ||
                r.onDpiChanged(e);
          }
          toJSON(e = !1) {
            var t, r, i, o, a, s;
            let n;
            if (this.paletteProvider) {
              if (!("toJSON" in this.paletteProvider))
                throw new Error(
                  "Series contains a palletProvider.  This must implement toJSON to be correctly serialized"
                );
              n = this.paletteProvider.toJSON();
            }
            const l = this.getRenderNextTo(),
              d = l && {
                renderable:
                  "string" == typeof l.renderable
                    ? l.renderable
                    : l.renderable.id,
                offset: l.offset,
              },
              h = {
                id: this.id,
                drawNaNAs: this.drawNaNAs,
                effect:
                  null === (t = this.effect) || void 0 === t
                    ? void 0
                    : t.toJSON(),
                isDigitalLine: this.isDigitalLine,
                isHovered: this.isHovered,
                isSelected: this.isSelected,
                isVisible: this.isVisible,
                opacity: this.opacity,
                paletteProvider: n,
                pointMarker:
                  null === (r = this.pointMarker) || void 0 === r
                    ? void 0
                    : r.toJSON(),
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
                animation:
                  this.animationQueue.length > 0
                    ? this.animationQueue[0].toJSON()
                    : void 0,
                resamplingMode: this.resamplingMode,
                resamplingPrecision: this.resamplingPrecision,
                clipToYRange: this.clipToYRange,
                yRangeMode: this.yRangeMode,
                surfaceRenderOrder: this.surfaceRenderOrderProperty,
                renderLayer: this.getRenderLayer(),
                renderOrder: this.getRenderOrder(),
                renderNextTo: d,
                onIsVisibleChanged: this.typeMap.get("onIsVisibleChanged"),
                onSelectedChanged: this.typeMap.get("onSelectedChanged"),
                onHoveredChanged: this.typeMap.get("onHoveredChanged"),
                dataLabelProvider:
                  null === (i = this.dataLabelProvider) || void 0 === i
                    ? void 0
                    : i.toJSON(),
              },
              u =
                null === (o = this.dataSeries) || void 0 === o
                  ? void 0
                  : o.toJSON(e),
              c = null == u ? void 0 : u.options;
            if (
              this.type === P.ESeriesType.ColumnSeries ||
              this.type === P.ESeriesType.ImpulseSeries ||
              this.type === P.ESeriesType.LineSeries ||
              this.type === P.ESeriesType.PolarLineSeries ||
              this.type === P.ESeriesType.TriangleSeries ||
              this.type === P.ESeriesType.MountainSeries ||
              this.type === P.ESeriesType.PolarMountainSeries ||
              this.type === P.ESeriesType.ScatterSeries ||
              this.type === P.ESeriesType.PolarScatterSeries ||
              this.type === P.ESeriesType.SplineLineSeries ||
              this.type === P.ESeriesType.SplineMountainSeries ||
              this.type === P.ESeriesType.SmoothStackedMountainSeries ||
              this.type === P.ESeriesType.StackedColumnSeries ||
              this.type === P.ESeriesType.PolarStackedColumnSeries ||
              this.type === P.ESeriesType.StackedMountainSeries ||
              this.type === P.ESeriesType.PolarStackedMountainSeries
            )
              return { type: this.type, options: h, xyData: c };
            if (this.type === P.ESeriesType.LineSegmentSeries)
              return (null === (a = this.dataSeries) || void 0 === a
                ? void 0
                : a.type) === k.EDataSeriesType.Xyxy
                ? { type: this.type, options: h, xyxyData: c }
                : { type: this.type, options: h, xyData: c };
            if (this.type === P.ESeriesType.PolarColumnSeries) {
              const e = this.columnXMode;
              return e === g.EColumnMode.MidWidth ||
                e === g.EColumnMode.StartWidth ||
                e === g.EColumnMode.StartEnd
                ? { type: this.type, options: h, xyxData: c }
                : { type: this.type, options: h, xyData: c };
            }
            return this.type === P.ESeriesType.BandSeries ||
              this.type === P.ESeriesType.SplineBandSeries ||
              this.type === P.ESeriesType.PolarBandSeries
              ? { type: this.type, options: h, xyyData: c }
              : this.type === P.ESeriesType.BubbleSeries
              ? { type: this.type, options: h, xyzData: c }
              : this.type === P.ESeriesType.CandlestickSeries ||
                this.type === P.ESeriesType.OhlcSeries
              ? { type: this.type, options: h, ohlcData: c }
              : this.type === P.ESeriesType.ErrorBarsSeries
              ? { type: this.type, options: h, hlcData: c }
              : this.type === P.ESeriesType.TextSeries
              ? { type: this.type, options: h, xyTextData: c }
              : this.type === P.ESeriesType.UniformHeatmapSeries ||
                this.type === P.ESeriesType.UniformContoursSeries ||
                this.type === P.ESeriesType.PolarUniformHeatmapSeries ||
                this.type === P.ESeriesType.NonUniformHeatmapSeries
              ? { type: this.type, options: h, heatmapData: c }
              : this.type === P.ESeriesType.RectangleSeries
              ? (null === (s = this.dataSeries) || void 0 === s
                  ? void 0
                  : s.type) === k.EDataSeriesType.Xyxy
                ? { type: this.type, options: h, xyxyData: c }
                : { type: this.type, options: h, xynData: c }
              : this.type === P.ESeriesType.BoxPlotSeries
              ? { type: this.type, options: h, boxPlotData: c }
              : { type: this.type, options: h };
          }
          enqueueAnimation(e) {
            this.animationQueue.push(e), this.invalidateParent();
          }
          runAnimation(e) {
            var t;
            (this.animationQueue = []),
              null === (t = this.animationFSM) ||
                void 0 === t ||
                t.toCompleted(),
              this.enqueueAnimation(e);
          }
          set animation(e) {
            e && this.animationQueue.push(e), this.invalidateParent();
          }
          get isRunningAnimation() {
            return G.animationHelpers.checkIsAnimationRunning(
              this.animationQueue,
              this.animationFSM
            );
          }
          get isRunningDataAnimation() {
            return (
              this.isRunningAnimation &&
              this.animationFSM &&
              (this.animationFSM.animation.isDataSeriesAnimation ||
                this.animationFSM.animation.isOnStartAnimation)
            );
          }
          onAnimate(e) {
            var t;
            if (
              !this.animationFSM ||
              (null === (t = this.animationFSM) || void 0 === t
                ? void 0
                : t.is([o.EAnimationState.Completed]))
            )
              if (this.animationQueue.length >= 1) {
                const e = this.animationQueue.shift();
                this.animationFSM = new o.SeriesAnimationFiniteStateMachine(
                  e,
                  this
                );
              } else this.animationFSM = void 0;
            this.animationFSM &&
              (this.dataSeries.xInitialAnimationValues ||
                this.dataSeries.createAnimationVectors(),
              G.animationHelpers.animationUpdate(
                this.animationFSM,
                e,
                this.beforeAnimationStart,
                this.afterAnimationComplete,
                this.updateAnimationProperties
              ));
          }
          toPointSeries(e) {
            return e
              ? ((this.pointSeries = this.dataSeries.toPointSeries(
                  e,
                  this.pointSeries,
                  this.resamplerHelper
                )),
                this.pointSeries.type === k.EDataSeriesType.XyN &&
                void 0 !== this.yArrayFilter
                  ? "number" == typeof this.yArrayFilter
                    ? this.pointSeries.subSeries[this.yArrayFilter]
                    : this.pointSeries.getSubSeriesByName(this.yArrayFilter)
                  : this.pointSeries)
              : this.dataSeries.toPointSeries();
          }
          getIndicesRange(e, t = !1) {
            var r;
            return null === (r = this.dataSeries) || void 0 === r
              ? void 0
              : r.getIndicesRange(e, t);
          }
          getCurrentRenderPassData() {
            return this.currentRenderPassData;
          }
          setCurrentRenderPassData(e) {
            var t;
            (this.currentRenderPassData = e),
              null === (t = this.hitTestProvider) ||
                void 0 === t ||
                t.update(e);
          }
          get supportsResampling() {
            return (
              ![
                P.ESeriesType.UniformContoursSeries,
                P.ESeriesType.UniformHeatmapSeries,
                P.ESeriesType.PolarUniformHeatmapSeries,
                P.ESeriesType.NonUniformHeatmapSeries,
                P.ESeriesType.BubbleSeries,
                P.ESeriesType.ErrorBarsSeries,
                P.ESeriesType.LineSegmentSeries,
              ].includes(this.type) &&
              !z.SciChartDefaults.debugDisableResampling &&
              !this.isStacked &&
              this.dataSeries &&
              this.dataSeries.count() > 0 &&
              (this.enableDrawingOptimisations ||
                this.dataSeries.fifoCapacity) &&
              (this.dataSeries.dataDistributionCalculator.isSortedAscending ||
                this.xAxis.isCategoryAxis)
            );
          }
          needsResampling(e) {
            return (
              (this.resamplingParams = e),
              (this.resamplingParams.resampleRequired =
                this.resamplerHelper.needsResampling(
                  e,
                  this.getNativeXValues()
                )),
              this.resamplingParams.resampleRequired
            );
          }
          get dataLabelProvider() {
            return this.dataLabelProviderProperty;
          }
          set dataLabelProvider(e) {
            (this.dataLabelProviderProperty = e),
              e.onAttach(this.webAssemblyContext, this),
              this.notifyPropertyChanged(W.PROPERTY.SERIES_TEXT_PROVIDER);
          }
          get renderDataTransform() {
            return this.renderDataTransformProperty;
          }
          set renderDataTransform(e) {
            if (e.parentSeries !== this)
              throw new Error(
                "renderDataTransform can only be added to the series it was created with"
              );
            (this.renderDataTransformProperty = e),
              this.notifyPropertyChanged(W.PROPERTY.SERIES_TEXT_PROVIDER);
          }
          resolveAutoColors(e, t, r) {
            if (
              this.strokeProperty &&
              this.strokeProperty.startsWith(Y.AUTO_COLOR)
            ) {
              const r = this.parentSurface.themeProvider.getStrokeColor(
                e,
                t,
                this.webAssemblyContext
              );
              this.stroke = Y.AUTO_COLOR + this.adjustAutoColor("stroke", r);
            }
            this.pointMarker && this.pointMarker.resolveAutoColors(e, t, r),
              this.dataLabelProvider &&
                this.dataLabelProvider.resolveAutoColors(e, t, r);
          }
          adjustAutoColor(e, t) {
            return t;
          }
          linkAxes() {
            if (((0, d.updateAxisIds)(this), this.parentSurface)) {
              if (!this.xAxisProperty && this.xAxisId) {
                const e = this.parentSurface.getXAxisById(this.xAxisId);
                e
                  ? (this.xAxisProperty = e)
                  : (console.warn(
                      `RenderableSeries looked for xAxis Id "${this.xAxisId}" but did not find. Default xAxis will be used`
                    ),
                    (this.xAxisProperty =
                      this.parentSurface.getDefaultXAxis()));
              }
              if (!this.yAxisProperty && this.yAxisId) {
                const e = this.parentSurface.getYAxisById(this.yAxisId);
                e
                  ? (this.yAxisProperty = e)
                  : (console.warn(
                      `RenderableSeries looked for yAxis Id "${this.yAxisId}" but did not find. Default yAxis will be used`
                    ),
                    (this.yAxisProperty =
                      this.parentSurface.getDefaultYAxis()));
              }
            }
          }
          addDrawingProviders(e, t) {}
          updateTransformedValues(e) {
            var t;
            if (
              !this.dataSeries ||
              !this.parentSurface ||
              !this.renderDataTransform
            )
              return;
            let r;
            if (
              this.currentRenderPassData &&
              (null != e ? e : k.EDataSeriesValueType.Default) ===
                k.EDataSeriesValueType.Default
            )
              r = this.currentRenderPassData;
            else {
              const i = (
                null === (t = this.resamplingParams) || void 0 === t
                  ? void 0
                  : t.resampleRequired
              )
                ? this.pointSeries
                : new V.XyPointSeriesWrapped(this.dataSeries, void 0, e);
              r = new H.RenderPassData(
                this.getIndicesRange(
                  this.xAxis.visibleRange,
                  this.xAxis.isCategoryAxis
                ),
                this.xAxis.getCurrentCoordinateCalculator,
                this.yAxis.getCurrentCoordinateCalculator,
                this.xAxis.isVerticalChart,
                i
              );
            }
            this.transformedRenderPassData =
              this.renderDataTransform.runTransform(r);
          }
          setAnimationVectors(e) {
            const t = this.dataSeries;
            e.isOnStartAnimation
              ? t.setFinalAnimationVectors(t)
              : e.isDataSeriesAnimation &&
                (t.setInitialAnimationVectors(t),
                t.setFinalAnimationVectors(e.dataSeries),
                t.validateAnimationVectors());
          }
          beforeAnimationStart() {
            var e;
            const { animation: t } = this.animationFSM;
            this.setAnimationVectors(t);
            const r =
              null === (e = null == t ? void 0 : t.styles) || void 0 === e
                ? void 0
                : e.pointMarker;
            r &&
              (this.pointMarker = G.animationHelpers.createPointMarker(
                this.webAssemblyContext,
                r
              ));
          }
          afterAnimationComplete() {
            if (this.dataSeries) {
              const e = this.dataSeries;
              e.setInitialAnimationVectors(void 0),
                e.setFinalAnimationVectors(void 0);
            }
          }
          updateAnimationProperties(e, t) {
            const { animation: r } = t;
            r.updateSeriesProperties(
              this,
              t.initialStyles,
              t.animationProgress
            );
            const i = this.dataSeries;
            i &&
              (i.updateAnimationProperties(e, r),
              (this.currentRenderPassData = void 0)),
              this.renderDataTransform &&
                (this.renderDataTransform.requiresTransform = !0),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          dataSeriesDataChanged(e) {
            this.renderDataTransform &&
              this.renderDataTransform.onDataChange(e),
              this.invalidateParent();
          }
          valueChanged(e, t) {
            return e !== t;
          }
          setPaletteProvider(e) {
            var t, r;
            (null === (t = this.paletteProviderProperty) || void 0 === t
              ? void 0
              : t.onDetached) && this.paletteProviderProperty.onDetached(),
              (this.paletteProviderProperty = e),
              (null === (r = this.paletteProviderProperty) || void 0 === r
                ? void 0
                : r.onAttached) &&
                this.paletteProviderProperty.onAttached(this),
              this.notifyPropertyChanged(W.PROPERTY.PALETTE_PROVIDER);
          }
          invalidateParent() {
            this.invalidateParentCallback && this.invalidateParentCallback();
          }
          effectPropertyChanged() {
            this.invalidateParent();
          }
          get canDraw() {
            return G.animationHelpers.checkCanDraw(this.animationFSM);
          }
        }
        (t.BaseRenderableSeries = K),
          (t.getDataPointWidth = (e, t, r, i, o, a) => {
            if (i < 0 || i > 1)
              throw new Error(
                "WidthFraction should be between 0.0 and 1.0 inclusive"
              );
            const n = e.size();
            let l = r;
            const d = n;
            if (d > 1) {
              let r = Number.NEGATIVE_INFINITY,
                i = Number.MAX_VALUE;
              if (o) (r = t.getCoordinate(n - 1)), (i = t.getCoordinate(0));
              else {
                let o;
                try {
                  (o = a.NumberUtil.MinMax(e)), (i = o.minD), (r = o.maxD);
                } finally {
                  (0, s.deleteSafe)(o);
                }
                (r = t.getCoordinate(r)), (i = t.getCoordinate(i));
              }
              l = Math.abs(r - i) / (d - 1);
            }
            return l * i;
          }),
          (t.getDelta = ({ pointSize: e, areaSize: t, range: r }) => {
            if (0 === t) return 0;
            const i = t / (t - e * X.DpiHelper.PIXEL_RATIO);
            return (Math.abs(r.diff) * (i - 1)) / 2;
          }),
          (t.adjustRangeByStrokeThickness = (e, r, i = 0) => {
            const o =
              i && (0, t.getDelta)({ pointSize: r, areaSize: i, range: e });
            return new h.NumberRange(e.min - o, e.max + o);
          }),
          (t.getDataPointWidthAdjustment = (e, t, r, i, o) => {
            let a = t / 2;
            return (
              e === f.EDataPointWidthMode.Relative &&
                (a = r > 1 ? ((i.diff / (r - 1)) * t) / 2 : 0),
              e === f.EDataPointWidthMode.Absolute &&
                (a = o.getDataWidth(t) / 2),
              a
            );
          });
      },
      35246: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseStackedCollection = void 0);
        const i = r(82229),
          o = (r(55023), r(56744)),
          a = r(23866),
          s = r(16819),
          n = r(98140),
          l = r(37796),
          d = r(3777),
          h = r(26361),
          u = r(9073),
          c = r(73538),
          p = (r(27307), r(24933)),
          g = r(54580),
          y = r(20977);
        class f extends l.ObservableArray {
          constructor(e, t) {
            var r, i, o, a, s, n, l, h, p;
            super(),
              (this.id = (0, c.generateGuid)()),
              (this.isStacked = !0),
              (this.isPolar = !1),
              (this.supportsResampling = !1),
              (this.isSpline = !1),
              (this.enableDrawingOptimisations = !0),
              (this.isAccumulatedVectorDirty = !0),
              (this.firstAnimationRender = !1),
              (this.isVisibleProperty = !0),
              (this.isOneHundredPercentProperty = !1),
              (this.animationQueue = []),
              (this.yRangeModeProperty = u.EYRangeMode.Drawn),
              (this.seriesNameProperty = void 0),
              (this.surfaceRenderOrderProperty = void 0),
              (this.renderLayerProperty = d.EDefaultRenderLayer.SeriesLayer),
              (this.renderOrderProperty = void 0),
              (this.webAssemblyContext = e),
              (this.isVisibleProperty =
                null !== (r = null == t ? void 0 : t.isVisible) && void 0 !== r
                  ? r
                  : this.isVisibleProperty),
              (this.xAxisIdProperty =
                null !== (i = null == t ? void 0 : t.xAxisId) && void 0 !== i
                  ? i
                  : this.xAxisIdProperty),
              (this.yAxisIdProperty =
                null !== (o = null == t ? void 0 : t.yAxisId) && void 0 !== o
                  ? o
                  : this.yAxisIdProperty),
              (this.isOneHundredPercentProperty =
                null !== (a = null == t ? void 0 : t.isOneHundredPercent) &&
                void 0 !== a
                  ? a
                  : this.isOneHundredPercentProperty),
              (this.yRangeModeProperty =
                null !== (s = null == t ? void 0 : t.yRangeMode) && void 0 !== s
                  ? s
                  : this.yRangeModeProperty),
              (this.updateAnimationProperties =
                this.updateAnimationProperties.bind(this)),
              (this.notifyPropertyChanged =
                this.notifyPropertyChanged.bind(this)),
              (this.getParentSurface = this.getParentSurface.bind(this)),
              (this.beforeAnimationStart =
                this.beforeAnimationStart.bind(this)),
              (this.afterAnimationComplete =
                this.afterAnimationComplete.bind(this)),
              (this.updateAnimationProperties =
                this.updateAnimationProperties.bind(this)),
              (this.surfaceRenderOrderProperty =
                null !== (n = null == t ? void 0 : t.surfaceRenderOrder) &&
                void 0 !== n
                  ? n
                  : this.surfaceRenderOrderProperty),
              (this.renderLayerProperty =
                null !== (l = null == t ? void 0 : t.renderLayer) &&
                void 0 !== l
                  ? l
                  : this.renderLayerProperty),
              (this.renderOrderProperty =
                null !== (h = null == t ? void 0 : t.renderOrder) &&
                void 0 !== h
                  ? h
                  : this.renderOrderProperty),
              (this.renderNextToProperty =
                null !== (p = null == t ? void 0 : t.renderNextTo) &&
                void 0 !== p
                  ? p
                  : this.renderNextToProperty),
              (this.accumulatedValues0 =
                new this.webAssemblyContext.SCRTDoubleVector()),
              (this.accumulatedFinalAnimationValues0 =
                new this.webAssemblyContext.SCRTDoubleVector());
          }
          get isVisibleChanged() {
            throw new Error(
              "getting visibleChanged event is not supported for BaseStackedCollection"
            );
          }
          get selected() {
            throw new Error(
              "getting selected event is not supported for BaseStackedCollection"
            );
          }
          get hovered() {
            throw new Error(
              "getting hovered event is not supported for BaseStackedCollection"
            );
          }
          get isSelected() {
            return !1;
          }
          set isSelected(e) {
            throw new Error(
              "Setting isSelected is not supported for BaseStackedCollection"
            );
          }
          get isHovered() {
            return !1;
          }
          set isHovered(e) {
            throw new Error(
              "Setting isHovered is not supported for BaseStackedCollection"
            );
          }
          get isDigitalLine() {
            throw new Error(
              "Setting or getting isDigitalLine is not supported for BaseStackedCollection"
            );
          }
          set isDigitalLine(e) {
            throw new Error(
              "Setting or getting isDigitalLine is not supported for BaseStackedCollection"
            );
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            (this.isVisibleProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.IS_VISIBLE);
          }
          get xAxisId() {
            return this.xAxisIdProperty;
          }
          set xAxisId(e) {
            e !== this.xAxisIdProperty &&
              ((this.xAxisIdProperty = e),
              (this.xAxisProperty = void 0),
              this.notifyPropertyChanged(y.PROPERTY.XAXIS_ID));
          }
          get xAxis() {
            return this.xAxisProperty;
          }
          get yAxis() {
            return this.yAxisProperty;
          }
          get yAxisId() {
            return this.yAxisIdProperty;
          }
          set yAxisId(e) {
            e !== this.yAxisIdProperty &&
              ((this.yAxisIdProperty = e),
              (this.yAxisProperty = void 0),
              this.notifyPropertyChanged(y.PROPERTY.YAXIS_ID));
          }
          get seriesName() {
            var e;
            return null !== (e = this.seriesNameProperty) && void 0 !== e
              ? e
              : this.getDataSeriesName();
          }
          set seriesName(e) {
            this.seriesNameProperty !== e &&
              ((this.seriesNameProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.SERIES_NAME));
          }
          get isOneHundredPercent() {
            return this.isOneHundredPercentProperty;
          }
          set isOneHundredPercent(e) {
            (this.isOneHundredPercentProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.IS_ONE_HUNDRED_PERCENT);
          }
          get yRangeMode() {
            return this.yRangeModeProperty;
          }
          set yRangeMode(e) {
            this.yRangeModeProperty !== e &&
              ((this.yRangeModeProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.YRANGEMODE));
          }
          get dataSeries() {
            throw Error(
              "dataSeries property is not supported for BaseStackedCollection"
            );
          }
          set dataSeries(e) {
            throw Error(
              "dataSeries property is not supported for BaseStackedCollection"
            );
          }
          get drawNaNAs() {
            throw Error(
              "drawNaNAs property is not supported for BaseStackedCollection"
            );
          }
          set drawNaNAs(e) {
            throw Error(
              "drawNaNAs property is not supported for BaseStackedCollection"
            );
          }
          get drawingProviders() {
            throw Error(
              "drawingProviders property is not supported for BaseStackedCollection"
            );
          }
          set drawingProviders(e) {
            throw Error(
              "drawingProviders property is not supported for BaseStackedCollection"
            );
          }
          get hitTestProvider() {
            throw Error(
              "hitTestProvider property is not supported for BaseStackedCollection, call hitTestProvider on BaseStackedRenderableSeries instead"
            );
          }
          set hitTestProvider(e) {
            throw Error(
              "hitTestProvider property is not supported for BaseStackedCollection, call hitTestProvider on BaseStackedRenderableSeries instead"
            );
          }
          get paletteProvider() {
            throw Error(
              "paletteProvider property is not supported for BaseStackedCollection"
            );
          }
          set paletteProvider(e) {
            throw Error(
              "paletteProvider property is not supported for BaseStackedCollection"
            );
          }
          get pointMarker() {
            throw Error(
              "pointMarker property is not supported for BaseStackedCollection"
            );
          }
          set pointMarker(e) {
            throw Error(
              "pointMarker property is not supported for BaseStackedCollection"
            );
          }
          get rolloverModifierProps() {
            throw Error(
              "rolloverModifierProps property is not supported for BaseStackedCollection"
            );
          }
          set rolloverModifierProps(e) {
            throw Error(
              "rolloverModifierProps property is not supported for BaseStackedCollection"
            );
          }
          get stroke() {
            throw Error(
              "stroke property is not supported for BaseStackedCollection"
            );
          }
          set stroke(e) {
            throw Error(
              "stroke property is not supported for BaseStackedCollection"
            );
          }
          get strokeThickness() {
            throw Error(
              "strokeThickness property is not supported for BaseStackedCollection"
            );
          }
          set strokeThickness(e) {
            throw Error(
              "strokeThickness property is not supported for BaseStackedCollection"
            );
          }
          get effect() {
            throw Error(
              "effect property is not supported for BaseStackedCollection"
            );
          }
          set effect(e) {
            throw Error(
              "effect property is not supported for BaseStackedCollection"
            );
          }
          get opacity() {
            throw Error(
              "opacity property is not supported for BaseStackedCollection"
            );
          }
          set opacity(e) {
            throw Error(
              "effect property is not supported for BaseStackedCollection"
            );
          }
          set rolloverModifierProps1(e) {
            throw Error(
              "rolloverModifierProps1() method is not supported for BaseStackedCollection"
            );
          }
          get rolloverModifierProps1() {
            throw Error(
              "rolloverModifierProps1() method is not supported for BaseStackedCollection"
            );
          }
          get resamplingMode() {
            throw Error(
              "resamplingMode property is not supported for BaseStackedCollection"
            );
          }
          set resamplingMode(e) {
            throw Error(
              "resamplingMode property is not supported for BaseStackedCollection"
            );
          }
          get resamplingPrecision() {
            throw Error(
              "resamplingPrecision property is not supported for BaseStackedCollection"
            );
          }
          set resamplingPrecision(e) {
            throw Error(
              "resamplingPrecision property is not supported for BaseStackedCollection"
            );
          }
          getSurfaceRenderOrder() {
            var e, t;
            return null !== (e = this.surfaceRenderOrderProperty) &&
              void 0 !== e
              ? e
              : null === (t = this.parentSurface) || void 0 === t
              ? void 0
              : t.getSurfaceRenderOrder();
          }
          setSurfaceRenderOrder(e) {
            this.surfaceRenderOrderProperty != e &&
              ((this.surfaceRenderOrderProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.SURFACE_RENDER_ORDER));
          }
          getRenderLayer() {
            if (
              this.renderLayerProperty === d.EDefaultRenderLayer.SeriesLayer
            ) {
              if (this.isSelected)
                return d.EDefaultRenderLayer.SelectedSeriesLayer;
              if (this.isHovered)
                return d.EDefaultRenderLayer.HoveredSeriesLayer;
            }
            return this.renderLayerProperty;
          }
          setRenderLayer(e) {
            this.renderLayerProperty != e &&
              ((this.renderLayerProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.RENDER_LAYER));
          }
          getRenderOrder() {
            return this.renderOrderProperty;
          }
          setRenderOrder(e) {
            this.renderOrderProperty != e &&
              ((this.renderOrderProperty = e),
              this.notifyPropertyChanged(y.PROPERTY.RENDER_LAYER));
          }
          setRenderNextTo(e, t) {
            a.Guard.notNull(e, "renderable"),
              (this.renderNextToProperty = { renderable: e, offset: t });
          }
          getRenderNextTo() {
            return this.renderNextToProperty;
          }
          setAccumulatedValuesDirty() {
            this.isAccumulatedVectorDirty = !0;
          }
          getIndicesRange(e) {
            throw Error(
              "getIndicesRange() method is not supported for BaseStackedCollection"
            );
          }
          getDataPointWidth(e, t, r) {
            throw Error(
              "getDataPointWidth() method is not supported for BaseStackedCollection"
            );
          }
          get canDraw() {
            return g.animationHelpers.checkCanDraw(this.animationFSM);
          }
          pushPalettedColors(e, t) {
            throw new Error("Method not implemented.");
          }
          getSeriesInfo(e) {
            throw new Error("Method not implemented.");
          }
          applyTheme(e) {
            this.asArray().forEach((t) => {
              t.applyTheme(e);
            });
          }
          delete() {
            (this.accumulatedValues0 = (0, o.deleteSafe)(
              this.accumulatedValues0
            )),
              (this.accumulatedFinalAnimationValues0 = (0, o.deleteSafe)(
                this.accumulatedFinalAnimationValues0
              )),
              (this.dataLabelProviderProperty = (0, o.deleteSafe)(
                this.dataLabelProvider
              )),
              this.asArray().forEach((e) => {
                e.delete();
              });
          }
          notifyPropertyChanged(e) {
            this.invalidateParent();
          }
          onDpiChanged(e) {
            this.asArray().forEach((t) => t.onDpiChanged(e));
          }
          getBaseXValues() {
            return [];
          }
          getDataSeriesName() {
            return "Stacked Collection";
          }
          getDataSeriesValuesCount() {
            if (this.getNativeXValues()) return this.getNativeXValues().size();
          }
          get isRunningDataAnimation() {
            return (
              this.isRunningAnimation &&
              this.animationFSM &&
              (this.animationFSM.animation.isDataSeriesAnimation ||
                this.animationFSM.animation.isOnStartAnimation)
            );
          }
          getNativeXValues() {
            var e;
            if (0 !== this.size())
              return null === (e = this.get(0).dataSeries) || void 0 === e
                ? void 0
                : e.getNativeXValues();
          }
          getYRange(e, t) {
            if (!this.isEnoughDataToDraw()) return new n.NumberRange();
            let r;
            return (
              this.getVisibleSeries().forEach((i) => {
                if (
                  i.accumulatedValues.size() === this.getNativeXValues().size()
                ) {
                  const o = (0, p.getWindowedYRange)(
                    this.webAssemblyContext,
                    this.getNativeXValues(),
                    i.getAccumulatedValues(this.isRunningDataAnimation),
                    e,
                    !0,
                    t,
                    !0,
                    this.yRangeMode === u.EYRangeMode.Visible
                      ? h.ESearchMode.RoundUp
                      : h.ESearchMode.RoundDown,
                    this.yRangeMode === u.EYRangeMode.Visible
                      ? h.ESearchMode.RoundDown
                      : h.ESearchMode.RoundUp
                  );
                  o && (r = r ? r.union(o) : o);
                }
              }),
              r || new n.NumberRange()
            );
          }
          hasDataSeries() {
            return !!this.getNativeXValues();
          }
          hasStrokePaletteProvider() {
            return !1;
          }
          hasFillPaletteProvider() {
            return !1;
          }
          hasPointMarkerPaletteProvider() {
            return !1;
          }
          onAttach(e) {
            if (
              ((this.parentSurface = e),
              this.linkAxes(),
              this.invalidateParentCallback)
            )
              throw new Error(
                "Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            this.invalidateParentCallback = e.invalidateElement;
          }
          onDetach() {
            (this.invalidateParentCallback = void 0),
              (this.parentSurface = void 0);
          }
          getVisibleSeries() {
            return this.asArray().filter((e) => e.isVisible);
          }
          enqueueAnimation(e) {
            this.animationQueue.push(e), this.invalidateParent();
          }
          runAnimation(e) {
            (this.animationQueue = []),
              this.animationFSM.toCompleted(),
              this.afterAnimationComplete();
          }
          set animation(e) {
            e && this.animationQueue.push(e), this.invalidateParent();
          }
          get isRunningAnimation() {
            return (
              !!g.animationHelpers.checkIsAnimationRunning(
                this.animationQueue,
                this.animationFSM
              ) || !!this.getVisibleSeries().some((e) => e.isRunningAnimation)
            );
          }
          onAnimate(e) {
            var t;
            if (
              !this.animationFSM ||
              (null === (t = this.animationFSM) || void 0 === t
                ? void 0
                : t.is([i.EAnimationState.Completed]))
            )
              if (this.animationQueue.length >= 1) {
                const e = this.animationQueue.shift();
                this.animationFSM = new i.SeriesAnimationFiniteStateMachine(
                  e,
                  void 0
                );
              } else this.animationFSM = void 0;
            this.getVisibleSeries().forEach((t) => {
              t.isRunningAnimation && t.onAnimate(e);
            }),
              this.animationFSM &&
                g.animationHelpers.animationUpdate(
                  this.animationFSM,
                  e,
                  this.beforeAnimationStart,
                  this.afterAnimationComplete,
                  this.updateAnimationProperties
                );
          }
          checkIsOutOfDataRange(e, t) {
            throw Error(
              "checkIsOutOfDataRange() method is not supported for BaseStackedCollection"
            );
          }
          toPointSeries(e) {}
          getCurrentRenderPassData() {
            return this.currentRenderPassData;
          }
          setCurrentRenderPassData(e) {
            this.currentRenderPassData = e;
          }
          getResamplingParams() {}
          get dataLabelProvider() {
            return this.dataLabelProviderProperty;
          }
          set dataLabelProvider(e) {
            (this.dataLabelProviderProperty = e),
              e.onAttach(this.webAssemblyContext, this),
              this.notifyPropertyChanged(y.PROPERTY.SERIES_TEXT_PROVIDER);
          }
          toJSON(e = !1) {
            var t;
            const r = [];
            for (const t of this.asArray()) r.push(t.toJSON(e));
            const i = this.getRenderNextTo(),
              o = i && {
                renderable:
                  "string" == typeof i.renderable
                    ? i.renderable
                    : i.renderable.id,
                offset: i.offset,
              },
              a = {
                isVisible: this.isVisible,
                isOneHundredPercent: this.isOneHundredPercent,
                xAxisId: this.xAxisId,
                yAxisId: this.yAxisId,
                yRangeMode: this.yRangeMode,
                dataLabelProvider:
                  null === (t = this.dataLabelProvider) || void 0 === t
                    ? void 0
                    : t.toJSON(),
                surfaceRenderOrder: this.surfaceRenderOrderProperty,
                renderLayer: this.getRenderLayer(),
                renderOrder: this.getRenderOrder(),
                renderNextTo: o,
              };
            return { type: this.type, series: r, options: a };
          }
          resolveAutoColors(e, t, r) {
            for (let i = 0; i < this.size(); i++)
              this.get(i).resolveAutoColors(e + i, t, r);
          }
          adjustAutoColor(e, t) {
            return t;
          }
          linkAxes() {
            if (((0, s.updateAxisIds)(this), this.parentSurface)) {
              if (!this.xAxisProperty && this.xAxisId) {
                const e = this.parentSurface.getXAxisById(this.xAxisId);
                e
                  ? (this.xAxisProperty = e)
                  : (console.warn(
                      `StackedCollection looked for xAxis Id "${this.xAxisId}" but did not find. Default xAxis will be used`
                    ),
                    (this.xAxisProperty =
                      this.parentSurface.getDefaultXAxis()));
              }
              if (!this.yAxisProperty && this.yAxisId) {
                const e = this.parentSurface.getYAxisById(this.yAxisId);
                e
                  ? (this.yAxisProperty = e)
                  : (console.warn(
                      `StackedCollection looked for yAxis Id "${this.yAxisId}" but did not find. Default yAxis will be used`
                    ),
                    (this.yAxisProperty =
                      this.parentSurface.getDefaultYAxis()));
              }
            }
          }
          isAllDataSeriesSet() {
            let e = !0;
            return (
              this.asArray().forEach((t) => {
                t.dataSeries || (e = !1);
              }),
              e
            );
          }
          invalidateParent() {
            this.invalidateParentCallback && this.invalidateParentCallback();
          }
          getFirstSeries() {
            if (0 !== this.size()) return this.get(0);
          }
          getParentSurface() {
            return this.parentSurface;
          }
          beforeAnimationStart() {
            this.updateAccumulatedVectors();
            const e = this.accumulatedValues0.size();
            this.accumulatedFinalAnimationValues0.resize(e, 0);
            for (let t = 0; t < e; t++)
              this.accumulatedFinalAnimationValues0.set(
                t,
                this.accumulatedValues0.get(t)
              );
            this.getVisibleSeries().forEach((e) => {
              e.beforeAnimationStart();
            });
          }
          afterAnimationComplete() {
            this.getVisibleSeries().forEach((e) => {
              e.afterAnimationComplete();
            });
          }
          updateAnimationProperties(e, t) {
            this.isAllDataSeriesSet() &&
              (t.animation.calculateAnimationValues(
                this.webAssemblyContext,
                this.accumulatedFinalAnimationValues0,
                this.accumulatedValues0,
                e
              ),
              this.getVisibleSeries().forEach((r) => {
                r.updateAnimationProperties(e, t);
              })),
              this.invalidateParentCallback && this.invalidateParentCallback();
          }
          updateHitTestProviders(e) {
            this.getVisibleSeries().forEach((t) => {
              var r;
              null === (r = t.hitTestProvider) || void 0 === r || r.update(e);
            });
          }
          isEnoughDataToDraw() {
            const e = this.getVisibleSeries().length;
            if (e < 1) return !1;
            for (let t = 0; t < e; t++) if (!this.get(t).dataSeries) return !1;
            for (let t = 0; t < e; t++)
              if (0 === this.get(t).dataSeries.count()) return !1;
            return !0;
          }
        }
        t.BaseStackedCollection = f;
      },
      73124: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseStackedMountainRenderableSeries = void 0);
        const i = r(16602),
          o = r(88915),
          a = r(84392),
          s = r(14184),
          n = r(48335),
          l = r(20977),
          d = r(7807),
          h = r(94707),
          u = r(99846);
        class c extends n.BaseStackedRenderableSeries {
          constructor(e, t) {
            var r, i, o;
            super(e, t),
              (this.fillProperty = "#7e8486"),
              (this.strokeY1Property = "transparent"),
              (this.strokeDashArrayProperty = []),
              (this.strokeY1DashArrayProperty = []),
              (this.fillProperty =
                null !== (r = null == t ? void 0 : t.fill) && void 0 !== r
                  ? r
                  : this.fillProperty),
              (this.stroke =
                null !== (i = null == t ? void 0 : t.stroke) && void 0 !== i
                  ? i
                  : s.SciChartSurfaceBase.DEFAULT_THEME.mountainLineColor),
              (this.strokeDashArrayProperty =
                null !== (o = null == t ? void 0 : t.strokeDashArray) &&
                void 0 !== o
                  ? o
                  : this.strokeDashArrayProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions);
          }
          onAttachToParentCollection(e, t, r) {
            if (this.parentCollection)
              throw new Error(
                "Invalid operation in StackedMountainRenderableSeries.onAttachToParentCollection, this series has been already attached to collection. Please detach it from the collection before attaching to another"
              );
            (this.parentCollection = e),
              (this.getParentSurfaceFn = t),
              (this.notifyParentPropertyChangedFn = r);
          }
          onAttach(e) {
            if (this.invalidateParentCallback)
              throw new Error(
                "Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            (this.invalidateParentCallback = e.invalidateElement),
              this.drawingProviders.forEach((e) => e.onAttachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(
                e.invalidateElement
              );
          }
          onDetach() {
            (this.invalidateParentCallback = void 0),
              this.drawingProviders.forEach((e) => e.onDetachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(void 0);
          }
          draw(e, t) {
            var r, o, a, s;
            const n = i.PerformanceDebugHelper.mark(
              i.EPerformanceMarkType.DrawSingleSeriesStart,
              {
                contextId: this.id,
                parentContextId:
                  null === (r = this.parentSurface) || void 0 === r
                    ? void 0
                    : r.id,
                level: i.EPerformanceDebugLevel.Verbose,
              }
            );
            (this.currentRenderPassData = t),
              null === (o = this.hitTestProvider) ||
                void 0 === o ||
                o.update(t);
            try {
              e.pushShaderEffect(this.effect),
                this.drawingProviders.forEach((r) => {
                  if (
                    this.renderDataTransform &&
                    this.renderDataTransform.drawingProviders.includes(r)
                  ) {
                    const i = this.renderDataTransform.runTransform(t);
                    r.draw(e, i);
                  } else r.draw(e, t);
                });
            } finally {
              e.popShaderEffect();
            }
            i.PerformanceDebugHelper.mark(
              i.EPerformanceMarkType.DrawSingleSeriesEnd,
              {
                contextId: this.id,
                parentContextId:
                  null === (a = this.parentSurface) || void 0 === a
                    ? void 0
                    : a.id,
                relatedId:
                  null === (s = null == n ? void 0 : n.detail) || void 0 === s
                    ? void 0
                    : s.relatedId,
                level: i.EPerformanceDebugLevel.Verbose,
              }
            );
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(l.PROPERTY.STROKE);
          }
          get fill() {
            return (0, a.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            this.fillProperty !== e &&
              ((this.fillProperty = e),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(l.PROPERTY.FILL)
              ),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(l.PROPERTY.FILL_Y1)
              ),
              this.notifyPropertyChanged(l.PROPERTY.FILL));
          }
          get strokeY1() {
            return this.strokeY1Property;
          }
          set strokeY1(e) {
            this.strokeY1Property !== e &&
              ((this.strokeY1Property = e),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(l.PROPERTY.STROKE_Y1)
              ));
          }
          get fillY1() {
            return (0, a.stripAutoColor)(this.fillProperty);
          }
          set fillY1(e) {
            throw new Error(
              "Setting fillY1 property is not supported on StackedMountainRenderableSeries"
            );
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.STROKE_DASH_ARRAY);
          }
          get strokeY1DashArray() {
            return this.strokeY1DashArrayProperty;
          }
          set strokeY1DashArray(e) {
            (this.strokeY1DashArrayProperty = e),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(l.PROPERTY.STROKE_Y1_DASH_ARRAY)
              );
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          getCurrentRenderPassData() {
            return this.currentRenderPassData;
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
                strokeDashArray: this.strokeDashArray,
                paletteProvider: this.paletteProvider,
              };
            return Object.assign(t.options, r), t;
          }
          toPointSeries(e) {
            return new o.XyPointSeriesWrapped(this.dataSeries);
          }
          hasStrokePaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideStrokeArgb);
          }
          hasFillPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideFillArgb);
          }
          hasPointMarkerPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overridePointMarkerArgb);
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(a.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = a.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          newHitTestProvider() {
            return new u.StackedMountainSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
          addDrawingProviders(e) {
            this.drawingProviders.push(
              new d.BandSeriesDrawingProvider(
                e,
                this,
                (e) => e.y1Values,
                (e) => e.yValues
              ),
              new h.PointMarkerDrawingProvider(e, this, (e) => e.y1Values)
            );
          }
        }
        t.BaseStackedMountainRenderableSeries = c;
      },
      48335: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseStackedRenderableSeries = void 0);
        const i = r(45921),
          o = r(56744),
          a = r(11043),
          s = r(2963),
          n = r(16602),
          l = r(75662),
          d = r(51885),
          h = r(33240),
          u = r(79961),
          c = r(20977),
          p = r(54962);
        class g extends u.BaseRenderableSeries {
          constructor(e, t) {
            super(e, t),
              (this.isStacked = !0),
              (this.rolloverModifierProps =
                new p.RolloverModifierRenderableSeriesProps(this)),
              (this.getParentSurfaceFn = () => {}),
              (this.typeMap = new Map()),
              (this.opacityOriginalValue = 1),
              (this.isStacked = !0),
              (this.accumulatedValues = new e.SCRTDoubleVector()),
              (this.accumulatedFinalAnimationValues = new e.SCRTDoubleVector()),
              (null == t ? void 0 : t.dataLabelProvider) &&
                ("draw" in t.dataLabelProvider ||
                  (t.dataLabelProvider.type === s.EDataLabelProviderType.Custom
                    ? (t.dataLabelProvider = (0, i.createType)(
                        a.EBaseType.DataLabelProvider,
                        t.dataLabelProvider.customType,
                        e,
                        t.dataLabelProvider.options
                      ))
                    : (t.dataLabelProvider = (0, i.createType)(
                        a.EBaseType.DataLabelProvider,
                        t.dataLabelProvider.type,
                        e,
                        t.dataLabelProvider.options
                      )))),
              (this.dataLabelProviderProperty =
                null == t ? void 0 : t.dataLabelProvider),
              this.dataLabelProviderProperty &&
                this.dataLabelProviderProperty.onAttach(e, this),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          dataSeriesDataChanged() {
            this.notifyPropertyChanged(c.PROPERTY.DATA_SERIES);
          }
          draw(e, t) {
            var r, i, o, a;
            const s = n.PerformanceDebugHelper.mark(
              n.EPerformanceMarkType.DrawSingleSeriesStart,
              {
                contextId: this.id,
                parentContextId:
                  null === (r = this.parentSurface) || void 0 === r
                    ? void 0
                    : r.id,
                level: n.EPerformanceDebugLevel.Verbose,
              }
            );
            (this.currentRenderPassData = t),
              null === (i = this.hitTestProvider) ||
                void 0 === i ||
                i.update(t),
              this.dataLabelProvider &&
                this.dataLabelProvider.generateDataLabels(e, t),
              n.PerformanceDebugHelper.mark(
                n.EPerformanceMarkType.DrawSingleSeriesEnd,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (o = this.parentSurface) || void 0 === o
                      ? void 0
                      : o.id,
                  relatedId:
                    null === (a = null == s ? void 0 : s.detail) || void 0 === a
                      ? void 0
                      : a.relatedId,
                  level: n.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          delete() {
            (this.accumulatedValues = (0, o.deleteSafe)(
              this.accumulatedValues
            )),
              (this.accumulatedFinalAnimationValues = (0, o.deleteSafe)(
                this.accumulatedFinalAnimationValues
              )),
              super.delete();
          }
          onDetachFromParentCollection() {
            (this.parentCollection = void 0),
              (this.getParentSurfaceFn = void 0),
              (this.notifyParentPropertyChangedFn = void 0),
              this.delete();
          }
          notifyPropertyChanged(e) {
            this.drawingProviders.forEach((t) => t.onSeriesPropertyChange(e)),
              this.notifyParentPropertyChangedFn &&
                this.notifyParentPropertyChangedFn(e);
          }
          checkIsOutOfDataRange(e, t) {
            const r = this.getDataSeriesValuesCount(),
              i =
                this.xAxis.getCurrentCoordinateCalculator()
                  .isCategoryCoordinateCalculator,
              o = i ? 0 : this.getNativeXValues().get(0),
              a = i ? r - 1 : this.getNativeXValues().get(r - 1);
            return e < o || e > a;
          }
          getAccumulatedValues(e) {
            return e
              ? this.accumulatedFinalAnimationValues
              : this.accumulatedValues;
          }
          getBaseXValues() {
            throw Error(
              "getBaseXValues() is not supported for BaseStackedRenderableSeries"
            );
          }
          hasStrokePaletteProvider() {
            throw Error(
              "hasStrokePaletteProvider() method is not supported for BaseStackedRenderableSeries"
            );
          }
          hasPointMarkerPaletteProvider() {
            throw Error(
              "hasFillPaletteProvider() method is not supported for BaseStackedRenderableSeries"
            );
          }
          hasFillPaletteProvider() {
            throw Error(
              "hasFillPaletteProvider() method is not supported for BaseStackedRenderableSeries"
            );
          }
          onAttach(e) {
            throw Error(
              "onAttach() method is not supported for BaseStackedRenderableSeries"
            );
          }
          onDetach() {
            throw Error(
              "onDetach() method is not supported for BaseStackedRenderableSeries"
            );
          }
          get resamplingMode() {
            return h.EResamplingMode.None;
          }
          set resamplingMode(e) {
            throw Error(
              "Setting resamplingMode property is not supported for BaseStackedRenderableSeries"
            );
          }
          get resamplingPrecision() {
            throw Error(
              "resamplingPrecision property is not supported for BaseStackedRenderableSeries"
            );
          }
          set resamplingPrecision(e) {
            throw Error(
              "resamplingPrecision property is not supported for BaseStackedRenderableSeries"
            );
          }
          get dataLabelProvider() {
            return this.dataLabelProviderProperty;
          }
          set dataLabelProvider(e) {
            (this.dataLabelProviderProperty = e),
              e.onAttach(this.webAssemblyContext, this),
              this.notifyPropertyChanged(c.PROPERTY.SERIES_TEXT_PROVIDER);
          }
          get parentSurface() {
            return this.getParentSurfaceFn ? this.getParentSurfaceFn() : void 0;
          }
          set parentSurface(e) {
            throw Error(
              "set parentSurface property is not supported for BaseStackedRenderableSeries"
            );
          }
          get xAxis() {
            return this.parentCollection.xAxis;
          }
          get yAxis() {
            return this.parentCollection.yAxis;
          }
          beforeAnimationStart() {
            if (
              ((this.opacityOriginalValue = this.opacity),
              this.isRunningAnimation)
            )
              return void super.beforeAnimationStart();
            const e = this.accumulatedValues.size();
            this.accumulatedFinalAnimationValues.resize(e, 0);
            for (let t = 0; t < e; t++)
              this.accumulatedFinalAnimationValues.set(
                t,
                this.accumulatedValues.get(t)
              );
          }
          afterAnimationComplete() {
            (this.opacityProperty = this.opacityOriginalValue),
              this.isRunningAnimation && super.afterAnimationComplete();
          }
          updateAnimationProperties(e, t) {
            if (this.isRunningAnimation)
              return (
                super.updateAnimationProperties(e, this.animationFSM),
                void this.parentCollection.setAccumulatedValuesDirty()
              );
            t.animation.isFadeEffectAnimation
              ? (this.opacity = e * this.opacityOriginalValue)
              : (this.opacity = this.opacityOriginalValue),
              t.animation.calculateAnimationValues(
                this.webAssemblyContext,
                this.accumulatedFinalAnimationValues,
                this.accumulatedValues,
                e
              ),
              this.renderDataTransform &&
                (this.renderDataTransform.requiresTransform = !0);
          }
          getSeriesInfo(e) {
            return new l.StackedXySeriesInfo(this, e);
          }
          toJSON(e = !1) {
            var t, r, i;
            const o = {
              id: this.id,
              opacity: this.opacity,
              animation: this.animation,
              dataLabelProvider:
                null === (t = this.dataLabelProvider) || void 0 === t
                  ? void 0
                  : t.toJSON(),
              pointMarker:
                null === (r = this.pointMarker) || void 0 === r
                  ? void 0
                  : r.toJSON(),
              stroke: this.stroke,
            };
            return (null === (i = this.dataSeries) || void 0 === i
              ? void 0
              : i.type) === d.EDataSeriesType.Xy
              ? {
                  type: this.type,
                  options: o,
                  xyData: this.dataSeries.toJSON(e).options,
                }
              : { type: this.type, options: o };
          }
          toPointSeries(e) {
            throw Error(
              "toPointSeries method is not supported for BaseStackedRenderableSeries"
            );
          }
          getCurrentRenderPassData() {
            throw Error(
              "getCurrentRenderPassData method is not supported for BaseStackedRenderableSeries"
            );
          }
          get xAxisId() {
            var e;
            return null === (e = this.parentCollection) || void 0 === e
              ? void 0
              : e.xAxisId;
          }
          set xAxisId(e) {
            throw Error(
              "Setting xAxisId property is not supported for BaseStackedRenderableSeries"
            );
          }
          get yAxisId() {
            var e;
            return null === (e = this.parentCollection) || void 0 === e
              ? void 0
              : e.yAxisId;
          }
          set yAxisId(e) {
            throw Error(
              "yAxisId property is not supported for BaseStackedRenderableSeries"
            );
          }
          linkAxes() {}
        }
        t.BaseStackedRenderableSeries = g;
      },
      81856: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BandSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(2963),
          a = r(96528),
          s = r(36420),
          n = r(8591),
          l = r(55172),
          d = r(33802);
        class h extends d.LineSeriesDataLabelProvider {
          constructor(e) {
            var t;
            super(e),
              (this.type = o.EDataLabelProviderType.Band),
              (this.singleLabelProperty = !1),
              (this.singleLabelProperty =
                null !== (t = null == e ? void 0 : e.singleLabel) &&
                void 0 !== t
                  ? t
                  : this.singleLabelProperty);
          }
          get singleLabel() {
            return this.singleLabelProperty;
          }
          set singleLabel(e) {
            (this.singleLabelProperty = e), this.invalidateParent();
          }
          getText(e) {
            if (this.singleLabel) {
              if (((this.state1.index = e.index), this.metaDataSelector)) {
                const t = e.renderPassData.pointSeries.indexes.get(e.index);
                return this.metaDataSelector(
                  e.parentSeries.dataSeries.getMetadataAt(t)
                );
              }
              const t =
                  !this.updateTextInAnimation &&
                  e.parentSeries.isRunningAnimation,
                r = t ? e.yValAfterAnimation() : e.yVal(),
                i = t ? this.state1.yValAfterAnimation() : this.state1.yVal();
              return this.getSingleLabelText(e.xVal(), r, i);
            }
            return super.getText(e);
          }
          getSingleLabelText(e, t, r) {
            var i, o, s, l;
            if (t == t || r == r) {
              let e = "";
              return (
                t == t &&
                  (e = (0, n.formatNumber)(
                    t,
                    null !== (i = this.numericFormat) && void 0 !== i
                      ? i
                      : a.ENumericFormat.Decimal,
                    null !== (o = this.precision) && void 0 !== o ? o : 1
                  )),
                t == t && r == r && (e += "\n"),
                r == r &&
                  (e += (0, n.formatNumber)(
                    r,
                    null !== (s = this.numericFormat) && void 0 !== s
                      ? s
                      : a.ENumericFormat.Decimal,
                    null !== (l = this.precision) && void 0 !== l ? l : 1
                  )),
                e
              );
            }
          }
          getPosition(e, t) {
            var r, o, a, n;
            if (this.singleLabel) {
              let l = e.xCoord(),
                d = (e.yCoord() + this.state1.yCoord()) / 2;
              const h = new i.Point(l, d);
              return (
                (d -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
                this.horizontalTextPosition === s.EHorizontalTextPosition.Center
                  ? (l -= t.m_fWidth / 2)
                  : this.horizontalTextPosition ===
                    s.EHorizontalTextPosition.Left
                  ? (l -=
                      t.m_fWidth +
                      (null !==
                        (o =
                          null === (r = this.style.padding) || void 0 === r
                            ? void 0
                            : r.right) && void 0 !== o
                        ? o
                        : 0))
                  : (l +=
                      null !==
                        (n =
                          null === (a = this.style.padding) || void 0 === a
                            ? void 0
                            : a.right) && void 0 !== n
                        ? n
                        : 0),
                this.verticalTextPosition === s.EVerticalTextPosition.Center
                  ? (d += t.m_fHeight / 2)
                  : this.verticalTextPosition ===
                      s.EVerticalTextPosition.Below && (d += t.m_fHeight),
                {
                  position: new i.Point(l, d),
                  rotationAngle: 0,
                  rotationCenter: h,
                }
              );
            }
            return super.getPosition(e, t);
          }
          getY1Provider(e) {
            return new d.LineSeriesDataLabelProvider(e.toJSON().options);
          }
          generateDataLabels(e, t) {
            if (this.singleLabel) {
              const r = t.pointSeries.y1Values;
              (this.state1 = new l.DataLabelState(
                e,
                t,
                this.style,
                this.color,
                r,
                this.parentSeries
              )),
                super.generateDataLabels(e, t);
            } else {
              super.generateDataLabels(e, t);
              const r = this.getY1Provider(this);
              (r.ySelector = (e) => e.y1Values),
                r.onAttach(this.webAssemblyContext, this.parentSeries),
                r.generateDataLabels(e, t),
                this.dataLabels.push(...r.dataLabels);
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = { singleLabel: this.singleLabel };
            return Object.assign(e.options, t), e;
          }
        }
        t.BandSeriesDataLabelProvider = h;
      },
      49613: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseDataLabelProvider = void 0);
        const i = r(23866),
          o = r(36420),
          a = r(48008),
          s = r(84392),
          n = r(98353),
          l = r(86127);
        t.BaseDataLabelProvider = class {
          constructor(e) {
            var t;
            (this.dataLabels = []),
              (this.drawImmediate = !1),
              (this.getstyleProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => ((e[t] = r), this.invalidateParent(), !0),
                })),
              (this.styleProperty = Object.assign(
                { fontFamily: "Default" },
                null == e ? void 0 : e.style
              )),
              (this.colorProperty = null == e ? void 0 : e.color),
              (this.drawImmediate =
                null !== (t = null == e ? void 0 : e.drawImmediate) &&
                void 0 !== t
                  ? t
                  : this.drawImmediate);
          }
          get useRotation() {
            return !1;
          }
          onAttach(e, t) {
            i.Guard.notNull(e, "webAssemblyContext"),
              i.Guard.notNull(t, "parentSeries"),
              (this.webAssemblyContext = e),
              (this.parentSeries = t);
          }
          onDetach() {
            (this.webAssemblyContext = void 0), (this.parentSeries = void 0);
          }
          delete() {}
          get style() {
            return this.styleProperty;
          }
          set style(e) {
            (this.styleProperty = this.getstyleProxy(e)),
              this.invalidateParent();
          }
          get color() {
            var e, t, r;
            return this.colorProperty
              ? (0, s.stripAutoColor)(this.colorProperty)
              : null ===
                  (r =
                    null ===
                      (t =
                        null === (e = this.parentSeries) || void 0 === e
                          ? void 0
                          : e.parentSurface) || void 0 === t
                      ? void 0
                      : t.themeProvider) || void 0 === r
              ? void 0
              : r.tickTextBrush;
          }
          set color(e) {
            (this.colorProperty = e), this.invalidateParent();
          }
          updateStyle(e) {
            (this.styleProperty = this.getstyleProxy(
              Object.assign(Object.assign({}, this.styleProperty), e)
            )),
              this.invalidateParent();
          }
          generateDataLabels(e, t) {}
          draw(e) {
            var t, r, i;
            if (!this.dataLabels || 0 === this.dataLabels.length) return;
            if (!this.style || !this.style.fontFamily || !this.style.fontSize)
              return;
            const s = (0, a.parseColorToUIntArgb)(this.color),
              d = l.DpiHelper.adjustTextStyle(this.style),
              h = e.getFont(d, this.useRotation),
              u = (0, o.convertMultiLineAlignment)(
                this.style.multiLineAlignment,
                this.webAssemblyContext
              );
            for (const e of this.dataLabels) {
              const { left: o, top: a } =
                  this.parentSeries.parentSurface.seriesViewRect,
                l = (0, n.getVector4)(
                  this.webAssemblyContext,
                  e.rotationCenter.x + o,
                  e.rotationCenter.y + a,
                  e.rotationAngle,
                  0
                );
              h.DrawStringAdvanced(
                null !== (t = e.text) && void 0 !== t ? t : "",
                null !== (r = e.color) && void 0 !== r ? r : s,
                Math.round(o + e.position.x),
                Math.round(a + e.position.y),
                l,
                u,
                null !== (i = this.style.lineSpacing) && void 0 !== i ? i : 2
              );
            }
            this.drawImmediate && h.End();
          }
          resolveAutoColors(e, t, r) {
            if (
              this.colorProperty &&
              this.colorProperty.startsWith(s.AUTO_COLOR)
            ) {
              const i = r.getStrokeColor(e, t, this.webAssemblyContext);
              this.color = s.AUTO_COLOR + i;
            }
          }
          toJSON() {
            return {
              type: this.type,
              options: { style: this.style, color: this.color },
            };
          }
          invalidateParent() {
            var e;
            (null === (e = this.parentSeries) || void 0 === e
              ? void 0
              : e.invalidateParentCallback) &&
              this.parentSeries.invalidateParentCallback();
          }
        };
      },
      15273: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BubbleSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(36420),
          a = r(2963),
          s = r(96852);
        class n extends s.DataLabelProvider {
          constructor(e) {
            var t, r;
            super(e),
              (this.type = a.EDataLabelProviderType.Bubble),
              (this.horizontalTextPositionProperty =
                null !== (t = null == e ? void 0 : e.horizontalTextPosition) &&
                void 0 !== t
                  ? t
                  : o.EHorizontalTextPosition.Center),
              (this.verticalTextPositionProperty =
                null !== (r = null == e ? void 0 : e.verticalTextPosition) &&
                void 0 !== r
                  ? r
                  : o.EVerticalTextPosition.Center);
          }
          getPosition(e, t) {
            var r, a, s, n, l, d, h, u;
            let c = e.xCoord(),
              p = e.yCoord();
            const g = new i.Point(c, p);
            p -= t.m_fHeight - t.GetLineBounds(0).m_fHeight;
            let y = Math.abs(e.parentSeries.getBubbleDiameter(e.index)) / 2;
            return (
              this.horizontalTextPosition === o.EHorizontalTextPosition.Center
                ? (c -= t.m_fWidth / 2)
                : this.horizontalTextPosition === o.EHorizontalTextPosition.Left
                ? (c -=
                    t.m_fWidth +
                    (null !==
                      (a =
                        null === (r = this.style.padding) || void 0 === r
                          ? void 0
                          : r.right) && void 0 !== a
                      ? a
                      : 0) +
                    y)
                : (c +=
                    (null !==
                      (n =
                        null === (s = this.style.padding) || void 0 === s
                          ? void 0
                          : s.right) && void 0 !== n
                      ? n
                      : 0) + y),
              this.verticalTextPosition === o.EVerticalTextPosition.Center
                ? (p += t.m_fHeight / 2)
                : this.verticalTextPosition === o.EVerticalTextPosition.Below
                ? (p +=
                    t.m_fHeight +
                    (null !==
                      (d =
                        null === (l = this.style.padding) || void 0 === l
                          ? void 0
                          : l.top) && void 0 !== d
                      ? d
                      : 0) +
                    y)
                : (p -=
                    (null !==
                      (u =
                        null === (h = this.style.padding) || void 0 === h
                          ? void 0
                          : h.bottom) && void 0 !== u
                      ? u
                      : 0) + y),
              {
                position: new i.Point(c, p),
                rotationCenter: g,
                rotationAngle: 0,
              }
            );
          }
        }
        t.BubbleSeriesDataLabelProvider = n;
      },
      1367: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnSeriesDataLabelProvider = t.EColumnDataLabelPosition =
            void 0);
        const i = r(75772),
          o = r(2963),
          a = r(36420),
          s = r(96852);
        var n;
        !(function (e) {
          (e.Outside = "Outside"),
            (e.Inside = "Inside"),
            (e.Position = "Position");
        })(
          (n = t.EColumnDataLabelPosition || (t.EColumnDataLabelPosition = {}))
        );
        class l extends s.DataLabelProvider {
          constructor(e) {
            var t;
            super(
              Object.assign(
                {
                  horizontalTextPosition: a.EHorizontalTextPosition.Center,
                  verticalTextPosition: a.EVerticalTextPosition.Center,
                },
                e
              )
            ),
              (this.type = o.EDataLabelProviderType.Column),
              (this.positionModeProperty = n.Outside),
              (this.positionModeProperty =
                null !== (t = null == e ? void 0 : e.positionMode) &&
                void 0 !== t
                  ? t
                  : this.positionMode);
          }
          get positionMode() {
            return this.positionModeProperty;
          }
          set positionMode(e) {
            (this.positionModeProperty = e), this.invalidateParent();
          }
          generateDataLabels(e, t) {
            const r = this.parentSeries;
            (this.yAdj = Math.ceil(r.strokeThickness / 2)),
              r.pointMarker &&
                (this.yAdj = Math.max(
                  this.yAdj,
                  Math.ceil(r.pointMarker.height / 2)
                )),
              super.generateDataLabels(e, t);
          }
          getPosition(e, t) {
            var r,
              o,
              s,
              l,
              d,
              h,
              u,
              c,
              p,
              g,
              y,
              f,
              v,
              m,
              S,
              P,
              C,
              b,
              x,
              A,
              T,
              E,
              R,
              D;
            let w = e.xCoord(),
              M = e.yCoord();
            const L = new i.Point(w, M);
            (M -= t.m_fHeight - t.GetLineBounds(0).m_fHeight), e.isXFlipped;
            const O = e.isYFlipped ? -1 : 1;
            return e.isVerticalChart
              ? (this.verticalTextPosition === a.EVerticalTextPosition.Center
                  ? (M += t.m_fHeight / 2)
                  : this.verticalTextPosition === a.EVerticalTextPosition.Below
                  ? (M +=
                      t.m_fHeight +
                      (null !==
                        (o =
                          null === (r = this.style.padding) || void 0 === r
                            ? void 0
                            : r.top) && void 0 !== o
                        ? o
                        : 0))
                  : (M -=
                      null !==
                        (l =
                          null === (s = this.style.padding) || void 0 === s
                            ? void 0
                            : s.bottom) && void 0 !== l
                        ? l
                        : 0),
                this.positionMode === n.Outside
                  ? (e.yVal() * O >= 0
                      ? (w +=
                          this.yAdj +
                          (null !==
                            (h =
                              null === (d = e.style.padding) || void 0 === d
                                ? void 0
                                : d.left) && void 0 !== h
                            ? h
                            : 1))
                      : (w -=
                          t.m_fWidth +
                          this.yAdj +
                          (null !==
                            (c =
                              null === (u = e.style.padding) || void 0 === u
                                ? void 0
                                : u.right) && void 0 !== c
                            ? c
                            : 1)),
                    {
                      position: new i.Point(w, M),
                      rotationCenter: L,
                      rotationAngle: 0,
                    })
                  : this.positionMode === n.Inside
                  ? (e.yVal() * O >= 0
                      ? (w -=
                          t.m_fWidth +
                          this.yAdj +
                          (null !==
                            (g =
                              null === (p = e.style.padding) || void 0 === p
                                ? void 0
                                : p.right) && void 0 !== g
                            ? g
                            : 1))
                      : (w +=
                          this.yAdj +
                          (null !==
                            (f =
                              null === (y = e.style.padding) || void 0 === y
                                ? void 0
                                : y.left) && void 0 !== f
                            ? f
                            : 1)),
                    {
                      position: new i.Point(w, M),
                      rotationCenter: L,
                      rotationAngle: 0,
                    })
                  : super.getPosition(e, t))
              : (this.horizontalTextPosition ===
                a.EHorizontalTextPosition.Center
                  ? (w -= t.m_fWidth / 2)
                  : this.horizontalTextPosition ===
                    a.EHorizontalTextPosition.Left
                  ? (w -=
                      t.m_fWidth +
                      (null !==
                        (m =
                          null === (v = this.style.padding) || void 0 === v
                            ? void 0
                            : v.right) && void 0 !== m
                        ? m
                        : 0))
                  : (w +=
                      null !==
                        (P =
                          null === (S = this.style.padding) || void 0 === S
                            ? void 0
                            : S.left) && void 0 !== P
                        ? P
                        : 0),
                this.positionMode === n.Outside
                  ? (e.yVal() * O >= 0
                      ? (M -=
                          this.yAdj +
                          (null !==
                            (b =
                              null === (C = e.style.padding) || void 0 === C
                                ? void 0
                                : C.bottom) && void 0 !== b
                            ? b
                            : 1))
                      : (M +=
                          t.m_fHeight +
                          this.yAdj +
                          (null !==
                            (A =
                              null === (x = e.style.padding) || void 0 === x
                                ? void 0
                                : x.top) && void 0 !== A
                            ? A
                            : 1)),
                    {
                      position: new i.Point(w, M),
                      rotationCenter: L,
                      rotationAngle: 0,
                    })
                  : this.positionMode === n.Inside
                  ? (e.yVal() * O >= 0
                      ? (M +=
                          t.m_fHeight +
                          this.yAdj +
                          (null !==
                            (E =
                              null === (T = e.style.padding) || void 0 === T
                                ? void 0
                                : T.top) && void 0 !== E
                            ? E
                            : 1))
                      : (M -=
                          this.yAdj +
                          (null !==
                            (D =
                              null === (R = e.style.padding) || void 0 === R
                                ? void 0
                                : R.bottom) && void 0 !== D
                            ? D
                            : 1)),
                    {
                      position: new i.Point(w, M),
                      rotationCenter: L,
                      rotationAngle: 0,
                    })
                  : super.getPosition(e, t));
          }
          toJSON() {
            const e = super.toJSON(),
              t = { positionMode: this.positionMode };
            return Object.assign(e.options, t), e;
          }
        }
        t.ColumnSeriesDataLabelProvider = l;
      },
      9488: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ContoursDataLabelProvider = void 0);
        const i = r(75772),
          o = r(87459),
          a = r(2963),
          s = r(96528),
          n = r(22022),
          l = r(8591),
          d = r(48008),
          h = r(98353),
          u = r(86127),
          c = r(49613);
        class p extends c.BaseDataLabelProvider {
          constructor(e) {
            var t, r, i, o;
            super(e),
              (this.type = a.EDataLabelProviderType.Contours),
              (this.isEnabledProperty = !0),
              (this.numericFormatProperty = s.ENumericFormat.Decimal),
              (this.precisionProperty = 1),
              (this.labelRowCountProperty = 10),
              (this.numericFormatProperty =
                null !== (t = null == e ? void 0 : e.numericFormat) &&
                void 0 !== t
                  ? t
                  : this.numericFormatProperty),
              (this.precision =
                null !== (r = null == e ? void 0 : e.precision) && void 0 !== r
                  ? r
                  : this.precisionProperty),
              (this.labelRowCountProperty =
                null !== (i = null == e ? void 0 : e.labelRowCount) &&
                void 0 !== i
                  ? i
                  : this.labelRowCountProperty),
              (this.metaDataSelector = null == e ? void 0 : e.metaDataSelector),
              (this.isEnabledProperty =
                null !== (o = null == e ? void 0 : e.isEnabled) && void 0 !== o
                  ? o
                  : this.isEnabledProperty);
          }
          get numericFormat() {
            return this.numericFormatProperty;
          }
          set numericFormat(e) {
            var t;
            (this.numericFormatProperty = e),
              null === (t = this.parentSeries) ||
                void 0 === t ||
                t.invalidateParentCallback();
          }
          get precision() {
            return this.precisionProperty;
          }
          set precision(e) {
            var t;
            (this.precisionProperty = e),
              null === (t = this.parentSeries) ||
                void 0 === t ||
                t.invalidateParentCallback();
          }
          get labelRowCount() {
            return this.labelRowCountProperty;
          }
          set labelRowCount(e) {
            var t;
            (this.labelRowCountProperty = e),
              null === (t = this.parentSeries) ||
                void 0 === t ||
                t.invalidateParentCallback();
          }
          get isEnabled() {
            return this.isEnabledProperty;
          }
          set isEnabled(e) {
            this.isEnabledProperty !== e &&
              ((this.isEnabledProperty = e), this.invalidateParent());
          }
          getText(e, t) {
            var r, i;
            if (this.metaDataSelector)
              return this.metaDataSelector(this.dataSeries.getMetadataAt(t, e));
            const o = this.zValues[t][e];
            return o == o
              ? (0, l.formatNumber)(
                  o,
                  null !== (r = this.numericFormat) && void 0 !== r
                    ? r
                    : s.ENumericFormat.Decimal,
                  null !== (i = this.precision) && void 0 !== i ? i : 1
                )
              : void 0;
          }
          getPosition(e, t, r, o, a, s) {
            let n = s.xCoordinateCalculator.getCoordinate(r),
              l = s.yCoordinateCalculator.getCoordinate(o);
            if (s.isVerticalChart) {
              const e = n;
              (n = l), (l = e);
            }
            return new i.Point(n, l);
          }
          shouldGenerate(e, t, r) {
            return e.height < r && e.width < t;
          }
          getColor(e, t, r) {
            return this.colorValue;
          }
          shouldSkipLabel(e, t, r, i, o) {
            const a = this.parentSeries.parentSurface.seriesViewRect;
            return (
              r.rect.y < 0 ||
              r.rect.bottom > a.height ||
              r.rect.x < 0 ||
              r.rect.right > a.width
            );
          }
          generateDataLabels(e, t) {
            var r, i, a, c;
            if (
              ((this.dataLabels = []),
              !(
                this.isEnabled &&
                this.style &&
                this.style.fontFamily &&
                this.style.fontSize
              ))
            )
              return;
            (this.dataSeries = this.parentSeries.dataSeries),
              (this.zValues = this.dataSeries.getZValues());
            const p = (0, h.getTextBounds)(this.webAssemblyContext),
              g = u.DpiHelper.adjustTextStyle(this.style),
              y = e.getFont(g);
            Math.abs(
              t.xCoordinateCalculator.getCoordinate(
                this.dataSeries.getXValue(1)
              ) -
                t.xCoordinateCalculator.getCoordinate(
                  this.dataSeries.getXValue(0)
                )
            ),
              Math.abs(
                t.yCoordinateCalculator.getCoordinate(
                  this.dataSeries.getYValue(1)
                ) -
                  t.yCoordinateCalculator.getCoordinate(
                    this.dataSeries.getYValue(0)
                  )
              ),
              (this.colorValue = (0, d.parseColorToUIntArgb)(this.color));
            const {
                xStart: f,
                xStep: v,
                yStart: m,
                yStep: S,
              } = this.parentSeries.dataSeries,
              P = this.parentSeries.getContourDrawingParams(),
              C = P.majorStepZ,
              b = (P.yMax - P.yMin) / (this.labelRowCount + 1);
            let x = m;
            for (let e = 0; e < this.dataSeries.arrayHeight; e++) {
              const d = m + S * e;
              if (d <= x + b) continue;
              if (
                ((x = d),
                t.yCoordinateCalculator.visibleMin > d + S ||
                  t.yCoordinateCalculator.visibleMax < d)
              )
                continue;
              let h;
              for (let d = 0; d < this.dataSeries.arrayWidth; d++) {
                const u = f + v * d;
                if (
                  t.xCoordinateCalculator.visibleMin > u + v ||
                  t.xCoordinateCalculator.visibleMax < u
                )
                  continue;
                const g = this.zValues[e][d];
                let m,
                  S = u;
                if (void 0 !== h) {
                  const e = Math.floor(h / C) * C,
                    t = e + C;
                  g <= e
                    ? ((m = (0, l.formatNumber)(
                        e,
                        null !== (r = this.numericFormat) && void 0 !== r
                          ? r
                          : s.ENumericFormat.Decimal,
                        null !== (i = this.precision) && void 0 !== i ? i : 1
                      )),
                      (S = (v * (e - g)) / (h - g) - v / 2 + u))
                    : g >= t &&
                      ((m = (0, l.formatNumber)(
                        t,
                        null !== (a = this.numericFormat) && void 0 !== a
                          ? a
                          : s.ENumericFormat.Decimal,
                        null !== (c = this.precision) && void 0 !== c ? c : 1
                      )),
                      (S = (v * (t - g)) / (g - h) - v / 2 + u));
                }
                if (((h = g), !m)) continue;
                y.CalculateStringBounds(null != m ? m : "", p, 2);
                const P = new n.Size(p.m_fWidth, p.m_fHeight),
                  b =
                    (this.dataSeries.getXValue(d),
                    this.dataSeries.getYValue(e)),
                  x = this.getPosition(d, e, S, b, P, t),
                  A = {
                    text: m,
                    position: x,
                    rect: new o.Rect(
                      x.x,
                      x.y - p.GetLineBounds(0).m_fHeight,
                      P.width,
                      P.height
                    ),
                    color: this.getColor(d, e, m),
                    dataX: this.dataSeries.getXValue(d),
                    dataY: this.dataSeries.getYValue(e),
                    rotationAngle: 0,
                    rotationCenter: x,
                  };
                this.dataLabels.push(A);
              }
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                numericFormat: this.numericFormat,
                precision: this.precision,
                labelRowCount: this.labelRowCount,
                isEnabled: this.isEnabled,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.ContoursDataLabelProvider = p;
      },
      96852: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataLabelProvider = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(87459),
          s = r(36420),
          n = r(2963),
          l = r(62993),
          d = r(96528),
          h = r(8591),
          u = r(98353),
          c = r(49613),
          p = r(55172),
          g = r(41493);
        class y extends c.BaseDataLabelProvider {
          constructor(e) {
            var t, r, i, o, a, h, u, c, p, g, y, f;
            super(e),
              (this.type = n.EDataLabelProviderType.Default),
              (this.dataLabels = []),
              (this.updateTextInAnimation = !1),
              (this.pointGapThresholdProperty = 0),
              (this.pointCountThresholdProperty = 1 / 0),
              (this.numericFormatProperty = d.ENumericFormat.Decimal),
              (this.engineeringPrefixProperty = {}),
              (this.precisionProperty = 1),
              (this.skipModeProperty =
                l.EDataLabelSkipMode.SkipIfOverlapPrevious),
              (this.skipNumberProperty = 0),
              (this.horizontalTextPositionProperty =
                s.EHorizontalTextPosition.Right),
              (this.verticalTextPositionProperty =
                s.EVerticalTextPosition.Above),
              (this.isEnabledProperty = !0),
              (this.pointGapThresholdProperty =
                null !== (t = null == e ? void 0 : e.pointGapThreshold) &&
                void 0 !== t
                  ? t
                  : this.pointGapThresholdProperty),
              (this.pointCountThresholdProperty =
                null !== (r = null == e ? void 0 : e.pointCountThreshold) &&
                void 0 !== r
                  ? r
                  : this.pointCountThresholdProperty),
              (this.numericFormatProperty =
                null !== (i = null == e ? void 0 : e.numericFormat) &&
                void 0 !== i
                  ? i
                  : this.numericFormatProperty),
              (this.engineeringPrefixProperty =
                null !== (o = null == e ? void 0 : e.engineeringPrefix) &&
                void 0 !== o
                  ? o
                  : this.engineeringPrefixProperty),
              (this.precision =
                null !== (a = null == e ? void 0 : e.precision) && void 0 !== a
                  ? a
                  : this.precisionProperty),
              (this.skipNumberProperty =
                null !== (h = null == e ? void 0 : e.skipNumber) && void 0 !== h
                  ? h
                  : this.skipNumberProperty),
              (this.skipModeProperty =
                null !== (u = null == e ? void 0 : e.skipMode) && void 0 !== u
                  ? u
                  : this.skipModeProperty),
              (this.metaDataSelector = null == e ? void 0 : e.metaDataSelector),
              (this.ySelector =
                null !== (c = null == e ? void 0 : e.ySelector) && void 0 !== c
                  ? c
                  : (e) => e.yValues),
              (this.updateTextInAnimation =
                null !== (p = null == e ? void 0 : e.updateTextInAnimation) &&
                void 0 !== p
                  ? p
                  : this.updateTextInAnimation),
              (this.horizontalTextPositionProperty =
                null !== (g = null == e ? void 0 : e.horizontalTextPosition) &&
                void 0 !== g
                  ? g
                  : this.horizontalTextPosition),
              (this.verticalTextPositionProperty =
                null !== (y = null == e ? void 0 : e.verticalTextPosition) &&
                void 0 !== y
                  ? y
                  : this.verticalTextPosition),
              (this.isEnabledProperty =
                null !== (f = null == e ? void 0 : e.isEnabled) && void 0 !== f
                  ? f
                  : this.isEnabledProperty);
          }
          onAttach(e, t) {
            i.Guard.notNull(e, "webAssemblyContext"),
              i.Guard.notNull(t, "parentSeries"),
              (this.webAssemblyContext = e),
              (this.parentSeries = t);
          }
          get pointGapThreshold() {
            return this.pointGapThresholdProperty;
          }
          set pointGapThreshold(e) {
            (this.pointGapThresholdProperty = e), this.invalidateParent();
          }
          get pointCountThreshold() {
            return this.pointCountThresholdProperty;
          }
          set pointCountThreshold(e) {
            (this.pointCountThresholdProperty = e), this.invalidateParent();
          }
          get skipMode() {
            return this.skipModeProperty;
          }
          set skipMode(e) {
            (this.skipModeProperty = e), this.invalidateParent();
          }
          get skipNumber() {
            return this.skipNumberProperty;
          }
          set skipNumber(e) {
            (this.skipNumberProperty = e), this.invalidateParent();
          }
          get numericFormat() {
            return this.numericFormatProperty;
          }
          set numericFormat(e) {
            (this.numericFormatProperty = e), this.invalidateParent();
          }
          get engineeringPrefix() {
            return this.engineeringPrefixProperty;
          }
          set engineeringPrefix(e) {
            (this.engineeringPrefixProperty = e), this.invalidateParent();
          }
          get precision() {
            return this.precisionProperty;
          }
          set precision(e) {
            (this.precisionProperty = e), this.invalidateParent();
          }
          get horizontalTextPosition() {
            return this.horizontalTextPositionProperty;
          }
          set horizontalTextPosition(e) {
            (this.horizontalTextPositionProperty = e), this.invalidateParent();
          }
          get verticalTextPosition() {
            return this.verticalTextPositionProperty;
          }
          set verticalTextPosition(e) {
            (this.verticalTextPositionProperty = e), this.invalidateParent();
          }
          get isEnabled() {
            return this.isEnabledProperty;
          }
          set isEnabled(e) {
            this.isEnabledProperty !== e &&
              ((this.isEnabledProperty = e), this.invalidateParent());
          }
          getText(e) {
            var t;
            if (this.metaDataSelector)
              return this.metaDataSelector(e.getMetaData());
            const r =
              !this.updateTextInAnimation && e.parentSeries.isRunningAnimation
                ? e.yValAfterAnimation()
                : e.yVal();
            return r == r
              ? this.engineeringPrefix
                ? (0, h.formatNumber)(
                    r,
                    this.numericFormat,
                    this.precision,
                    this.engineeringPrefixProperty
                  )
                : (0, h.formatNumber)(
                    r,
                    null !== (t = this.numericFormat) && void 0 !== t
                      ? t
                      : d.ENumericFormat.Decimal,
                    this.precision
                  )
              : void 0;
          }
          shouldGenerate(e) {
            var t, r;
            if (e.pointCount > this.pointCountThresholdProperty) return !1;
            if (!e.font) return !1;
            const i = this.getText(e),
              o = (0, u.getTextBounds)(this.webAssemblyContext);
            return (
              e.font.CalculateStringBounds(
                null != i ? i : "",
                o,
                null !==
                  (r =
                    null === (t = this.style) || void 0 === t
                      ? void 0
                      : t.lineSpacing) && void 0 !== r
                  ? r
                  : 2
              ),
              e.pointGap >= o.m_fWidth * this.pointGapThreshold
            );
          }
          getPosition(e, t) {
            var r, i, a, n, l, d, h, u;
            let c = e.xCoord(),
              p = e.yCoord();
            const g = new o.Point(c, p);
            return (
              (p -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
              this.horizontalTextPosition === s.EHorizontalTextPosition.Center
                ? (c -= t.m_fWidth / 2)
                : this.horizontalTextPosition === s.EHorizontalTextPosition.Left
                ? (c -=
                    t.m_fWidth +
                    (null !==
                      (i =
                        null === (r = this.style.padding) || void 0 === r
                          ? void 0
                          : r.right) && void 0 !== i
                      ? i
                      : 0))
                : (c +=
                    null !==
                      (n =
                        null === (a = this.style.padding) || void 0 === a
                          ? void 0
                          : a.left) && void 0 !== n
                      ? n
                      : 0),
              this.verticalTextPosition === s.EVerticalTextPosition.Center
                ? (p += t.m_fHeight / 2)
                : this.verticalTextPosition === s.EVerticalTextPosition.Below
                ? (p +=
                    t.m_fHeight +
                    (null !==
                      (d =
                        null === (l = this.style.padding) || void 0 === l
                          ? void 0
                          : l.top) && void 0 !== d
                      ? d
                      : 0))
                : (p -=
                    null !==
                      (u =
                        null === (h = this.style.padding) || void 0 === h
                          ? void 0
                          : h.bottom) && void 0 !== u
                      ? u
                      : 0),
              {
                position: new o.Point(c, p),
                rotationAngle: 0,
                rotationCenter: g,
              }
            );
          }
          getColor(e, t) {
            return e.color;
          }
          shouldSkipLabel(e, t) {
            var r;
            const i = e.parentSeries.parentSurface.seriesViewRect;
            if (t.rect.y < 0 || t.rect.bottom > i.height) return !0;
            if (t.rect.x < 0 || t.rect.right > i.width) return !0;
            switch (this.skipModeProperty) {
              case l.EDataLabelSkipMode.SkipIfOverlapPrevious:
                return this.skipIfOverlapPrevious(e, t);
              case l.EDataLabelSkipMode.SkipIfOverlapNext:
                return this.skipIfOverlapNext(e, t);
              case l.EDataLabelSkipMode.SkipIfSame:
                return (
                  (null === (r = e.lastLabel) || void 0 === r
                    ? void 0
                    : r.text) === t.text
                );
              case l.EDataLabelSkipMode.ShowAll:
              default:
                return !1;
            }
          }
          getDataLabelState(e, t, r, i, o, a) {
            return new p.DataLabelState(e, t, r, i, o, a);
          }
          generateDataLabels(e, t) {
            var r, i;
            if (
              ((this.dataLabels = []),
              !(
                this.isEnabled &&
                this.style &&
                this.style.fontFamily &&
                this.style.fontSize
              ))
            )
              return;
            const o = this.ySelector(t.pointSeries);
            if (!o || 0 === o.size()) return;
            this.state = this.getDataLabelState(
              e,
              t,
              this.style,
              this.color,
              o,
              this.parentSeries
            );
            const {
                fifoCapacity: s,
                fifoSweeping: n,
                fifoSweepingGap: d,
                fifoStartIndex: h,
              } = this.parentSeries.dataSeries,
              c = (0, u.getTextBounds)(this.webAssemblyContext);
            if (!this.shouldGenerate(this.state)) return;
            let p = 0;
            const y = Math.max(0, this.skipNumberProperty);
            for (
              let e = this.state.indexStart;
              e <= this.state.indexEnd;
              e += y + 1
            ) {
              if (
                ((this.state.index =
                  this.skipModeProperty ===
                  l.EDataLabelSkipMode.SkipIfOverlapNext
                    ? this.state.indexEnd - (e - this.state.indexStart)
                    : e),
                n &&
                  this.state.pointCount === s &&
                  this.state.index >= h &&
                  this.state.index < h + d)
              )
                continue;
              const t = this.getText(this.state);
              if (!t) continue;
              this.state.font.CalculateStringBounds(
                null != t ? t : "",
                c,
                null !==
                  (i =
                    null === (r = this.style) || void 0 === r
                      ? void 0
                      : r.lineSpacing) && void 0 !== i
                  ? i
                  : 2
              );
              const {
                  position: o,
                  rotationAngle: u,
                  rotationCenter: g,
                } = this.getPosition(this.state, c),
                y = this.getColor(this.state, t),
                f = c.GetLineBounds(0).m_fHeight,
                v = {
                  text: t,
                  position: o,
                  rect: new a.Rect(o.x, o.y - f, c.m_fWidth, c.m_fHeight),
                  color: y,
                  dataX: this.state.xCoord(),
                  dataY: this.state.yCoord(),
                  rotationAngle: u,
                  rotationCenter: g,
                };
              this.shouldSkipLabel(this.state, v)
                ? p++
                : this.state.dataLabels.push(v);
            }
            p > 100 &&
              p / (this.state.indexEnd - this.state.indexStart) > 0.8 &&
              g.performanceWarnings.dataLabelsSkippingMany.warn(),
              (this.dataLabels = this.state.dataLabels);
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                numericFormat: this.numericFormat,
                pointGapThreshold: this.pointGapThreshold,
                precision: this.precision,
                pointCountThreshold: this.pointCountThreshold,
                skipNumber: this.skipNumber,
                skipMode: this.skipMode,
                updateTextInAnimation: this.updateTextInAnimation,
                horizontalTextPosition: this.horizontalTextPosition,
                verticalTextPosition: this.verticalTextPosition,
                isEnabled: this.isEnabled,
                engineeringPrefix: this.engineeringPrefixProperty,
              };
            return Object.assign(e.options, t), e;
          }
          skipIfOverlapPrevious(e, t) {
            const r = e.lastLabel;
            return !(
              !r ||
              r.rect.right + e.xPadding < t.rect.left ||
              Math.abs(r.rect.y - t.rect.y) > t.rect.height + e.yPadding
            );
          }
          skipIfOverlapNext(e, t) {
            const r = e.lastLabel;
            return !(
              !r ||
              t.rect.right + e.xPadding < r.rect.left ||
              Math.abs(r.rect.y - t.rect.y) > t.rect.height + e.yPadding
            );
          }
        }
        t.DataLabelProvider = y;
      },
      55172: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DataLabelState = void 0);
        const i = r(98140),
          o = r(48008),
          a = r(86127);
        t.DataLabelState = class {
          constructor(e, t, r, s, n, l) {
            var d, h, u, c, p, g, y, f, v;
            (this.dataLabels = []),
              (this.indexProperty = 0),
              (this.xCoordCache = void 0),
              (this.yCoordCache = void 0);
            const m = t.pointSeries,
              S = t.xCoordinateCalculator.isCategoryCoordinateCalculator;
            if (
              ((this.style = a.DpiHelper.adjustTextStyle(r)),
              (this.color = (0, o.parseColorToUIntArgb)(s)),
              (this.xValues = S ? m.indexes : m.xValues),
              (this.yValues = n),
              (this.parentSeries = l),
              (this.renderPassData = t),
              (this.yFinalValues =
                null === (d = this.parentSeries.dataSeries) || void 0 === d
                  ? void 0
                  : d.yFinalAnimationValues),
              (this.isXFlipped = (
                t.isVerticalChart
                  ? this.renderPassData.yCoordinateCalculator
                  : this.renderPassData.xCoordinateCalculator
              ).hasFlippedCoordinates),
              (this.isYFlipped = (
                t.isVerticalChart
                  ? this.renderPassData.xCoordinateCalculator
                  : this.renderPassData.yCoordinateCalculator
              ).hasFlippedCoordinates),
              t.indexRange)
            )
              (this.indexStart = m.resampled ? 0 : t.indexRange.min),
                (this.pointCount = m.resampled
                  ? m.count
                  : t.indexRange.diff + 1),
                (this.indexEnd = m.resampled ? m.count - 1 : t.indexRange.max),
                this.pointCount > 1
                  ? (this.pointGap = t.isVerticalChart
                      ? Math.abs(
                          this.yCoord(this.indexStart) -
                            this.yCoord(this.indexEnd)
                        ) / this.pointCount
                      : Math.abs(
                          this.xCoord(this.indexStart) -
                            this.xCoord(this.indexEnd)
                        ) / this.pointCount)
                  : (this.pointGap = 1 / 0);
            else {
              const e = this.parentSeries.getIndicesRange(
                new i.NumberRange(
                  t.xCoordinateCalculator.visibleMin,
                  t.xCoordinateCalculator.visibleMax
                ),
                S
              );
              (this.indexStart = e.min),
                (this.indexEnd = e.max),
                (this.pointCount = t.indexRange.diff + 1),
                this.pointCount > 1
                  ? (this.pointGap = t.isVerticalChart
                      ? Math.abs(
                          this.yCoord(this.indexStart) -
                            this.yCoord(this.indexEnd)
                        ) / this.pointCount
                      : Math.abs(
                          this.xCoord(this.indexStart) -
                            this.xCoord(this.indexEnd)
                        ) / this.pointCount)
                  : (this.pointGap = 1 / 0);
            }
            (this.index = this.indexStart),
              (this.font = e.getFont(this.style)),
              (this.xPadding =
                (null !==
                  (u =
                    null === (h = this.style.padding) || void 0 === h
                      ? void 0
                      : h.left) && void 0 !== u
                  ? u
                  : 0) +
                (null !==
                  (p =
                    null === (c = this.style.padding) || void 0 === c
                      ? void 0
                      : c.right) && void 0 !== p
                  ? p
                  : 0)),
              (this.yPadding =
                (null !==
                  (y =
                    null === (g = this.style.padding) || void 0 === g
                      ? void 0
                      : g.top) && void 0 !== y
                  ? y
                  : 0) +
                (null !==
                  (v =
                    null === (f = this.style.padding) || void 0 === f
                      ? void 0
                      : f.bottom) && void 0 !== v
                  ? v
                  : 0)),
              (this.fifoSweeping = l.dataSeries.fifoSweeping);
          }
          get index() {
            return this.indexProperty;
          }
          set index(e) {
            (this.xCoordCache = void 0),
              (this.yCoordCache = void 0),
              (this.indexProperty = e);
          }
          getIndexInternal(e) {
            let t = null != e ? e : this.indexProperty;
            return (
              this.isXFlipped || (t = this.indexEnd - (t - this.indexStart)), t
            );
          }
          xVal(e) {
            return this.parentSeries.dataSeries.getNativeValue(
              this.xValues,
              this.getIndexInternal(e)
            );
          }
          yVal(e) {
            return this.parentSeries.dataSeries.getNativeValue(
              this.yValues,
              this.getIndexInternal(e)
            );
          }
          yValAfterAnimation(e) {
            return this.yFinalValues
              ? this.yFinalValues.get(this.getIndexInternal(e))
              : this.yVal(e);
          }
          xCoord(e) {
            return this.renderPassData.isVerticalChart
              ? this.yCoordInternal(e)
              : this.xCoordInternal(e);
          }
          yCoord(e) {
            return this.renderPassData.isVerticalChart
              ? this.xCoordInternal(e)
              : this.yCoordInternal(e);
          }
          hasNext(e) {
            const t = null != e ? e : this.indexProperty;
            return this.isXFlipped ? t < this.indexEnd : t > 0;
          }
          get lastLabel() {
            return this.dataLabels.length > 0
              ? this.dataLabels[this.dataLabels.length - 1]
              : void 0;
          }
          getMetaData() {
            const e = this.renderPassData.pointSeries.indexes.get(this.index);
            return this.parentSeries.dataSeries.getMetadataAt(
              e,
              this.fifoSweeping
            );
          }
          get isVerticalChart() {
            return this.renderPassData.isVerticalChart;
          }
          getXCoord(e) {
            return this.renderPassData.xCoordinateCalculator.getCoordinate(e);
          }
          getYCoord(e) {
            return this.renderPassData.yCoordinateCalculator.getCoordinate(e);
          }
          xCoordInternal(e) {
            return void 0 !== e
              ? this.renderPassData.xCoordinateCalculator.getCoordinate(
                  this.xVal(e)
                )
              : (void 0 !== this.xCoordCache ||
                  (this.xCoordCache =
                    this.renderPassData.xCoordinateCalculator.getCoordinate(
                      this.xVal()
                    )),
                this.xCoordCache);
          }
          yCoordInternal(e) {
            return void 0 !== e
              ? this.renderPassData.yCoordinateCalculator.getCoordinate(
                  this.yVal(e)
                )
              : (void 0 !== this.yCoordCache ||
                  (this.yCoordCache =
                    this.renderPassData.yCoordinateCalculator.getCoordinate(
                      this.yVal()
                    )),
                this.yCoordCache);
          }
        };
      },
      75933: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HeatMapDataLabelProvider = void 0);
        const i = r(75772),
          o = r(87459),
          a = r(2963),
          s = r(96528),
          n = r(22022),
          l = r(8591),
          d = r(48008),
          h = r(98353),
          u = r(86127),
          c = r(49613);
        class p extends c.BaseDataLabelProvider {
          constructor(e) {
            var t, r, i;
            super(e),
              (this.type = a.EDataLabelProviderType.Heatmap),
              (this.isEnabledProperty = !0),
              (this.numericFormatProperty = s.ENumericFormat.Decimal),
              (this.precisionProperty = 1),
              (this.numericFormatProperty =
                null !== (t = null == e ? void 0 : e.numericFormat) &&
                void 0 !== t
                  ? t
                  : this.numericFormatProperty),
              (this.precision =
                null !== (r = null == e ? void 0 : e.precision) && void 0 !== r
                  ? r
                  : this.precisionProperty),
              (this.metaDataSelector = null == e ? void 0 : e.metaDataSelector),
              (this.isEnabledProperty =
                null !== (i = null == e ? void 0 : e.isEnabled) && void 0 !== i
                  ? i
                  : this.isEnabledProperty);
          }
          get numericFormat() {
            return this.numericFormatProperty;
          }
          set numericFormat(e) {
            var t;
            (this.numericFormatProperty = e),
              null === (t = this.parentSeries) ||
                void 0 === t ||
                t.invalidateParentCallback();
          }
          get precision() {
            return this.precisionProperty;
          }
          set precision(e) {
            var t;
            (this.precisionProperty = e),
              null === (t = this.parentSeries) ||
                void 0 === t ||
                t.invalidateParentCallback();
          }
          get isEnabled() {
            return this.isEnabledProperty;
          }
          set isEnabled(e) {
            this.isEnabledProperty !== e &&
              ((this.isEnabledProperty = e), this.invalidateParent());
          }
          getText(e, t) {
            var r, i;
            if (this.metaDataSelector)
              return this.metaDataSelector(this.dataSeries.getMetadataAt(t, e));
            const o = this.zValues[t][e];
            return o == o
              ? (0, l.formatNumber)(
                  o,
                  null !== (r = this.numericFormat) && void 0 !== r
                    ? r
                    : s.ENumericFormat.Decimal,
                  null !== (i = this.precision) && void 0 !== i ? i : 1
                )
              : void 0;
          }
          getPosition(e, t, r, o, a, s, n, l) {
            let d = l.xCoordinateCalculator.getCoordinate(r),
              h = l.yCoordinateCalculator.getCoordinate(o);
            if (l.isVerticalChart) {
              const e = d;
              (d = h), (h = e);
            }
            return (
              l.xCoordinateCalculator.hasFlippedCoordinates
                ? (d += (s - a.width) / 2)
                : (d -= s - (s - a.width) / 2),
              l.yCoordinateCalculator.hasFlippedCoordinates
                ? (h += n - (n - a.height) / 2)
                : (h -= (n - a.height) / 2),
              {
                position: new i.Point(d, h),
                rotationCenter: new i.Point(d, h),
                rotationAngle: 0,
              }
            );
          }
          shouldGenerate(e, t, r) {
            return e.height < r && e.width < t;
          }
          getColor(e, t, r) {
            return this.colorValue;
          }
          shouldSkipLabel(e, t, r, i, o) {
            const a = this.parentSeries.parentSurface.seriesViewRect;
            return (
              r.rect.y < 0 ||
              r.rect.bottom > a.height ||
              r.rect.x < 0 ||
              r.rect.right > a.width
            );
          }
          generateDataLabels(e, t) {
            var r, i;
            if (
              ((this.dataLabels = []),
              !(
                this.isEnabled &&
                this.style &&
                this.style.fontFamily &&
                this.style.fontSize
              ))
            )
              return;
            (this.dataSeries = this.parentSeries.dataSeries),
              (this.zValues = this.dataSeries.getZValues());
            const a = (0, h.getTextBounds)(this.webAssemblyContext),
              s = u.DpiHelper.adjustTextStyle(this.style),
              l = e.getFont(s);
            let c = Math.abs(
                t.xCoordinateCalculator.getCoordinate(
                  this.dataSeries.getXValue(1)
                ) -
                  t.xCoordinateCalculator.getCoordinate(
                    this.dataSeries.getXValue(0)
                  )
              ),
              p = Math.abs(
                t.yCoordinateCalculator.getCoordinate(
                  this.dataSeries.getYValue(1)
                ) -
                  t.yCoordinateCalculator.getCoordinate(
                    this.dataSeries.getYValue(0)
                  )
              );
            if (
              (l.CalculateStringBounds(
                null !== (r = this.getText(0, 0)) && void 0 !== r ? r : "",
                a,
                null !== (i = this.style.lineSpacing) && void 0 !== i ? i : 2
              ),
              t.isVerticalChart && ([p, c] = [c, p]),
              !this.shouldGenerate(new n.Size(a.m_fWidth, a.m_fHeight), c, p))
            )
              return;
            this.colorValue = (0, d.parseColorToUIntArgb)(this.color);
            const {
              xStart: g,
              xStep: y,
              yStart: f,
              yStep: v,
            } = this.parentSeries.dataSeries;
            for (let e = 0; e < this.dataSeries.arrayHeight; e++) {
              const r = f + v * e;
              if (
                !(
                  t.yCoordinateCalculator.visibleMin > r + v ||
                  t.yCoordinateCalculator.visibleMax < r
                )
              )
                for (let r = 0; r < this.dataSeries.arrayWidth; r++) {
                  const i = g + y * r;
                  if (
                    t.xCoordinateCalculator.visibleMin > i + y ||
                    t.xCoordinateCalculator.visibleMax < i
                  )
                    continue;
                  const s = this.getText(r, e);
                  if (!s) continue;
                  l.CalculateStringBounds(null != s ? s : "", a, 2);
                  const d = new n.Size(a.m_fWidth, a.m_fHeight),
                    h = this.dataSeries.getXValue(r),
                    u = this.dataSeries.getYValue(e),
                    {
                      position: f,
                      rotationCenter: v,
                      rotationAngle: m,
                    } = this.getPosition(r, e, h, u, d, c, p, t),
                    S = {
                      text: s,
                      position: f,
                      rect: new o.Rect(
                        f.x,
                        f.y - a.GetLineBounds(0).m_fHeight,
                        d.width,
                        d.height
                      ),
                      color: this.getColor(r, e, s),
                      dataX: this.dataSeries.getXValue(r),
                      dataY: this.dataSeries.getYValue(e),
                      rotationAngle: m,
                      rotationCenter: v,
                    };
                  this.shouldSkipLabel(r, e, S, c, p) ||
                    this.dataLabels.push(S);
                }
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                numericFormat: this.numericFormat,
                precision: this.precision,
                isEnabled: this.isEnabled,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.HeatMapDataLabelProvider = p;
      },
      33802: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(2963),
          a = r(96852);
        class s extends a.DataLabelProvider {
          constructor(e) {
            var t;
            super(e),
              (this.type = o.EDataLabelProviderType.Line),
              (this.aboveBelowProperty = !0),
              (this.aboveBelowProperty =
                null !== (t = null == e ? void 0 : e.aboveBelow) && void 0 !== t
                  ? t
                  : this.aboveBelow);
          }
          get aboveBelow() {
            return this.aboveBelowProperty;
          }
          set aboveBelow(e) {
            (this.aboveBelowProperty = e), this.invalidateParent();
          }
          generateDataLabels(e, t) {
            const r = this.parentSeries;
            (this.yAdj = Math.ceil(r.strokeThickness / 2)),
              r.pointMarker &&
                (this.yAdj = Math.max(
                  this.yAdj,
                  Math.ceil(r.pointMarker.height / 2)
                )),
              super.generateDataLabels(e, t);
          }
          getPosition(e, t) {
            var r, o, a, s, n, l;
            if (this.aboveBelow) {
              let d = e.xCoord(),
                h = e.yCoord();
              const u = new i.Point(d, h);
              if (
                ((h -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
                (d +=
                  null !==
                    (o =
                      null === (r = this.style.padding) || void 0 === r
                        ? void 0
                        : r.left) && void 0 !== o
                    ? o
                    : 0),
                e.hasNext())
              ) {
                const r = e.yCoord(e.index + 1),
                  i = e.xCoord(e.index + 1);
                (i > d && r > h) || (i < d && r < h)
                  ? (h -=
                      this.yAdj +
                      (null !==
                        (s =
                          null === (a = e.style.padding) || void 0 === a
                            ? void 0
                            : a.bottom) && void 0 !== s
                        ? s
                        : 1))
                  : (h +=
                      t.m_fHeight +
                      this.yAdj +
                      (null !==
                        (l =
                          null === (n = e.style.padding) || void 0 === n
                            ? void 0
                            : n.top) && void 0 !== l
                        ? l
                        : 1));
              }
              return {
                position: new i.Point(d, h),
                rotationAngle: 0,
                rotationCenter: u,
              };
            }
            return super.getPosition(e, t);
          }
          toJSON() {
            const e = super.toJSON(),
              t = { aboveBelow: this.aboveBelow };
            return Object.assign(e.options, t), e;
          }
        }
        t.LineSeriesDataLabelProvider = s;
      },
      31544: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonUniformHeatMapDataLabelProvider = void 0);
        const i = r(75772),
          o = r(87459),
          a = r(2963),
          s = r(22022),
          n = r(48008),
          l = r(98353),
          d = r(86127),
          h = r(75933);
        class u extends h.HeatMapDataLabelProvider {
          constructor() {
            super(...arguments),
              (this.type = a.EDataLabelProviderType.NonUniformHeatmap),
              (this.cellSizeThresholdCoefficient = 1);
          }
          getPosition(e, t, r, o, a, s, n, l) {
            let d = l.xCoordinateCalculator.getCoordinate(r),
              h = l.yCoordinateCalculator.getCoordinate(o);
            if (l.isVerticalChart) {
              const e = d;
              (d = h), (h = e);
            }
            return (
              l.xCoordinateCalculator.hasFlippedCoordinates
                ? (d += (s - a.width) / 2)
                : (d -= s - (s - a.width) / 2),
              l.yCoordinateCalculator.hasFlippedCoordinates
                ? (h += n - (n - a.height) / 2)
                : (h -= (n - a.height) / 2),
              {
                position: new i.Point(d, h),
                rotationCenter: new i.Point(d, h),
                rotationAngle: 0,
              }
            );
          }
          generateDataLabels(e, t) {
            var r, i;
            if (
              ((this.dataLabels = []),
              !this.style || !this.style.fontFamily || !this.style.fontSize)
            )
              return;
            (this.dataSeries = this.parentSeries.dataSeries),
              (this.zValues = this.dataSeries.getZValues());
            const a = (0, l.getTextBounds)(this.webAssemblyContext),
              h = d.DpiHelper.adjustTextStyle(this.style),
              u = e.getFont(h),
              c = Math.abs(
                t.xCoordinateCalculator.getCoordinate(
                  this.dataSeries.getXValue(this.dataSeries.arrayWidth)
                ) -
                  t.xCoordinateCalculator.getCoordinate(
                    this.dataSeries.getXValue(0)
                  )
              ),
              p = Math.abs(
                t.yCoordinateCalculator.getCoordinate(
                  this.dataSeries.getYValue(this.dataSeries.arrayHeight)
                ) -
                  t.yCoordinateCalculator.getCoordinate(
                    this.dataSeries.getYValue(0)
                  )
              ),
              g = this.dataSeries.xCellSizes,
              y = this.dataSeries.yCellSizes;
            u.CalculateStringBounds(
              null !== (r = this.getText(0, 0)) && void 0 !== r ? r : "",
              a,
              null !== (i = this.style.lineSpacing) && void 0 !== i ? i : 2
            );
            const f = a.m_fHeight * this.cellSizeThresholdCoefficient,
              v = a.m_fWidth * this.cellSizeThresholdCoefficient;
            this.colorValue = (0, n.parseColorToUIntArgb)(this.color);
            for (let e = 0; e < this.dataSeries.arrayHeight; e++) {
              let r = p * y[e];
              if (r < f) continue;
              const i = this.dataSeries.getYValue(e),
                n = this.dataSeries.yCellOffsets[e + 1];
              if (
                !(
                  t.yCoordinateCalculator.visibleMin > i ||
                  t.yCoordinateCalculator.visibleMax < n
                )
              )
                for (let n = 0; n < this.dataSeries.arrayWidth; n++) {
                  let l = c * g[n];
                  if (l < v) continue;
                  const d = this.dataSeries.getXValue(n),
                    h = this.dataSeries.xCellOffsets[n + 1];
                  if (
                    t.xCoordinateCalculator.visibleMin > d ||
                    t.xCoordinateCalculator.visibleMax < h
                  )
                    continue;
                  const p = this.getText(n, e);
                  if (!p) continue;
                  u.CalculateStringBounds(null != p ? p : "", a, 2);
                  const y = new s.Size(a.m_fWidth, a.m_fHeight);
                  if (t.isVerticalChart) {
                    const e = r;
                    (r = l), (l = e);
                  }
                  const {
                      position: f,
                      rotationAngle: m,
                      rotationCenter: S,
                    } = this.getPosition(n, e, d, i, y, l, r, t),
                    P = {
                      text: p,
                      position: f,
                      rect: new o.Rect(
                        f.x,
                        f.y - a.GetLineBounds(0).m_fHeight,
                        y.width,
                        y.height
                      ),
                      color: this.getColor(n, e, p),
                      dataX: d,
                      dataY: i,
                      rotationAngle: m,
                      rotationCenter: S,
                    };
                  this.shouldSkipLabel(n, e, P, l, r) ||
                    this.dataLabels.push(P);
                }
            }
          }
        }
        t.NonUniformHeatMapDataLabelProvider = u;
      },
      98585: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RectangleDataLabelState = void 0);
        const i = r(60960),
          o = r(54624),
          a = r(55172);
        class s extends a.DataLabelState {
          constructor(e, t, r, i, a, s) {
            super(e, t, r, i, a, s),
              (this.x1CoordCache = void 0),
              (this.y1CoordCache = void 0);
            const n = t.pointSeries;
            (this.x1Values = n.getYValuesByName(o.EValueName.X1)),
              (this.defaultY1 = s.defaultY1),
              (this.y1Values = n.getYValuesByName(o.EValueName.Y1)),
              (this.columnXMode = s.columnXMode),
              (this.columnYMode = s.columnYMode),
              (this.columnWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                s.dataPointWidth,
                s.dataPointWidthMode
              ));
          }
          x1Val(e) {
            return this.parentSeries.dataSeries.getNativeValue(
              this.x1Values,
              this.getIndexInternal(e)
            );
          }
          y1Val(e) {
            return this.y1Values
              ? this.parentSeries.dataSeries.getNativeValue(
                  this.y1Values,
                  this.getIndexInternal(e)
                )
              : this.defaultY1;
          }
          x1Coord(e) {
            return this.renderPassData.isVerticalChart
              ? this.y1CoordInternal(e)
              : this.x1CoordInternal(e);
          }
          get index() {
            return this.indexProperty;
          }
          set index(e) {
            (this.xCoordCache = void 0),
              (this.yCoordCache = void 0),
              (this.x1CoordCache = void 0),
              (this.y1CoordCache = void 0),
              (this.indexProperty = e);
          }
          y1Coord(e) {
            return this.renderPassData.isVerticalChart
              ? this.x1CoordInternal(e)
              : this.y1CoordInternal(e);
          }
          x1CoordForXColumnModes(e) {
            return this.columnXMode === i.EColumnMode.MidWidth ||
              this.columnXMode === i.EColumnMode.StartWidth
              ? this.renderPassData.xCoordinateCalculator.getCoordWidth(
                  this.x1Val(e)
                )
              : this.columnXMode === i.EColumnMode.Start ||
                this.columnXMode === i.EColumnMode.Mid
              ? this.columnWidth
              : this.renderPassData.xCoordinateCalculator.getCoordinate(
                  this.x1Val(e)
                );
          }
          x1CoordInternal(e) {
            return void 0 !== e
              ? this.x1CoordForXColumnModes(e)
              : (void 0 !== this.x1CoordCache ||
                  (this.x1CoordCache = this.x1CoordForXColumnModes()),
                this.x1CoordCache);
          }
          y1CoordForYColumnModes(e) {
            return this.columnYMode === i.EColumnYMode.CenterHeight ||
              this.columnYMode === i.EColumnYMode.TopHeight
              ? this.renderPassData.yCoordinateCalculator.getCoordWidth(
                  this.y1Val(e)
                )
              : this.renderPassData.yCoordinateCalculator.getCoordinate(
                  this.y1Val(e)
                );
          }
          y1CoordInternal(e) {
            return void 0 !== e
              ? this.y1CoordForYColumnModes(e)
              : (void 0 !== this.y1CoordCache ||
                  (this.y1CoordCache = this.y1CoordForYColumnModes()),
                this.y1CoordCache);
          }
        }
        t.RectangleDataLabelState = s;
      },
      70027: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RectangleSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(2963),
          a = r(77110),
          s = r(96852),
          n = r(98585);
        class l extends s.DataLabelProvider {
          constructor(e) {
            super(e), (this.type = o.EDataLabelProviderType.Rectangle);
          }
          getDataLabelState(e, t, r, i, o, a) {
            return new n.RectangleDataLabelState(e, t, r, i, o, a);
          }
          getPosition(e, t) {
            const { columnXMode: r, columnYMode: o } = this.parentSeries,
              {
                xMin: s,
                xMax: n,
                yMin: l,
                yMax: d,
              } = a.dataLabelHelpers.calcRectangleBorders(
                r,
                o,
                !e.isXFlipped,
                e.isYFlipped,
                e.xCoord(),
                e.yCoord(),
                e.x1Coord(),
                e.y1Coord()
              ),
              h = (s + n) / 2,
              u = (l + d) / 2,
              c = new i.Point(h, u);
            let p = h,
              g = u - (t.m_fHeight - t.GetLineBounds(0).m_fHeight);
            return (
              (p -= t.m_fWidth / 2),
              (g += t.m_fHeight / 2),
              {
                position: new i.Point(p, g),
                rotationAngle: 0,
                rotationCenter: c,
              }
            );
          }
          toJSON() {
            const e = super.toJSON();
            return Object.assign(e.options, {}), e;
          }
        }
        t.RectangleSeriesDataLabelProvider = l;
      },
      93752: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedCollectionDataLabelProvider = void 0);
        const i = r(49613);
        class o extends i.BaseDataLabelProvider {
          constructor() {
            super();
          }
          generateDataLabels(e, t) {}
          draw(e) {
            for (const t of this.parentSeries.asArray())
              t.isVisible && t.dataLabelProvider.draw(e);
          }
        }
        t.StackedCollectionDataLabelProvider = o;
      },
      74026: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedColumnSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(2963),
          a = r(36420),
          s = r(1367),
          n = r(96852);
        class l extends n.DataLabelProvider {
          constructor(e) {
            var t;
            super(
              Object.assign(
                {
                  horizontalTextPosition: a.EHorizontalTextPosition.Center,
                  verticalTextPosition: a.EVerticalTextPosition.Center,
                },
                e
              )
            ),
              (this.type = o.EDataLabelProviderType.Column),
              (this.positionModeProperty = s.EColumnDataLabelPosition.Outside),
              (this.positionModeProperty =
                null !== (t = null == e ? void 0 : e.positionMode) &&
                void 0 !== t
                  ? t
                  : this.positionMode);
          }
          get positionMode() {
            return this.positionModeProperty;
          }
          set positionMode(e) {
            (this.positionModeProperty = e), this.invalidateParent();
          }
          CalculateShift(e) {
            const t = this.columnWidth,
              r = this.groupSize;
            return (
              e -
              (t * r) / 2 -
              (this.spacing * (r - 1)) / 2 +
              this.groupIndex * (this.spacing + t) +
              0.5 * t
            );
          }
          generateDataLabels(e, t) {
            const r = this.parentSeries;
            (this.yAdj = Math.ceil(r.strokeThickness / 2)),
              r.pointMarker &&
                (this.yAdj = Math.max(
                  this.yAdj,
                  Math.ceil(r.pointMarker.height / 2)
                )),
              super.generateDataLabels(e, t);
          }
          getPosition(e, t) {
            var r,
              o,
              n,
              l,
              d,
              h,
              u,
              c,
              p,
              g,
              y,
              f,
              v,
              m,
              S,
              P,
              C,
              b,
              x,
              A,
              T,
              E,
              R,
              D,
              w,
              M,
              L,
              O,
              I,
              k,
              _,
              V;
            const N = e.isXFlipped
                ? e.index
                : e.indexEnd - (e.index - e.indexStart),
              B = this.topVector.get(N);
            let F = e.xCoord(),
              H = e.yCoord();
            const Y = e.renderPassData.yCoordinateCalculator;
            e.isVerticalChart
              ? ((H = this.CalculateShift(H)), (F = Y.getCoordinate(B)))
              : ((F = this.CalculateShift(F)), (H = Y.getCoordinate(B))),
              (H -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
              e.isXFlipped;
            const z = e.isYFlipped ? -1 : 1;
            return e.isVerticalChart
              ? (this.verticalTextPosition === a.EVerticalTextPosition.Center
                  ? (H += t.m_fHeight / 2)
                  : this.verticalTextPosition === a.EVerticalTextPosition.Below
                  ? (H +=
                      t.m_fHeight +
                      (null !==
                        (o =
                          null === (r = this.style.padding) || void 0 === r
                            ? void 0
                            : r.top) && void 0 !== o
                        ? o
                        : 1))
                  : (H -=
                      null !==
                        (l =
                          null === (n = this.style.padding) || void 0 === n
                            ? void 0
                            : n.bottom) && void 0 !== l
                        ? l
                        : 0),
                this.positionMode === s.EColumnDataLabelPosition.Outside
                  ? (e.yVal() * z >= 0
                      ? ((F += this.yAdj),
                        e.isXFlipped
                          ? (F +=
                              null !==
                                (c =
                                  null === (u = e.style.padding) || void 0 === u
                                    ? void 0
                                    : u.left) && void 0 !== c
                                ? c
                                : 1)
                          : (F -=
                              t.m_fWidth +
                              (null !==
                                (h =
                                  null === (d = e.style.padding) || void 0 === d
                                    ? void 0
                                    : d.right) && void 0 !== h
                                ? h
                                : 1)))
                      : ((F -=
                          this.yAdj -
                          (null !==
                            (g =
                              null === (p = e.style.padding) || void 0 === p
                                ? void 0
                                : p.right) && void 0 !== g
                            ? g
                            : 1)),
                        (e.isXFlipped || e.isYFlipped) &&
                          (F -=
                            t.m_fWidth +
                            (null !==
                              (f =
                                null === (y = e.style.padding) || void 0 === y
                                  ? void 0
                                  : y.left) && void 0 !== f
                              ? f
                              : 1))),
                    {
                      position: new i.Point(F, H),
                      rotationCenter: new i.Point(F, H),
                      rotationAngle: 0,
                    })
                  : this.positionMode === s.EColumnDataLabelPosition.Inside
                  ? (e.yVal() * z >= 0
                      ? ((F -=
                          this.yAdj +
                          (null !==
                            (m =
                              null === (v = e.style.padding) || void 0 === v
                                ? void 0
                                : v.right) && void 0 !== m
                            ? m
                            : 1)),
                        (e.isXFlipped || e.isYFlipped) &&
                          (F -=
                            t.m_fWidth +
                            (null !==
                              (P =
                                null === (S = e.style.padding) || void 0 === S
                                  ? void 0
                                  : S.left) && void 0 !== P
                              ? P
                              : 1)))
                      : ((F +=
                          this.yAdj +
                          (null !==
                            (b =
                              null === (C = e.style.padding) || void 0 === C
                                ? void 0
                                : C.left) && void 0 !== b
                            ? b
                            : 1)),
                        e.isXFlipped ||
                          (F -=
                            t.m_fWidth +
                            (null !==
                              (A =
                                null === (x = e.style.padding) || void 0 === x
                                  ? void 0
                                  : x.right) && void 0 !== A
                              ? A
                              : 1))),
                    {
                      position: new i.Point(F, H),
                      rotationCenter: new i.Point(F, H),
                      rotationAngle: 0,
                    })
                  : super.getPosition(e, t))
              : (this.horizontalTextPosition ===
                a.EHorizontalTextPosition.Center
                  ? (F -= t.m_fWidth / 2)
                  : this.horizontalTextPosition ===
                    a.EHorizontalTextPosition.Left
                  ? (F -=
                      t.m_fWidth +
                      (null !==
                        (E =
                          null === (T = this.style.padding) || void 0 === T
                            ? void 0
                            : T.right) && void 0 !== E
                        ? E
                        : 0) +
                      t.m_fWidth)
                  : (F +=
                      null !==
                        (D =
                          null === (R = this.style.padding) || void 0 === R
                            ? void 0
                            : R.left) && void 0 !== D
                        ? D
                        : 0 + t.m_fWidth),
                this.positionMode === s.EColumnDataLabelPosition.Outside
                  ? (e.yVal() * z >= 0
                      ? (H -=
                          this.yAdj +
                          (null !==
                            (M =
                              null === (w = e.style.padding) || void 0 === w
                                ? void 0
                                : w.bottom) && void 0 !== M
                            ? M
                            : 1))
                      : (H +=
                          t.m_fHeight +
                          this.yAdj +
                          (null !==
                            (O =
                              null === (L = e.style.padding) || void 0 === L
                                ? void 0
                                : L.top) && void 0 !== O
                            ? O
                            : 1)),
                    {
                      position: new i.Point(F, H),
                      rotationCenter: new i.Point(F, H),
                      rotationAngle: 0,
                    })
                  : this.positionMode === s.EColumnDataLabelPosition.Inside
                  ? (e.yVal() * z >= 0
                      ? (H +=
                          t.m_fHeight +
                          this.yAdj +
                          (null !==
                            (k =
                              null === (I = e.style.padding) || void 0 === I
                                ? void 0
                                : I.top) && void 0 !== k
                            ? k
                            : 1))
                      : (H -=
                          this.yAdj +
                          (null !==
                            (V =
                              null === (_ = e.style.padding) || void 0 === _
                                ? void 0
                                : _.bottom) && void 0 !== V
                            ? V
                            : 1)),
                    {
                      position: new i.Point(F, H),
                      rotationCenter: new i.Point(F, H),
                      rotationAngle: 0,
                    })
                  : super.getPosition(e, t));
          }
          toJSON() {
            const e = super.toJSON(),
              t = { positionMode: this.positionMode };
            return Object.assign(e.options, t), e;
          }
        }
        t.StackedColumnSeriesDataLabelProvider = l;
      },
      1126: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TextDataLabelProvider = void 0);
        const i = r(75772),
          o = r(87459),
          a = r(98353),
          s = r(49613),
          n = r(2963),
          l = r(55172),
          d = r(36420);
        class h extends s.BaseDataLabelProvider {
          constructor(e) {
            var t, r, i, o;
            super(
              Object.assign(Object.assign({}, e), {
                style: Object.assign(
                  { fontSize: 12 },
                  null == e ? void 0 : e.style
                ),
              })
            ),
              (this.type = n.EDataLabelProviderType.Text),
              (this.calculateTextBounds = !1),
              (this.horizontalTextPositionProperty =
                d.EHorizontalTextPosition.Right),
              (this.verticalTextPositionProperty =
                d.EVerticalTextPosition.Above),
              (this.isEnabledProperty = !0),
              (this.calculateTextBounds =
                null !== (t = null == e ? void 0 : e.calculateTextBounds) &&
                void 0 !== t
                  ? t
                  : this.calculateTextBounds),
              (this.horizontalTextPositionProperty =
                null !== (r = null == e ? void 0 : e.horizontalTextPosition) &&
                void 0 !== r
                  ? r
                  : this.horizontalTextPosition),
              (this.verticalTextPositionProperty =
                null !== (i = null == e ? void 0 : e.verticalTextPosition) &&
                void 0 !== i
                  ? i
                  : this.verticalTextPosition),
              (this.isEnabledProperty =
                null !== (o = null == e ? void 0 : e.isEnabled) && void 0 !== o
                  ? o
                  : this.isEnabledProperty);
          }
          get horizontalTextPosition() {
            return this.horizontalTextPositionProperty;
          }
          set horizontalTextPosition(e) {
            (this.horizontalTextPositionProperty = e), this.invalidateParent();
          }
          get verticalTextPosition() {
            return this.verticalTextPositionProperty;
          }
          set verticalTextPosition(e) {
            (this.verticalTextPositionProperty = e), this.invalidateParent();
          }
          get isEnabled() {
            return this.isEnabledProperty;
          }
          set isEnabled(e) {
            this.isEnabledProperty !== e &&
              ((this.isEnabledProperty = e), this.invalidateParent());
          }
          getPosition(e, t) {
            var r, o, a, s, n, l, h, u;
            let c = e.xCoord();
            this.horizontalTextPosition === d.EHorizontalTextPosition.Center
              ? (c -= t.m_fWidth / 2)
              : this.horizontalTextPosition === d.EHorizontalTextPosition.Left
              ? (c -=
                  t.m_fWidth +
                  (null !==
                    (o =
                      null === (r = this.style.padding) || void 0 === r
                        ? void 0
                        : r.right) && void 0 !== o
                    ? o
                    : 0))
              : (c +=
                  null !==
                    (s =
                      null === (a = this.style.padding) || void 0 === a
                        ? void 0
                        : a.right) && void 0 !== s
                    ? s
                    : 0);
            const p = t.m_fHeight - t.GetLineBounds(0).m_fHeight;
            let g = e.yCoord() - p;
            return (
              this.verticalTextPosition === d.EVerticalTextPosition.Center
                ? (g += t.m_fHeight / 2)
                : this.verticalTextPosition === d.EVerticalTextPosition.Below
                ? (g +=
                    t.m_fHeight +
                    (null !==
                      (l =
                        null === (n = this.style.padding) || void 0 === n
                          ? void 0
                          : n.top) && void 0 !== l
                      ? l
                      : 0))
                : (g -=
                    null !==
                      (u =
                        null === (h = this.style.padding) || void 0 === h
                          ? void 0
                          : h.bottom) && void 0 !== u
                      ? u
                      : 0),
              new i.Point(c, g)
            );
          }
          getColor(e, t) {
            return e.color;
          }
          generateDataLabels(e, t) {
            var r, i, s, n, h;
            if (
              ((this.dataLabels = []),
              !(
                this.isEnabled &&
                this.style &&
                this.style.fontFamily &&
                this.style.fontSize
              ))
            )
              return;
            const u = this.parentSeries.dataSeries;
            if (!u || !u.textValues)
              return void console.warn(
                "TextDataLabelProvider requires an XyTextDataSeries"
              );
            const c = new l.DataLabelState(
                e,
                t,
                this.style,
                this.color,
                t.pointSeries.yValues,
                this.parentSeries
              ),
              p = (0, a.getTextBounds)(this.webAssemblyContext),
              {
                fifoCapacity: g,
                fifoSweeping: y,
                fifoSweepingGap: f,
                fifoStartIndex: v,
              } = this.parentSeries.dataSeries,
              m = t.pointSeries.indexes,
              S =
                this.verticalTextPosition !== d.EVerticalTextPosition.Above ||
                this.horizontalTextPosition !==
                  d.EHorizontalTextPosition.Right ||
                this.calculateTextBounds;
            if (u) {
              c.font.CalculateStringBounds(
                null !== (r = u.getTextValue(0)) && void 0 !== r ? r : "",
                p,
                null !==
                  (s =
                    null === (i = this.style) || void 0 === i
                      ? void 0
                      : i.lineSpacing) && void 0 !== s
                  ? s
                  : 2
              );
              for (let e = 0; e < m.size(); e++) {
                c.index = e;
                const t = m.get(c.index);
                if (y && c.pointCount === g && c.index >= v && c.index < v + f)
                  continue;
                const r = u.getTextValue(t);
                S &&
                  c.font.CalculateStringBounds(
                    null != r ? r : "",
                    p,
                    null !==
                      (h =
                        null === (n = this.style) || void 0 === n
                          ? void 0
                          : n.lineSpacing) && void 0 !== h
                      ? h
                      : 2
                  );
                const i = this.getPosition(c, p),
                  a = p.GetLineBounds(0).m_fHeight,
                  s = {
                    text: r,
                    position: i,
                    rect: new o.Rect(i.x, i.y - a, p.m_fWidth, p.m_fHeight),
                    color: this.getColor(c, r),
                    dataX: c.xCoord(),
                    dataY: c.yCoord(),
                    rotationAngle: 0,
                    rotationCenter: i,
                  };
                this.dataLabels.push(s);
              }
            }
            this.onAfterGenerate(this.dataLabels);
          }
          onAfterGenerate(e) {}
          toJSON() {
            const e = super.toJSON(),
              t = {
                calculateTextBounds: this.calculateTextBounds,
                horizontalTextPosition: this.horizontalTextPosition,
                verticalTextPosition: this.verticalTextPosition,
                isEnabled: this.isEnabled,
              };
            return Object.assign(e.options, t), e;
          }
        }
        t.TextDataLabelProvider = h;
      },
      77110: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.dataLabelHelpers = void 0);
        const i = r(60960);
        t.dataLabelHelpers = {
          calcRectangleBorders: function (e, t, r, o, a, s, n, l) {
            let d = Math.min(a, n),
              h = Math.max(a, n);
            e === i.EColumnMode.Mid || e === i.EColumnMode.MidWidth
              ? ((d = a - n / 2), (h = a + n / 2))
              : e === i.EColumnMode.Start
              ? ((d = a), (h = a + n))
              : e === i.EColumnMode.StartWidth &&
                (r ? ((d = a - n), (h = a)) : ((d = a), (h = a + n)));
            let u = Math.min(s, l),
              c = Math.max(s, l);
            return (
              t === i.EColumnYMode.CenterHeight
                ? ((u = s - l / 2), (c = s + l / 2))
                : t === i.EColumnYMode.TopHeight &&
                  (o ? ((u = s - l), (c = s)) : ((u = s), (c = s + l))),
              { xMin: d, xMax: h, yMin: u, yMax: c }
            );
          },
        };
      },
      7807: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BandSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(21915),
          s = r(16185),
          n = r(14184),
          l = r(20977),
          d = r(65043);
        class h extends d.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r),
              (this.args = new this.webAssemblyContext.SCRTBandDrawingParams()),
              (this.y1Selector = null != i ? i : (e) => e.y1Values),
              (this.linesPenCache = new a.Pen2DCache(e)),
              (this.strokePenY1Cache = new a.Pen2DCache(e)),
              (this.fillBrushCache = new o.BrushCache(e)),
              (this.fillBrushY1Cache = new o.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTBandSeriesDrawingProvider());
            const {
                parentSurface: e,
                stroke: t,
                strokeThickness: r,
                fill: i,
                strokeY1: o,
                fillY1: s,
                opacity: l,
                strokeDashArray: d,
                strokeY1DashArray: h,
                fillLinearGradient: u,
                fillLinearGradientY1: c,
                customTextureOptions: p,
              } = this.parentSeries,
              g = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.height /
                  n.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              y = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.width /
                  n.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            (0, a.createPenInCache)(this.linesPenCache, t, r, l, d),
              (0, a.createPenInCache)(this.strokePenY1Cache, o, r, l, h),
              this.fillBrushCache.create(i, l, g, y, u, p),
              this.fillBrushY1Cache.create(s, l, g, y, c, p);
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.linesPenCache = (0, i.deleteSafe)(this.linesPenCache)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              (this.strokePenY1Cache = (0, i.deleteSafe)(
                this.strokePenY1Cache
              )),
              (this.fillBrushY1Cache = (0, i.deleteSafe)(
                this.fillBrushY1Cache
              )),
              super.delete();
          }
          draw(e, t) {
            var r;
            const i = t.pointSeries,
              n =
                this.parentSeries.dataSeries.dataDistributionCalculator
                  .containsNaN;
            this.args.Reset(),
              (this.args.forceShaderMethod = !0),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.lineGaps = n
                ? this.parentSeries.drawNaNAs ===
                  s.ELineDrawMode.DiscontinuousLine
                  ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                  : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
                : this.webAssemblyContext.SCRTLineGapMode.Default),
              (this.args.isDigitalLine = this.parentSeries.isDigitalLine);
            const l = (0, o.getScrtBrushFromCache)(this.fillBrushCache);
            l && this.args.SetFillBrush(l);
            const d = (0, a.getScrtPenFromCache)(this.linesPenCache);
            d && this.args.SetLinesPen(d);
            const h = (0, o.getScrtBrushFromCache)(this.fillBrushY1Cache);
            h && this.args.SetFillBrush1(h);
            const u = (0, a.getScrtPenFromCache)(this.strokePenY1Cache);
            u && this.args.SetLinesPen1(u);
            const c = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              p = i.xValues,
              {
                fifoCapacity: g,
                fifoSweeping: y,
                fifoSweepingGap: f,
              } = this.parentSeries.dataSeries,
              v = i.fifoStartIndex;
            let m = c ? i.indexes : p,
              S = this.ySelector(i),
              P = this.y1Selector(i);
            const { startIndex: C, count: b } = this.getStartAndCount(t, m);
            (this.args.count = b),
              (this.args.startIndex = C),
              g > 0 &&
                y &&
                g === this.parentSeries.dataSeries.count() &&
                (this.args.count = v),
              super.applyStrokeFillPaletting(
                void 0,
                void 0,
                void 0,
                void 0,
                this.parentSeries.opacity,
                !0,
                !0,
                t
              );
            const x =
              null === (r = this.palettingState.paletteTextureCache) ||
              void 0 === r
                ? void 0
                : r.value;
            x && this.args.SetPalette(x),
              (this.args.isSmoothColors =
                this.palettingState.gradientPaletting);
            const A = e.getNativeContext();
            this.nativeDrawingProvider.DrawPointsVec(
              A,
              m,
              S,
              P,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              g > 0 &&
                y &&
                g === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(S.size(), v + f)),
                (this.args.count = Math.max(0, S.size() - v - f)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPointsVec(
                    A,
                    m,
                    S,
                    P,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(l.PROPERTY.STROKE),
              this.onSeriesPropertyChange(l.PROPERTY.STROKE_Y1);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              parentSurface: t,
              stroke: r,
              strokeY1: i,
              strokeThickness: o,
              fill: s,
              fillY1: d,
              opacity: h,
              strokeDashArray: u,
              strokeY1DashArray: c,
              fillLinearGradient: p,
              fillLinearGradientY1: g,
              customTextureOptions: y,
            } = this.parentSeries;
            if (
              e === l.PROPERTY.STROKE ||
              e === l.PROPERTY.STROKE_THICKNESS ||
              e === l.PROPERTY.OPACITY ||
              e === l.PROPERTY.STROKE_DASH_ARRAY
            )
              return (
                (this.palettingState.requiresUpdate = !0),
                void (0, a.createPenInCache)(this.linesPenCache, r, o, h, u)
              );
            if (
              e === l.PROPERTY.STROKE_Y1 ||
              e === l.PROPERTY.STROKE_THICKNESS ||
              e === l.PROPERTY.OPACITY ||
              e === l.PROPERTY.STROKE_Y1_DASH_ARRAY
            )
              return (
                (this.palettingState.requiresUpdate = !0),
                void (0, a.createPenInCache)(this.strokePenY1Cache, i, o, h, c)
              );
            const f = (null == t ? void 0 : t.isCopyCanvasSurface)
                ? t.domCanvas2D.height /
                  n.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              v = (null == t ? void 0 : t.isCopyCanvasSurface)
                ? t.domCanvas2D.width /
                  n.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            (e !== l.PROPERTY.FILL &&
              e !== l.PROPERTY.OPACITY &&
              e !== l.PROPERTY.FILL_LINEAR_GRADIENT &&
              e != l.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
              ((this.palettingState.requiresUpdate = !0),
              this.fillBrushCache.create(s, h, f, v, p, y)),
              (e !== l.PROPERTY.FILL_Y1 &&
                e !== l.PROPERTY.OPACITY &&
                e !== l.PROPERTY.FILL_LINEAR_GRADIENT_Y1 &&
                e != l.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                ((this.palettingState.requiresUpdate = !0),
                this.fillBrushY1Cache.create(d, h, f, v, g, y));
          }
        }
        t.BandSeriesDrawingProvider = h;
      },
      65043: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseSeriesDrawingProvider = void 0);
        const i = r(55023),
          o = r(56744),
          a = r(23866),
          s = r(22950),
          n = r(8591),
          l = r(48008),
          d = r(59348),
          h = r(32747),
          u = r(33841),
          c = r(20977);
        class p extends i.DeletableEntity {
          constructor(e, t, r, i) {
            var o;
            super(),
              a.Guard.notNull(e, "webAssemblyContext"),
              a.Guard.notNull(t, "parentSeries"),
              (this.webAssemblyContext = e),
              (this.parentSeries = t),
              i && (this.xSelector = i),
              r && (this.ySelector = r),
              (this.palettingState = {
                palettedColors: void 0,
                palettedColorsHashCode: 0,
                gradientPaletting: !1,
                paletteTextureCache: new d.PaletteCache(e),
                requiresUpdate: !0,
              }),
              (this.seriesHasDataChanges =
                this.seriesHasDataChanges.bind(this)),
              (this.parentDataSeries = this.parentSeries.dataSeries),
              null === (o = this.parentDataSeries) ||
                void 0 === o ||
                o.dataChanged.subscribe(this.seriesHasDataChanges);
          }
          xSelector(e) {
            return e.xValues;
          }
          ySelector(e) {
            const t = this.parentSeries.yArrayFilter;
            return t
              ? "number" == typeof t
                ? e.getYValues(t, !1)
                : e.getYValuesByName(t, !1)
              : e.yValues;
          }
          getStartAndCount(e, t) {
            var r, i, o;
            const a = null == e ? void 0 : e.pointSeries,
              s =
                null === (r = this.parentSeries) || void 0 === r
                  ? void 0
                  : r.xAxis,
              n =
                null === (i = null == s ? void 0 : s.clipToXRange) ||
                void 0 === i ||
                i;
            let l = t.size(),
              d = Math.min(a ? a.xValues.size() : l, l),
              h = 0;
            return (
              n &&
                !(null == a ? void 0 : a.resampled) &&
                (null === (o = null == e ? void 0 : e.indexRange) ||
                void 0 === o
                  ? void 0
                  : o.diff) >= 0 &&
                (e.indexRange.diff + 1 < d && (h = e.indexRange.min),
                (d = Math.min(e.indexRange.diff + 1, d))),
              { startIndex: h, count: d }
            );
          }
          applyStrokePaletting(e, t) {
            var r, i, o, a;
            const n = this.parentSeries.paletteProvider;
            if (
              this.parentSeries.hasStrokePaletteProvider() ||
              void 0 !== n.applyPaletting
            ) {
              const a = (0, s.uintArgbColorMultiplyOpacity)(
                (0, l.parseColorToUIntArgb)(this.parentSeries.stroke),
                this.parentSeries.opacity
              );
              if (isNaN(a))
                throw Error(
                  "applyStrokePaletting(): renderSeries.stroke " +
                    this.parentSeries.stroke +
                    " cannot be converted to a valid color"
                );
              const d = this.parentSeries.paletteProvider,
                u = this.parentSeries.dataSeries,
                c =
                  null ==
                  (t =
                    null != t
                      ? t
                      : this.parentSeries.getCurrentRenderPassData())
                    ? void 0
                    : t.pointSeries,
                p =
                  null !== (r = c ? this.xSelector(c) : void 0) && void 0 !== r
                    ? r
                    : u.getNativeXValues(),
                g =
                  null !== (i = c ? this.ySelector(c) : void 0) && void 0 !== i
                    ? i
                    : u.getNativeYValues(),
                { startIndex: y, count: f } = this.getStartAndCount(t, p);
              if (
                (this.palettingState.palettedColors ||
                  (this.palettingState.palettedColors =
                    new this.webAssemblyContext.UIntVector()),
                (this.palettingState.originalPenColor = e.m_uiColor),
                (e.m_uiColor = 4294967295),
                (e.m_bGradient =
                  d.strokePaletteMode === h.EStrokePaletteMode.GRADIENT),
                n.applyPaletting)
              )
                return void n.applyPaletting(
                  this.palettingState,
                  p,
                  g,
                  null !== (o = null == c ? void 0 : c.indexes) && void 0 !== o
                    ? o
                    : u.getNativeIndexes(),
                  y,
                  f
                );
              if (
                (this.shouldUpdatePalette(t, d, y, f, !1),
                !this.palettingState.requiresUpdate)
              )
                return;
              this.palettingState.palettedColors.clear(),
                this.palettingState.palettedColors.reserve(f);
              const v = c && c.indexes.size() > 0;
              for (let e = y; e < y + f; e++) {
                let t = v ? c.indexes.get(e) : e;
                t < 0 ? (t = 0) : t >= u.count() && (t = u.count() - 1);
                const r = p.get(e),
                  i = g ? g.get(e) : void 0,
                  o = d.overrideStrokeArgb(
                    r,
                    i,
                    t,
                    this.parentSeries.opacity,
                    u.getMetadataAt(t)
                  );
                this.parentSeries.pushPalettedColors(
                  o || a,
                  this.palettingState
                );
              }
              this.palettingState.requiresUpdate = !1;
            } else
              this.palettingState.originalPenColor &&
                ((e.m_uiColor = this.palettingState.originalPenColor),
                (this.palettingState.originalPenColor = void 0)),
                null === (a = this.palettingState.palettedColors) ||
                  void 0 === a ||
                  a.clear();
            this.palettingState.palettedColors ||
              (this.palettingState.palettedColors =
                new this.webAssemblyContext.UIntVector());
          }
          applyStrokeFillPaletting(e, t, r, i, o, a = !1, d = !0, u) {
            var c, p, g, y, f, v;
            const m = this.parentSeries.hasStrokePaletteProvider(),
              S = this.parentSeries.hasFillPaletteProvider(),
              P = this.parentSeries.hasPointMarkerPaletteProvider(),
              C = this.parentSeries.paletteProvider,
              b = this.parentSeries.paletteProvider,
              x = void 0 !== (null == b ? void 0 : b.applyPaletting);
            if (m || S || P || x) {
              let v, S;
              if (a)
                v = S =
                  this.webAssemblyContext.SCRTPalette.GetNoOverrideColorCode();
              else {
                const t = void 0 !== o;
                (v =
                  e && t
                    ? (0, s.uintArgbColorMultiplyOpacity)(
                        (0, l.parseColorToUIntArgb)(e),
                        o
                      )
                    : 4294967295),
                  (S =
                    r && t
                      ? (0, s.uintArgbColorMultiplyOpacity)(
                          (0, l.parseColorToUIntArgb)(r),
                          o
                        )
                      : 4294967295);
              }
              if (isNaN(v))
                throw Error(
                  "updatePalette(): parentSeries.stroke " +
                    e +
                    " cannot be converted to a valid color"
                );
              if (isNaN(S))
                throw Error(
                  "updatePalette(): fillColor " +
                    S +
                    " cannot be converted to a valid color"
                );
              const P = this.parentSeries.dataSeries,
                x =
                  null ==
                  (u =
                    null != u
                      ? u
                      : this.parentSeries.getCurrentRenderPassData())
                    ? void 0
                    : u.pointSeries,
                A =
                  null !== (c = x ? this.xSelector(x) : void 0) && void 0 !== c
                    ? c
                    : P.getNativeXValues(),
                T =
                  null !== (p = x ? this.ySelector(x) : void 0) && void 0 !== p
                    ? p
                    : P.getNativeYValues(),
                { startIndex: E, count: R } = this.getStartAndCount(u, A);
              if (
                (this.palettingState.palettedColors ||
                  (this.palettingState.palettedColors =
                    new this.webAssemblyContext.UIntVector()),
                b.applyPaletting)
              )
                return void b.applyPaletting(
                  this.palettingState,
                  A,
                  T,
                  null !== (g = null == x ? void 0 : x.indexes) && void 0 !== g
                    ? g
                    : P.getNativeIndexes(),
                  E,
                  R
                );
              if (
                (this.shouldUpdatePalette(u, C, E, R, !0),
                !this.palettingState.requiresUpdate)
              )
                return;
              this.palettingState.paletteTextureCache.reset(),
                this.palettingState.palettedColors.clear(),
                this.palettingState.palettedColors.reserve(2 * R),
                d &&
                  (t &&
                    m &&
                    ((this.palettingState.originalPenColor = t.m_uiColor),
                    (t.m_uiColor = 4294967295),
                    (this.palettingState.originalPenGradient = t.m_bGradient),
                    (t.m_bGradient =
                      C.strokePaletteMode === h.EStrokePaletteMode.GRADIENT)),
                  i &&
                    ((this.palettingState.originalBrushColor = i.GetColor()),
                    i.SetColor(4294967295)));
              let D = 0;
              const w = x && x.indexes.size() > 0;
              for (let e = E; e < E + R; e++) {
                let t = w ? x.indexes.get(e) : e;
                t < 0 ? (t = 0) : t >= P.count() && (t = P.count() - 1);
                const r = A.get(e),
                  i = T ? T.get(e) : void 0,
                  s = this.overridePaletteProviderColors(
                    this.parentSeries,
                    r,
                    i,
                    t,
                    o,
                    P.getMetadataAt(t)
                  ),
                  l = null !== (y = s.stroke) && void 0 !== y ? y : v,
                  d = null !== (f = s.fill) && void 0 !== f ? f : S;
                this.palettingState.palettedColors.push_back(l),
                  this.palettingState.palettedColors.push_back(d),
                  a &&
                    ((D = (0, n.numericHashCode)(D, l)),
                    (D = (0, n.numericHashCode)(D, d)));
              }
              a &&
                (this.palettingState.palettedColorsHashCode !== D &&
                  this.palettingState.paletteTextureCache.reset(),
                this.palettingState.paletteTextureCache.create(
                  this.palettingState.palettedColors
                ),
                (this.palettingState.palettedColorsHashCode = D)),
                (this.palettingState.requiresUpdate = !1);
            } else
              this.palettingState.paletteTextureCache.reset(),
                null === (v = this.palettingState.palettedColors) ||
                  void 0 === v ||
                  v.clear(),
                t &&
                  (this.palettingState.originalPenColor &&
                    ((t.m_uiColor = this.palettingState.originalPenColor),
                    (this.palettingState.originalPenColor = void 0)),
                  this.palettingState.originalPenGradient &&
                    ((t.m_bGradient = this.palettingState.originalPenGradient),
                    (this.palettingState.originalPenGradient = void 0))),
                i &&
                  this.palettingState.originalBrushColor &&
                  (i.SetColor(this.palettingState.originalBrushColor),
                  (this.palettingState.originalBrushColor = void 0));
            this.palettingState.palettedColors ||
              (this.palettingState.palettedColors =
                new this.webAssemblyContext.UIntVector()),
              (this.palettingState.gradientPaletting =
                this.isGradientFillPaletting(this.parentSeries));
          }
          createSolidBrush(e, t) {
            return (0, u.createSolidBrush)(this.webAssemblyContext, e, t);
          }
          delete() {
            var e;
            this.palettingState.palettedColors &&
              (this.palettingState.palettedColors = (0, o.deleteSafe)(
                this.palettingState.palettedColors
              )),
              (this.palettingState.paletteTextureCache = (0, o.deleteSafe)(
                this.palettingState.paletteTextureCache
              )),
              (this.parentDataSeries = this.parentSeries.dataSeries),
              null === (e = this.parentDataSeries) ||
                void 0 === e ||
                e.dataChanged.unsubscribe(this.seriesHasDataChanges);
          }
          onSeriesPropertyChange(e) {
            var t, r;
            e === c.PROPERTY.DATA_SERIES &&
              (null === (t = this.parentDataSeries) ||
                void 0 === t ||
                t.dataChanged.unsubscribe(this.seriesHasDataChanges),
              (this.parentDataSeries = this.parentSeries.dataSeries),
              null === (r = this.parentDataSeries) ||
                void 0 === r ||
                r.dataChanged.subscribe(this.seriesHasDataChanges),
              (this.palettingState.requiresUpdate = !0));
          }
          onDpiChanged(e) {}
          onAttachSeries() {}
          onDetachSeries() {}
          seriesHasDataChanges() {
            this.palettingState.requiresUpdate = !0;
          }
          shouldUpdatePalette(e, t, r, i, o) {
            var a, s, n, l, d, h;
            (null === (a = null == e ? void 0 : e.pointSeries) || void 0 === a
              ? void 0
              : a.resampled) &&
              (null == e ? void 0 : e.resamplingHash) !==
                this.palettingState.lastResamplingHash &&
              ((this.palettingState.lastResamplingHash =
                null == e ? void 0 : e.resamplingHash),
              (this.palettingState.requiresUpdate = !0)),
              null !== (s = t.isRangeIndependant) && void 0 !== s && s
                ? (null !== (d = this.palettingState.lastStartIndex) &&
                  void 0 !== d
                    ? d
                    : Number.MAX_SAFE_INTEGER) > r ||
                  (null !== (h = this.palettingState.lastCount) && void 0 !== h
                    ? h
                    : 0) < i ||
                  r + i >
                    this.palettingState.lastStartIndex +
                      this.palettingState.lastCount
                  ? ((this.palettingState.lastStartIndex = r),
                    (this.palettingState.lastCount = i),
                    (this.palettingState.requiresUpdate = !0),
                    (this.palettingState.paletteStartIndex = 0))
                  : (this.palettingState.paletteStartIndex =
                      r * (o ? 2 : 1) - this.palettingState.lastStartIndex)
                : ((null !== (n = this.palettingState.lastStartIndex) &&
                  void 0 !== n
                    ? n
                    : 0) === r &&
                    (null !== (l = this.palettingState.lastCount) &&
                    void 0 !== l
                      ? l
                      : 0) === i) ||
                  ((this.palettingState.lastStartIndex = r),
                  (this.palettingState.lastCount = i),
                  (this.palettingState.requiresUpdate = !0),
                  (this.palettingState.paletteStartIndex = 0)),
              (t.shouldUpdatePalette && !t.shouldUpdatePalette()) ||
                (this.palettingState.requiresUpdate = !0);
          }
          overridePaletteProviderColors(e, t, r, i, o, a) {
            let s, n;
            return (
              e.hasStrokePaletteProvider() &&
                (s = e.paletteProvider.overrideStrokeArgb(t, r, i, o, a)),
              e.hasFillPaletteProvider() &&
                (n = e.paletteProvider.overrideFillArgb(t, r, i, o, a)),
              { stroke: s, fill: n }
            );
          }
          isGradientFillPaletting(e) {
            return (
              !!e.hasFillPaletteProvider() &&
              e.paletteProvider.fillPaletteMode === h.EFillPaletteMode.GRADIENT
            );
          }
        }
        t.BaseSeriesDrawingProvider = p;
      },
      79687: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxPlotSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(60960),
          a = r(51269),
          s = r(21915),
          n = r(14184),
          l = r(20977),
          d = r(65043);
        class h extends d.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i);
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.capPenCache = new s.Pen2DCache(this.webAssemblyContext)),
              (this.whiskersPenCache = new s.Pen2DCache(
                this.webAssemblyContext
              )),
              (this.medianLinePenCache = new s.Pen2DCache(
                this.webAssemblyContext
              )),
              (this.boxPenCache = new s.Pen2DCache(this.webAssemblyContext)),
              (this.boxFillBrushCache = new a.BrushCache(
                this.webAssemblyContext
              )),
              (this.nativeBoxDrawingProvider =
                new this.webAssemblyContext.SCRTRectangleSeriesDrawingProvider()),
              (this.boxArgs =
                new this.webAssemblyContext.SCRTRectangleDrawingParams()),
              (this.nativeLineDrawingProvider =
                new this.webAssemblyContext.SCRTLineSegmentDrawingProvider()),
              (this.lineArgs =
                new this.webAssemblyContext.SCRTLineSegmentDrawingParams()),
              (this.tempXVec = new this.webAssemblyContext.SCRTDoubleVector()),
              (this.tempYVec = new this.webAssemblyContext.SCRTDoubleVector());
            const {
              capStroke: e,
              capStrokeDashArray: t,
              capStrokeThickness: r,
              whiskersStroke: i,
              whiskersStrokeDashArray: o,
              whiskersStrokeThickness: n,
              medianStroke: l,
              medianStrokeDashArray: d,
              medianStrokeThickness: h,
              boxStroke: u,
              boxStrokeThickness: c,
              boxStrokeDashArray: p,
              opacity: g,
            } = this.getProperties();
            (0, s.createPenInCache)(this.capPenCache, e, r, g, t, !1),
              (0, s.createPenInCache)(this.whiskersPenCache, i, n, g, o, !1),
              (0, s.createPenInCache)(this.medianLinePenCache, l, h, g, d, !1),
              (0, s.createPenInCache)(this.boxPenCache, u, c, g, p, !1),
              this.createBoxBrush();
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          getProperties() {
            const {
              dataPointWidthMode: e,
              cap: {
                dataPointWidth: t,
                stroke: r,
                strokeDashArray: i,
                strokeThickness: o,
              },
              whiskers: { stroke: a, strokeDashArray: s, strokeThickness: n },
              medianLine: { stroke: l, strokeDashArray: d, strokeThickness: h },
              dataPointWidth: u,
              stroke: c,
              strokeThickness: p,
              strokeDashArray: g,
              fill: y,
              fillLinearGradient: f,
              opacity: v,
            } = this.parentSeries;
            return {
              dataPointWidthMode: e,
              capDataPointWidth: t,
              capStroke: r,
              capStrokeDashArray: i,
              capStrokeThickness: o,
              whiskersStroke: a,
              whiskersStrokeDashArray: s,
              whiskersStrokeThickness: n,
              medianStroke: l,
              medianStrokeDashArray: d,
              medianStrokeThickness: h,
              boxDataPointWidth: u,
              boxStroke: c,
              boxStrokeThickness: p,
              boxStrokeDashArray: g,
              boxFill: y,
              boxFillLinearGradient: f,
              opacity: null != v ? v : 1,
            };
          }
          delete() {
            (this.capPenCache = (0, i.deleteSafe)(this.capPenCache)),
              (this.whiskersPenCache = (0, i.deleteSafe)(
                this.whiskersPenCache
              )),
              (this.medianLinePenCache = (0, i.deleteSafe)(
                this.medianLinePenCache
              )),
              (this.boxPenCache = (0, i.deleteSafe)(this.boxPenCache)),
              (this.boxFillBrushCache = (0, i.deleteSafe)(
                this.boxFillBrushCache
              )),
              (this.nativeBoxDrawingProvider = (0, i.deleteSafe)(
                this.nativeBoxDrawingProvider
              )),
              (this.boxArgs = (0, i.deleteSafe)(this.boxArgs)),
              (this.nativeLineDrawingProvider = (0, i.deleteSafe)(
                this.nativeLineDrawingProvider
              )),
              (this.lineArgs = (0, i.deleteSafe)(this.lineArgs)),
              (this.tempXVec = (0, i.deleteSafe)(this.tempXVec)),
              (this.tempYVec = (0, i.deleteSafe)(this.tempYVec)),
              super.delete();
          }
          drawBoxes(e, t) {
            const r = t.pointSeries,
              i = this.parentSeries.parentSurface.seriesViewRect,
              {
                boxStroke: n,
                boxFill: l,
                opacity: d,
                boxFillLinearGradient: h,
              } = this.getProperties();
            this.boxArgs.Reset(),
              (this.boxArgs.verticalChart = t.isVerticalChart),
              (this.boxArgs.columnWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                this.parentSeries.dataPointWidth,
                this.parentSeries.dataPointWidthMode
              )),
              (this.boxArgs.xMode = (0, o.convertColumnMode)(
                o.EColumnMode.Mid,
                this.webAssemblyContext
              )),
              (this.boxArgs.yMode = (0, o.convertYColumnMode)(
                o.EColumnYMode.TopBottom,
                this.webAssemblyContext
              ));
            const u = (0, s.getScrtPenFromCache)(this.boxPenCache);
            u && this.boxArgs.SetLinesPen(u);
            const c = (0, a.getScrtBrushFromCache)(this.boxFillBrushCache);
            c && this.boxArgs.SetFillBrush(c),
              (this.boxArgs.viewportWidth = i.width),
              (this.boxArgs.viewportHeight = i.height),
              super.applyStrokeFillPaletting(n, u, l, c, d, !1, void 0 !== h),
              this.boxArgs.SetPalettedColors(
                this.palettingState.palettedColors
              ),
              (this.boxArgs.paletteStart =
                2 * this.palettingState.paletteStartIndex);
            const p = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              g = r.xValues,
              y = r.upperQuartileValues,
              f = r.lowerQuartileValues,
              v = p ? r.indexes : g,
              { startIndex: m, count: S } = this.getStartAndCount(t, v);
            (this.boxArgs.count = S),
              (this.boxArgs.startIndex = m),
              this.boxArgs.SetX(v),
              this.boxArgs.SetY(y),
              this.boxArgs.SetY2(f);
            const {
                fifoCapacity: P,
                fifoSweeping: C,
                fifoSweepingGap: b,
              } = this.parentSeries.dataSeries,
              x = r.fifoStartIndex;
            C &&
              P === this.parentSeries.dataSeries.count() &&
              (this.boxArgs.count = x);
            const A = e.getNativeContext();
            this.nativeBoxDrawingProvider.DrawPoints(
              A,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.boxArgs
            ),
              C &&
                P === this.parentSeries.dataSeries.count() &&
                ((this.boxArgs.startIndex = Math.min(y.size(), x + b)),
                (this.boxArgs.count = Math.max(0, y.size() - x - b)),
                this.boxArgs.count > 0 &&
                  this.nativeBoxDrawingProvider.DrawPoints(
                    A,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.boxArgs
                  ));
          }
          drawWhiskers(e, t, r, i) {
            const o = t.pointSeries,
              a = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              { startIndex: n, count: l } = this.getStartAndCount(t, o.xValues),
              d = a ? o.indexes : o.xValues,
              h = (0, s.getScrtPenFromCache)(this.whiskersPenCache);
            h &&
              (this.lineArgs.Reset(),
              (this.lineArgs.fourVectorsMode = !0),
              this.lineArgs.SetY2(i),
              this.lineArgs.SetLinesPen(h),
              (this.lineArgs.forceShaderMethod = !0),
              (this.lineArgs.verticalChart = t.isVerticalChart),
              (this.lineArgs.count = l),
              (this.lineArgs.startIndex = n),
              this.nativeLineDrawingProvider.DrawLinesVec(
                e.getNativeContext(),
                d,
                r,
                t.xCoordinateCalculator.nativeCalculator,
                t.yCoordinateCalculator.nativeCalculator,
                this.lineArgs
              ));
          }
          drawLines(e, t, r, i) {
            r &&
              (this.lineArgs.Reset(),
              this.lineArgs.SetLinesPen(r),
              (this.lineArgs.forceShaderMethod = !0),
              (this.lineArgs.forceClamp = !0),
              (this.lineArgs.verticalChart = t.isVerticalChart),
              (this.lineArgs.count = i),
              (this.lineArgs.startIndex = 0),
              this.nativeLineDrawingProvider.DrawLinesVec(
                e.getNativeContext(),
                this.tempXVec,
                this.tempYVec,
                t.xCoordinateCalculator.nativeCalculator,
                t.yCoordinateCalculator.nativeCalculator,
                this.lineArgs
              ));
          }
          prepareTempCapVectors(e, t, r, i, o) {
            this.tempXVec.clear(), this.tempYVec.clear();
            const { capDataPointWidth: a, dataPointWidthMode: s } =
                this.getProperties(),
              n = this.parentSeries.getDataPointWidth(i, a, s),
              l = 0.5 * i.getDataWidth(n),
              { minimumValues: d, maximumValues: h } = r,
              u = o ? r.indexes : r.xValues;
            for (let r = e; r < t; r++) {
              const e = u.get(r),
                t = d.get(r),
                i = h.get(r);
              this.tempXVec.push_back(e - l),
                this.tempYVec.push_back(i),
                this.tempXVec.push_back(e + l),
                this.tempYVec.push_back(i),
                this.tempXVec.push_back(e - l),
                this.tempYVec.push_back(t),
                this.tempXVec.push_back(e + l),
                this.tempYVec.push_back(t);
            }
            return 4 * t;
          }
          prepareTempMedianVectors(e, t, r, i, o) {
            this.tempXVec.clear(), this.tempYVec.clear();
            const { boxDataPointWidth: a, dataPointWidthMode: s } =
                this.getProperties(),
              n = this.parentSeries.getDataPointWidth(i, a, s),
              l = 0.5 * i.getDataWidth(n),
              { medianValues: d } = r,
              h = o ? r.indexes : r.xValues;
            for (let r = e; r < t; r++) {
              const e = h.get(r),
                t = d.get(r);
              this.tempXVec.push_back(e - l),
                this.tempYVec.push_back(t),
                this.tempXVec.push_back(e + l),
                this.tempYVec.push_back(t);
            }
            return 2 * t;
          }
          draw(e, t) {
            const r = t.pointSeries,
              i = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              { startIndex: o, count: a } = this.getStartAndCount(t, r.xValues);
            this.drawWhiskers(e, t, r.lowerQuartileValues, r.minimumValues),
              this.drawWhiskers(e, t, r.upperQuartileValues, r.maximumValues),
              this.drawLines(
                e,
                t,
                (0, s.getScrtPenFromCache)(this.capPenCache),
                this.prepareTempCapVectors(o, a, r, t.xCoordinateCalculator, i)
              ),
              this.drawBoxes(e, t),
              this.drawLines(
                e,
                t,
                (0, s.getScrtPenFromCache)(this.medianLinePenCache),
                this.prepareTempMedianVectors(
                  o,
                  a,
                  r,
                  t.xCoordinateCalculator,
                  i
                )
              );
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(l.PROPERTY.OPACITY);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              boxStroke: t,
              boxStrokeThickness: r,
              opacity: i,
              boxStrokeDashArray: o,
              capStroke: a,
              capStrokeThickness: n,
              capStrokeDashArray: d,
              whiskersStroke: h,
              whiskersStrokeDashArray: u,
              whiskersStrokeThickness: c,
              medianStroke: p,
              medianStrokeDashArray: g,
              medianStrokeThickness: y,
            } = this.getProperties();
            (e !== l.PROPERTY.STROKE &&
              e !== l.PROPERTY.STROKE_THICKNESS &&
              e !== l.PROPERTY.OPACITY &&
              e !== l.PROPERTY.STROKE_DASH_ARRAY) ||
              (0, s.createPenInCache)(this.boxPenCache, t, r, i, o, !1),
              (e !== l.PROPERTY.OPACITY &&
                e !== l.PROPERTY.FILL &&
                e !== l.PROPERTY.FILL_LINEAR_GRADIENT) ||
                this.createBoxBrush(),
              (e !== l.PROPERTY.OPACITY && e !== l.PROPERTY.BOX_SERIES_CAP) ||
                (0, s.createPenInCache)(this.capPenCache, a, n, i, d, !1),
              (e !== l.PROPERTY.OPACITY &&
                e !== l.PROPERTY.BOX_SERIES_WHISKERS) ||
                (0, s.createPenInCache)(this.whiskersPenCache, h, c, i, u, !1),
              (e !== l.PROPERTY.OPACITY &&
                e !== l.PROPERTY.BOX_SERIES_MEDIAN) ||
                (0, s.createPenInCache)(
                  this.medianLinePenCache,
                  p,
                  y,
                  i,
                  g,
                  !1
                );
          }
          createBoxBrush() {
            const e = this.parentSeries.parentSurface,
              {
                opacity: t,
                boxFill: r,
                boxFillLinearGradient: i,
              } = this.getProperties(),
              o = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.height /
                  n.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              s = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.width /
                  n.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            return (0, a.createBrushInCache)(
              this.boxFillBrushCache,
              r,
              t,
              o,
              s,
              i
            );
          }
        }
        t.BoxPlotSeriesDrawingProvider = h;
      },
      9297: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BubbleSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(86127),
          a = r(65043);
        class s extends a.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTBubbleSeriesDrawingProvider()),
              (this.args =
                new this.webAssemblyContext.SCRTPointDrawingParams());
          }
          onSeriesPropertyChange(e) {}
          draw(e, t) {
            var r;
            const i = this.parentSeries.pointMarker;
            if (void 0 === i) return;
            const a = i.getSprite(),
              s = t.pointSeries,
              n = t.xCoordinateCalculator.isCategoryCoordinateCalculator;
            this.args.Reset();
            const l = s.xValues,
              d = s.yValues,
              h = s.zValues,
              { startIndex: u, count: c } = this.getStartAndCount(t, l);
            (this.args.count = c), (this.args.startIndex = u);
            const {
                fifoCapacity: p,
                fifoSweeping: g,
                fifoSweepingGap: y,
              } = this.parentSeries.dataSeries,
              f = s.fifoStartIndex;
            g &&
              p === this.parentSeries.dataSeries.count() &&
              (this.args.count = f),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.forceShaderMethod = !0),
              this.args.SetSpriteTexture(a.getTexture()),
              super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                void 0,
                void 0,
                void 0,
                this.parentSeries.opacity
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.paletteStart =
                null !== (r = this.palettingState.paletteStartIndex) &&
                void 0 !== r
                  ? r
                  : 0),
              (this.args.zMultiplier =
                this.parentSeries.zMultiplier * o.DpiHelper.PIXEL_RATIO);
            let v = n ? s.indexes : l;
            const m = e.getNativeContext();
            this.drawPoints(
              m,
              v,
              d,
              h,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            ),
              g &&
                p === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(d.size(), f + y)),
                (this.args.count = Math.max(0, d.size() - f - y)),
                this.args.count > 0 &&
                  this.drawPoints(
                    m,
                    v,
                    d,
                    h,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args,
                    this.parentSeries.parentSurface.seriesViewRect
                  ));
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
          overridePaletteProviderColors(e, t, r, i, o, a) {
            if (e.hasPointMarkerPaletteProvider()) {
              const s = e.paletteProvider.overridePointMarkerArgb(
                t,
                r,
                i,
                o,
                a
              );
              if (s) return s;
            }
            return { stroke: void 0, fill: void 0 };
          }
          isGradientFillPaletting(e) {
            return !1;
          }
          drawPoints(e, t, r, i, o, a, s, n) {
            this.nativeDrawingProvider.DrawPointsVec(e, t, r, i, o, a, s);
          }
        }
        t.BubbleSeriesDrawingProvider = s;
      },
      50836: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(21915),
          s = r(14184),
          n = r(20977),
          l = r(65043);
        class d extends l.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i),
              (this.nativeDrawingProvider =
                new e.SCRTColumnSeriesDrawingProvider()),
              (this.args =
                new this.webAssemblyContext.SCRTColumnDrawingParams()),
              (this.strokePenCache = new a.Pen2DCache(e)),
              (this.strokePenFillColoredCache = new a.Pen2DCache(e)),
              (this.fillBrushCache = new o.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries();
            const {
              stroke: e,
              strokeThickness: t,
              fill: r,
              opacity: i,
            } = this.getProperties(this.parentSeries);
            (0, a.createPenInCache)(this.strokePenCache, e, t, i),
              0 === t &&
                (0, a.createPenInCache)(
                  this.strokePenFillColoredCache,
                  r,
                  1,
                  i
                ),
              this.createBrush();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.strokePenFillColoredCache = (0, i.deleteSafe)(
                this.strokePenFillColoredCache
              )),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          getProperties(e) {
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            } = e;
            return {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            };
          }
          draw(e, t) {
            const r = t.pointSeries,
              i = this.parentSeries.parentSurface.seriesViewRect,
              { strokeThickness: s } = this.getProperties(this.parentSeries);
            this.args.Reset(),
              (this.args.forceShaderMethod = !0),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.zeroLineY = this.parentSeries.zeroLineY),
              (this.args.columnWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                this.parentSeries.dataPointWidth,
                this.parentSeries.dataPointWidthMode
              )),
              (this.args.bottomRadius = this.parentSeries.cornerRadius);
            let n = this.strokePenCache;
            1 === this.args.columnWidth &&
              0 === s &&
              ((this.args.columnWidth = 0),
              (n = this.strokePenFillColoredCache));
            const l = (0, a.getScrtPenFromCache)(n);
            l && this.args.SetLinesPen(l);
            const d = (0, o.getScrtBrushFromCache)(this.fillBrushCache);
            d && this.args.SetFillBrush(d),
              (this.args.viewportWidth = i.width),
              (this.args.viewportHeight = i.height),
              super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                l,
                this.parentSeries.fill,
                d,
                this.parentSeries.opacity,
                !1,
                void 0 !== this.parentSeries.fillLinearGradient
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.paletteStart =
                2 * this.palettingState.paletteStartIndex);
            const h = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              u = this.xSelector(r),
              c = this.ySelector(r),
              p = h ? r.indexes : u,
              { startIndex: g, count: y } = this.getStartAndCount(t, p);
            (this.args.count = y), (this.args.startIndex = g);
            const {
                fifoCapacity: f,
                fifoSweeping: v,
                fifoSweepingGap: m,
              } = this.parentSeries.dataSeries,
              S = r.fifoStartIndex;
            v &&
              f === this.parentSeries.dataSeries.count() &&
              (this.args.count = S);
            const P = e.getNativeContext();
            this.nativeDrawingProvider.DrawPointsVec(
              P,
              p,
              c,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              v &&
                f === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(c.size(), S + m)),
                (this.args.count = Math.max(0, c.size() - S - m)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPointsVec(
                    P,
                    p,
                    c,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(n.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
            } = this.parentSeries;
            (e !== n.PROPERTY.STROKE &&
              e !== n.PROPERTY.STROKE_THICKNESS &&
              e !== n.PROPERTY.OPACITY) ||
              (0, a.createPenInCache)(this.strokePenCache, t, r, i),
              (e !== n.PROPERTY.FILL &&
                e !== n.PROPERTY.OPACITY &&
                e !== n.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                this.createBrush(),
              0 !== r ||
                (e !== n.PROPERTY.STROKE_THICKNESS &&
                  e !== n.PROPERTY.STROKE &&
                  e !== n.PROPERTY.OPACITY &&
                  e !== n.PROPERTY.FILL) ||
                (0, a.createPenInCache)(
                  this.strokePenFillColoredCache,
                  o,
                  1,
                  i
                );
          }
          createBrush() {
            const e = this.parentSeries.parentSurface,
              {
                fillLinearGradient: t,
                fill: r,
                opacity: i,
                customTextureOptions: o,
              } = this.getProperties(this.parentSeries),
              a = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.height /
                  s.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              n = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.width /
                  s.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            return this.fillBrushCache.create(r, i, a, n, t, o).scrtBrush;
          }
        }
        t.ColumnSeriesDrawingProvider = d;
      },
      71788: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ErrorSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(87459),
          a = r(2192),
          s = r(79226),
          n = r(32287),
          l = r(21915),
          d = r(16185),
          h = r(51392),
          u = r(98353),
          c = r(20977),
          p = r(65043);
        class g extends p.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t), (this.linesPenCache = new l.Pen2DCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries();
            const {
              stroke: e,
              strokeThickness: t,
              opacity: r,
              strokeDashArray: i,
            } = this.parentSeries;
            (0, l.createPenInCache)(this.linesPenCache, e, t, r, i);
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          delete() {
            (this.linesPenCache = (0, i.deleteSafe)(this.linesPenCache)),
              super.delete();
          }
          draw(e, t) {
            const r = (0, l.getScrtPenFromCache)(this.linesPenCache);
            if (!r) return;
            const i = t.pointSeries,
              c = (0, u.getVectorColorVertex)(this.webAssemblyContext),
              p = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              g = i.xValues,
              y = p ? i.indexes : g,
              f = i.yValues,
              v = i.highValues,
              m = i.lowValues,
              S =
                this.parentSeries.errorDirection === s.EErrorDirection.Vertical,
              P = S ? t.xCoordinateCalculator : t.yCoordinateCalculator,
              C =
                0.5 *
                this.parentSeries.getDataPointWidth(
                  P,
                  this.parentSeries.dataPointWidth,
                  this.parentSeries.dataPointWidthMode
                ),
              b = this.parentSeries.xAxis.type === a.EAxisType.LogarithmicAxis,
              x = this.parentSeries.yAxis.type === a.EAxisType.LogarithmicAxis,
              A = this.parentSeries.xAxis.isNegative,
              T = this.parentSeries.yAxis.isNegative,
              E = this.parentSeries.errorMode !== n.EErrorMode.Low,
              R = this.parentSeries.errorMode !== n.EErrorMode.High,
              D = y.size();
            if (S)
              for (let e = 0; e < D; ++e) {
                const r = y.get(e),
                  i = f.get(e);
                let o = E ? v.get(e) : i,
                  a = R ? m.get(e) : i;
                const s = x && !T && a <= 0;
                s && (a = this.parentSeries.yAxis.visibleRange.min);
                const n = x && T && o >= 0;
                n && (o = this.parentSeries.yAxis.visibleRange.max);
                const l = t.xCoordinateCalculator.getCoordinate(r),
                  d = t.yCoordinateCalculator.getCoordinate(i),
                  h = t.yCoordinateCalculator.getCoordinate(o),
                  u = t.yCoordinateCalculator.getCoordinate(a),
                  p = l - C,
                  g = l + C;
                this.parentSeries.drawConnector &&
                  this.addLineVertices(
                    c,
                    l,
                    isNaN(o) ? d : h,
                    l,
                    isNaN(a) ? d : u
                  ),
                  E &&
                    !n &&
                    this.parentSeries.drawWhiskers &&
                    this.addLineVertices(c, p, h, g, h),
                  R &&
                    !s &&
                    this.parentSeries.drawWhiskers &&
                    this.addLineVertices(c, p, u, g, u);
              }
            else
              for (let e = 0; e < D; ++e) {
                const r = y.get(e),
                  i = f.get(e);
                let o = R ? m.get(e) : r,
                  a = E ? v.get(e) : r;
                const s = b && !A && o <= 0;
                s && (o = h.MIN_LOG_AXIS_VALUE);
                const n = b && A && a >= 0;
                n && (a = -h.MIN_LOG_AXIS_VALUE);
                const l = t.xCoordinateCalculator.getCoordinate(r),
                  d = t.yCoordinateCalculator.getCoordinate(i),
                  u = t.xCoordinateCalculator.getCoordinate(a),
                  p = t.xCoordinateCalculator.getCoordinate(o),
                  g = d - C,
                  S = d + C;
                this.parentSeries.drawConnector &&
                  this.addLineVertices(
                    c,
                    isNaN(o) ? l : p,
                    d,
                    isNaN(a) ? l : u,
                    d
                  ),
                  E &&
                    !n &&
                    this.parentSeries.drawWhiskers &&
                    this.addLineVertices(c, u, g, u, S),
                  R &&
                    !s &&
                    this.parentSeries.drawWhiskers &&
                    this.addLineVertices(c, p, g, p, S);
              }
            const w = o.Rect.intersect(
              this.parentSeries.parentSurface.clipRect,
              this.parentSeries.parentSurface.viewRect
            );
            e.drawLinesNative(c, r, d.ELineDrawMode.DiscontinuousLine, w);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(c.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              strokeDashArray: o,
            } = this.parentSeries;
            (e !== c.PROPERTY.STROKE &&
              e !== c.PROPERTY.STROKE_THICKNESS &&
              e !== c.PROPERTY.OPACITY &&
              e !== c.PROPERTY.STROKE_DASH_ARRAY) ||
              (0, l.createPenInCache)(this.linesPenCache, t, r, i, o);
          }
          addLineVertices(e, t, r, i, o) {
            this.parentSeries.xAxis.isVerticalChart
              ? (e.push_back((0, u.getVertex)(this.webAssemblyContext, r, t)),
                e.push_back((0, u.getVertex)(this.webAssemblyContext, o, i)))
              : (e.push_back((0, u.getVertex)(this.webAssemblyContext, t, r)),
                e.push_back((0, u.getVertex)(this.webAssemblyContext, i, o)));
          }
        }
        t.ErrorSeriesDrawingProvider = g;
      },
      24315: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.calculateHeatmapTexture =
            t.calculateCellCoordinates =
            t.calculateOffsets =
            t.createColorMap =
            t.getCellColor =
            t.getColor =
            t.getColorDataForTexture =
              void 0);
        const i = r(22950),
          o = r(48008);
        (t.getColorDataForTexture = (e, r, i) => {
          const {
            xStartInd: o,
            textureWidth: a,
            xInc: s,
            yStartInd: n,
            textureHeight: l,
            yInc: d,
            zValues: h,
            webAssemblyContext: u,
            colorMap: c,
            opacity: p,
            horCellCount: g,
            vertCellCount: y,
            horCellOffsets: f,
            vertCellOffsets: v,
            colorMin: m,
            colorMax: S,
            arrayWidth: P,
            arrayHeight: C,
            fillValuesOutOfRange: b,
          } = e;
          r.resize(a * l, 0);
          let x = 0,
            A = v[x];
          const T = new Array(g);
          let E,
            R = !1,
            D = o,
            w = n;
          for (let e = 0; e < l; e++) {
            let l = 0,
              g = f[l];
            if (
              e > A &&
              ((R = !1),
              x++,
              (A = v[x]),
              e - A > Number.EPSILON && Math.floor(A) + 1 === e)
            )
              e--;
            else {
              R
                ? (E = T[l])
                : ((D = o + l * s),
                  (w = n + x * d),
                  (E = (0, t.getColor)(w, D, c, p, h, u, m, S, P, C, b, i)),
                  (T[l] = E));
              for (let n = 0; n < a; n++) {
                if (n > g) {
                  if (
                    (l++,
                    (g = f[l]),
                    n - g > Number.EPSILON && Math.floor(g) + 1 === n)
                  ) {
                    n--;
                    continue;
                  }
                  R
                    ? (E = T[l])
                    : ((D = o + l * s),
                      (E = (0, t.getColor)(w, D, c, p, h, u, m, S, P, C, b, i)),
                      (T[l] = E));
                }
                r.set(e * a + n, E);
              }
              R = !0;
            }
          }
          return r;
        }),
          (t.getColor = (e, r, o, a, s, n, l, d, h, u, c, p) => {
            if (e >= u || r >= h) return 0;
            const g = s[e][r],
              y = (0, t.getCellColor)(g, o, l, d, c, n, p);
            return (0, i.uintArgbColorMultiplyOpacity)(y, a);
          }),
          (t.getCellColor = (e, t, r, i, o, a, s) => {
            if (isNaN(e)) return 0;
            if (o) e = (e = e < r ? r : e) > i ? i : e;
            else if (e < r || e > i) return 0;
            const n = (e - r) * ((s - 1) / Math.abs(i - r));
            let l = Math.floor(n + 0.5 * Math.sign(e));
            return (l = a.NumberUtil.Constrain(l, 0, t.length - 1)), t[l];
          }),
          (t.createColorMap = (e, t) => {
            const r = Array.from(Array(t)),
              i = [...e];
            i.sort((e, t) =>
              e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0
            );
            const s = i.length,
              n = i[0].offset;
            let l = i[i.length - 1].offset - n;
            const d = l / (t - 1);
            let h = i[0].color,
              u = i[0].offset,
              c = h,
              p = u;
            s > 1 && ((c = i[1].color), (p = i[1].offset)), (l = p - u);
            let g = 0;
            for (let e = 0; e < t; ++e) {
              const t = n + e * d;
              let y;
              t >= p &&
                (g++,
                (u = p),
                (h = c),
                g + 1 < s && ((c = i[g + 1].color), (p = i[g + 1].offset)),
                (l = p - u)),
                (y =
                  h === c || l <= Number.EPSILON
                    ? Number.parseInt((0, o.parseColorToHexStringArgb)(c), 16)
                    : a(h, c, (t - u) / l)),
                (r[e] = y);
            }
            return r;
          });
        const a = (e, t, r) => {
          const i = (0, o.parseColorToTArgb)(e),
            a = (0, o.parseColorToTArgb)(t),
            s = i.opacity,
            n = a.opacity,
            l = i.red,
            d = a.red,
            h = i.green,
            u = a.green,
            c = i.blue,
            p = a.blue,
            g = l + Math.floor((d - l) * r),
            y = h + Math.floor((u - h) * r),
            f = c + Math.floor((p - c) * r),
            v = s + Math.floor((n - s) * r);
          return Number.parseInt(
            "0x" +
              (0, o.toHex)(v) +
              (0, o.toHex)(g) +
              (0, o.toHex)(y) +
              (0, o.toHex)(f),
            16
          );
        };
        (t.calculateOffsets = (e, r, i, o, a, s, n, l, d, h, u) => {
          let c = e.left < 0 ? -e.left : 0;
          const p = e.top < 0 ? -e.top : 0;
          return (
            r && (c = e.right > u.bottom ? e.right - u.bottom : 0),
            {
              horCellOffsets: (0, t.calculateCellCoordinates)(
                i,
                e.width,
                a,
                s,
                n,
                -c
              ),
              vertCellOffsets: (0, t.calculateCellCoordinates)(
                o,
                e.height,
                l,
                d,
                h,
                -p
              ),
            }
          );
        }),
          (t.calculateCellCoordinates = (e, t, r, i, o, a) => {
            let s = 0,
              n = r;
            for (let t = 0; t < i; t++, n += o) s += e[n];
            const l = 1 / s,
              d = new Array(i);
            let h = a;
            for (let a = 0; a < i - 1; a++)
              (h += e[a * o + r] * l * t), (d[a] = h);
            return (d[i - 1] = t + a), d;
          }),
          (t.calculateHeatmapTexture = (e, r, i, o) => {
            const {
                textureWidth: a,
                textureHeight: s,
                webAssemblyContext: n,
                useInterpolation: l,
              } = e,
              d = (0, t.getColorDataForTexture)(e, r, o),
              h = i.create(
                a,
                s,
                n.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8
              );
            return (
              n.SCRTSetTextureLinearSamplerEnabled(h, l),
              n.SCRTFillTextureAbgr(h, a, s, d),
              h
            );
          });
      },
      81284: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HeightSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(28268),
          a = r(69854),
          s = r(48008),
          n = r(51269),
          l = r(21915),
          d = r(32747),
          h = r(98353),
          u = r(20977),
          c = r(65043),
          p = r(74218);
        class g extends c.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r),
              (this.args =
                new this.webAssemblyContext.SCRTHeightSeriesParams()),
              (this.colorSettings =
                new this.webAssemblyContext.SCRTHeightColorSettings()),
              (this.zSelector = null != i ? i : (e) => e.zValues),
              (this.linesPenCache = new l.Pen2DCache(e)),
              (this.fillBrushCache = new n.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTHeightSeriesDrawingProvider());
            const {
              stroke: e,
              strokeThickness: t,
              fill: r,
              opacity: i,
              strokeDashArray: o,
              customTextureOptions: a,
            } = this.parentSeries;
            (0, l.createPenInCache)(this.linesPenCache, e, t, i, o),
              this.fillBrushCache.create(r, i, 1, 1, void 0, a);
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.linesPenCache = (0, i.deleteSafe)(this.linesPenCache)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          draw(e, t) {
            var r;
            const u = t.pointSeries;
            this.args.Reset(), this.colorSettings.Reset();
            const c = (0, n.getScrtBrushFromCache)(this.fillBrushCache);
            c && this.args.SetFillBrush(c);
            const {
              zMultiplier: g,
              zLimits: y,
              paletteProvider: f,
              normalise: v,
              isInverseHeight: m,
              strokeThickness: S,
              heightMode: P,
            } = this.parentSeries;
            (this.args.zMultiplier = g),
              (this.args.isInverseHeight = m),
              (this.args.normaliseHeights = v);
            const C = (0, l.getScrtPenFromCache)(this.linesPenCache);
            C && S > 0 && this.args.SetEdgePen(C);
            const b = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              x = u.xValues;
            let A = b ? u.indexes : x,
              T = this.ySelector(u),
              E = this.zSelector(u);
            if (!v || (y && y.max !== Number.MAX_VALUE))
              (this.args.minHeight = y.min), (this.args.maxHeight = y.max);
            else {
              let e;
              try {
                (e = this.webAssemblyContext.NumberUtil.MinMax(E)),
                  (this.args.minHeight = e.minD),
                  (this.args.maxHeight = e.maxD);
              } finally {
                (0, i.deleteSafe)(e);
              }
            }
            const { startIndex: R, count: D } = this.getStartAndCount(t, A);
            if (
              ((this.args.startIndex = Math.max(0, R - 1)),
              (this.args.count = Math.min(A.size(), D + 1)),
              (this.args.verticalChart = t.isVerticalChart),
              P === p.EHeightSeriesMode.Horizontal
                ? this.args.SetNormalDirection(
                    t.isVerticalChart
                      ? (0, h.getVector3)(this.webAssemblyContext, 0, 1, 0)
                      : (0, h.getVector3)(this.webAssemblyContext, 1, 0, 0)
                  )
                : P === p.EHeightSeriesMode.Vertical &&
                  this.args.SetNormalDirection(
                    t.isVerticalChart
                      ? (0, h.getVector3)(this.webAssemblyContext, 1, 0, 0)
                      : (0, h.getVector3)(this.webAssemblyContext, 0, 1, 0)
                  ),
              void 0 !== f.overrideFillArgb &&
                (super.applyStrokeFillPaletting(
                  this.parentSeries.stroke,
                  C,
                  this.parentSeries.fill,
                  c,
                  this.parentSeries.opacity,
                  !1,
                  !0,
                  t
                ),
                this.args.SetPalettedColors(this.palettingState.palettedColors),
                (this.args.paletteStart =
                  this.palettingState.paletteStartIndex),
                (this.args.interpolate =
                  this.palettingState.gradientPaletting)),
              this.parentSeries.colorSettings)
            ) {
              const e = this.parentSeries.colorSettings.colorStops;
              (0, a.validateColorStops)(this.parentSeries.colorSettings);
              for (const t of e)
                this.colorSettings.AddColorStop(
                  t.dataValue,
                  (0, s.parseColorToUIntArgb)(t.color)
                );
              this.parentSeries.colorSettings.infraColor &&
                (this.colorSettings.m_uiInfra = (0, s.parseColorToUIntArgb)(
                  this.parentSeries.colorSettings.infraColor
                )),
                this.parentSeries.colorSettings.ultraColor &&
                  (this.colorSettings.m_uiUltra = (0, s.parseColorToUIntArgb)(
                    this.parentSeries.colorSettings.ultraColor
                  )),
                (this.colorSettings.m_fMinHeight = e[0].dataValue),
                (this.colorSettings.m_fMaxHeight = e[e.length - 1].dataValue),
                (this.colorSettings.m_bIsGradient =
                  this.parentSeries.colorSettings.colorPickMode ===
                  o.EColorPickMode.Interpolated),
                (this.args.interpolate =
                  this.parentSeries.colorSettings.fillMode ===
                  d.EFillPaletteMode.GRADIENT),
                (this.colorSettings.m_fMaxTextureSize =
                  null !==
                    (r = this.parentSeries.colorSettings.maxTextureSize) &&
                  void 0 !== r
                    ? r
                    : 0),
                this.args.SetHeightColors(this.colorSettings);
            }
            this.parentSeries.heightsForColoringDataSeries &&
              this.args.SetHeightsForColoring(
                this.parentSeries.getHeightsForColoring(u.resampled)
              );
            const w = e.getNativeContext();
            this.nativeDrawingProvider.DrawPointsVec(
              w,
              A,
              T,
              E,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            );
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(u.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              stroke: t,
              strokeThickness: r,
              fill: i,
              opacity: o,
              strokeDashArray: a,
              customTextureOptions: s,
            } = this.parentSeries;
            (e !== u.PROPERTY.STROKE &&
              e !== u.PROPERTY.STROKE_THICKNESS &&
              e !== u.PROPERTY.OPACITY &&
              e !== u.PROPERTY.STROKE_DASH_ARRAY) ||
              ((this.palettingState.requiresUpdate = !0),
              (0, l.createPenInCache)(this.linesPenCache, t, r, o, a)),
              (e !== u.PROPERTY.FILL &&
                e !== u.PROPERTY.OPACITY &&
                e !== u.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                ((this.palettingState.requiresUpdate = !0),
                this.fillBrushCache.create(i, o, 1, 1, void 0, s));
          }
        }
        t.HeightSeriesDrawingProvider = g;
      },
      66743: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSegmentSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(54624),
          a = r(21915),
          s = r(51885),
          n = r(20977),
          l = r(65043);
        class d extends l.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i),
              (this.linesPenCache = new a.Pen2DCache(e)),
              (this.args = new e.SCRTLineSegmentDrawingParams());
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(n.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            if (
              (super.onSeriesPropertyChange(e),
              e === n.PROPERTY.PALETTE_PROVIDER &&
                this.linesPenCache.invalidateCache(),
              e === n.PROPERTY.STROKE ||
                e === n.PROPERTY.STROKE_THICKNESS ||
                e === n.PROPERTY.PALETTE_PROVIDER ||
                e === n.PROPERTY.OPACITY ||
                e === n.PROPERTY.STROKE_DASH_ARRAY)
            ) {
              this.palettingState.requiresUpdate = !0;
              const {
                stroke: e,
                strokeThickness: t,
                opacity: r,
                strokeDashArray: i,
              } = this.getProperties(this.parentSeries);
              e &&
                (0, a.createPenInCache)(
                  this.linesPenCache,
                  e,
                  t,
                  null != r ? r : 1,
                  i,
                  !0
                );
            }
          }
          getProperties(e) {
            var t;
            const {
              stroke: r,
              strokeThickness: i,
              opacity: o,
              strokeDashArray: a,
              dataSeries: n,
            } = e;
            return {
              stroke: r,
              strokeThickness: i,
              opacity: o,
              strokeDashArray: a,
              dataSeriesType:
                null !== (t = null == n ? void 0 : n.type) && void 0 !== t
                  ? t
                  : s.EDataSeriesType.Xy,
            };
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTLineSegmentDrawingProvider());
            const {
              stroke: e,
              strokeThickness: t,
              opacity: r,
              strokeDashArray: i,
            } = this.getProperties(this.parentSeries);
            e &&
              (0, a.createPenInCache)(
                this.linesPenCache,
                e,
                t,
                null != r ? r : 1,
                i,
                !0
              );
          }
          onDetachSeries() {
            super.onDetachSeries(),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              ));
          }
          getStartAndCount(e, t) {
            var r, i, o;
            const a = null == e ? void 0 : e.pointSeries,
              s =
                null === (r = this.parentSeries) || void 0 === r
                  ? void 0
                  : r.xAxis,
              n =
                null === (i = null == s ? void 0 : s.clipToXRange) ||
                void 0 === i ||
                i;
            let l = t.size(),
              d = Math.min(a ? a.xValues.size() : l, l),
              h = 0;
            return (
              n &&
                !(null == a ? void 0 : a.resampled) &&
                (null === (o = null == e ? void 0 : e.indexRange) ||
                void 0 === o
                  ? void 0
                  : o.diff) >= 0 &&
                (e.indexRange.diff + 1 < d && (h = e.indexRange.min),
                (d = Math.min(e.indexRange.diff + 1, d)),
                h % 2 == 1 && (h--, d++)),
              { startIndex: h, count: d }
            );
          }
          updateArgs(e) {}
          drawXy(e, t) {
            const { stroke: r } = this.getProperties(this.parentSeries),
              i = (0, a.getScrtPenFromCache)(this.linesPenCache);
            if (!i || !r) return;
            if (
              (this.args.Reset(),
              this.args.SetLinesPen(i),
              (this.args.forceShaderMethod = !0),
              (this.args.forceClamp = !0),
              (this.args.verticalChart = t.isVerticalChart),
              t.xCoordinateCalculator.isCategoryCoordinateCalculator)
            )
              return void console.error(
                "Category Axis is not supported for LineSegmentRenderableSeries"
              );
            const o = t.pointSeries,
              s = this.xSelector(o),
              n = this.ySelector(o),
              { startIndex: l, count: d } = this.getStartAndCount(t, s);
            (this.args.count = d),
              (this.args.startIndex = l),
              this.applyStrokePaletting(i, t),
              this.palettingState.palettedColors &&
                this.args.SetPalettedColors(this.palettingState.palettedColors),
              this.updateArgs(t);
            const h = e.getNativeContext();
            this.drawLines(
              e,
              h,
              s,
              n,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            );
          }
          drawXyXy(e, t) {
            const { stroke: r } = this.getProperties(this.parentSeries),
              i = (0, a.getScrtPenFromCache)(this.linesPenCache);
            if (!i || !r) return;
            if (
              (this.args.Reset(),
              (this.args.fourVectorsMode = !0),
              this.args.SetLinesPen(i),
              (this.args.forceShaderMethod = !0),
              (this.args.verticalChart = t.isVerticalChart),
              t.xCoordinateCalculator.isCategoryCoordinateCalculator)
            )
              return void console.error(
                "Category Axis is not supported for LineSegmentRenderableSeries"
              );
            const s = t.pointSeries,
              n = this.xSelector(s),
              l = this.ySelector(s),
              d = s.getYValuesByName(o.EValueName.X1),
              h = s.getYValuesByName(o.EValueName.Y1),
              { startIndex: u, count: c } = this.getStartAndCount(t, n);
            (this.args.count = c),
              (this.args.startIndex = u),
              this.args.SetX2(d),
              this.args.SetY2(h),
              this.applyStrokePaletting(i, t),
              this.palettingState.palettedColors &&
                (this.args.SetPalettedColors(
                  this.palettingState.palettedColors
                ),
                this.args.SetPalettedColors2(
                  this.palettingState.palettedColors
                )),
              this.updateArgs(t);
            const p = e.getNativeContext();
            this.drawLines(
              e,
              p,
              n,
              l,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            );
          }
          draw(e, t) {
            const { dataSeriesType: r } = this.getProperties(this.parentSeries);
            r === s.EDataSeriesType.Xyxy
              ? this.drawXyXy(e, t)
              : this.drawXy(e, t);
          }
          delete() {
            (this.linesPenCache = (0, i.deleteSafe)(this.linesPenCache)),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
          drawLines(e, t, r, i, o, a, s, n) {
            s.count <= 0 ||
              this.nativeDrawingProvider.DrawLinesVec(t, r, i, o, a, s);
          }
        }
        t.LineSegmentSeriesDrawingProvider = d;
      },
      36898: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(21915),
          a = r(16185),
          s = r(20782),
          n = r(20977),
          l = r(65043);
        class d extends l.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i),
              (this.linesPenCache = new o.Pen2DCache(e)),
              (this.args = new e.SCRTLineDrawingParams());
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(n.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            if (
              (super.onSeriesPropertyChange(e),
              e === n.PROPERTY.PALETTE_PROVIDER &&
                this.linesPenCache.invalidateCache(),
              e === n.PROPERTY.STROKE ||
                e === n.PROPERTY.STROKE_THICKNESS ||
                e === n.PROPERTY.PALETTE_PROVIDER ||
                e === n.PROPERTY.OPACITY ||
                e === n.PROPERTY.STROKE_DASH_ARRAY)
            ) {
              this.palettingState.requiresUpdate = !0;
              const {
                stroke: e,
                strokeThickness: t,
                opacity: r,
                strokeDashArray: i,
              } = this.getProperties(this.parentSeries);
              e &&
                (0, o.createPenInCache)(
                  this.linesPenCache,
                  e,
                  t,
                  null != r ? r : 1,
                  i
                );
            }
          }
          getProperties(e) {
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              strokeDashArray: o,
              isDigitalLine: a,
              drawNaNAs: s,
              lineType: n,
            } = e;
            return {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              strokeDashArray: o,
              isDigitalLine: a,
              drawNaNAs: s,
              lineType: n,
              containsNaN: void 0,
            };
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTLineSeriesDrawingProvider());
            const {
              stroke: e,
              strokeThickness: t,
              opacity: r,
              strokeDashArray: i,
            } = this.getProperties(this.parentSeries);
            e &&
              (0, o.createPenInCache)(
                this.linesPenCache,
                e,
                t,
                null != r ? r : 1,
                i
              );
          }
          onDetachSeries() {
            super.onDetachSeries(),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              ));
          }
          updateArgs(e) {}
          draw(e, t) {
            var r;
            const {
                stroke: i,
                isDigitalLine: n,
                lineType: l,
                drawNaNAs: d,
                containsNaN: h,
              } = this.getProperties(this.parentSeries),
              u = (0, o.getScrtPenFromCache)(this.linesPenCache);
            if (!u || !i) return;
            const c = t.pointSeries;
            let p =
              this.parentSeries.dataSeries.dataDistributionCalculator
                .containsNaN;
            (p = null != h ? h : p),
              this.args.Reset(),
              this.args.SetLinesPen(u),
              (this.args.isDigitalLine = n || l !== s.ELineType.Normal),
              (this.args.drawDigitalVertical = l !== s.ELineType.DigitalNoEdge),
              (this.args.digitalYX = l === s.ELineType.DigitalYX),
              (this.args.forceShaderMethod = !0),
              (this.args.containsNaN = p),
              (this.args.forceClamp = !this.args.isDigitalLine),
              (this.args.lineGaps = p
                ? d === a.ELineDrawMode.DiscontinuousLine
                  ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                  : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
                : this.webAssemblyContext.SCRTLineGapMode.Default),
              (this.args.verticalChart = t.isVerticalChart);
            const g = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              {
                fifoCapacity: y,
                fifoSweeping: f,
                fifoSweepingGap: v,
              } = this.parentSeries.dataSeries,
              m = c.fifoStartIndex,
              S = this.xSelector(c);
            let P = g ? c.indexes : S,
              C = this.ySelector(c);
            const { startIndex: b, count: x } = this.getStartAndCount(t, P);
            (this.args.count = x),
              (this.args.startIndex = b),
              f &&
                y === this.parentSeries.dataSeries.count() &&
                (this.args.count = m),
              this.applyStrokePaletting(u, t),
              this.palettingState.palettedColors &&
                (this.args.SetPalettedColors(
                  this.palettingState.palettedColors
                ),
                (this.args.paletteStart =
                  null !== (r = this.palettingState.paletteStartIndex) &&
                  void 0 !== r
                    ? r
                    : 0)),
              this.updateArgs(t);
            const A = e.getNativeContext();
            this.drawLines(
              e,
              A,
              P,
              C,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            ),
              f &&
                y === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(C.size(), m + v)),
                (this.args.count = Math.max(0, C.size() - m - v)),
                this.args.count > 0 &&
                  this.drawLines(
                    e,
                    A,
                    P,
                    C,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args,
                    this.parentSeries.parentSurface.seriesViewRect
                  ));
          }
          delete() {
            (this.linesPenCache = (0, i.deleteSafe)(this.linesPenCache)),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
          drawLines(e, t, r, i, o, a, s, n) {
            this.nativeDrawingProvider.DrawLinesVec(t, r, i, o, a, s);
          }
        }
        t.LineSeriesDrawingProvider = d;
      },
      36877: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MountainSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(21915),
          s = r(16185),
          n = r(14184),
          l = r(20977),
          d = r(65043);
        class h extends d.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTMountainSeriesDrawingProvider()),
              (this.args =
                new this.webAssemblyContext.SCRTMountainDrawingParams()),
              (this.strokePenCache = new a.Pen2DCache(e)),
              (this.fillBrushCache = new o.BrushCache(e));
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          draw(e, t) {
            var r;
            const i = t.pointSeries,
              o =
                this.parentSeries.dataSeries.dataDistributionCalculator
                  .containsNaN;
            this.args.Reset(),
              (this.args.forceShaderMethod = !0),
              (this.args.lineGaps = o
                ? this.parentSeries.drawNaNAs ===
                  s.ELineDrawMode.DiscontinuousLine
                  ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                  : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
                : this.webAssemblyContext.SCRTLineGapMode.Default),
              (this.args.verticalChart = t.isVerticalChart);
            const { visibleMin: n, visibleMax: l } =
              t.getyCoordinateCalculator();
            (this.args.zeroLineY = Math.max(
              Math.min(this.parentSeries.zeroLineY, l),
              n
            )),
              (this.args.isDigitalLine = this.parentSeries.isDigitalLine);
            const d = this.createBrush();
            d && this.args.SetFillBrush(d);
            const h = (0, a.getScrtPenFromCache)(this.strokePenCache);
            h && this.args.SetLinesPen(h),
              super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                h,
                this.parentSeries.fill,
                d,
                this.parentSeries.opacity,
                !0,
                void 0 !== this.parentSeries.fillLinearGradient,
                t
              );
            const u =
              null === (r = this.palettingState.paletteTextureCache) ||
              void 0 === r
                ? void 0
                : r.value;
            u && this.args.SetPalette(u),
              (this.args.isSmoothColors =
                this.palettingState.gradientPaletting);
            const {
                fifoCapacity: c,
                fifoSweeping: p,
                fifoSweepingGap: g,
              } = this.parentSeries.dataSeries,
              y = i.fifoStartIndex,
              f = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              v = i.xValues;
            let m = f ? i.indexes : v,
              S = i.yValues;
            const { startIndex: P, count: C } = this.getStartAndCount(t, m);
            (this.args.count = C),
              (this.args.startIndex = P),
              p &&
                c === this.parentSeries.dataSeries.count() &&
                (this.args.count = y);
            const b = e.getNativeContext();
            this.parentSeries.parentSurface.seriesViewRect,
              this.nativeDrawingProvider.DrawPointsVec(
                b,
                m,
                S,
                t.xCoordinateCalculator.nativeCalculator,
                t.yCoordinateCalculator.nativeCalculator,
                this.args
              ),
              p &&
                c === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(S.size(), y + g)),
                (this.args.count = Math.max(0, S.size() - y - g)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPointsVec(
                    b,
                    m,
                    S,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(l.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e),
              (e !== l.PROPERTY.STROKE &&
                e !== l.PROPERTY.STROKE_DASH_ARRAY &&
                e !== l.PROPERTY.STROKE_THICKNESS &&
                e !== l.PROPERTY.OPACITY) ||
                this.createPen(),
              (e !== l.PROPERTY.FILL &&
                e !== l.PROPERTY.OPACITY &&
                e !== l.PROPERTY.FILL_LINEAR_GRADIENT) ||
                this.createBrush();
          }
          onAttachSeries() {
            super.onAttachSeries(), this.createPen(), this.createBrush();
          }
          createBrush() {
            this.palettingState.requiresUpdate = !0;
            const {
                fill: e,
                opacity: t,
                fillLinearGradient: r,
                parentSurface: i,
                customTextureOptions: a,
              } = this.parentSeries,
              s = (null == i ? void 0 : i.isCopyCanvasSurface)
                ? i.domCanvas2D.height /
                  n.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              l = (null == i ? void 0 : i.isCopyCanvasSurface)
                ? i.domCanvas2D.width /
                  n.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            return (
              this.fillBrushCache.create(e, t, s, l, r, a),
              (0, o.getScrtBrushFromCache)(this.fillBrushCache)
            );
          }
          createPen() {
            const {
              stroke: e,
              strokeThickness: t,
              opacity: r,
              strokeDashArray: i,
            } = this.parentSeries;
            return (
              (this.palettingState.requiresUpdate = !0),
              (0, a.createPenInCache)(this.strokePenCache, e, t, r, i)
            );
          }
        }
        t.MountainSeriesDrawingProvider = h;
      },
      37182: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__rest) ||
          function (e, t) {
            var r = {};
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) &&
                t.indexOf(i) < 0 &&
                (r[i] = e[i]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (i = Object.getOwnPropertySymbols(e); o < i.length; o++)
                t.indexOf(i[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, i[o]) &&
                  (r[i[o]] = e[i[o]]);
            }
            return r;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonUniformHeatmapDrawingProvider = void 0);
        const o = r(56744),
          a = r(98140),
          s = r(87459),
          n = r(4748),
          l = r(80445),
          d = r(53904),
          h = r(20977),
          u = r(65043),
          c = r(24315);
        class p extends u.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.heatTextureCache = new l.TextureCache(e)),
              (this.colorDataVector = new e.UIntVector()),
              this.onSeriesPropertyChange(h.PROPERTY.DATA_SERIES),
              this.onSeriesPropertyChange(h.PROPERTY.COLOR_MAP);
          }
          delete() {
            (this.colorDataVector = (0, o.deleteSafe)(this.colorDataVector)),
              (this.heatTextureCache = (0, o.deleteSafe)(
                this.heatTextureCache
              )),
              super.delete();
          }
          onSeriesPropertyChange(e) {
            (e === h.PROPERTY.DATA_SERIES ||
              e === h.PROPERTY.COLOR_MAP ||
              e.includes(d.COLOR_MAP_PREFIX) ||
              e === h.PROPERTY.OPACITY) &&
              (this.colorGradientScale = (0, c.createColorMap)(
                this.parentSeries.colorMap.gradientStops,
                100
              ));
          }
          draw(e, t) {
            const { isVerticalChart: r } = t,
              i = this.parentSeries.dataSeries,
              o = this.parentSeries.parentSurface.seriesViewRect,
              s = this.parentSeries.colorMap,
              n = this.colorGradientScale,
              l = i.getZValues(),
              d = i.getXIndicesRange(
                new a.NumberRange(
                  t.xCoordinateCalculator.visibleMin,
                  t.xCoordinateCalculator.visibleMax
                ),
                !1
              ),
              h = i.getYIndicesRange(
                new a.NumberRange(
                  t.yCoordinateCalculator.visibleMin,
                  t.yCoordinateCalculator.visibleMax
                ),
                !1
              ),
              u = i.getXValue(d.min),
              c = i.getXValue(d.max),
              p = i.getYValue(h.min),
              g = i.getYValue(h.max),
              y = !t.xCoordinateCalculator.hasFlippedCoordinates,
              f = t.yCoordinateCalculator.hasFlippedCoordinates,
              v = t.xCoordinateCalculator.getCoordinate(y ? c : u),
              m = t.xCoordinateCalculator.getCoordinate(y ? u : c),
              S = t.yCoordinateCalculator.getCoordinate(f ? p : g),
              P = t.yCoordinateCalculator.getCoordinate(f ? g : p),
              C = Math.ceil(Math.abs(v - m)),
              b = Math.ceil(Math.abs(S - P)),
              x = C <= 0 || b <= 0;
            if (
              !(
                v > (r ? o.height : o.width) ||
                S > (r ? o.width : o.height) ||
                m < 0 ||
                P < 0 ||
                x
              )
            ) {
              const a = d,
                u = h;
              let c = y ? a.max - 1 : a.min;
              const p = f ? u.min : u.max - 1;
              let g = y ? -1 : 1;
              const m = f ? 1 : -1;
              r && ((c = y ? a.min : a.max - 1), (g = y ? 1 : -1));
              const P = a.diff,
                x = u.diff,
                A = e.getNativeContext();
              this.drawHeatmapInTypescript(
                A,
                i.xCellOffsets,
                i.yCellOffsets,
                l,
                t.xCoordinateCalculator,
                t.yCoordinateCalculator,
                {
                  horCellCount: P,
                  vertCellCount: x,
                  arrayWidth: i.arrayWidth,
                  arrayHeight: i.arrayHeight,
                  opacity: this.parentSeries.opacity,
                  colorGradientScale: n,
                  colorMin: s.minimum,
                  colorMax: s.maximum,
                  horStartInd: c,
                  vertStartInd: p,
                  horInc: g,
                  vertInc: m,
                  isVerticalChart: r,
                  heatmapStartX: v,
                  heatmapStartY: S,
                  heatmapWidth: C,
                  heatmapHeight: b,
                  xCellSizes: i.xCellSizes,
                  yCellSizes: i.yCellSizes,
                  seriesViewRect: o,
                }
              );
            }
          }
          drawHeatmapInTypescript(e, t, r, i, o, a, n) {
            const {
                horStartInd: l,
                horInc: d,
                vertStartInd: h,
                vertInc: u,
                horCellCount: p,
                vertCellCount: g,
                heatmapStartX: y,
                heatmapStartY: f,
                heatmapWidth: v,
                heatmapHeight: m,
                opacity: S,
                colorGradientScale: P,
                colorMin: C,
                colorMax: b,
                isVerticalChart: x,
                arrayWidth: A,
                arrayHeight: T,
                xCellSizes: E,
                yCellSizes: R,
                seriesViewRect: D,
              } = n,
              w = t[0],
              M = t[t.length - 1],
              L = r[0],
              O = r[r.length - 1],
              I = Math.max(w, o.visibleMin),
              k = Math.min(M, o.visibleMax),
              _ = Math.max(L, a.visibleMin),
              V = Math.min(O, a.visibleMax),
              N = !o.hasFlippedCoordinates,
              B = a.hasFlippedCoordinates,
              F = o.getCoordinate(N ? k : I),
              H = o.getCoordinate(N ? I : k),
              Y = a.getCoordinate(B ? V : _),
              z = a.getCoordinate(B ? _ : V),
              j = Math.ceil(Math.abs(F - H)),
              X = Math.ceil(Math.abs(Y - z)),
              G = new s.Rect(y, f, v, m),
              { horCellOffsets: W, vertCellOffsets: U } = (0,
              c.calculateOffsets)(G, x, E, R, l, p, d, h, g, u, D),
              $ = this.calculateHeatmapTexture({
                xStartInd: l,
                textureWidth: j,
                xInc: d,
                yStartInd: h,
                textureHeight: X,
                yInc: u,
                zValues: i,
                webAssemblyContext: this.webAssemblyContext,
                colorMap: P,
                opacity: S,
                horCellCount: p,
                vertCellCount: g,
                horCellOffsets: W,
                vertCellOffsets: U,
                colorMin: C,
                colorMax: b,
                arrayWidth: A,
                arrayHeight: T,
                fillValuesOutOfRange: this.parentSeries.fillValuesOutOfRange,
                useInterpolation: this.parentSeries.useLinearTextureFiltering,
              });
            if (x) {
              e.PushMatrix(), e.PushState(), e.Rotate(-90);
              const t = N ? -F : -j - F;
              e.Translate(t, 0);
              const r = N ? 0 : j,
                i = Y;
              return (
                e.DrawTexture($, r - j, i - X, j, X),
                e.PopMatrix(),
                void e.PopState()
              );
            }
            e.DrawTexture($, F, z, j, X);
          }
          calculateHeatmapTexture(e) {
            if (!this.getMemoizedHeatmapTexture) {
              const e = (e, r) => {
                var [o] = e,
                  { horCellOffsets: a, vertCellOffsets: s } = o,
                  n = i(o, ["horCellOffsets", "vertCellOffsets"]),
                  l = r[0],
                  d = l.horCellOffsets,
                  h = l.vertCellOffsets,
                  u = i(l, ["horCellOffsets", "vertCellOffsets"]);
                return (
                  t(Object.values(n), Object.values(u)) && t(a, d) && t(s, h)
                );
              };
              this.getMemoizedHeatmapTexture = (0, n.memoize)(
                c.calculateHeatmapTexture,
                e
              );
            }
            const t = (e, t) => !e.some((e, r) => e !== t[r]);
            return this.getMemoizedHeatmapTexture(
              e,
              this.colorDataVector,
              this.heatTextureCache,
              100
            );
          }
        }
        t.NonUniformHeatmapDrawingProvider = p;
      },
      88302: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcSeriesDrawingProvider = t.EOhlcDrawingMode = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(21915),
          s = r(20977),
          n = r(65043);
        var l;
        !(function (e) {
          (e.Candles = "Candles"), (e.Ohlc = "Ohlc");
        })((l = t.EOhlcDrawingMode || (t.EOhlcDrawingMode = {})));
        class d extends n.BaseSeriesDrawingProvider {
          constructor(e, t, r) {
            super(e, t),
              (this.drawingMode = r),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTCandlestickSeriesDrawingProvider()),
              (this.args = new this.webAssemblyContext.SCRTOhlcDrawingParams());
            const {
                strokeThickness: i,
                strokeUp: s,
                strokeDown: n,
                opacity: l,
              } = t,
              d = t;
            (this.strokeUpPenCache = new a.Pen2DCache(e)),
              (this.strokeDownPenCache = new a.Pen2DCache(e)),
              (this.brushUpCache = new o.BrushCache(e)),
              (this.brushDownCache = new o.BrushCache(e)),
              (0, a.createPenInCache)(this.strokeUpPenCache, s, i, l),
              (0, a.createPenInCache)(this.strokeDownPenCache, n, i, l),
              d.brushUp &&
                (0, o.createBrushInCache)(this.brushUpCache, d.brushUp, l),
              d.brushDown &&
                (0, o.createBrushInCache)(this.brushDownCache, d.brushDown, l);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(s.PROPERTY.STROKE_UP),
              this.onSeriesPropertyChange(s.PROPERTY.STROKE_DOWN);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              strokeThickness: t,
              strokeUp: r,
              strokeDown: i,
              opacity: n,
            } = this.parentSeries;
            (e !== s.PROPERTY.STROKE_UP &&
              e !== s.PROPERTY.STROKE_THICKNESS &&
              e !== s.PROPERTY.OPACITY) ||
              (0, a.createPenInCache)(this.strokeUpPenCache, r, t, n),
              (e !== s.PROPERTY.STROKE_DOWN &&
                e !== s.PROPERTY.STROKE_THICKNESS &&
                e !== s.PROPERTY.OPACITY) ||
                (0, a.createPenInCache)(this.strokeDownPenCache, i, t, n);
            const l = this.parentSeries;
            (e !== s.PROPERTY.BRUSH_DOWN && e !== s.PROPERTY.OPACITY) ||
              (0, o.createBrushInCache)(
                this.brushDownCache,
                null == l ? void 0 : l.brushDown,
                n
              ),
              (e !== s.PROPERTY.BRUSH_UP && e !== s.PROPERTY.OPACITY) ||
                (0, o.createBrushInCache)(
                  this.brushUpCache,
                  null == l ? void 0 : l.brushUp,
                  n
                );
          }
          draw(e, t) {
            const r = t.pointSeries;
            if ((this.args.Reset(), this.drawingMode === l.Candles)) {
              const e = (0, o.getScrtBrushFromCache)(this.brushUpCache),
                t = (0, o.getScrtBrushFromCache)(this.brushDownCache);
              if (!e || !t) return;
              this.args.SetBrushes(e, t);
            }
            const i = (0, a.getScrtPenFromCache)(this.strokeUpPenCache),
              s = (0, a.getScrtPenFromCache)(this.strokeDownPenCache);
            if (!i || !s) return;
            this.args.SetPens(i, s);
            const n = "#ffffffff";
            super.applyStrokeFillPaletting(
              n,
              void 0,
              n,
              void 0,
              this.parentSeries.opacity
            ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.forceShaderMethod = !0),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.candleWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                this.parentSeries.dataPointWidth,
                this.parentSeries.dataPointWidthMode
              )),
              (this.args.drawAsOhlc = this.drawingMode === l.Ohlc);
            const d = e.getNativeContext(),
              h =
                (this.parentSeries.parentSurface.seriesViewRect,
                this.parentSeries.dataSeries,
                t.xCoordinateCalculator.isCategoryCoordinateCalculator),
              u = r.xValues,
              c = r.openValues,
              p = r.highValues,
              g = r.lowValues,
              y = r.closeValues,
              { startIndex: f, count: v } = this.getStartAndCount(t, u);
            (this.args.count = v), (this.args.startIndex = f);
            const {
                fifoCapacity: m,
                fifoSweeping: S,
                fifoSweepingGap: P,
              } = this.parentSeries.dataSeries,
              C = r.fifoStartIndex;
            S &&
              m === this.parentSeries.dataSeries.count() &&
              (this.args.count = C);
            let b = h ? r.indexes : u;
            this.args.SetValues(b, c, p, g, y),
              this.nativeDrawingProvider.DrawPointsVec(
                d,
                t.xCoordinateCalculator.nativeCalculator,
                t.yCoordinateCalculator.nativeCalculator,
                this.args
              ),
              S &&
                m === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(y.size(), C + P)),
                (this.args.count = Math.max(0, y.size() - C - P)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPointsVec(
                    d,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          delete() {
            (this.strokeDownPenCache = (0, i.deleteSafe)(
              this.strokeDownPenCache
            )),
              (this.strokeUpPenCache = (0, i.deleteSafe)(
                this.strokeUpPenCache
              )),
              (this.brushUpCache = (0, i.deleteSafe)(this.brushUpCache)),
              (this.brushDownCache = (0, i.deleteSafe)(this.brushDownCache)),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
        }
        t.OhlcSeriesDrawingProvider = d;
      },
      94707: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PointMarkerDrawingProvider = void 0);
        const i = r(56744),
          o = r(65043);
        class a extends o.BaseSeriesDrawingProvider {
          constructor(e, t, r, i, o) {
            super(e, t, r, o),
              (this.ySplineValuesSelector =
                void 0 === i ? (e) => e.ySplineValues : i),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTScatterSeriesDrawingProvider()),
              (this.xAnimationPointMarkerValues =
                new this.webAssemblyContext.SCRTDoubleVector()),
              (this.yAnimationPointMarkerValues =
                new this.webAssemblyContext.SCRTDoubleVector()),
              (this.args =
                new this.webAssemblyContext.SCRTPointDrawingParams());
          }
          onSeriesPropertyChange(e) {}
          getProperties(e) {
            return e;
          }
          updateArgs(e) {}
          draw(e, t) {
            var r, i;
            const o =
              null === (r = this.getProperties(this.parentSeries)) ||
              void 0 === r
                ? void 0
                : r.pointMarker;
            if (void 0 === o) return;
            let a, s;
            this.parentSeries.hasPointMarkerPaletteProvider()
              ? ((a = o.getFillMask()), (s = o.getStrokeMask()))
              : ((a = o.getSprite()), (s = void 0));
            const n = t.pointSeries,
              l = t.xCoordinateCalculator.isCategoryCoordinateCalculator;
            let d = this.xSelector(n),
              h = this.ySelector(n);
            this.args.Reset(),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.forceShaderMethod = !0),
              this.args.SetSpriteTexture(a.getTexture()),
              s && this.args.SetStrokeMask(s.getTexture());
            const {
                fifoCapacity: u,
                fifoSweeping: c,
                fifoSweepingGap: p,
              } = this.parentSeries.dataSeries,
              g = n.fifoStartIndex;
            if (o.lastPointOnly && h.size() > 0)
              (this.args.count = 1),
                (this.args.startIndex =
                  c && this.parentSeries.dataSeries.count() === u
                    ? g - 1
                    : h.size() - 1);
            else {
              const { startIndex: e, count: r } = this.getStartAndCount(t, d);
              (this.args.count = r),
                (this.args.startIndex = e),
                c &&
                  u === this.parentSeries.dataSeries.count() &&
                  (this.args.count = g);
            }
            this.applyStrokeFillPaletting(
              o.stroke,
              void 0,
              o.fill,
              void 0,
              this.parentSeries.opacity
            ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.paletteStart =
                null !== (i = this.palettingState.paletteStartIndex) &&
                void 0 !== i
                  ? i
                  : 0),
              this.updateArgs(t);
            const y = e.getNativeContext();
            this.drawPoints(
              y,
              l ? n.indexes : d,
              h,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            ),
              c &&
                u === this.parentSeries.dataSeries.count() &&
                !o.lastPointOnly &&
                ((this.args.startIndex = Math.min(h.size(), g + p)),
                (this.args.count = Math.max(0, h.size() - g - p)),
                this.args.count > 0 &&
                  this.drawPoints(
                    y,
                    l ? n.indexes : d,
                    h,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args,
                    this.parentSeries.parentSurface.seriesViewRect
                  ));
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.xAnimationPointMarkerValues = (0, i.deleteSafe)(
                this.xAnimationPointMarkerValues
              )),
              (this.yAnimationPointMarkerValues = (0, i.deleteSafe)(
                this.yAnimationPointMarkerValues
              )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
          overridePaletteProviderColors(e, t, r, i, o, a) {
            if (e.hasPointMarkerPaletteProvider()) {
              const s = e.paletteProvider.overridePointMarkerArgb(
                t,
                r,
                i,
                o,
                a
              );
              if (s) return s;
            }
            return { stroke: void 0, fill: void 0 };
          }
          isGradientFillPaletting(e) {
            return !1;
          }
          drawPoints(e, t, r, i, o, a, s) {
            this.nativeDrawingProvider.DrawPointsVec(e, t, r, i, o, a);
          }
          pointMarkerXYValuesFromSpline(e, t, r, i) {
            this.xAnimationPointMarkerValues.resize(e, 0),
              this.yAnimationPointMarkerValues.resize(e, 0);
            for (let o = 0; o < e - 1; o++) {
              const e = t.get((i + 1) * o);
              this.xAnimationPointMarkerValues.set(o, e);
              const a = r.get((i + 1) * o);
              this.yAnimationPointMarkerValues.set(o, a);
            }
            const o = r.size() - 1;
            this.xAnimationPointMarkerValues.set(e - 1, t.get(o)),
              this.yAnimationPointMarkerValues.set(e - 1, r.get(o));
          }
        }
        t.PointMarkerDrawingProvider = a;
      },
      13473: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RectangleSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(60960),
          a = r(54624),
          s = r(51269),
          n = r(21915),
          l = r(14184),
          d = r(20977),
          h = r(65043);
        class u extends h.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i),
              (this.nativeDrawingProvider =
                new e.SCRTRectangleSeriesDrawingProvider()),
              (this.args =
                new this.webAssemblyContext.SCRTRectangleDrawingParams()),
              (this.strokePenCache = new n.Pen2DCache(e)),
              (this.strokePenFillColoredCache = new n.Pen2DCache(e)),
              (this.fillBrushCache = new s.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries();
            const {
              stroke: e,
              strokeThickness: t,
              fill: r,
              opacity: i,
            } = this.getProperties(this.parentSeries);
            (0, n.createPenInCache)(this.strokePenCache, e, t, i),
              0 === t &&
                (0, n.createPenInCache)(
                  this.strokePenFillColoredCache,
                  r,
                  1,
                  i
                ),
              this.createBrush();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.strokePenFillColoredCache = (0, i.deleteSafe)(
                this.strokePenFillColoredCache
              )),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          getProperties(e) {
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            } = e;
            return {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            };
          }
          draw(e, t) {
            const r = t.pointSeries,
              i = this.parentSeries.parentSurface.seriesViewRect,
              { strokeThickness: l } = this.getProperties(this.parentSeries);
            this.args.Reset(),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.columnWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                this.parentSeries.dataPointWidth,
                this.parentSeries.dataPointWidthMode
              )),
              (this.args.bottomRadius = this.parentSeries.topCornerRadius),
              (this.args.topRadius = this.parentSeries.bottomCornerRadius),
              (this.args.xMode = (0, o.convertColumnMode)(
                this.parentSeries.columnXMode,
                this.webAssemblyContext
              )),
              (this.args.defaultY2 = this.parentSeries.defaultY1),
              (this.args.yMode = (0, o.convertYColumnMode)(
                this.parentSeries.columnYMode,
                this.webAssemblyContext
              ));
            let d = this.strokePenCache;
            1 === this.args.columnWidth &&
              0 === l &&
              ((this.args.columnWidth = 0),
              (d = this.strokePenFillColoredCache));
            const h = (0, n.getScrtPenFromCache)(d);
            h && this.args.SetLinesPen(h);
            const u = (0, s.getScrtBrushFromCache)(this.fillBrushCache);
            u && this.args.SetFillBrush(u),
              (this.args.viewportWidth = i.width),
              (this.args.viewportHeight = i.height),
              super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                h,
                this.parentSeries.fill,
                u,
                this.parentSeries.opacity,
                !1,
                void 0 !== this.parentSeries.fillLinearGradient
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.paletteStart =
                2 * this.palettingState.paletteStartIndex);
            const c = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              p = this.xSelector(r),
              g = this.ySelector(r),
              y = c ? r.indexes : p,
              { startIndex: f, count: v } = this.getStartAndCount(t, y);
            if (
              ((this.args.count = v),
              (this.args.startIndex = f),
              this.args.SetX(y),
              g && this.args.SetY(g),
              this.parentSeries.columnXMode === o.EColumnMode.MidWidth ||
                this.parentSeries.columnXMode === o.EColumnMode.StartEnd ||
                this.parentSeries.columnXMode === o.EColumnMode.StartWidth)
            ) {
              const e = r.getYValuesByName(a.EValueName.X1);
              if (!e)
                throw new Error(
                  `columnMode ${this.parentSeries.columnXMode} requires an DataSeries with a yValue called ${a.EValueName.X1}`
                );
              this.args.SetX2(e);
            }
            const m = r.getYValuesByName(a.EValueName.Y1);
            m && this.args.SetY2(m);
            const {
                fifoCapacity: S,
                fifoSweeping: P,
                fifoSweepingGap: C,
              } = this.parentSeries.dataSeries,
              b = r.fifoStartIndex;
            P &&
              S === this.parentSeries.dataSeries.count() &&
              (this.args.count = b);
            const x = e.getNativeContext();
            this.nativeDrawingProvider.DrawPoints(
              x,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              P &&
                S === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(g.size(), b + C)),
                (this.args.count = Math.max(0, g.size() - b - C)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPoints(
                    x,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(d.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
            } = this.parentSeries;
            (e !== d.PROPERTY.STROKE &&
              e !== d.PROPERTY.STROKE_THICKNESS &&
              e !== d.PROPERTY.OPACITY) ||
              (0, n.createPenInCache)(this.strokePenCache, t, r, i),
              (e !== d.PROPERTY.FILL &&
                e !== d.PROPERTY.OPACITY &&
                e !== d.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                this.createBrush(),
              0 !== r ||
                (e !== d.PROPERTY.STROKE_THICKNESS &&
                  e !== d.PROPERTY.STROKE &&
                  e !== d.PROPERTY.OPACITY &&
                  e !== d.PROPERTY.FILL) ||
                (0, n.createPenInCache)(
                  this.strokePenFillColoredCache,
                  o,
                  1,
                  i
                );
          }
          createBrush() {
            const e = this.parentSeries.parentSurface,
              {
                fillLinearGradient: t,
                fill: r,
                opacity: i,
                customTextureOptions: o,
              } = this.getProperties(this.parentSeries),
              a = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.height /
                  l.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              s = (null == e ? void 0 : e.isCopyCanvasSurface)
                ? e.domCanvas2D.width /
                  l.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            return this.fillBrushCache.create(r, i, a, s, t, o).scrtBrush;
          }
        }
        t.RectangleSeriesDrawingProvider = u;
      },
      68015: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SmearSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(28268),
          a = r(22950),
          s = r(69854),
          n = r(48008),
          l = r(65043);
        class d extends l.BaseSeriesDrawingProvider {
          constructor(e, t, r, i, o) {
            super(e, t, r),
              (this.args = new this.webAssemblyContext.SCRTSmearSeriesParams()),
              (this.colorSettings =
                new this.webAssemblyContext.SCRTHeightColorSettings()),
              (this.yColorSelector =
                null != o ? o : (e) => e.getNativeXValues()),
              (this.zColorSelector =
                null != i ? i : (e) => e.getNativeYValues());
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTSmearSeriesDrawingProvider());
            const {
              stroke: e,
              strokeThickness: t,
              opacity: r,
            } = this.parentSeries;
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              super.delete();
          }
          draw(e, t) {
            var r;
            const i = t.pointSeries;
            this.colorSettings.Reset();
            const l = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              d = i.xValues,
              h = this.parentSeries.colorDataSeries;
            let u = l ? i.indexes : d,
              c = this.ySelector(i),
              p = this.yColorSelector(h),
              g = this.zColorSelector(h);
            this.args.SetX(u), this.args.SetY(c);
            const { startIndex: y, count: f } = this.getStartAndCount(t, u);
            if (
              ((this.args.m_iStartIndex = y),
              (this.args.m_iCount = f),
              (this.args.m_dYOffset = this.parentSeries.yOffset),
              (this.args.smoothColors = this.parentSeries.smoothColors),
              f < 2)
            )
              return;
            if (this.parentSeries.colorSettings) {
              const e = this.parentSeries.colorSettings.colorStops;
              (0, s.validateColorStops)(this.parentSeries.colorSettings);
              for (const t of e) {
                const e = (0, n.parseColorToUIntArgb)(t.color);
                this.colorSettings.AddColorStop(t.dataValue, e);
              }
              this.parentSeries.colorSettings.infraColor &&
                (this.colorSettings.m_uiInfra = (0, n.parseColorToUIntArgb)(
                  this.parentSeries.colorSettings.infraColor
                )),
                this.parentSeries.colorSettings.ultraColor &&
                  (this.colorSettings.m_uiUltra = (0, n.parseColorToUIntArgb)(
                    this.parentSeries.colorSettings.ultraColor
                  )),
                (this.colorSettings.m_fMinHeight = e[0].dataValue),
                (this.colorSettings.m_fMaxHeight = e[e.length - 1].dataValue),
                (this.colorSettings.m_bIsGradient =
                  this.parentSeries.colorSettings.colorPickMode ===
                  o.EColorPickMode.Interpolated),
                (this.colorSettings.m_fMaxTextureSize =
                  null !==
                    (r = this.parentSeries.colorSettings.maxTextureSize) &&
                  void 0 !== r
                    ? r
                    : 0),
                this.args.SetHeightColors(this.colorSettings),
                this.args.SetColorZvalues(g);
            } else if (this.parentSeries.paletteProvider) {
              const e = this.parentSeries.paletteProvider,
                t = this.parentSeries.paletteProvider,
                r = (0, a.uintArgbColorMultiplyOpacity)(
                  (0, n.parseColorToUIntArgb)(this.parentSeries.stroke),
                  this.parentSeries.opacity
                );
              this.palettingState.palettedColors ||
                (this.palettingState.palettedColors =
                  new this.webAssemblyContext.UIntVector());
              const i = p.size();
              if (e.applyPaletting)
                return void e.applyPaletting(
                  this.palettingState,
                  p,
                  g,
                  h.getNativeIndexes(),
                  0,
                  i
                );
              if (
                (this.palettingState.palettedColors.clear(),
                this.palettingState.palettedColors.reserve(i),
                t.overrideStrokeArgb)
              )
                for (let e = 0; e < i; e++) {
                  const i = p.get(e),
                    o = g.get(e),
                    a = t.overrideStrokeArgb(
                      i,
                      o,
                      e,
                      this.parentSeries.opacity,
                      h.getMetadataAt(e)
                    );
                  this.palettingState.palettedColors.push_back(a || r);
                }
              else
                for (let e = 0; e < i; e++)
                  this.palettingState.palettedColors.push_back(g.get(e));
              (this.palettingState.requiresUpdate = !1),
                this.args.SetColors(this.palettingState.palettedColors);
            }
            const v = e.getNativeContext();
            this.nativeDrawingProvider.CreateSmearSeriesColorsTexture(
              p,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              this.nativeDrawingProvider.CreateSmearSeriesValuesTexture(
                t.xCoordinateCalculator.nativeCalculator,
                t.yCoordinateCalculator.nativeCalculator,
                this.args
              ),
              this.nativeDrawingProvider.DrawSmearSeries(v, this.args);
          }
          onDpiChanged(e) {
            super.onDpiChanged(e);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
          }
        }
        t.SmearSeriesDrawingProvider = d;
      },
      74397: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TriangleSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(20977),
          s = r(65043),
          n = r(95808),
          l = r(54624);
        class d extends s.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r, i),
              (this.brushCache = new o.BrushCache(e)),
              (this.args = new e.SCRTTriangleDrawingParams());
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(a.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            if (
              (super.onSeriesPropertyChange(e),
              e === a.PROPERTY.PALETTE_PROVIDER &&
                this.brushCache.invalidateCache(),
              e === a.PROPERTY.FILL ||
                e === a.PROPERTY.OPACITY ||
                e === a.PROPERTY.FILL_LINEAR_GRADIENT)
            ) {
              this.palettingState.requiresUpdate = !0;
              const {
                fill: e,
                opacity: t,
                fillLinearGradient: r,
                customTextureOptions: i,
              } = this.getProperties(this.parentSeries);
              this.brushCache.create(e, null != t ? t : 1, 1, 1, r, i);
            }
          }
          getProperties(e) {
            const {
              fill: t,
              opacity: r,
              drawMode: i,
              polygonVertices: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            } = e;
            return {
              fill: t,
              opacity: r,
              drawMode: i,
              polygonVertices: o,
              fillLinearGradient: a,
              customTextureOptions: s,
            };
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTTriangleSeriesDrawingProvider());
            const {
              fill: e,
              opacity: t,
              fillLinearGradient: r,
              customTextureOptions: i,
            } = this.getProperties(this.parentSeries);
            this.brushCache.create(e, null != t ? t : 1, 1, 1, r, i);
          }
          onDetachSeries() {
            super.onDetachSeries(),
              (this.nativeDrawingProvider = (0, i.deleteSafe)(
                this.nativeDrawingProvider
              ));
          }
          updateArgs(e) {}
          getBrushForDrawing() {
            return this.brushCache;
          }
          draw(e, t) {
            const {
                fill: r,
                drawMode: i,
                polygonVertices: a,
              } = this.getProperties(this.parentSeries),
              s = (0, o.getScrtBrushFromCache)(this.getBrushForDrawing());
            if (!s || !r) return;
            const d = t.pointSeries;
            this.args.Reset(),
              i === n.ETriangleSeriesDrawMode.Polygon
                ? (this.args.drawMode =
                    this.webAssemblyContext.SCRTTriangleDrawMode.Polygon)
                : i === n.ETriangleSeriesDrawMode.Strip
                ? (this.args.drawMode =
                    this.webAssemblyContext.SCRTTriangleDrawMode.Strip)
                : (this.args.drawMode =
                    this.webAssemblyContext.SCRTTriangleDrawMode.List),
              (this.args.iPolygonVertices = a),
              this.args.SetFillBrush(s),
              (this.args.bVerticalChart = t.isVerticalChart);
            const h = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              u = this.xSelector(d);
            this.parentSeries.hasFillPaletteProvider() &&
              (super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                void 0,
                this.parentSeries.fill,
                s,
                this.parentSeries.opacity,
                !1,
                !0
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors));
            let c = h ? d.indexes : u,
              p = this.ySelector(d);
            const { startIndex: g, count: y } = this.getStartAndCount(t, c);
            (this.args.iCount = y), (this.args.iStartIndex = g);
            const f = d.getYValuesByName(l.EValueName.X1),
              v = d.getYValuesByName(l.EValueName.Y1);
            if (f && v) this.args.SetTX(f), this.args.SetTY(v);
            else if (f || v)
              throw new Error(
                "You must either supply both x1 values and y1 values for texture coordinates, or neither to use screen coordinates for the texture"
              );
            this.updateArgs(t);
            const m = e.getNativeContext();
            this.drawTriangles(
              e,
              m,
              c,
              p,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args,
              this.parentSeries.parentSurface.seriesViewRect
            );
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.brushCache = (0, i.deleteSafe)(this.brushCache)),
              super.delete();
          }
          drawTriangles(e, t, r, i, o, a, s, n) {
            this.nativeDrawingProvider.DrawTrianglesVec(t, r, i, o, a, s);
          }
        }
        t.TriangleSeriesDrawingProvider = d;
      },
      9184: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformContoursDrawingProvider = void 0);
        const i = r(84745),
          o = r(56744),
          a = r(23866),
          s = r(48008),
          n = r(80445),
          l = r(98353),
          d = r(35992),
          h = r(53904),
          u = r(20977),
          c = r(65043);
        class p extends c.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.heightsTextureCache = new n.TextureCache(e)),
              this.onSeriesPropertyChange(u.PROPERTY.DATA_SERIES),
              this.onSeriesPropertyChange(u.PROPERTY.COLOR_MAP);
          }
          delete() {
            (this.heightsTextureCache = (0, o.deleteSafe)(
              this.heightsTextureCache
            )),
              (this.heightData = (0, o.deleteSafe)(this.heightData)),
              (this.paletteTexture = (0, o.deleteSafe)(this.paletteTexture)),
              super.delete();
          }
          onSeriesPropertyChange(e) {
            const t =
                e === u.PROPERTY.COLOR_MAP || e.includes(h.COLOR_MAP_PREFIX),
              r = e === u.PROPERTY.DATA_SERIES;
            if (
              (t &&
                ((this.paletteTexture = (0, o.deleteSafe)(this.paletteTexture)),
                this.parentSeries.colorMap &&
                this.parentSeries.colorMap.gradientStops
                  ? (this.paletteTexture = this.createPaletteTexture(
                      256,
                      1,
                      this.parentSeries.colorMap.gradientStops
                    ))
                  : (this.paletteTexture = this.createPaletteTexture(
                      256,
                      1,
                      void 0
                    ))),
              r)
            ) {
              const e = this.parentSeries.dataSeries;
              if (e) {
                const t = this.heightsTextureCache.create(
                  e.arrayWidth,
                  e.arrayHeight,
                  this.webAssemblyContext.eTSRTextureFormat
                    .TSR_TEXTUREFORMAT_R32F
                );
                this.webAssemblyContext.SCRTSetTextureLinearSamplerEnabled(
                  t,
                  !0
                );
              }
            }
          }
          draw(e, t) {
            var r, i;
            const o =
              null === (r = this.heightsTextureCache) || void 0 === r
                ? void 0
                : r.value;
            if (o) {
              const r = this.parentSeries.dataSeries;
              this.webAssemblyContext.SCRTFillTextureFloat32(
                o,
                r.arrayWidth,
                r.arrayHeight,
                r.getNormalizedVector(
                  null !== (i = this.parentSeries.colorMap) && void 0 !== i
                    ? i
                    : this.getDefaultColorMap(r)
                )
              );
              const a = this.parentSeries.getContourDrawingParams(),
                { isVerticalChart: s } = t;
              let n = t.xCoordinateCalculator.getCoordinate(a.xMin);
              const l = t.yCoordinateCalculator.getCoordinate(a.yMin);
              let d = t.xCoordinateCalculator.getCoordinate(a.xMax);
              const h = t.yCoordinateCalculator.getCoordinate(a.yMax),
                u = Math.abs(n - d),
                c = () => {
                  this.parentSeries.minorsPerMajor > 0 &&
                    this.drawContours(
                      e,
                      n,
                      l,
                      d,
                      h,
                      a.zMin,
                      a.zMax,
                      a.zOffset,
                      a.minorStepZ,
                      a.minorLineStyle
                    ),
                    this.drawContours(
                      e,
                      n,
                      l,
                      d,
                      h,
                      a.zMin,
                      a.zMax,
                      a.zOffset,
                      a.majorStepZ,
                      a.majorLineStyle
                    );
                };
              if (s) {
                const r = e.getNativeContext(),
                  i = t.xCoordinateCalculator.hasFlippedCoordinates;
                r.PushMatrix(), r.PushState(), r.Rotate(-90);
                const o = i ? -u - n : -n;
                r.Translate(o, 0),
                  (n = i ? u : 0),
                  (d = i ? 0 : u),
                  c(),
                  r.PopMatrix(),
                  r.PopState();
              } else c();
            }
          }
          drawContours(e, t, r, i, o, a, n, d, h, u) {
            const c = (0, l.getVector4)(this.webAssemblyContext, 0, 1, 0, 0),
              p = new this.webAssemblyContext.SCRTContourParams(),
              g = n - a,
              y = d / g,
              f = (0, s.parseColorToTArgb)(u.color);
            p.SetColorVector(
              f.red / 255,
              f.green / 255,
              f.blue / 255,
              f.opacity / 255
            );
            const v = g / h;
            p.SetParamsAVector(u.strokeThickness, v, y, 0),
              p.SetParamsBVector(a, n, 0, 0);
            const m = e.getNativeContext(),
              S = this.heightsTextureCache.value;
            m.DrawHeatmapRectWithContours(null, S, t, r, i, o, c, p),
              null == p || p.delete();
          }
          computeHeightMap(e, t, r, i, a, s) {
            var n;
            const l = e * t;
            (null === (n = this.heightData) || void 0 === n
              ? void 0
              : n.size()) !== l &&
              ((this.heightData = (0, o.deleteSafe)(this.heightData)),
              (this.heightData = new this.webAssemblyContext.FloatVector()),
              this.heightData.resize(l, 0));
            for (let o = 0; o < e; o++)
              for (let n = 0; n < t; n++) {
                const l = i
                  ? r[s ? n : t - 1 - n][a ? e - o - 1 : o]
                  : r[s ? o : e - 1 - o][a ? t - n - 1 : n];
                this.heightData.set(o * t + n, isNaN(l) ? -1 : l);
              }
            return this.heightData;
          }
          createPaletteTexture(e, t, r) {
            if (i.IS_TEST_ENV) return;
            a.Guard.isTrue(e > 0, "width must be greater than 0"),
              a.Guard.isTrue(t > 0, "height must be greater than 0");
            const o = new d.CanvasTexture(this.webAssemblyContext, e, t);
            o.clear();
            const s = o.getContext(),
              n = e;
            if (r) {
              const e = s.createLinearGradient(0, 0, n, 0);
              r.forEach((t) => {
                e.addColorStop(t.offset, t.color);
              }),
                (s.fillStyle = e);
            } else s.fillStyle = "black";
            return s.fillRect(0, 0, e, t), o.copyTexture(), o;
          }
          getDefaultColorMap(e) {
            const t = e.zRange;
            return { minimum: t.min, maximum: t.max };
          }
        }
        t.UniformContoursDrawingProvider = p;
      },
      76566: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformHeatmapDrawingProvider = void 0);
        const i = r(84745),
          o = r(56744),
          a = r(23866),
          s = r(80445),
          n = r(35992),
          l = r(53904),
          d = r(20977),
          h = r(65043);
        class u extends h.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.heatTextureCache = new s.TextureCache(e)),
              this.recreatePalette(),
              this.onSeriesPropertyChange(d.PROPERTY.DATA_SERIES),
              this.onSeriesPropertyChange(d.PROPERTY.COLOR_MAP);
          }
          delete() {
            (this.paletteTexture = (0, o.deleteSafe)(this.paletteTexture)),
              (this.heatTextureCache = (0, o.deleteSafe)(
                this.heatTextureCache
              )),
              super.delete();
          }
          onSeriesPropertyChange(e) {
            const t =
                e === d.PROPERTY.COLOR_MAP ||
                e.includes(l.COLOR_MAP_PREFIX) ||
                e === d.PROPERTY.OPACITY,
              r =
                e === d.PROPERTY.DATA_SERIES ||
                e === d.PROPERTY.USE_LINEAR_TEXTURE_FILTERING;
            if ((t && this.recreatePalette(), r)) {
              const e = this.parentSeries.dataSeries,
                t = this.parentSeries.useLinearTextureFiltering;
              if (e) {
                const r = this.heatTextureCache.create(
                  e.arrayWidth,
                  e.arrayHeight,
                  this.webAssemblyContext.eTSRTextureFormat
                    .TSR_TEXTUREFORMAT_R32F
                );
                this.webAssemblyContext.SCRTSetTextureLinearSamplerEnabled(
                  r,
                  t
                );
              }
            }
          }
          seriesHasDataChanges() {
            this.onSeriesPropertyChange(d.PROPERTY.DATA_SERIES);
          }
          draw(e, t) {
            var r;
            const { isVerticalChart: i } = t,
              o = !t.xCoordinateCalculator.hasFlippedCoordinates,
              a =
                (t.yCoordinateCalculator.hasFlippedCoordinates,
                null === (r = this.heatTextureCache) || void 0 === r
                  ? void 0
                  : r.value);
            if (a) {
              const r = this.parentSeries.dataSeries,
                s = r.getNormalizedVector(
                  this.parentSeries.colorMap,
                  this.parentSeries.fillValuesOutOfRange
                );
              (this.packedFloatParams =
                this.webAssemblyContext.SCRTFillTextureFloat32(
                  a,
                  r.arrayWidth,
                  r.arrayHeight,
                  s
                )),
                (this.packedFloatParams.x = 0),
                (this.packedFloatParams.y = 1);
              const n = r.xRange,
                l = r.yRange,
                d = t.xCoordinateCalculator.getCoordinate(n.min),
                h = t.yCoordinateCalculator.getCoordinate(l.min),
                u = t.xCoordinateCalculator.getCoordinate(n.max),
                c = t.yCoordinateCalculator.getCoordinate(l.max),
                p = e.getNativeContext(),
                g =
                  (this.parentSeries.parentSurface.seriesViewRect,
                  Math.abs(d - u));
              if (i) {
                p.PushMatrix(), p.PushState(), p.Rotate(-90);
                const e = o ? -d : -g - d;
                p.Translate(e, 0);
                const t = o ? 0 : g,
                  r = o ? g : 0,
                  i = h,
                  a = c;
                this.drawHeatmap(p, t, i, r, a), p.PopMatrix(), p.PopState();
              } else this.drawHeatmap(p, d, h, u, c);
            }
          }
          createPaletteTexture(e, t, r, o, s) {
            if (i.IS_TEST_ENV) return;
            a.Guard.isTrue(e > 0, "width must be greater than 0"),
              a.Guard.isTrue(t > 0, "height must be greater than 0"),
              a.Guard.notNull(r, "gradientStops");
            const l = new n.CanvasTexture(this.webAssemblyContext, e, t);
            l.clear();
            const d = l.getContext();
            s && ((d.fillStyle = "#ffffff00"), d.fillRect(0, 0, 1, t));
            const h = e,
              u = d.createLinearGradient(0, 0, h, 0);
            r.forEach((e) => {
              u.addColorStop(e.offset, e.color);
            }),
              (d.fillStyle = u),
              (d.globalAlpha = o);
            const c = s ? 1 : 0;
            return d.fillRect(c, 0, e, t), l.copyTexture(), l;
          }
          recreatePalette() {
            var e, t;
            const r =
              null === (e = this.parentSeries.dataSeries) || void 0 === e
                ? void 0
                : e.hasNaNs;
            (this.hasNaNs === r &&
              this.opacity === this.parentSeries.opacity &&
              this.gradientStops ===
                (null === (t = this.parentSeries.colorMap) || void 0 === t
                  ? void 0
                  : t.gradientStops)) ||
              ((this.paletteTexture = (0, o.deleteSafe)(this.paletteTexture)),
              this.parentSeries.colorMap &&
                this.parentSeries.colorMap.gradientStops &&
                ((this.hasNaNs = r),
                (this.opacity = this.parentSeries.opacity),
                (this.gradientStops = this.parentSeries.colorMap.gradientStops),
                (this.paletteTexture = this.createPaletteTexture(
                  256,
                  1,
                  this.parentSeries.colorMap.gradientStops,
                  this.parentSeries.opacity,
                  r
                ))));
          }
          drawHeatmap(e, t, r, i, o) {
            const a = this.packedFloatParams,
              s = new this.webAssemblyContext.SCRTContourParams(),
              n = this.heatTextureCache.value;
            this.recreatePalette(),
              e.DrawHeatmapRectWithContours(
                this.paletteTexture.getTexture(),
                n,
                t,
                r,
                i,
                o,
                a,
                s
              ),
              s.delete(),
              a.delete();
          }
        }
        t.UniformHeatmapDrawingProvider = u;
      },
      98550: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastBandRenderableSeries = void 0);
        const i = r(5337),
          o = r(20181);
        class a extends o.BaseBandRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.BandSeries),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this));
          }
        }
        t.FastBandRenderableSeries = a;
      },
      33236: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastBoxPlotRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(2192),
          s = r(27970),
          n = r(5337),
          l = r(51885),
          d = r(22769),
          h = r(84392),
          u = r(14184),
          c = r(79961),
          p = r(20977),
          g = r(79687),
          y = r(94707),
          f = r(82767);
        class v extends c.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, o, a, l, d, h, c, p, f, v, m, S, P, C, b, x, A;
            super(e, t),
              (this.type = n.ESeriesType.BoxPlotSeries),
              (this.dataPointWidthModeProperty =
                s.EDataPointWidthMode.Relative),
              (this.capProperty = {
                dataPointWidth: 0.25,
                stroke: u.SciChartSurfaceBase.DEFAULT_THEME.lineSeriesColor,
                strokeDashArray: [],
                strokeThickness: 2,
              }),
              (this.whiskersProperty = {
                stroke: u.SciChartSurfaceBase.DEFAULT_THEME.lineSeriesColor,
                strokeDashArray: [],
                strokeThickness: 2,
              }),
              (this.medianLineProperty = {
                stroke: u.SciChartSurfaceBase.DEFAULT_THEME.lineSeriesColor,
                strokeDashArray: [],
                strokeThickness: 4,
              }),
              (this.dataPointWidthProperty = 0.5),
              (this.strokeDashArrayProperty = []),
              (this.fillProperty =
                u.SciChartSurfaceBase.DEFAULT_THEME.columnFillBrush),
              (this.dataPointWidthMode =
                null !== (r = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== r
                  ? r
                  : this.dataPointWidthModeProperty),
              (null == t ? void 0 : t.cap) &&
                ((this.capProperty.dataPointWidth =
                  null !== (i = t.cap.dataPointWidth) && void 0 !== i
                    ? i
                    : this.capProperty.dataPointWidth),
                (this.capProperty.stroke =
                  null !== (o = t.cap.stroke) && void 0 !== o
                    ? o
                    : this.capProperty.stroke),
                (this.capProperty.strokeDashArray =
                  null !== (a = t.cap.strokeDashArray) && void 0 !== a
                    ? a
                    : this.capProperty.strokeDashArray),
                (this.capProperty.strokeThickness =
                  null !== (l = t.cap.strokeThickness) && void 0 !== l
                    ? l
                    : this.capProperty.strokeThickness)),
              (null == t ? void 0 : t.whiskers) &&
                ((this.whiskersProperty.stroke =
                  null !== (d = t.whiskers.stroke) && void 0 !== d
                    ? d
                    : this.whiskersProperty.stroke),
                (this.whiskersProperty.strokeDashArray =
                  null !== (h = t.whiskers.strokeDashArray) && void 0 !== h
                    ? h
                    : this.whiskersProperty.strokeDashArray),
                (this.whiskersProperty.strokeThickness =
                  null !== (c = t.whiskers.strokeThickness) && void 0 !== c
                    ? c
                    : this.whiskersProperty.strokeThickness)),
              (null == t ? void 0 : t.medianLine) &&
                ((this.medianLineProperty.stroke =
                  null !== (p = t.medianLine.stroke) && void 0 !== p
                    ? p
                    : this.medianLineProperty.stroke),
                (this.medianLineProperty.strokeDashArray =
                  null !== (f = t.medianLine.strokeDashArray) && void 0 !== f
                    ? f
                    : this.medianLineProperty.strokeDashArray),
                (this.medianLineProperty.strokeThickness =
                  null !== (v = t.medianLine.strokeThickness) && void 0 !== v
                    ? v
                    : this.medianLineProperty.strokeThickness)),
              (this.strokeThickness =
                null !== (m = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== m
                  ? m
                  : 0),
              (this.dataPointWidthProperty =
                null !== (S = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== S
                  ? S
                  : this.dataPointWidthProperty),
              (this.strokeDashArrayProperty =
                null !== (P = null == t ? void 0 : t.strokeDashArray) &&
                void 0 !== P
                  ? P
                  : this.strokeDashArrayProperty),
              (this.fillProperty =
                null !== (C = null == t ? void 0 : t.fill) && void 0 !== C
                  ? C
                  : this.fillProperty),
              (this.fillLinearGradientProperty =
                null !== (b = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== b
                  ? b
                  : this.fillLinearGradientProperty),
              (this.drawingProviders = [
                new g.BoxPlotSeriesDrawingProvider(e, this),
                new y.PointMarkerDrawingProvider(e, this),
              ]),
              (null === (x = this.paletteProvider) || void 0 === x
                ? void 0
                : x.onAttached) &&
                (null === (A = this.paletteProvider) ||
                  void 0 === A ||
                  A.onAttached(this)),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.lineSeriesColor &&
              (this.stroke = e.lineSeriesColor);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          get cap() {
            return this.capProperty;
          }
          set cap(e) {
            (this.capProperty = Object.assign(
              Object.assign({}, this.capProperty),
              e
            )),
              this.notifyPropertyChanged(p.PROPERTY.BOX_SERIES_CAP);
          }
          get whiskers() {
            return this.whiskersProperty;
          }
          set whiskers(e) {
            (this.whiskersProperty = Object.assign(
              Object.assign({}, this.whiskersProperty),
              e
            )),
              this.notifyPropertyChanged(p.PROPERTY.BOX_SERIES_WHISKERS);
          }
          get medianLine() {
            return this.medianLineProperty;
          }
          set medianLine(e) {
            (this.medianLineProperty = Object.assign(
              Object.assign({}, this.medianLineProperty),
              e
            )),
              this.notifyPropertyChanged(p.PROPERTY.BOX_SERIES_MEDIAN);
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH);
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.STROKE_DASH_ARRAY);
          }
          get fill() {
            return (0, h.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get paletteProvider() {}
          set paletteProvider(e) {
            throw new Error(
              "paletteProvider is not supported by FastBoxPlotRenderableSeries!"
            );
          }
          delete() {
            super.delete(),
              (this.pointSeries = (0, i.deleteSafe)(this.pointSeries));
          }
          getXRange() {
            var e;
            const t = super.getXRange(),
              r = (0, c.getDataPointWidthAdjustment)(
                this.dataPointWidthMode,
                this.dataPointWidth,
                this.dataSeries.count(),
                t,
                this.xAxis.getCurrentCoordinateCalculator()
              ),
              i = new o.NumberRange(t.min - r, t.max + r);
            return this.strokeThickness
              ? (0, c.adjustRangeByStrokeThickness)(
                  i,
                  this.strokeThickness,
                  null === (e = this.parentSurface.seriesViewRect) ||
                    void 0 === e
                    ? void 0
                    : e.height
                )
              : i;
          }
          getYRange(e, t = !1) {
            var r;
            const i = this.isRunningDataAnimation
                ? l.EDataSeriesValueType.FinalAnimationValues
                : l.EDataSeriesValueType.Default,
              o = this.dataSeries.getWindowedYRange(
                e,
                !0,
                t,
                i,
                this.yRangeMode
              );
            return this.yAxis.type === a.EAxisType.LogarithmicAxis
              ? o
              : (0, c.adjustRangeByStrokeThickness)(
                  o,
                  this.cap.strokeThickness,
                  null === (r = this.parentSurface.seriesViewRect) ||
                    void 0 === r
                    ? void 0
                    : r.height
                );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                dataPointWidthMode: this.dataPointWidthMode,
                cap: this.capProperty,
                whiskers: this.whiskersProperty,
                medianLine: this.medianLineProperty,
                dataPointWidth: this.dataPointWidth,
                strokeDashArray: this.strokeDashArray,
                fill: this.fill,
                fillLinearGradient: this.fillLinearGradient,
              };
            return Object.assign(t.options, r), t;
          }
          toPointSeries(e) {
            if (e) throw new Error("Box Plot Series don't support resampling!");
            return new d.BoxPlotPointSeriesWrapped(this.dataSeries);
          }
          newHitTestProvider() {
            return new f.BoxPlotSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.FastBoxPlotRenderableSeries = v;
      },
      11555: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastBubbleRenderableSeries = void 0);
        const i = r(5337),
          o = r(62507),
          a = r(10749),
          s = r(79961),
          n = r(9297),
          l = r(89748),
          d = r(15273),
          h = r(20977);
        class u extends s.BaseRenderableSeries {
          constructor(e, t) {
            var r, o, s;
            super(e, t),
              (this.type = i.ESeriesType.BubbleSeries),
              (this.zMultiplierProperty = 1),
              (this.zMultiplierProperty =
                null !== (r = null == t ? void 0 : t.zMultiplier) &&
                void 0 !== r
                  ? r
                  : this.zMultiplierProperty),
              this.pointMarker ||
                (this.pointMarker = new a.EllipsePointMarker(e, {
                  width: 64,
                  height: 64,
                })),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (s = this.paletteProvider) ||
                  void 0 === s ||
                  s.onAttached(this)),
              (this.drawingProviders = []),
              this.drawingProviders.push(
                new n.BubbleSeriesDrawingProvider(e, this)
              ),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new d.BubbleSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          get paletteProvider() {
            return this.paletteProviderProperty;
          }
          set paletteProvider(e) {
            this.setPaletteProvider(e);
          }
          get zMultiplier() {
            return this.zMultiplierProperty;
          }
          set zMultiplier(e) {
            (this.zMultiplierProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.Z_MULTIPLIER);
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.lineSeriesColor &&
              (this.stroke = e.lineSeriesColor);
          }
          getBubbleDiameter(e) {
            return this.dataSeries.getNativeZValues().get(e);
          }
          getNativeZValues() {
            return this.dataSeries.getNativeZValues();
          }
          toPointSeries(e) {
            return new o.XyzPointSeriesWrapped(this.dataSeries);
          }
          newHitTestProvider() {
            return new l.BubbleSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { zMultiplier: this.zMultiplier };
            return Object.assign(t.options, r), t;
          }
        }
        t.FastBubbleRenderableSeries = u;
      },
      12641: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastCandlestickRenderableSeries = void 0);
        const i = r(5337),
          o = r(84392),
          a = r(14184),
          s = r(18790),
          n = r(20977),
          l = r(88302);
        class d extends s.BaseOhlcRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.CandlestickSeries),
              (this.brushUp =
                (null == t ? void 0 : t.brushUp) ||
                a.SciChartSurfaceBase.DEFAULT_THEME.upBodyBrush),
              (this.brushDown =
                (null == t ? void 0 : t.brushDown) ||
                a.SciChartSurfaceBase.DEFAULT_THEME.downBodyBrush),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this)),
              (this.drawingProviders = []),
              this.drawingProviders.push(
                new l.OhlcSeriesDrawingProvider(
                  e,
                  this,
                  l.EOhlcDrawingMode.Candles
                )
              );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.brushUp === t.upBodyBrush && (this.brushUp = e.upBodyBrush),
              this.brushDown === t.downBodyBrush &&
                (this.brushDown = e.downBodyBrush);
          }
          get brushUp() {
            return (0, o.stripAutoColor)(this.brushUpProperty);
          }
          set brushUp(e) {
            (this.brushUpProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.BRUSH_UP);
          }
          get brushDown() {
            return (0, o.stripAutoColor)(this.brushDownProperty);
          }
          set brushDown(e) {
            (this.brushDownProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.BRUSH_DOWN);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { brushDown: this.brushDown, brushUp: this.brushUp };
            return Object.assign(t.options, r), t;
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.brushUpProperty.startsWith(o.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.brushUp = o.AUTO_COLOR + this.adjustAutoColor("brushUp", i);
            }
            const i = (e + Math.floor(t / 2)) % t;
            if (this.brushDownProperty.startsWith(o.AUTO_COLOR)) {
              const e = r.getFillColor(i, t, this.webAssemblyContext);
              this.brushDown =
                o.AUTO_COLOR + this.adjustAutoColor("brushDown", e);
            }
          }
        }
        t.FastCandlestickRenderableSeries = d;
      },
      20667: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getXRange = t.FastColumnRenderableSeries = void 0);
        const i = r(98140),
          o = r(27970),
          a = r(5337),
          s = r(84392),
          n = r(14184),
          l = r(79961),
          d = r(20977),
          h = r(1367),
          u = r(50836),
          c = r(94707),
          p = r(18314);
        class g extends l.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, s, l, d, u, c, p;
            super(e, t),
              (this.type = a.ESeriesType.ColumnSeries),
              (this.fillProperty =
                n.SciChartSurfaceBase.DEFAULT_THEME.columnFillBrush),
              (this.zeroLineYProperty = 0),
              (this.dataPointWidthProperty = 0.8),
              (this.dataPointWidthModeProperty =
                o.EDataPointWidthMode.Relative),
              (this.cornerRadiusProperty = 0),
              (this.fillProperty =
                null !== (r = null == t ? void 0 : t.fill) && void 0 !== r
                  ? r
                  : this.fillProperty),
              (this.zeroLineY =
                null !== (i = null == t ? void 0 : t.zeroLineY) && void 0 !== i
                  ? i
                  : this.zeroLineYProperty),
              (this.dataPointWidthProperty =
                null !== (s = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== s
                  ? s
                  : this.dataPointWidthProperty),
              (this.dataPointWidthMode =
                null !== (l = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== l
                  ? l
                  : this.dataPointWidthModeProperty),
              (this.fillLinearGradientProperty =
                null !== (d = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== d
                  ? d
                  : this.fillLinearGradientProperty),
              (this.cornerRadiusProperty =
                null !== (u = null == t ? void 0 : t.cornerRadius) &&
                void 0 !== u
                  ? u
                  : this.cornerRadiusProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions),
              (null === (c = this.paletteProvider) || void 0 === c
                ? void 0
                : c.onAttached) &&
                (null === (p = this.paletteProvider) ||
                  void 0 === p ||
                  p.onAttached(this)),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new h.ColumnSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new u.ColumnSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new c.PointMarkerDrawingProvider(e, this)
              );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.fill === t.columnFillBrush && (this.fill = e.columnFillBrush),
              this.stroke === t.columnLineColor &&
                (this.stroke = e.columnLineColor);
          }
          get fill() {
            return (0, s.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            this.fillProperty !== e &&
              ((this.fillProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.FILL));
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get zeroLineY() {
            return this.zeroLineYProperty;
          }
          set zeroLineY(e) {
            (this.zeroLineYProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.ZERO_LINE_Y);
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.DATA_POINT_WIDTH);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          get cornerRadius() {
            return this.cornerRadiusProperty;
          }
          set cornerRadius(e) {
            (this.cornerRadiusProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.CORNER_RADIUS);
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          getXRange() {
            const e = super.getXRange(),
              t = (0, l.getDataPointWidthAdjustment)(
                this.dataPointWidthMode,
                this.dataPointWidth,
                this.dataSeries.count(),
                e,
                this.xAxis.getCurrentCoordinateCalculator()
              );
            return new i.NumberRange(e.min - t, e.max + t);
          }
          getYRange(e, t = !1) {
            const r = super.getYRange(e, t);
            if (r)
              return new i.NumberRange(
                Math.min(r.min, this.zeroLineY),
                Math.max(r.max, this.zeroLineY)
              );
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(s.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = s.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                dataPointWidth: this.dataPointWidth,
                dataPointWidthMode: this.dataPointWidthMode,
                fill: this.fill,
                zeroLineY: this.zeroLineY,
                fillLinearGradient: this.fillLinearGradient,
                cornerRadius: this.cornerRadius,
              };
            return Object.assign(t.options, r), t;
          }
          newHitTestProvider() {
            return new p.ColumnSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        (t.FastColumnRenderableSeries = g),
          (t.getXRange = (e, t, r) => {
            if (t > 1) {
              const o = ((e.diff / (t - 1)) * r) / 2;
              return new i.NumberRange(e.min - o, e.max + o);
            }
            return e;
          });
      },
      43852: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastErrorBarsRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(2192),
          s = r(27970),
          n = r(79226),
          l = r(32287),
          d = r(5337),
          h = r(51885),
          u = r(89236),
          c = r(79961),
          p = r(20977),
          g = r(71788),
          y = r(94707),
          f = r(99828);
        class v extends c.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, o, a, h, u, c, p, f;
            super(e, t),
              (this.type = d.ESeriesType.ErrorBarsSeries),
              (this.dataPointWidthProperty = 0.5),
              (this.dataPointWidthModeProperty =
                s.EDataPointWidthMode.Relative),
              (this.errorModeProperty = l.EErrorMode.Both),
              (this.errorDirectionProperty = n.EErrorDirection.Vertical),
              (this.strokeDashArrayProperty = []),
              (this.drawWhiskersProperty = !0),
              (this.drawConnectorProperty = !0),
              (this.dataPointWidth =
                null !== (r = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== r
                  ? r
                  : this.dataPointWidthProperty),
              (this.errorModeProperty =
                null !== (i = null == t ? void 0 : t.errorMode) && void 0 !== i
                  ? i
                  : this.errorModeProperty),
              (this.errorDirectionProperty =
                null !== (o = null == t ? void 0 : t.errorDirection) &&
                void 0 !== o
                  ? o
                  : this.errorDirectionProperty),
              (this.dataPointWidthMode =
                null !== (a = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== a
                  ? a
                  : this.dataPointWidthModeProperty),
              (this.strokeDashArray =
                null !== (h = null == t ? void 0 : t.strokeDashArray) &&
                void 0 !== h
                  ? h
                  : this.strokeDashArrayProperty),
              (this.drawWhiskers =
                null !== (u = null == t ? void 0 : t.drawWhiskers) &&
                void 0 !== u
                  ? u
                  : this.drawWhiskersProperty),
              (this.drawConnector =
                null !== (c = null == t ? void 0 : t.drawConnector) &&
                void 0 !== c
                  ? c
                  : this.drawConnectorProperty),
              (this.drawingProviders = [
                new g.ErrorSeriesDrawingProvider(e, this),
                new y.PointMarkerDrawingProvider(e, this),
              ]),
              (null === (p = this.paletteProvider) || void 0 === p
                ? void 0
                : p.onAttached) &&
                (null === (f = this.paletteProvider) ||
                  void 0 === f ||
                  f.onAttached(this)),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.stroke === t.lineSeriesColor &&
              (this.stroke = e.lineSeriesColor);
          }
          get strokeDashArray() {
            return this.strokeDashArrayProperty;
          }
          set strokeDashArray(e) {
            (this.strokeDashArrayProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.STROKE_DASH_ARRAY);
          }
          get drawWhiskers() {
            return this.drawWhiskersProperty;
          }
          set drawWhiskers(e) {
            (this.drawWhiskersProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DRAW_WHISKERS);
          }
          get drawConnector() {
            return this.drawConnectorProperty;
          }
          set drawConnector(e) {
            (this.drawConnectorProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DRAW_CONNECTOR);
          }
          get paletteProvider() {}
          set paletteProvider(e) {
            throw new Error(
              "paletteProvider is not supported by FastErrorBarsRenderableSeries!"
            );
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH);
          }
          get errorMode() {
            return this.errorModeProperty;
          }
          set errorMode(e) {
            (this.errorModeProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.ERROR_MODE);
          }
          get errorDirection() {
            return this.errorDirectionProperty;
          }
          set errorDirection(e) {
            (this.errorDirectionProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.ERROR_DIRECTION);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          delete() {
            super.delete(),
              (this.pointSeries = (0, i.deleteSafe)(this.pointSeries));
          }
          getDataPointWidth(e, t, r) {
            const i =
                this.errorDirection === n.EErrorDirection.Vertical
                  ? this.dataSeries.getNativeXValues()
                  : this.dataSeries.getNativeYValues(),
              o = e.viewportDimension,
              a = e.isCategoryCoordinateCalculator;
            if (r === s.EDataPointWidthMode.Range) {
              const r = e.visibleMax - e.visibleMin;
              return (e.viewportDimension / r) * t;
            }
            if (r === s.EDataPointWidthMode.Absolute) return t;
            {
              let r = Math.floor(
                (0, c.getDataPointWidth)(i, e, o, t, a, this.webAssemblyContext)
              );
              return r % 2 != 0 && (r -= 1), r <= 1 && (r = 1), r;
            }
          }
          getXRange() {
            var e;
            const t = this.errorDirection === n.EErrorDirection.Vertical,
              r = this.errorMode !== l.EErrorMode.Low,
              i = this.errorMode !== l.EErrorMode.High,
              o = this.dataSeries.getXRange(
                h.EDataSeriesValueType.Default,
                !t,
                r,
                i
              );
            return this.xAxis.type === a.EAxisType.LogarithmicAxis
              ? o
              : t
              ? this.adjustRangeByDataPointWidth(o, this.xAxis)
              : (0, c.adjustRangeByStrokeThickness)(
                  o,
                  this.strokeThickness,
                  null === (e = this.parentSurface.seriesViewRect) ||
                    void 0 === e
                    ? void 0
                    : e.width
                );
          }
          getYRange(e, t = !1) {
            var r;
            const i = this.errorDirection === n.EErrorDirection.Horizontal,
              o = this.errorMode !== l.EErrorMode.Low,
              s = this.errorMode !== l.EErrorMode.High,
              d = this.isRunningDataAnimation
                ? h.EDataSeriesValueType.FinalAnimationValues
                : h.EDataSeriesValueType.Default,
              u = this.dataSeries.getWindowedYRange(
                e,
                !0,
                t,
                d,
                this.yRangeMode,
                i,
                o,
                s
              );
            return this.yAxis.type === a.EAxisType.LogarithmicAxis
              ? u
              : i
              ? this.adjustRangeByDataPointWidth(u, this.yAxis)
              : (0, c.adjustRangeByStrokeThickness)(
                  u,
                  this.strokeThickness,
                  null === (r = this.parentSurface.seriesViewRect) ||
                    void 0 === r
                    ? void 0
                    : r.height
                );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                dataPointWidth: this.dataPointWidth,
                dataPointWidthMode: this.dataPointWidthMode,
                errorDirection: this.errorDirection,
                errorMode: this.errorMode,
                drawWhiskers: this.drawWhiskers,
                drawConnector: this.drawConnector,
                strokeDashArray: this.strokeDashArray,
              };
            return Object.assign(t.options, r), t;
          }
          toPointSeries(e) {
            if (e)
              throw new Error("Error Bars Series don't support resampling!");
            return new u.HlcPointSeriesWrapped(this.dataSeries);
          }
          newHitTestProvider() {
            return new f.ErrorSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
          adjustRangeByDataPointWidth(e, t) {
            const r = (0, c.getDataPointWidthAdjustment)(
              this.dataPointWidthMode,
              this.dataPointWidth,
              this.dataSeries.count(),
              e,
              t.getCurrentCoordinateCalculator()
            );
            return new o.NumberRange(e.min - r, e.max + r);
          }
        }
        t.FastErrorBarsRenderableSeries = v;
      },
      93522: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastImpulseRenderableSeries = void 0);
        const i = r(98140),
          o = r(5337),
          a = r(84392),
          s = r(10749),
          n = r(14184),
          l = r(79961),
          d = r(20977),
          h = r(20667),
          u = r(30995);
        class c extends h.FastColumnRenderableSeries {
          constructor(e, t) {
            var r, i, a, l;
            super(e, t),
              (this.type = o.ESeriesType.ImpulseSeries),
              (this.impulseFillProperty =
                n.SciChartSurfaceBase.DEFAULT_THEME.impulseFillBrush),
              (this.impulseSizeProperty = 10),
              (this.impulseDataPointWidthProperty = 0),
              (this.impulseStrokeThicknessProperty = 1),
              (this.strokeThickness =
                null !== (r = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== r
                  ? r
                  : this.impulseStrokeThicknessProperty),
              (this.fill =
                null !== (i = null == t ? void 0 : t.fill) && void 0 !== i
                  ? i
                  : this.impulseFillProperty),
              (this.size =
                null !== (a = null == t ? void 0 : t.size) && void 0 !== a
                  ? a
                  : this.impulseSizeProperty),
              (this.stroke =
                null !== (l = null == t ? void 0 : t.fill) && void 0 !== l
                  ? l
                  : this.impulseFillProperty),
              (this.dataPointWidth = this.impulseDataPointWidthProperty),
              (null == t ? void 0 : t.pointMarker) ||
                (this.pointMarker = new s.EllipsePointMarker(e, {
                  width: this.impulseSizeProperty,
                  height: this.impulseSizeProperty,
                  fill: this.fill,
                  stroke: this.fill,
                }));
          }
          get fill() {
            return (0, a.stripAutoColor)(this.impulseFillProperty);
          }
          set fill(e) {
            (this.impulseFillProperty = e),
              (this.stroke = e),
              this.pointMarker &&
                ((this.pointMarker.fill = e), (this.pointMarker.stroke = e)),
              this.impulseFillProperty !== e &&
                this.notifyPropertyChanged(d.PROPERTY.STROKE);
          }
          get size() {
            return this.impulseSizeProperty;
          }
          set size(e) {
            (this.impulseSizeProperty = e),
              this.pointMarker &&
                ((this.pointMarker.width = e), (this.pointMarker.height = e));
          }
          getXRange() {
            var e, t;
            const r = super.getXRange(),
              o = (0, l.getDelta)({
                pointSize: this.size,
                areaSize:
                  null !==
                    (t =
                      null === (e = this.parentSurface.seriesViewRect) ||
                      void 0 === e
                        ? void 0
                        : e.width) && void 0 !== t
                    ? t
                    : 0,
                range: r,
              });
            return new i.NumberRange(r.min - o, r.max + o);
          }
          getYRange(e, t = !1) {
            var r, o;
            const a = super.getYRange(e, t);
            if (!a) return;
            const s = (0, l.getDelta)({
              pointSize: this.size,
              areaSize:
                null !==
                  (o =
                    null === (r = this.parentSurface.seriesViewRect) ||
                    void 0 === r
                      ? void 0
                      : r.height) && void 0 !== o
                  ? o
                  : 0,
              range: a,
            });
            return new i.NumberRange(a.min - s, a.max + s);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                size: this.size,
                zeroLineY: this.zeroLineY,
              };
            return Object.assign(t.options, r), t;
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.fill === t.impulseFillBrush &&
              (this.fill = e.impulseFillBrush);
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.impulseFillProperty.startsWith(a.AUTO_COLOR))
            ) {
              const i = r.getStrokeColor(e, t, this.webAssemblyContext);
              this.fill = a.AUTO_COLOR + this.adjustAutoColor("impulseFill", i);
            }
          }
          newHitTestProvider() {
            return new u.ImpulseSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.FastImpulseRenderableSeries = c;
      },
      65297: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastLineRenderableSeries = void 0);
        const i = r(5337),
          o = r(20782),
          a = r(33802);
        class s extends o.BaseLineRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.LineSeries),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new a.LineSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this));
          }
        }
        t.FastLineRenderableSeries = s;
      },
      72362: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(36650),
          a = r(96852);
        class s extends o.BaseMountainRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.MountainSeries),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new a.DataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this));
          }
        }
        t.FastMountainRenderableSeries = s;
      },
      95179: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastOhlcRenderableSeries = void 0);
        const i = r(5337),
          o = r(18790),
          a = r(88302);
        class s extends o.BaseOhlcRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.OhlcSeries),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this)),
              (this.drawingProviders = []),
              this.drawingProviders.push(
                new a.OhlcSeriesDrawingProvider(
                  e,
                  this,
                  a.EOhlcDrawingMode.Ohlc
                )
              );
          }
        }
        t.FastOhlcRenderableSeries = s;
      },
      16098: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastRectangleRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(60960),
          s = r(27970),
          n = r(5337),
          l = r(54624),
          d = r(51885),
          h = r(84392),
          u = r(14184),
          c = r(79961),
          p = r(20977),
          g = r(13473),
          y = r(92762),
          f = r(70027);
        class v extends c.BaseRenderableSeries {
          constructor(e, t) {
            var r, i, o, l, d, h, c, p, g, y, v;
            super(e, t),
              (this.type = n.ESeriesType.RectangleSeries),
              (this.defaultY1Property = 0),
              (this.fillProperty =
                u.SciChartSurfaceBase.DEFAULT_THEME.columnFillBrush),
              (this.dataPointWidthProperty = 1),
              (this.dataPointWidthModeProperty = s.EDataPointWidthMode.Range),
              (this.columnXModeProperty = a.EColumnMode.Mid),
              (this.columnYModeProperty = a.EColumnYMode.TopBottom),
              (this.topCornerRadiusProperty = 0),
              (this.bottomCornerRadiusProperty = 0),
              (this.fillProperty =
                null !== (r = null == t ? void 0 : t.fill) && void 0 !== r
                  ? r
                  : this.fillProperty),
              (this.defaultY1Property =
                null !== (i = null == t ? void 0 : t.defaultY1) && void 0 !== i
                  ? i
                  : this.defaultY1Property),
              (this.dataPointWidthProperty =
                null !== (o = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== o
                  ? o
                  : this.dataPointWidthProperty),
              (this.dataPointWidthModeProperty =
                null !== (l = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== l
                  ? l
                  : this.dataPointWidthModeProperty),
              (this.fillLinearGradientProperty =
                null !== (d = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== d
                  ? d
                  : this.fillLinearGradientProperty),
              (this.topCornerRadiusProperty =
                null !== (h = null == t ? void 0 : t.topCornerRadius) &&
                void 0 !== h
                  ? h
                  : this.topCornerRadiusProperty),
              (this.bottomCornerRadiusProperty =
                null !== (c = null == t ? void 0 : t.bottomCornerRadius) &&
                void 0 !== c
                  ? c
                  : this.bottomCornerRadiusProperty),
              (this.columnXModeProperty =
                null !== (p = null == t ? void 0 : t.columnXMode) &&
                void 0 !== p
                  ? p
                  : this.columnXModeProperty),
              (this.columnYModeProperty =
                null !== (g = null == t ? void 0 : t.columnYMode) &&
                void 0 !== g
                  ? g
                  : this.columnYModeProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions),
              (null === (y = this.paletteProvider) || void 0 === y
                ? void 0
                : y.onAttached) &&
                (null === (v = this.paletteProvider) ||
                  void 0 === v ||
                  v.onAttached(this)),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new f.RectangleSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new g.RectangleSeriesDrawingProvider(e, this)
            );
          }
          applyTheme(e) {
            super.applyTheme(e);
            const t = this.parentSurface.previousThemeProvider;
            this.fill === t.columnFillBrush && (this.fill = e.columnFillBrush),
              this.stroke === t.columnLineColor &&
                (this.stroke = e.columnLineColor);
          }
          get defaultY1() {
            return this.defaultY1Property;
          }
          set defaultY1(e) {
            (this.defaultY1Property = e),
              this.notifyPropertyChanged(p.PROPERTY.DEFAULT_Y1);
          }
          get fill() {
            return (0, h.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            this.fillProperty !== e &&
              ((this.fillProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL));
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get columnXMode() {
            return this.columnXModeProperty;
          }
          set columnXMode(e) {
            this.columnXModeProperty !== e &&
              ((this.columnXModeProperty = e),
              this.notifyPropertyChanged("COLUMN_MODE"));
          }
          get columnYMode() {
            return this.columnYModeProperty;
          }
          set columnYMode(e) {
            this.columnYModeProperty !== e &&
              ((this.columnYModeProperty = e),
              this.notifyPropertyChanged("COLUMN_MODE"));
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          get topCornerRadius() {
            return this.topCornerRadiusProperty;
          }
          set topCornerRadius(e) {
            (this.topCornerRadiusProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.TOP_CORNER_RADIUS);
          }
          get bottomCornerRadius() {
            return this.bottomCornerRadiusProperty;
          }
          set bottomCornerRadius(e) {
            (this.bottomCornerRadiusProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.BOTTOM_CORNER_RADIUS);
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(p.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          getXRange() {
            const e = this.dataSeries.count(),
              t = this.dataSeries;
            if (
              [a.EColumnMode.MidWidth, a.EColumnMode.StartWidth].includes(
                this.columnXMode
              )
            ) {
              const e = t.getNativeXValues(),
                r = t.getYValuesByName(l.EValueName.X1);
              let s;
              const n = this.columnXMode === a.EColumnMode.MidWidth;
              let d,
                h = e.get(0),
                u = e.get(t.count() - 1);
              try {
                (s = this.webAssemblyContext.NumberUtil.MinMaxPair(
                  t.getNativeXValues(),
                  r,
                  n ? 0.5 : 1,
                  n ? -0.5 : 0
                )),
                  (h = s.minD),
                  (u = s.maxD);
              } finally {
                (0, i.deleteSafe)(s);
              }
              return h === u
                ? new o.NumberRange(h - 1, u + 1)
                : (h > u && ((d = h), (h = u), (u = d)),
                  new o.NumberRange(h, u));
            }
            if (this.columnXMode === a.EColumnMode.StartEnd) {
              const e = t.getXRange(d.EDataSeriesValueType.Default),
                r = t.getXRangeByName(
                  d.EDataSeriesValueType.Default,
                  l.EValueName.X1
                );
              return new o.NumberRange(
                Math.min(e.min, r.min),
                Math.max(e.max, r.max)
              );
            }
            {
              const t = super.getXRange();
              let r = this.dataPointWidth;
              if (
                (this.dataPointWidthMode === s.EDataPointWidthMode.Relative &&
                  (r = e > 1 ? (t.diff / (e - 1)) * this.dataPointWidth : 0),
                this.dataPointWidthMode === s.EDataPointWidthMode.Absolute &&
                  (r =
                    this.xAxis
                      .getCurrentCoordinateCalculator()
                      .getDataWidth(this.dataPointWidth) / 2),
                this.columnXMode === a.EColumnMode.Mid)
              )
                return new o.NumberRange(t.min - r / 2, t.max + r / 2);
              if (this.columnXMode === a.EColumnMode.Start)
                return new o.NumberRange(t.min, t.max + r);
            }
            return new o.NumberRange(0, 0);
          }
          getYRange(e, t) {
            const r = this.dataSeries.getYValuesByName(l.EValueName.Y1);
            if (
              [a.EColumnYMode.CenterHeight, a.EColumnYMode.TopHeight].includes(
                this.columnYMode
              )
            ) {
              const s = a.EColumnYMode.CenterHeight === this.columnYMode,
                n = t ? e : this.getIndicesRange(e, !1),
                d = Math.max(Math.floor(n.min), 0),
                h = Math.min(Math.ceil(n.max), this.dataSeries.count() - 1);
              if (h < d) return;
              let u;
              const c = this.dataSeries.getYValuesByName(l.EValueName.Y);
              if (r) {
                let e, t;
                const a = s ? -0.5 : -1,
                  n = s ? 0.5 : 0;
                try {
                  (u = this.webAssemblyContext.NumberUtil.MinMaxPairWithIndex(
                    c,
                    r,
                    a,
                    n,
                    d,
                    h - d + 1
                  )),
                    (e = u.minD),
                    (t = u.maxD);
                } finally {
                  (0, i.deleteSafe)(u);
                }
                return new o.NumberRange(e, t);
              }
              {
                const r = super.getYRange(e, t);
                if (!r) return;
                return s
                  ? new o.NumberRange(
                      r.min - this.defaultY1 / 2,
                      r.max + this.defaultY1 / 2
                    )
                  : new o.NumberRange(r.min - this.defaultY1, r.max);
              }
            }
            {
              const i = super.getYRange(e, t);
              if (!i) return;
              return r
                ? i
                : new o.NumberRange(
                    Math.min(i.min, this.defaultY1),
                    Math.max(i.max, this.defaultY1)
                  );
            }
          }
          getIndicesRange(e, t) {
            return new o.NumberRange(0, this.dataSeries.count() - 1);
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(h.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = h.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                columnXMode: this.columnXMode,
                dataPointWidth: this.dataPointWidth,
                dataPointWidthMode: this.dataPointWidthMode,
                defaultY1: this.defaultY1,
                fill: this.fill,
                fillLinearGradient: this.fillLinearGradient,
                topCornerRadius: this.topCornerRadius,
                bottomCornerRadius: this.bottomCornerRadius,
                columnYMode: this.columnYMode,
              };
            return Object.assign(t.options, r), t;
          }
          newHitTestProvider() {
            return new y.RectangleSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.FastRectangleRenderableSeries = v;
      },
      89078: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FastTextRenderableSeries = void 0);
        const i = r(5337),
          o = r(33240),
          a = r(79961),
          s = r(1126),
          n = r(94707),
          l = r(92231);
        class d extends a.BaseRenderableSeries {
          constructor(e, t) {
            super(e, t),
              (this.type = i.ESeriesType.TextSeries),
              (this.drawingProviders = []),
              this.drawingProviders.push(
                new n.PointMarkerDrawingProvider(e, this)
              ),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new s.TextDataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation);
          }
          needsResampling(e) {
            return (
              !!this.dataSeries.fifoCapacity &&
              ((e.resamplingMode = o.EResamplingMode.None),
              this.resamplerHelper.resetAndFillBasicNativeArgs(
                e,
                this.getNativeXValues()
              ),
              !0)
            );
          }
          newHitTestProvider() {
            return new l.TextSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.FastTextRenderableSeries = d;
      },
      21037: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GlowEffect = void 0);
        const i = r(75323),
          o = r(93545);
        class a extends o.ShaderEffect {
          constructor(e, t) {
            super(e, new e.SCRTGlowEffect(), {
              range: (null == t ? void 0 : t.range) || 1,
              intensity: (null == t ? void 0 : t.intensity) || 1,
            }),
              (this.type = i.EShaderEffectType.Glow);
          }
        }
        t.GlowEffect = a;
      },
      60981: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HeatmapColorMap = void 0);
        const i = r(3214),
          o = r(50605),
          a = r(20977);
        class s {
          constructor(e) {
            var t, r;
            (this.minimumProperty =
              null !== (t = null == e ? void 0 : e.minimum) && void 0 !== t
                ? t
                : 0),
              (this.maximumProperty =
                null !== (r = null == e ? void 0 : e.maximum) && void 0 !== r
                  ? r
                  : 100),
              (this.gradientStops = (null == e ? void 0 : e.gradientStops) || [
                { offset: 0, color: "Red" },
                { offset: 1, color: "Green" },
              ]),
              (this.propertyChanged = new i.EventHandler()),
              this.calculateScaleFactor();
          }
          get gradientStops() {
            return this.gradientStopsProperty;
          }
          set gradientStops(e) {
            (this.gradientStopsProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.GRADIENT_STOPS);
          }
          get minimum() {
            return this.minimumProperty;
          }
          set minimum(e) {
            (this.minimumProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.MINIMUM);
          }
          get maximum() {
            return this.maximumProperty;
          }
          set maximum(e) {
            (this.maximumProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.MAXIMUM);
          }
          toJSON() {
            return {
              minimum: this.minimum,
              maximum: this.maximum,
              gradientStops: this.gradientStops,
            };
          }
          notifyPropertyChanged(e) {
            var t;
            null === (t = this.propertyChanged) ||
              void 0 === t ||
              t.raiseEvent(new o.PropertyChangedEventArgs(e));
          }
          calculateScaleFactor() {
            this.scaleFactorProperty =
              (s.DefaultPrecision - 1) /
              Math.abs(this.maximumProperty - this.minimumProperty);
          }
        }
        (t.HeatmapColorMap = s), (s.DefaultPrecision = 1e3);
      },
      72704: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BandSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              g = h.getNativeY1Values(),
              y = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                p,
                l,
                d,
                u,
                0
              );
            if (h.dataDistributionCalculator.isSortedAscending && u >= 0) {
              (y.y1Value = g.get(u)), (y.y1Coord = s.getCoordinate(y.y1Value));
              const e = o.hitTestHelpers.testIsHitForBand(
                this.parentSeries.isDigitalLine,
                i,
                s,
                h.getNativeXValues(),
                (e) => p.get(e),
                (e) => g.get(e),
                u,
                l,
                d,
                h
              );
              (y.isHit = e.isHit),
                (y.point2dataSeriesIndex = e.secondPointIndex),
                void 0 !== e.secondPointIndex &&
                  ((y.point2xValue = c.get(e.secondPointIndex)),
                  (y.point2xCoord = i.getCoordinate(y.point2xValue)),
                  (y.point2yValue = p.get(e.secondPointIndex)),
                  (y.point2yCoord = s.getCoordinate(y.point2yValue)),
                  (y.point2y1Value = g.get(e.secondPointIndex)),
                  (y.point2y1Coord = s.getCoordinate(y.point2y1Value)),
                  (y.point2metadata = h.getMetadataAt(e.secondPointIndex)));
            } else y.isHit = !1;
            return y;
          }
          hitTestDataPoint(
            e,
            t,
            r = i.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            const s = this.getTranslatedHitTestPoint(e, t);
            if (!s) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: n,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? s.y : s.x,
              u = d ? s.x : s.y,
              c = this.parentSeries.dataSeries;
            if (!c) return a.HitTestInfo.empty();
            const { nearestPointIndex: p, distance: g } =
                o.hitTestHelpers.getNearestXyyPoint(
                  this.webAssemblyContext,
                  n,
                  l,
                  c,
                  h,
                  u,
                  r
                ),
              y = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                n,
                l,
                d,
                c,
                c.getNativeXValues(),
                c.getNativeYValues(),
                h,
                u,
                p,
                r,
                g
              );
            return (
              p >= 0
                ? ((y.y1Value = c.getNativeY1Values().get(p)),
                  (y.y1Coord = l.getCoordinate(y.y1Value)),
                  (y.isHit =
                    o.hitTestHelpers.testIsHitForPoint(
                      n,
                      l,
                      c.getNativeXValues(),
                      c.getNativeYValues(),
                      p,
                      h,
                      u,
                      r,
                      c
                    ) ||
                    o.hitTestHelpers.testIsHitForPoint(
                      n,
                      l,
                      c.getNativeXValues(),
                      c.getNativeY1Values(),
                      p,
                      h,
                      u,
                      r,
                      c
                    )))
                : (y.isHit = !1),
              y
            );
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              g = h.getNativeY1Values(),
              y = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                p,
                l,
                d,
                u,
                0
              );
            if (
              (u >= 0
                ? ((y.isHit = y.isWithinDataBounds),
                  (y.y1Value = g.get(u)),
                  (y.y1Coord = s.getCoordinate(y.y1Value)))
                : (y.isHit = !1),
              h.dataDistributionCalculator.isSortedAscending && u >= 0)
            ) {
              const e = c.size(),
                t = i.getCoordinate(
                  i.isCategoryCoordinateCalculator ? u : c.get(u)
                );
              if (
                !(
                  (u === e - 1 &&
                    (i.hasFlippedCoordinates ? l >= t : l <= t)) ||
                  (0 === u && (i.hasFlippedCoordinates ? l <= t : l >= t))
                )
              ) {
                const e = o.hitTestHelpers.testIsHitForLine(
                  i,
                  s,
                  c,
                  p,
                  u,
                  l,
                  d,
                  0,
                  h
                );
                (y.point2dataSeriesIndex = e.secondPointIndex),
                  void 0 !== e.secondPointIndex &&
                    ((y.point2xValue = c.get(e.secondPointIndex)),
                    (y.point2xCoord = i.getCoordinate(y.point2xValue)),
                    (y.point2yValue = p.get(e.secondPointIndex)),
                    (y.point2yCoord = s.getCoordinate(y.point2yValue)),
                    (y.point2y1Value = g.get(e.secondPointIndex)),
                    (y.point2y1Coord = s.getCoordinate(y.point2y1Value)),
                    (y.point2metadata = h.getMetadataAt(e.secondPointIndex)));
              }
            }
            return y;
          }
        }
        t.BandSeriesHitTestProvider = s;
      },
      7541: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseHitTestProvider = void 0);
        const i = r(23866),
          o = r(75772),
          a = r(32873),
          s = r(85414),
          n = r(35013);
        class l {
          constructor(e, t) {
            i.Guard.notNull(e, "parentSeries"),
              (this.parentSeries = e),
              (this.webAssemblyContext = t);
          }
          update(e) {
            this.currentRenderPassData = e;
          }
          hitTestDataPoint(e, t, r = l.DEFAULT_HIT_TEST_RADIUS) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: a,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? i.y : i.x,
              u = d ? i.x : i.y,
              c = this.parentSeries.dataSeries;
            if (!c) return n.HitTestInfo.empty();
            const p = s.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                o,
                a,
                c,
                h,
                u,
                r
              ),
              g = c.getNativeXValues(),
              y = c.getNativeYValues(),
              f = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                a,
                d,
                c,
                g,
                y,
                h,
                u,
                p.nearestPointIndex,
                r,
                p.distance
              );
            return (
              p.nearestPointIndex >= 0
                ? (f.isHit = s.hitTestHelpers.testIsHitForPoint(
                    o,
                    a,
                    g,
                    y,
                    p.nearestPointIndex,
                    h,
                    u,
                    r,
                    c
                  ))
                : (f.isHit = !1),
              f
            );
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = l.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTestDataPoint(e, t, r);
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: o,
                isVerticalChart: a,
              } = this.currentRenderPassData,
              l = a ? r.y : r.x,
              d = a ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return n.HitTestInfo.empty();
            const u = s.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              g = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                o,
                a,
                h,
                c,
                p,
                l,
                d,
                u,
                0,
                void 0
              );
            if (
              ((g.isHit = g.isWithinDataBounds),
              h.dataDistributionCalculator.isSortedAscending && u >= 0)
            ) {
              const e = c.size(),
                t = i.getCoordinate(
                  i.isCategoryCoordinateCalculator ? u : c.get(u)
                );
              if (
                !(
                  (u === e - 1 &&
                    (i.hasFlippedCoordinates ? l >= t : l <= t)) ||
                  (0 === u && (i.hasFlippedCoordinates ? l <= t : l >= t))
                )
              ) {
                const e = s.hitTestHelpers.testIsHitForLine(
                  i,
                  o,
                  c,
                  p,
                  u,
                  l,
                  d,
                  0,
                  h
                );
                (g.point2dataSeriesIndex = e.secondPointIndex),
                  (g.point2xValue = c.get(e.secondPointIndex)),
                  (g.point2xCoord = i.getCoordinate(g.point2xValue)),
                  (g.point2yValue = p.get(e.secondPointIndex)),
                  (g.point2yCoord = o.getCoordinate(g.point2yValue)),
                  (g.point2metadata = h.getMetadataAt(e.secondPointIndex));
              }
            }
            return g;
          }
          getTranslatedHitTestPoint(e, t) {
            if (this.currentRenderPassData && void 0 !== e && void 0 !== t)
              return (0, a.translateFromCanvasToSeriesViewRect)(
                new o.Point(e, t),
                this.parentSeries.parentSurface.seriesViewRect
              );
          }
        }
        (t.BaseHitTestProvider = l), (l.DEFAULT_HIT_TEST_RADIUS = 7.07);
      },
      82767: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BoxPlotSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeMedianValues(),
              {
                getDataPointWidth: g,
                dataPointWidth: y,
                dataPointWidthMode: f,
                cap: { dataPointWidth: v },
              } = this.parentSeries,
              m = g(i, Math.max(y, v), f),
              S = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                p,
                l,
                d,
                u,
                0,
                void 0,
                m
              ),
              P = h.getNativeMinimumValues(),
              C = h.getNativeMaximumValues();
            if (u >= 0) {
              S.isHit = o.hitTestHelpers.testIsHitForBoxPlot(
                i,
                s,
                m,
                h,
                c,
                P,
                C,
                u,
                l,
                d
              );
              const e = C.get(u),
                t = h.getNativeUpperQuartileValues().get(u),
                r = p.get(u),
                a = h.getNativeLowerQuartileValues().get(u),
                n = P.get(u);
              S.yValues = [e, t, r, a, n];
            } else S.isHit = !1;
            return S;
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = i.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            const r = this.hitTest(e, t);
            return (r.isHit = r.isWithinDataBounds), r;
          }
        }
        t.BoxPlotSeriesHitTestProvider = s;
      },
      89748: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BubbleSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(86127),
          a = r(7541),
          s = r(85414),
          n = r(35013);
        class l extends a.BaseHitTestProvider {
          hitTest(e, t, r = 0) {
            const a = this.getTranslatedHitTestPoint(e, t);
            if (!a) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: l,
                yCoordinateCalculator: d,
                isVerticalChart: h,
              } = this.currentRenderPassData,
              u = h ? a.y : a.x,
              c = h ? a.x : a.y,
              p = this.parentSeries.dataSeries;
            if (!p) return n.HitTestInfo.empty();
            const g = s.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                l,
                d,
                p,
                u,
                c,
                r
              ),
              y = p.getNativeXValues(),
              f = p.getNativeYValues(),
              v = p.getNativeZValues(),
              m = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                l,
                d,
                h,
                p,
                y,
                f,
                u,
                c,
                g.nearestPointIndex,
                r
              );
            if (g.nearestPointIndex >= 0) {
              m.zValue = v.get(g.nearestPointIndex);
              const e = (0, i.calcDistance)(u, c, m.xCoord, m.yCoord);
              m.isHit = e < (m.zValue * o.DpiHelper.PIXEL_RATIO) / 2 + r;
              const t = l.isCategoryCoordinateCalculator,
                a = t ? 0 : y.get(0),
                s = l.getCoordinate(a),
                n = p.getNativeZValues().get(0) / 2,
                d = t ? y.size() - 1 : y.get(y.size() - 1),
                h = l.getCoordinate(d),
                f = p.getNativeZValues().get(y.size() - 1) / 2;
              m.isWithinDataBounds =
                s < h
                  ? s - n <= m.hitTestPoint.x && m.hitTestPoint.x <= h + f
                  : h - f <= m.hitTestPoint.x && m.hitTestPoint.x <= s + n;
            } else m.isHit = !1;
            return m;
          }
          hitTestDataPoint(
            e,
            t,
            r = a.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t, r);
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: o,
                isVerticalChart: a,
              } = this.currentRenderPassData,
              l = a ? r.y : r.x,
              d = a ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return n.HitTestInfo.empty();
            const u = h.getNativeXValues(),
              c = h.getNativeYValues(),
              p = h.getNativeZValues(),
              g = s.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              y = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                o,
                a,
                h,
                u,
                c,
                l,
                d,
                g,
                0
              );
            if (g >= 0) {
              y.zValue = p.get(g);
              const e = i.isCategoryCoordinateCalculator,
                t = e ? 0 : u.get(0),
                r = i.getCoordinate(t),
                o = h.getNativeZValues().get(0) / 2,
                a = e ? u.size() - 1 : u.get(u.size() - 1),
                s = i.getCoordinate(a),
                n = h.getNativeZValues().get(u.size() - 1) / 2;
              (y.isWithinDataBounds =
                r < s
                  ? r - o <= y.hitTestPoint.x && y.hitTestPoint.x <= s + n
                  : s - n <= y.hitTestPoint.x && y.hitTestPoint.x <= r + o),
                (y.isHit = y.isWithinDataBounds);
            } else y.isHit = !1;
            return y;
          }
        }
        t.BubbleSeriesHitTestProvider = l;
      },
      18314: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ColumnSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              {
                getDataPointWidth: g,
                dataPointWidth: y,
                zeroLineY: f,
                dataPointWidthMode: v,
              } = this.parentSeries,
              m = g(i, y, v),
              S = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                p,
                l,
                d,
                u,
                0,
                void 0,
                m
              );
            return (
              (S.isHit =
                u >= 0 &&
                o.hitTestHelpers.testIsHitForColumn(
                  i,
                  s,
                  m,
                  f,
                  h,
                  c,
                  p,
                  u,
                  l,
                  d
                )),
              S
            );
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = i.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            const r = this.hitTest(e, t);
            return (
              r.dataSeriesIndex >= 0 && (r.isHit = r.isWithinDataBounds), r
            );
          }
        }
        t.ColumnSeriesHitTestProvider = s;
      },
      99828: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ErrorSeriesHitTestProvider = void 0);
        const i = r(79226),
          o = r(32287),
          a = r(21670),
          s = r(7541),
          n = r(85414),
          l = r(35013);
        class d extends s.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return l.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: o,
                isVerticalChart: a,
              } = this.currentRenderPassData,
              s = a ? r.y : r.x,
              d = a ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return l.HitTestInfo.empty();
            const u = n.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                s,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              g = n.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                o,
                a,
                h,
                c,
                p,
                s,
                d,
                u,
                0
              );
            if (u >= 0) {
              const e = n.hitTestHelpers.testIsHitForErrorBars(
                i,
                o,
                this.parentSeries,
                c,
                p,
                u,
                s,
                d
              );
              (g.isHit = e.isHit),
                (g.highValue = e.highValue),
                (g.lowValue = e.lowValue);
            } else g.isHit = !1;
            return g;
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = s.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return l.HitTestInfo.empty();
            const {
                xCoordinateCalculator: s,
                yCoordinateCalculator: d,
                isVerticalChart: h,
              } = this.currentRenderPassData,
              u = h ? r.y : r.x,
              c = h ? r.x : r.y,
              p = this.parentSeries.dataSeries;
            if (!p) return l.HitTestInfo.empty();
            const g = p.getNativeXValues(),
              y = p.getNativeYValues(),
              f = p.getNativeLowValues(),
              v = p.getNativeHighValues(),
              m = n.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                s,
                p,
                u,
                p.dataDistributionCalculator.isSortedAscending
              ),
              S = n.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                s,
                d,
                h,
                p,
                g,
                y,
                u,
                c,
                m,
                0
              ),
              P = s.isCategoryCoordinateCalculator;
            if (m >= 0) {
              const e =
                this.parentSeries.errorDirection === i.EErrorDirection.Vertical;
              (S.highValue = v.get(m)), (S.lowValue = f.get(m));
              const t = this.parentSeries.errorMode !== o.EErrorMode.High,
                r = this.parentSeries.errorMode !== o.EErrorMode.Low;
              let n, l;
              e
                ? ((n = P ? 0 : g.get(0)),
                  (l = P ? g.size() - 1 : g.get(g.size() - 1)))
                : ((n = t ? f.get(0) : g.get(0)),
                  (l = r ? v.get(g.size() - 1) : g.get(g.size() - 1)));
              const h =
                  this.parentSeries.getDataPointWidth(
                    e ? s : d,
                    this.parentSeries.dataPointWidth,
                    this.parentSeries.dataPointWidthMode
                  ) / 2,
                u = s.getCoordinate(S.hitTestPointValues.x),
                c = s.getCoordinate(n),
                p = s.getCoordinate(l);
              (S.isWithinDataBounds = (0, a.testIsInInterval)(u, c - h, p + h)),
                (S.isHit = S.isWithinDataBounds);
            } else S.isHit = !1;
            return S;
          }
        }
        t.ErrorSeriesHitTestProvider = d;
      },
      35013: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HitTestInfo = void 0);
        class r {
          constructor(e, t = !1) {
            (this.isEmpty = t), (this.associatedSeries = e);
          }
          static empty() {
            return new r(void 0, !0);
          }
          getEuclideanDistance() {
            var e, t;
            const r =
                (null === (e = this.hitTestPoint) || void 0 === e
                  ? void 0
                  : e.x) - this.xCoord,
              i =
                (null === (t = this.hitTestPoint) || void 0 === t
                  ? void 0
                  : t.y) - this.yCoord;
            return Math.sqrt(r * r + i * i);
          }
          get distance() {
            return void 0 !== this.distanceProperty
              ? this.distanceProperty
              : this.getEuclideanDistance();
          }
          set distance(e) {
            this.distanceProperty = e;
          }
        }
        t.HitTestInfo = r;
      },
      30995: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ImpulseSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(86127),
          a = r(7541),
          s = r(85414),
          n = r(35013);
        class l extends a.BaseHitTestProvider {
          hitTest(e, t, r = a.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? i.y : i.x,
              u = d ? i.x : i.y,
              c = this.parentSeries.dataSeries;
            if (!c) return n.HitTestInfo.empty();
            const p = s.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                o,
                l,
                c,
                h,
                u,
                r
              ),
              g = s.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                c,
                h,
                c.dataDistributionCalculator.isSortedAscending
              ),
              y = c.getNativeXValues(),
              f = c.getNativeYValues(),
              v = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                l,
                d,
                c,
                y,
                f,
                h,
                u,
                g,
                0
              );
            return (
              g >= 0 || p.nearestPointIndex >= 0
                ? (v.isHit =
                    s.hitTestHelpers.testIsHitForImpulse(
                      o,
                      l,
                      this.parentSeries,
                      y,
                      f,
                      g,
                      h,
                      u,
                      r
                    ) ||
                    s.hitTestHelpers.testIsHitForPoint(
                      o,
                      l,
                      y,
                      f,
                      p.nearestPointIndex,
                      h,
                      u,
                      this.parentSeries.size,
                      c
                    ))
                : (v.isHit = !1),
              v
            );
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = a.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t, r);
          }
          hitTestXSlice(e, t) {
            var r;
            const a = this.getTranslatedHitTestPoint(e, t);
            if (!a) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: l,
                yCoordinateCalculator: d,
                isVerticalChart: h,
              } = this.currentRenderPassData,
              u = h ? a.y : a.x,
              c = h ? a.x : a.y,
              p = this.parentSeries.dataSeries;
            if (!p) return n.HitTestInfo.empty();
            const g = p.getNativeXValues(),
              y = p.getNativeYValues(),
              f = s.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                l,
                p,
                u,
                p.dataDistributionCalculator.isSortedAscending
              ),
              v = s.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                l,
                d,
                h,
                p,
                g,
                y,
                u,
                c,
                f,
                0
              ),
              m = l.isCategoryCoordinateCalculator,
              S =
                (null !== (r = this.parentSeries.size) && void 0 !== r
                  ? r
                  : 0) * o.DpiHelper.PIXEL_RATIO,
              P = l.getDataWidth(S);
            if (f >= 0) {
              const e = m ? 0 : g.get(0),
                t = m ? g.size() - 1 : g.get(g.size() - 1);
              (v.isWithinDataBounds = (0, i.testIsInInterval)(
                v.hitTestPointValues.x,
                e,
                t,
                P / 2
              )),
                (v.isHit = v.isWithinDataBounds);
            } else v.isHit = !1;
            return v;
          }
        }
        t.ImpulseSeriesHitTestProvider = l;
      },
      98888: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSegmentSeriesHitTestProvider = void 0);
        const i = r(51885),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t, r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS) {
            return this.parentSeries.dataSeries.type === i.EDataSeriesType.Xyxy
              ? this.hitTestXyXy(e, t, r)
              : this.hitTestXy(e, t, r);
          }
          hitTestXy(e, t, r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: n,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? i.y : i.x,
              u = d ? i.x : i.y,
              c = this.parentSeries.dataSeries;
            if (!c) return s.HitTestInfo.empty();
            const p = c.getNativeXValues(),
              g = c.getNativeYValues(),
              y = p.size();
            if (y < 2) return s.HitTestInfo.empty();
            const {
                isHit: f,
                isWithinDataBounds: v,
                nearestPointIndex: m,
                nearestDistance: S,
              } = a.hitTestHelpers.getNearestLineSegment(
                n,
                l,
                y / 2,
                (e) => p.get(2 * e),
                (e) => g.get(2 * e),
                (e) => p.get(2 * e + 1),
                (e) => g.get(2 * e + 1),
                h,
                u,
                r
              ),
              P = m >= 0 ? 2 * m : -1,
              C = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                n,
                l,
                d,
                c,
                p,
                g,
                h,
                u,
                P,
                r,
                S
              );
            return (
              -1 !== P &&
                ((C.dataSeriesIndex = P),
                (C.isWithinDataBounds = v),
                (C.isHit = f),
                (C.xValue = p.get(P)),
                (C.xCoord = n.getCoordinate(C.xValue)),
                (C.yValue = g.get(P)),
                (C.yCoord = l.getCoordinate(C.yValue)),
                (C.point2dataSeriesIndex = P + 1),
                (C.point2xValue = p.get(P + 1)),
                (C.point2xCoord = n.getCoordinate(C.point2xValue)),
                (C.point2yValue = g.get(P + 1)),
                (C.point2yCoord = l.getCoordinate(C.point2yValue)),
                (C.point2metadata = c.getMetadataAt(P + 1))),
              C
            );
          }
          hitTestXyXy(e, t, r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: n,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? i.y : i.x,
              u = d ? i.x : i.y,
              c = this.parentSeries.dataSeries;
            if (!c) return s.HitTestInfo.empty();
            const p = c.getNativeXValues(),
              g = c.yValues,
              y = c.x1Values,
              f = c.y1Values,
              v = p.size();
            if (v < 1) return s.HitTestInfo.empty();
            const {
                isHit: m,
                isWithinDataBounds: S,
                nearestPointIndex: P,
                nearestDistance: C,
              } = a.hitTestHelpers.getNearestLineSegment(
                n,
                l,
                v,
                (e) => p.get(e),
                (e) => g.get(e),
                (e) => y.get(e),
                (e) => f.get(e),
                h,
                u,
                r
              ),
              b = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                n,
                l,
                d,
                c,
                p,
                g,
                h,
                u,
                P,
                r,
                C
              );
            return (
              -1 !== P &&
                ((b.dataSeriesIndex = P),
                (b.isWithinDataBounds = S),
                (b.isHit = m),
                (b.xValue = p.get(P)),
                (b.xCoord = n.getCoordinate(b.xValue)),
                (b.yValue = g.get(P)),
                (b.yCoord = l.getCoordinate(b.yValue)),
                (b.point2dataSeriesIndex = P),
                (b.point2xValue = y.get(P)),
                (b.point2xCoord = n.getCoordinate(b.point2xValue)),
                (b.point2yValue = f.get(P)),
                (b.point2yCoord = l.getCoordinate(b.point2yValue)),
                (b.point2metadata = c.getMetadataAt(P))),
              b
            );
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t, r);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t);
          }
          hitTestDataPoint(e, t, r) {
            return this.hitTest(e, t);
          }
        }
        t.LineSegmentSeriesHitTestProvider = n;
      },
      28628: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t, r = i.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS) {
            const o = this.getTranslatedHitTestPoint(e, t);
            if (!o) return a.HitTestInfo.empty();
            const { isVerticalChart: s } = this.currentRenderPassData,
              n = s ? o.y : o.x,
              l = s ? o.x : o.y;
            return this.parentSeries.dataSeries.dataDistributionCalculator
              .isSortedAscending
              ? this.hitTestSorted(n, l, r)
              : this.hitTestUnsorted(n, l, r);
          }
          hitTestSorted(e, t, r) {
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = this.parentSeries.dataSeries;
            if (!l) return a.HitTestInfo.empty();
            const d = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                l,
                e,
                l.dataDistributionCalculator.isSortedAscending
              ),
              h = l.getNativeXValues(),
              u = l.getNativeYValues(),
              c = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                l,
                h,
                u,
                e,
                t,
                d,
                r,
                void 0
              );
            if (d >= 0) {
              const a = h.size(),
                n = i.getCoordinate(
                  i.isCategoryCoordinateCalculator ? d : h.get(d)
                );
              if (
                (d === a - 1 && (i.hasFlippedCoordinates ? e >= n : e <= n)) ||
                (0 === d && (i.hasFlippedCoordinates ? e <= n : e >= n))
              )
                c.isHit = o.hitTestHelpers.testIsHitForPoint(
                  i,
                  s,
                  h,
                  u,
                  d,
                  e,
                  t,
                  r,
                  l
                );
              else {
                const a = o.hitTestHelpers.testIsHitForLine(
                  i,
                  s,
                  h,
                  u,
                  d,
                  e,
                  t,
                  r,
                  l
                );
                (c.isHit = a.isHit),
                  (c.point2dataSeriesIndex = a.secondPointIndex),
                  (c.point2xValue = h.get(a.secondPointIndex)),
                  (c.point2xCoord = i.getCoordinate(c.point2xValue)),
                  (c.point2yValue = u.get(a.secondPointIndex)),
                  (c.point2yCoord = s.getCoordinate(c.point2yValue)),
                  (c.point2metadata = l.getMetadataAt(a.secondPointIndex));
              }
            } else c.isHit = !1;
            return c;
          }
          hitTestUnsorted(e, t, r) {
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = this.parentSeries.dataSeries;
            if (!l) return a.HitTestInfo.empty();
            const d = o.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                i,
                s,
                l,
                e,
                t,
                r
              ),
              h = l.getNativeXValues(),
              u = l.getNativeYValues(),
              c = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                l,
                h,
                u,
                e,
                t,
                d.nearestPointIndex,
                r,
                d.distance
              );
            if (d.nearestPointIndex >= 0) {
              const a = h.size(),
                n = (e) => h.get(e),
                d = (e) => u.get(e),
                p = (e) => h.get(e + 1),
                g = (e) => u.get(e + 1),
                {
                  isHit: y,
                  isWithinDataBounds: f,
                  nearestPointIndex: v,
                } = o.hitTestHelpers.getNearestLineSegment(
                  i,
                  s,
                  a - 1,
                  n,
                  d,
                  p,
                  g,
                  e,
                  t,
                  r
                );
              if (-1 !== v)
                return (
                  (c.dataSeriesIndex = v),
                  (c.isWithinDataBounds = f),
                  (c.isHit = y),
                  (c.xValue = h.get(v)),
                  (c.xCoord = i.getCoordinate(c.xValue)),
                  (c.yValue = u.get(v)),
                  (c.yCoord = s.getCoordinate(c.yValue)),
                  (c.point2dataSeriesIndex = v + 1),
                  (c.point2xValue = h.get(v + 1)),
                  (c.point2xCoord = i.getCoordinate(c.point2xValue)),
                  (c.point2yValue = u.get(v + 1)),
                  (c.point2yCoord = s.getCoordinate(c.point2yValue)),
                  (c.point2metadata = l.getMetadataAt(v + 1)),
                  c
                );
            }
            return (c.isHit = !1), c;
          }
        }
        t.LineSeriesHitTestProvider = s;
      },
      47453: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MountainSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries,
              u = h.dataSeries;
            if (!u) return a.HitTestInfo.empty();
            const c = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                u,
                l,
                u.dataDistributionCalculator.isSortedAscending
              ),
              p = u.getNativeXValues(),
              g = u.getNativeYValues(),
              y = o.hitTestHelpers.createHitTestInfo(
                h,
                i,
                s,
                n,
                u,
                p,
                g,
                l,
                d,
                c,
                0
              );
            if (u.dataDistributionCalculator.isSortedAscending && c >= 0) {
              const e = o.hitTestHelpers.testIsHitForMountain(
                this.parentSeries.isDigitalLine,
                i,
                s,
                u,
                h.zeroLineY,
                c,
                l,
                d
              );
              (y.isHit = e.isHit),
                (y.point2dataSeriesIndex = e.secondPointIndex),
                void 0 !== e.secondPointIndex &&
                  ((y.point2xValue = p.get(e.secondPointIndex)),
                  (y.point2xCoord = i.getCoordinate(y.point2xValue)),
                  (y.point2yValue = g.get(e.secondPointIndex)),
                  (y.point2yCoord = s.getCoordinate(y.point2yValue)),
                  (y.point2metadata = u.getMetadataAt(e.secondPointIndex)));
            } else y.isHit = !1;
            return y;
          }
        }
        t.MountainSeriesHitTestProvider = s;
      },
      80456: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonUniformHeatmapHitTestProvider = void 0);
        const i = r(75772),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = a.hitTestHelpers.getNearestNonUniformHeatmapPoint(
                o,
                n,
                u,
                d,
                h
              ),
              { xIndex: p, yIndex: g, zValue: y } = c,
              f = new s.HitTestInfo(this.parentSeries);
            (f.seriesName = this.parentSeries.seriesName),
              (f.dataSeriesType = u.type),
              (f.hitTestPoint = new i.Point(d, h));
            const v = o.getDataValue(d),
              m = n.getDataValue(h);
            return (
              (f.hitTestPointValues = new i.Point(v, m)),
              (f.xValue = v),
              (f.yValue = m),
              (f.heatmapXIndex = p),
              (f.heatmapYIndex = g),
              (f.zValue = y),
              (f.heatmapValue = y),
              (f.xCoord = d),
              (f.yCoord = h),
              (f.isHit = -1 !== p && -1 !== g),
              (f.isWithinDataBounds = f.isHit),
              -1 !== p && -1 !== g && (f.metadata = u.getMetadataAt(g, p)),
              f
            );
          }
          hitTestDataPoint(e, t) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t);
          }
        }
        t.NonUniformHeatmapHitTestProvider = n;
      },
      8535: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t, r = 0) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? i.y : i.x,
              h = l ? i.x : i.y,
              u = this.parentSeries,
              c = this.parentSeries.dataSeries;
            if (!c) return s.HitTestInfo.empty();
            const p = a.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                c,
                d,
                c.dataDistributionCalculator.isSortedAscending
              ),
              g = c.getNativeXValues(),
              y = c.getNativeYValues(),
              f = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                n,
                l,
                c,
                g,
                y,
                d,
                h,
                p,
                r
              );
            if (p >= 0) {
              const e = a.hitTestHelpers.testIsHitForOHLC(
                o,
                n,
                u,
                c,
                p,
                d,
                h,
                r
              );
              (f.isHit = e.isHit),
                (f.openValue = e.openValue),
                (f.highValue = e.highValue),
                (f.lowValue = e.lowValue),
                (f.closeValue = e.closeValue);
            } else f.isHit = !1;
            return f;
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t, r);
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = u.getNativeXValues(),
              p = u.getNativeYValues(),
              g = a.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                u,
                d,
                u.dataDistributionCalculator.isSortedAscending
              ),
              y = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                n,
                l,
                u,
                c,
                p,
                d,
                h,
                g,
                0
              );
            if (g >= 0) {
              (y.openValue = u.getNativeOpenValues().get(g)),
                (y.highValue = u.getNativeHighValues().get(g)),
                (y.lowValue = u.getNativeLowValues().get(g)),
                (y.closeValue = u.getNativeCloseValues().get(g));
              const e = o.isCategoryCoordinateCalculator,
                t = e ? 0 : c.get(0),
                r = e ? c.size() - 1 : c.get(c.size() - 1),
                { dataPointWidth: a } = this.parentSeries;
              (y.isWithinDataBounds = (0, i.testIsInInterval)(
                y.hitTestPointValues.x,
                t,
                r,
                a / 2
              )),
                (y.isHit = y.isWithinDataBounds);
            } else y.isHit = !1;
            return y;
          }
        }
        t.OhlcSeriesHitTestProvider = n;
      },
      92762: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RectangleSeriesHitTestProvider = void 0);
        const i = r(75772),
          o = r(54624),
          a = r(32873),
          s = r(7541),
          n = r(85414),
          l = r(51462),
          d = r(35013);
        class h extends s.BaseHitTestProvider {
          getTranslatedHitTestPoint(e, t) {
            if (!this.currentRenderPassData || void 0 === e || void 0 === t)
              return;
            const r = (0, a.translateFromCanvasToSeriesViewRect)(
              new i.Point(e, t),
              this.parentSeries.parentSurface.seriesViewRect
            );
            return r
              ? this.isPolar()
                ? this.parentSeries.xAxis.reverseTransform(r.x, r.y)
                : r
              : void 0;
          }
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return d.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: a,
                isVerticalChart: s,
              } = this.currentRenderPassData,
              l = r.x,
              h = r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return d.HitTestInfo.empty();
            const c = u.getNativeXValues(),
              p = u.getYValuesByName(o.EValueName.X1),
              g = u.getYValuesByName(o.EValueName.Y),
              y = u.getYValuesByName(o.EValueName.Y1),
              {
                getDataPointWidth: f,
                dataPointWidth: v,
                defaultY1: m,
                columnXMode: S,
                columnYMode: P,
                dataPointWidthMode: C,
              } = this.parentSeries,
              b = f(i, v, C),
              {
                nearestPointIndex: x,
                isHit: A,
                isWithinDataBounds: T,
              } = this.hitTestForBox(
                this.webAssemblyContext,
                i,
                a,
                c,
                p,
                g,
                y,
                l,
                h,
                m,
                b,
                S,
                P,
                s,
                this.isPolar()
              ),
              E = n.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                a,
                s,
                u,
                c,
                g,
                l,
                h,
                x,
                0
              );
            return (E.isHit = A), (E.isWithinDataBounds = T), E;
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = s.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t);
          }
          hitTestDataPoint(e, t, r) {
            return this.hitTest(e, t);
          }
          hitTestForBox(e, t, r, i, o, a, s, n, d, h, u, c, p, g, y) {
            return l.hitTestHelpersRectangleSeries.hitTestForBoxUnsorted(
              t,
              r,
              i,
              o,
              a,
              s,
              n,
              d,
              h,
              u,
              c,
              p,
              g,
              y
            );
          }
          isPolar() {
            return this.parentSeries.parentSurface.isPolar;
          }
        }
        t.RectangleSeriesHitTestProvider = h;
      },
      64485: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ScatterSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t, r = 0) {
            const o = this.getTranslatedHitTestPoint(e, t);
            if (!o) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: n,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? o.y : o.x,
              u = d ? o.x : o.y,
              c = this.parentSeries.dataSeries;
            if (!c) return s.HitTestInfo.empty();
            const p = a.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                n,
                l,
                c,
                h,
                u,
                r
              ),
              g = c.getNativeXValues(),
              y = c.getNativeYValues(),
              f = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                n,
                l,
                d,
                c,
                g,
                y,
                h,
                u,
                p.nearestPointIndex,
                r
              );
            if (p.nearestPointIndex >= 0) {
              const { width: e, height: t } = this.parentSeries.pointMarker,
                o = n.isCategoryCoordinateCalculator,
                a = o ? 0 : g.get(0),
                s = n.getCoordinate(a),
                l = o ? g.size() - 1 : g.get(g.size() - 1),
                d = n.getCoordinate(l);
              (f.isWithinDataBounds = (0, i.testIsInInterval)(h, s, d, e / 2)),
                (f.isHit = (0, i.testIsInBounds)(
                  h,
                  u,
                  f.xCoord - e / 2 - r,
                  f.yCoord + t / 2 + r,
                  f.xCoord + e / 2 + r,
                  f.yCoord - t / 2 - r
                ));
            } else f.isHit = !1;
            return f;
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = u.getNativeXValues(),
              p = u.getNativeYValues(),
              g = a.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                u,
                d,
                u.dataDistributionCalculator.isSortedAscending
              ),
              y = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                n,
                l,
                u,
                c,
                p,
                d,
                h,
                g,
                0
              );
            if (g >= 0) {
              const { width: e } = this.parentSeries.pointMarker,
                t = o.isCategoryCoordinateCalculator;
              let r, a;
              if (u.dataDistributionCalculator.isSortedAscending) {
                const e = t ? 0 : c.get(0);
                r = o.getCoordinate(e);
                const i = t ? c.size() - 1 : c.get(c.size() - 1);
                a = o.getCoordinate(i);
              } else {
                const e = u.getXRange();
                (r = o.getCoordinate(e.min)), (a = o.getCoordinate(e.max));
              }
              (y.isWithinDataBounds = (0, i.testIsInInterval)(d, r, a, e / 2)),
                (y.isHit = y.isWithinDataBounds);
            } else y.isHit = !1;
            return y;
          }
        }
        t.ScatterSeriesHitTestProvider = n;
      },
      51825: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedColumnSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = a.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                u,
                d,
                u.dataDistributionCalculator.isSortedAscending
              ),
              p = u.getNativeXValues(),
              g = u.getNativeYValues(),
              {
                accumulatedValues: y,
                getGroupIndex: f,
                getGroupsCount: v,
                getColumnWidth: m,
              } = this.parentSeries,
              S = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                n,
                l,
                u,
                p,
                y,
                d,
                h,
                c,
                0
              );
            if (c >= 0) {
              const e = f(),
                t = v(),
                r = m(o),
                a = r / 2,
                s = (0.5 + e - t / 2) * r;
              S.xValue = o.getDataValue(S.xCoord + s);
              const l = g.get(c),
                u = y.get(c),
                P = n.getCoordinate(u),
                C = n.getCoordinate(u - l),
                b = S.xCoord + s;
              S.isHit = (0, i.testIsInBounds)(d, h, b - a, C, b + a, P);
              const x = o.isCategoryCoordinateCalculator,
                A = x ? 0 : p.get(0),
                T = o.getCoordinate(A),
                E = x ? p.size() - 1 : p.get(p.size() - 1),
                R = o.getCoordinate(E);
              (S.isWithinDataBounds = (0, i.testIsInInterval)(
                S.hitTestPoint.x,
                T,
                R,
                (r * t) / 2
              )),
                (S.y1Value = g.get(c));
            } else S.isHit = !1;
            return S;
          }
          hitTestDataPoint(
            e,
            t,
            r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            throw Error(
              "hitTestDataPoint method is not supported for StackedColumnSeriesHitTestProvider"
            );
          }
          hitTestForDataPointSelectionModifier(
            e,
            t,
            r = o.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = a.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                o,
                u,
                d,
                u.dataDistributionCalculator.isSortedAscending
              ),
              p = u.getNativeXValues(),
              g = u.getNativeYValues(),
              {
                accumulatedValues: y,
                getGroupIndex: f,
                getGroupsCount: v,
                getColumnWidth: m,
              } = this.parentSeries,
              S = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                o,
                n,
                l,
                u,
                p,
                y,
                d,
                h,
                c,
                0
              );
            if (c >= 0) {
              const e = f(),
                t = v(),
                r = m(o),
                a = r / 2,
                s = o.isCategoryCoordinateCalculator,
                n = s ? 0 : p.get(0),
                l = o.getCoordinate(n),
                h = s ? p.size() - 1 : p.get(p.size() - 1),
                u = o.getCoordinate(h);
              S.isWithinDataBounds = (0, i.testIsInInterval)(
                S.hitTestPoint.x,
                l,
                u,
                (r * t) / 2
              );
              const y = (0.5 + e - t / 2) * r;
              S.xValue = o.getDataValue(S.xCoord + y);
              const P = S.xCoord + y;
              (S.isHit = (0, i.testIsInInterval)(d, P - a, P + a)),
                (S.y1Value = g.get(c));
            } else S.isHit = !1;
            return S;
          }
        }
        t.StackedColumnSeriesHitTestProvider = n;
      },
      99846: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedMountainSeriesHitTestProvider = void 0);
        const i = r(7541),
          o = r(85414),
          a = r(35013);
        class s extends i.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              { accumulatedValues: p } = this.parentSeries,
              g = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                p,
                l,
                d,
                u,
                0
              );
            if (u >= 0) {
              const e = (e) => p.get(e),
                t = (e) => p.get(e) - h.getNativeYValues().get(e),
                r = o.hitTestHelpers.testIsHitForBand(
                  this.parentSeries.isDigitalLine,
                  i,
                  s,
                  c,
                  e,
                  t,
                  u,
                  l,
                  d,
                  h
                );
              (g.isHit = r.isHit),
                (g.point2dataSeriesIndex = r.secondPointIndex);
            } else g.isHit = !1;
            return g;
          }
          hitTestXSlice(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return a.HitTestInfo.empty();
            const {
                xCoordinateCalculator: i,
                yCoordinateCalculator: s,
                isVerticalChart: n,
              } = this.currentRenderPassData,
              l = n ? r.y : r.x,
              d = n ? r.x : r.y,
              h = this.parentSeries.dataSeries;
            if (!h) return a.HitTestInfo.empty();
            const u = o.hitTestHelpers.getNearestXPoint(
                this.webAssemblyContext,
                i,
                h,
                l,
                h.dataDistributionCalculator.isSortedAscending
              ),
              c = h.getNativeXValues(),
              p = h.getNativeYValues(),
              { accumulatedValues: g } = this.parentSeries,
              y = o.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                i,
                s,
                n,
                h,
                c,
                g,
                l,
                d,
                u,
                0
              );
            return (
              u >= 0
                ? ((y.y1Value = p.get(u)), (y.isHit = y.isWithinDataBounds))
                : (y.isHit = !1),
              y
            );
          }
          hitTestDataPoint(
            e,
            t,
            r = i.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS
          ) {
            return this.hitTest(e, t);
          }
        }
        t.StackedMountainSeriesHitTestProvider = s;
      },
      92231: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TextSeriesHitTestProvider = void 0);
        const i = r(21670),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t, r) {
            const o = this.getTranslatedHitTestPoint(e, t);
            if (!o) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: n,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? o.y : o.x,
              u = d ? o.x : o.y,
              c = this.parentSeries.dataSeries,
              p = a.hitTestHelpers.getNearestXyPoint(
                this.webAssemblyContext,
                n,
                l,
                c,
                h,
                u,
                r
              ),
              g = c.getNativeXValues(),
              y = c.getNativeYValues(),
              f = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                n,
                l,
                d,
                c,
                g,
                y,
                h,
                u,
                p.nearestPointIndex,
                r,
                p.distance
              ),
              v = this.parentSeries.dataLabelProvider.dataLabels;
            let m = !1;
            for (const e of v) {
              const { left: t, top: r, right: a, bottom: s } = e.rect;
              if ((0, i.testIsInBounds)(o.x, o.y, t, r, a, s)) {
                m = !0;
                break;
              }
            }
            return (f.isHit = m), f;
          }
        }
        t.TextSeriesHitTestProvider = n;
      },
      22735: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TriangleSeriesHitTestProvider = void 0);
        const i = r(75772),
          o = r(95808),
          a = r(7541),
          s = r(85414),
          n = r(35013);
        class l extends a.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return n.HitTestInfo.empty();
            const {
                xCoordinateCalculator: a,
                yCoordinateCalculator: l,
                isVerticalChart: d,
              } = this.currentRenderPassData,
              h = d ? r.y : r.x,
              u = d ? r.x : r.y,
              c = this.parentSeries.dataSeries;
            if (!c) return n.HitTestInfo.empty();
            const p = c.getNativeXValues(),
              g = c.getNativeYValues(),
              { drawMode: y, polygonVertices: f } = this.parentSeries,
              {
                nearestPointIndex: v,
                nearestPointIndex2: m,
                isHit: S,
              } = s.hitTestHelpers.getNearestTriangle(
                this.webAssemblyContext,
                a,
                l,
                p,
                g,
                h,
                u,
                y,
                f
              ),
              P = new n.HitTestInfo(this.parentSeries);
            (P.seriesName = this.parentSeries.seriesName),
              (P.dataSeriesType = c.type),
              (P.hitTestPoint = new i.Point(h, u));
            const C = a.getDataValue(h),
              b = l.getDataValue(u);
            if (
              ((P.hitTestPointValues = new i.Point(C, b)),
              (P.dataSeriesIndex = v),
              (P.point2dataSeriesIndex = m),
              (P.distance = S ? 0 : 1),
              v >= 0)
            ) {
              const e = c.getNativeValue(p, v),
                t = c.getNativeValue(g, v);
              (P.xCoord = a.getCoordinate(e)),
                (P.yCoord = l.getCoordinate(t)),
                (P.xValue = e),
                (P.yValue = t),
                (P.metadata = c.getMetadataAt(v));
            }
            if (m >= 0) {
              const e = c.getNativeValue(p, m),
                t = c.getNativeValue(g, m);
              (P.point2xCoord = a.getCoordinate(e)),
                (P.point2yCoord = l.getCoordinate(t)),
                (P.point2xValue = e),
                (P.point2yValue = t),
                (P.metadata = c.getMetadataAt(v));
            }
            if (v >= 0) {
              const e = y === o.ETriangleSeriesDrawMode.Polygon ? f : 3,
                t = [],
                r = [];
              for (let i = v; i < v + e; i++) {
                const e = c.getNativeValue(p, i),
                  o = c.getNativeValue(g, i);
                t.push(e), r.push(o);
              }
              (P.xValues = t), (P.yValues = r);
            }
            return (P.isHit = S), P;
          }
          hitTestForDataPointSelectionModifier(e, t) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t);
          }
          hitTestDataPoint(e, t, r) {
            return this.hitTest(e, t);
          }
        }
        t.TriangleSeriesHitTestProvider = l;
      },
      3798: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformHeatmapHitTestProvider = void 0);
        const i = r(75772),
          o = r(7541),
          a = r(85414),
          s = r(35013);
        class n extends o.BaseHitTestProvider {
          hitTest(e, t) {
            const r = this.getTranslatedHitTestPoint(e, t);
            if (!r) return s.HitTestInfo.empty();
            const {
                xCoordinateCalculator: o,
                yCoordinateCalculator: n,
                isVerticalChart: l,
              } = this.currentRenderPassData,
              d = l ? r.y : r.x,
              h = l ? r.x : r.y,
              u = this.parentSeries.dataSeries;
            if (!u) return s.HitTestInfo.empty();
            const c = a.hitTestHelpers.getNearestUniformHeatmapPoint(
                o,
                n,
                u,
                d,
                h
              ),
              { xIndex: p, yIndex: g, zValue: y } = c,
              f = new s.HitTestInfo(this.parentSeries);
            (f.seriesName = this.parentSeries.seriesName),
              (f.dataSeriesType = u.type),
              (f.hitTestPoint = new i.Point(d, h));
            const v = o.getDataValue(d),
              m = n.getDataValue(h);
            return (
              (f.hitTestPointValues = new i.Point(v, m)),
              (f.xValue = v),
              (f.yValue = m),
              (f.heatmapXIndex = p),
              (f.heatmapYIndex = g),
              (f.zValue = y),
              (f.heatmapValue = y),
              (f.xCoord = d),
              (f.yCoord = h),
              (f.isHit = -1 !== p && -1 !== g),
              (f.isWithinDataBounds = f.isHit),
              -1 !== p && -1 !== g && (f.metadata = u.getMetadataAt(g, p)),
              f
            );
          }
          hitTestDataPoint(e, t) {
            return this.hitTest(e, t);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t);
          }
        }
        t.UniformHeatmapHitTestProvider = n;
      },
      85414: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hitTestHelpers = void 0);
        const i = r(56744),
          o = r(75772),
          a = r(79226),
          s = r(21670),
          n = (r(60960), r(35013)),
          l = r(95808),
          d = (e, t, r, i, o) => r + ((o - r) * (e - t)) / (i - t),
          h = (e, t, r, i, o, a, s) => {
            const n = t.isCategoryCoordinateCalculator
                ? i.getNativeIndexes()
                : i.getNativeXValues(),
              l = i.getNativeYValues();
            return u(
              e,
              t,
              r,
              n,
              l,
              i.dataDistributionCalculator.isSortedAscending,
              o,
              a,
              s
            );
          },
          u = (e, t, r, o, a, s, n, l, d) => {
            let h;
            try {
              return (
                (h = e.SCRTHitTestHelper.GetNearestXyPoint(
                  t.nativeCalculator,
                  r.nativeCalculator,
                  o,
                  a,
                  s,
                  n,
                  l,
                  null != d ? d : 1
                )),
                { nearestPointIndex: h.minD, distance: h.maxD }
              );
            } finally {
              (0, i.deleteSafe)(h);
            }
          };
        t.hitTestHelpers = {
          createHitTestInfo: (e, t, r, i, a, l, d, h, u, c, p, g, y) => {
            const f = t.isCategoryCoordinateCalculator,
              v = new n.HitTestInfo(e);
            (v.seriesName = e.seriesName),
              (v.dataSeriesType = a.type),
              (v.hitTestPoint = new o.Point(h, u));
            const m = t.getDataValue(h),
              S = r.getDataValue(u);
            if (
              ((v.hitTestPointValues = new o.Point(m, S)),
              (v.dataSeriesIndex = c),
              (v.hitTestRadius = p),
              (v.isCategoryAxis = f),
              (v.distance = g),
              c >= 0)
            ) {
              const e = f ? c : a.getNativeValue(l, c),
                i = a.getNativeValue(d, c);
              (v.xCoord = t.getCoordinate(e)),
                (v.yCoord = r.getCoordinate(i)),
                (v.xValue = e),
                f && (v.xCategoryValue = l.get(c)),
                (v.yValue = i);
              let o = f ? 0 : a.getNativeValue(l, 0),
                n = f ? l.size() - 1 : a.getNativeValue(l, l.size() - 1);
              if (!a.dataDistributionCalculator.isSortedAscending)
                for (let e = 0; e < a.count(); e++) {
                  const t = a.getNativeValue(l, e);
                  t < o && (o = t), t > n && (n = t);
                }
              const h = void 0 !== y ? t.getDataWidth(y) : 0;
              (v.isWithinDataBounds = (0, s.testIsInInterval)(m, o, n, h / 2)),
                (v.metadata = a.getMetadataAt(c));
            } else v.isWithinDataBounds = !1;
            return (v.isHit = void 0), v;
          },
          getNearestPoint: u,
          getNearestXPoint: (e, t, r, i, o) =>
            h(e, t, t, r, i, 0, 0).nearestPointIndex,
          getNearestXyPoint: h,
          getNearestXyyPoint: (e, t, r, o, a, s, n) => {
            const l = t.isCategoryCoordinateCalculator
                ? o.getNativeIndexes()
                : o.getNativeXValues(),
              d = o.getNativeYValues();
            let h, u, c;
            try {
              (h = e.SCRTHitTestHelper.GetNearestXyPoint(
                t.nativeCalculator,
                r.nativeCalculator,
                l,
                d,
                o.dataDistributionCalculator.isSortedAscending,
                a,
                s,
                null != n ? n : 1
              )),
                (u = h.minD),
                (c = h.maxD);
            } finally {
              (0, i.deleteSafe)(h);
            }
            try {
              return (
                (h = e.SCRTHitTestHelper.GetNearestXyPoint(
                  t.nativeCalculator,
                  r.nativeCalculator,
                  l,
                  o.getNativeY1Values(),
                  o.dataDistributionCalculator.isSortedAscending,
                  a,
                  s,
                  null != n ? n : 1
                )),
                c < h.maxD
                  ? { nearestPointIndex: u, distance: c }
                  : { nearestPointIndex: h.minD, distance: h.maxD }
              );
            } finally {
              (0, i.deleteSafe)(h);
            }
          },
          getNearestUniformHeatmapPoint: (e, t, r, i, o) => {
            const a = e.getDataValue(i),
              s = t.getDataValue(o),
              n = Math.floor((a - r.xStart) / r.xStep),
              l = Math.floor((s - r.yStart) / r.yStep);
            return n < 0 || n >= r.arrayWidth || l < 0 || l >= r.arrayHeight
              ? { xIndex: -1, yIndex: -1, zValue: void 0 }
              : { xIndex: n, yIndex: l, zValue: r.getZValue(l, n) };
          },
          getNearestNonUniformHeatmapPoint: (e, t, r, i, o) => {
            const a = e.getDataValue(i),
              s = t.getDataValue(o),
              { xCellOffsets: n, yCellOffsets: l } = r;
            let d = -1;
            if (a >= n[0] && a <= n[n.length - 1])
              for (let e = 0; e < n.length; e++)
                if (a >= n[e] && a <= n[e + 1]) {
                  d = e;
                  break;
                }
            let h = -1;
            if (s >= l[0] && s <= l[l.length - 1])
              for (let e = 0; e < l.length - 1; e++)
                if (s >= l[e] && s <= l[e + 1]) {
                  h = e;
                  break;
                }
            return d < 0 || d >= r.arrayWidth || h < 0 || h >= r.arrayHeight
              ? { xIndex: -1, yIndex: -1, zValue: void 0 }
              : { xIndex: d, yIndex: h, zValue: r.getZValue(h, d) };
          },
          getNearestTriangle: (e, t, r, i, o, a, s, n, d) => {
            const h =
                n === l.ETriangleSeriesDrawMode.Polygon ||
                n === l.ETriangleSeriesDrawMode.List,
              u = n === l.ETriangleSeriesDrawMode.List ? 3 : d,
              c = e.SCRTHitTestHelper.GetNearestTriangle(
                h,
                u,
                t.nativeCalculator,
                r.nativeCalculator,
                i,
                o,
                a,
                s
              );
            return {
              nearestPointIndex: c.minD,
              nearestPointIndex2: c.maxD,
              isHit: c.minD >= 0,
            };
          },
          getNearestLineSegment: (e, t, r, i, o, a, n, l, d, h) => {
            let u = Number.MAX_VALUE,
              c = Number.NEGATIVE_INFINITY,
              p = Number.MAX_VALUE,
              g = Number.NEGATIVE_INFINITY;
            const y = (e, t) => {
              for (let i = 0; i < r; i++) {
                const r = e(i),
                  o = t(i);
                (u = r < u ? r : u),
                  (c = r > c ? r : c),
                  (p = o < p ? o : p),
                  (g = o > g ? o : g);
              }
            };
            y(i, o), y(a, n);
            const f = e.getDataValue(l),
              v = t.getDataValue(d),
              m = u <= f && f <= c && p <= v && v <= g;
            let S = Number.MAX_VALUE,
              P = -1;
            for (let u = 0; u < r; u++) {
              const r = i(u),
                c = o(u),
                p = a(u),
                g = n(u),
                y = e.getCoordinate(r),
                f = t.getCoordinate(c),
                v = e.getCoordinate(p),
                m = t.getCoordinate(g),
                C = (0, s.calcDistance)(y, f, v, m),
                b = (0, s.calcDistance)(y, f, l, d),
                x = (0, s.calcDistance)(v, m, l, d);
              if (b <= C + h && x <= C + h) {
                const e = (0, s.calcDistanceFromLine)(l, d, y, f, v, m);
                e <= S && ((S = e), (P = u));
              }
            }
            return {
              isHit: S <= h,
              isWithinDataBounds: m,
              nearestPointIndex: P,
              nearestDistance: P >= 0 ? S : void 0,
            };
          },
          testIsHitForPoint: (e, t, r, i, o, a, n, l, d) => {
            const h = e.isCategoryCoordinateCalculator
                ? o
                : d.getNativeValue(r, o),
              u = d.getNativeValue(i, o),
              c = e.getCoordinate(h),
              p = t.getCoordinate(u);
            return (0, s.calcDistance)(a, n, c, p) < l;
          },
          testIsHitForLine: (e, t, r, i, o, a, n, l, d) => {
            let h, u, c, p, g, y;
            const f = e.isCategoryCoordinateCalculator,
              v = f ? o : d.getNativeValue(r, o),
              m = d.getNativeValue(i, o);
            v <= e.getDataValue(a)
              ? ((c = v),
                (g = m),
                (p = f ? o + 1 : d.getNativeValue(r, o + 1)),
                (y = d.getNativeValue(i, o + 1)),
                (u = o + 1))
              : ((c = f ? o - 1 : d.getNativeValue(r, o - 1)),
                (g = d.getNativeValue(i, o - 1)),
                (u = o - 1),
                (p = v),
                (y = m));
            const S = e.getCoordinate(c),
              P = e.getCoordinate(p),
              C = t.getCoordinate(g),
              b = t.getCoordinate(y),
              x = (0, s.calcDistance)(S, C, P, b),
              A = (0, s.calcDistance)(S, C, a, n),
              T = (0, s.calcDistance)(P, b, a, n);
            return (
              (h =
                !(A > x + l || T > x + l) &&
                (0, s.calcDistanceFromLine)(a, n, S, C, P, b) < l),
              { isHit: h, secondPointIndex: u }
            );
          },
          testIsHitForBand: (e, t, r, i, o, a, s, n, l, h) => {
            let u;
            const c = t.getDataValue(n),
              p = t.isCategoryCoordinateCalculator,
              g = p ? s : h.getNativeValue(i, s),
              y = g <= c,
              f = y ? s + 1 : s - 1;
            if (f < 0 || f >= i.size())
              return { isHit: !1, secondPointIndex: void 0 };
            const v = p ? f : h.getNativeValue(i, f),
              m = y ? g : v,
              S = o(y ? s : f),
              P = a(y ? s : f),
              C = y ? v : g,
              b = o(y ? f : s),
              x = a(y ? f : s),
              A = t.getCoordinate(m),
              T = t.getCoordinate(C),
              E = r.getCoordinate(S),
              R = r.getCoordinate(b),
              D = r.getCoordinate(P),
              w = r.getCoordinate(x);
            if (e) u = E < D ? l >= E && l <= D : l >= D && l <= E;
            else {
              const e = d(n, A, E, T, R),
                t = d(n, A, D, T, w);
              u = e < t ? l >= e && l <= t : l >= t && l <= e;
            }
            return { isHit: u, secondPointIndex: f };
          },
          testIsHitForColumn: (e, t, r, i, o, a, n, l, d, h, u = undefined) => {
            const c = e.isCategoryCoordinateCalculator
                ? l
                : o.getNativeValue(a, l),
              p = o.getNativeValue(n, l),
              g = e.getCoordinate(c),
              y = t.getCoordinate(p),
              f = t.getCoordinate(i),
              v = r / 2,
              m = f > y ? f : y,
              S = f > y ? y : f;
            return void 0 !== u
              ? u <= v && h <= m && h >= S
              : (0, s.testIsInBounds)(d, h, g - v, m, g + v, S);
          },
          testIsHitForOHLC: (e, t, r, i, o, a, n, l) => {
            const {
                getDataPointWidth: d,
                dataPointWidth: h,
                dataPointWidthMode: u,
              } = r,
              c = e.isCategoryCoordinateCalculator
                ? o
                : i.getNativeValue(i.getNativeXValues(), o),
              p = e.getCoordinate(c),
              g = i.getNativeValue(i.getNativeOpenValues(), o),
              y = t.getCoordinate(g),
              f = i.getNativeValue(i.getNativeHighValues(), o),
              v = t.getCoordinate(f),
              m = i.getNativeValue(i.getNativeLowValues(), o),
              S = t.getCoordinate(m),
              P = i.getNativeValue(i.getNativeCloseValues(), o),
              C = t.getCoordinate(P),
              b = d(e, h, u) / 2,
              x = C > y ? C : y,
              A = C > y ? y : C,
              T = (0, s.testIsInBounds)(a, n, p - b, x, p + b, A),
              E = (0, s.calcDistanceFromLineSegment)(a, n, p, v, p, S);
            return {
              isHit: T || E < l,
              openValue: g,
              highValue: f,
              lowValue: m,
              closeValue: P,
            };
          },
          testIsHitForMountain: (e, t, r, i, o, a, s, n) => {
            let l;
            const h = i.getNativeXValues(),
              u = t.isCategoryCoordinateCalculator,
              c = u ? a : i.getNativeValue(h, a),
              p = i.getNativeYValues(),
              g = c <= t.getDataValue(s),
              y = g ? a + 1 : a - 1;
            if (y < 0 || y >= i.count())
              return { isHit: !1, secondPointIndex: void 0 };
            const f = u ? y : h.get(y),
              v = g ? c : f,
              m = g ? i.getNativeValue(p, a) : i.getNativeValue(p, y),
              S = g ? f : c,
              P = g ? i.getNativeValue(p, y) : i.getNativeValue(p, a),
              C = t.getCoordinate(v),
              b = t.getCoordinate(S),
              x = r.getCoordinate(m),
              A = r.getCoordinate(P),
              T = r.getCoordinate(o);
            if (e) l = x < T ? n >= x && n <= T : n >= T && n <= x;
            else {
              const e = d(s, C, x, b, A);
              l = e < T ? n >= e && n <= T : n >= T && n <= e;
            }
            return { isHit: l, secondPointIndex: y };
          },
          testIsHitForErrorBars: (e, t, r, i, o, n, l, d) => {
            const {
                getDataPointWidth: h,
                dataPointWidth: u,
                errorDirection: c,
                dataSeries: p,
                dataPointWidthMode: g,
              } = r,
              y = e.isCategoryCoordinateCalculator,
              f = c === a.EErrorDirection.Vertical,
              v = y ? n : p.getNativeValue(i, n),
              m = p.getNativeValue(o, n);
            let S = p.getNativeValue(p.getNativeHighValues(), n),
              P = p.getNativeValue(p.getNativeLowValues(), n);
            isNaN(S) && (S = m), isNaN(P) && (P = m);
            const C = e.getCoordinate(v),
              b = t.getCoordinate(m),
              x = f ? t.getCoordinate(S) : e.getCoordinate(S),
              A = f ? t.getCoordinate(P) : e.getCoordinate(P),
              T = h(f ? e : t, u, g) / 2;
            let E = !1;
            const R = x > A ? x : A,
              D = x > A ? A : x;
            return (
              (E = f
                ? (0, s.testIsInBounds)(l, d, C - T, R, C + T, D)
                : (0, s.testIsInBounds)(l, d, D, b + T, R, b - T)),
              { isHit: E, highValue: S, lowValue: P }
            );
          },
          testIsHitForImpulse: (e, t, r, i, o, a, n, l, d) => {
            const { zeroLineY: h, dataSeries: u } = r,
              c = e.isCategoryCoordinateCalculator ? a : u.getNativeValue(i, a),
              p = u.getNativeValue(o, a),
              g = e.getCoordinate(c),
              y = t.getCoordinate(p),
              f = t.getCoordinate(h),
              v = f > y ? f : y,
              m = f > y ? y : f;
            return (0, s.testIsInBounds)(n, l, g, v, g, m, d);
          },
          testIsHitForBoxPlot: (e, t, r, i, o, a, n, l, d, h) => {
            const u = e.isCategoryCoordinateCalculator
                ? l
                : i.getNativeValue(o, l),
              c = i.getNativeValue(a, l),
              p = i.getNativeValue(n, l),
              g = e.getCoordinate(u),
              y = t.getCoordinate(c),
              f = t.getCoordinate(p),
              v = r / 2,
              m = f > y ? f : y,
              S = f > y ? y : f;
            return (0, s.testIsInBounds)(d, h, g - v, m, g + v, S);
          },
        };
      },
      51462: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hitTestHelpersRectangleSeries = void 0);
        const i = r(60960);
        function o(e, t, r, o, a, s, n) {
          const l = e ? e.get(s) : 1,
            d = t ? t.get(s) : a;
          let h = l,
            u = d;
          switch (n) {
            case i.EColumnYMode.TopBottom:
              break;
            case i.EColumnYMode.TopHeight:
              u = l - d;
              break;
            case i.EColumnYMode.CenterHeight:
              const e = d / 2;
              (h = l + e), (u = l - e);
          }
          const c = r.getCoordinate(h),
            p = r.getCoordinate(u),
            g = Math.max(c, p);
          return Math.min(c, p) <= o && o <= g;
        }
        function a(e, t, r, a, s, n, l, d, h, u, c, p, g) {
          const y = [[t.getDataValue(l), l]];
          if (g) {
            const e = l - 2 * Math.PI,
              r = t.getDataValue(e);
            y.push([r, e]);
            const i = l + 2 * Math.PI,
              o = t.getDataValue(i);
            y.push([o, i]);
          }
          const f = a.size(),
            v = t.isFlipped ? -1 : 1,
            m = c === i.EColumnMode.Mid ? 0 : u / 2,
            S = t.getDataWidth(m);
          let P,
            C,
            b = -1,
            x = Number.MAX_VALUE;
          if (
            (y.forEach(([r, i]) => {
              const o = ((r, i) => {
                const o = e.NumberUtil.FindIndex(
                  a,
                  r - S,
                  e.SCRTFindIndexSearchMode.Nearest,
                  !0
                );
                if (-1 === o)
                  return {
                    index: -1,
                    dist: Number.MAX_VALUE,
                    xCoord: void 0,
                    xHitCoord: void 0,
                  };
                const s = t.getCoordinate(a.get(o));
                return {
                  index: o,
                  dist: Math.abs(s + v * m - i),
                  xCoord: s,
                  xHitCoord: i,
                };
              })(r, i);
              o.index >= 0 &&
                o.dist < x &&
                ((b = o.index),
                (x = o.dist),
                (P = o.xCoord),
                (C = o.xHitCoord));
            }),
            -1 === b)
          )
            return { isHit: !1, nearestPointIndex: -1, isWithinDataBounds: !1 };
          const A = x <= u / 2,
            T = o(s, n, r, d, h, b, p);
          let E = !1;
          return (
            b > 0 && b < f - 1 && (E = !0),
            a.size() <= 1
              ? (E = A)
              : t.isFlipped
              ? (0 === b && (C <= P + v * m || A) && (E = !0),
                b === f - 1 && (C >= P + v * m || A) && (E = !0))
              : (0 === b && (C >= P + v * m || A) && (E = !0),
                b === f - 1 && (C <= P + v * m || A) && (E = !0)),
            { nearestPointIndex: b, isHit: A && T, isWithinDataBounds: E }
          );
        }
        function s(e, t, r, a, s, n, l, d, h, u, c, p, g, y) {
          const f = r.size(),
            v = u / 2;
          let m,
            S = -1,
            P = Number.MAX_VALUE,
            C = !1,
            b = Number.MAX_VALUE,
            x = Number.NEGATIVE_INFINITY;
          const A = (e, t, r) => {
              const i = t - r,
                o = r - e;
              return i >= 0 && o >= 0 ? 0 : Math.min(Math.abs(i), Math.abs(o));
            },
            T = (e, r, i) => {
              e < b && (b = e), r > x && (x = r);
              const a = o(s, n, t, d, h, i, p),
                {
                  isHit: u,
                  xCoordDist: c,
                  xHitCoord: f,
                } = ((e, t) => {
                  let r = A(e, t, l),
                    i = l;
                  return (
                    y &&
                      !g &&
                      [l - 2 * Math.PI, l + 2 * Math.PI].forEach((o) => {
                        const a = A(e, t, o);
                        a < r && ((r = a), (i = o));
                      }),
                    { xCoordDist: r, xHitCoord: i, isHit: 0 === r }
                  );
                })(e, r),
                v = u && a;
              C
                ? v && c < P && ((S = i), (P = c), (m = f))
                : v
                ? ((C = !0), (S = i), (P = c), (m = f))
                : c < P && ((S = i), (P = c), (m = f));
            },
            E = e.isFlipped;
          switch (c) {
            case i.EColumnMode.Mid:
              for (let t = 0; t < f; t++) {
                const i = r.get(t),
                  o = e.getCoordinate(i);
                T(o - v, o + v, t);
              }
              break;
            case i.EColumnMode.Start:
              for (let t = 0; t < f; t++) {
                const i = r.get(t),
                  o = e.getCoordinate(i);
                T(E ? o - u : o, E ? o : o + u, t);
              }
              break;
            case i.EColumnMode.MidWidth:
              for (let t = 0; t < f; t++) {
                const i = r.get(t),
                  o = a.get(t),
                  s = e.getCoordinate(i - o / 2),
                  n = e.getCoordinate(i + o / 2);
                E ? T(n, s, t) : T(s, n, t);
              }
              break;
            case i.EColumnMode.StartWidth:
              for (let t = 0; t < f; t++) {
                const i = r.get(t),
                  o = a.get(t),
                  s = e.getCoordinate(i),
                  n = e.getCoordinate(i + o);
                E ? T(n, s, t) : T(s, n, t);
              }
              break;
            case i.EColumnMode.StartEnd:
              for (let t = 0; t < f; t++) {
                const i = r.get(t),
                  o = a.get(t),
                  s = e.getCoordinate(i),
                  n = e.getCoordinate(o);
                E ? T(n, s, t) : T(s, n, t);
              }
          }
          return -1 === S
            ? { isHit: !1, nearestPointIndex: -1, isWithinDataBounds: !1 }
            : {
                isHit: 0 === P && o(s, n, t, d, h, S, p),
                nearestPointIndex: S,
                isWithinDataBounds: b <= m && m <= x,
              };
        }
        t.hitTestHelpersRectangleSeries = {
          hitTestForBoxSorted: a,
          hitTestForBoxUnsorted: s,
          hitTestForBox: function (
            e,
            t,
            r,
            o,
            n,
            l,
            d,
            h,
            u,
            c,
            p,
            g,
            y,
            f,
            v,
            m
          ) {
            return f
              ? s(t, r, o, n, l, d, h, u, c, p, g, y, !0, m)
              : !v || (g !== i.EColumnMode.Mid && g !== i.EColumnMode.Start)
              ? s(t, r, o, n, l, d, h, u, c, p, g, y, !1, m)
              : a(e, t, r, o, l, d, h, u, c, p, g, y, m);
          },
        };
      },
      69570: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HoveredChangedArgs = void 0),
          (t.HoveredChangedArgs = class {
            constructor(e, t, r, i) {
              (this.source = e),
                (this.hoveredSeries = t),
                (this.allSeries = r),
                (this.hitTestInfo = i);
            }
          });
      },
      55303: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LineSegmentRenderableSeries = void 0);
        const i = r(5337),
          o = r(33070),
          a = r(20782),
          s = r(33802),
          n = r(66743),
          l = r(94707),
          d = r(98888);
        class h extends a.BaseLineRenderableSeries {
          constructor(e, t) {
            var r, o;
            super(e, t),
              (this.type = i.ESeriesType.LineSegmentSeries),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new s.LineSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this));
          }
          toPointSeries(e) {
            return new o.BasePointSeriesWrapped(this.dataSeries);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new n.LineSegmentSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new l.PointMarkerDrawingProvider(e, this)
              );
          }
          newHitTestProvider() {
            return new d.LineSegmentSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.LineSegmentRenderableSeries = h;
      },
      50085: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonUniformHeatmapRenderableSeries = void 0);
        const i = r(84745),
          o = r(5337),
          a = r(53904),
          s = r(31544),
          n = r(37182),
          l = r(80456);
        class d extends a.BaseHeatmapRenderableSeries {
          constructor(e, t) {
            super(e, t),
              (this.type = o.ESeriesType.NonUniformHeatmapSeries),
              (this.drawingProviders = []),
              i.IS_TEST_ENV ||
                this.drawingProviders.push(
                  new n.NonUniformHeatmapDrawingProvider(e, this)
                ),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new s.NonUniformHeatMapDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                ));
          }
          newHitTestProvider() {
            return new l.NonUniformHeatmapHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.NonUniformHeatmapRenderableSeries = d;
      },
      72979: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarColumnDataLabelState = void 0);
        const i = r(54624),
          o = r(62652);
        class a extends o.PolarDataLabelState {
          constructor(e, t, r, o, a, s) {
            var n;
            super(e, t, r, o, a, s),
              (this.x1CoordCache = void 0),
              (this.zeroXCoordCache = void 0),
              (this.zeroYCoordCache = void 0),
              (this.accumulatedWidthCoordCache = void 0),
              (this.accumulatedWidthValues = []);
            const l = t.pointSeries;
            (this.x1Values =
              null !== (n = l.getYValuesByName(i.EValueName.X1)) && void 0 !== n
                ? n
                : this.xValues),
              (this.columnWidthProperty = s.getDataPointWidth(
                t.xCoordinateCalculator,
                s.dataPointWidth,
                s.dataPointWidthMode
              )),
              (this.isFlippedProperty = t.xCoordinateCalculator.isFlipped);
          }
          fillAccumulatedWidthValues() {
            this.accumulatedWidthValues = [];
            let e = 0;
            this.accumulatedWidthValues.push(e);
            for (let t = 0; t < this.xValues.size() - 1; t++)
              (e += this.xValues.get(t)), this.accumulatedWidthValues.push(e);
          }
          get columnWidth() {
            return this.columnWidthProperty;
          }
          get isFlipped() {
            return this.isFlippedProperty;
          }
          x1Val(e) {
            return this.parentSeries.dataSeries.getNativeValue(
              this.x1Values,
              this.getIndexInternal(e)
            );
          }
          accumulatedWidth(e) {
            return this.accumulatedWidthValues
              ? this.accumulatedWidthValues[this.getIndexInternal(e)]
              : this.xVal(e);
          }
          accumulatedWidthCoord(e) {
            return void 0 !== e
              ? this.renderPassData.xCoordinateCalculator.getCoordinate(
                  this.accumulatedWidth(e)
                )
              : (void 0 !== this.accumulatedWidthCoordCache ||
                  (this.accumulatedWidthCoordCache =
                    this.renderPassData.xCoordinateCalculator.getCoordinate(
                      this.accumulatedWidth()
                    )),
                this.accumulatedWidthCoordCache);
          }
          get index() {
            return this.indexProperty;
          }
          set index(e) {
            (this.xCoordCache = void 0),
              (this.yCoordCache = void 0),
              (this.x1CoordCache = void 0),
              (this.accumulatedWidthCoordCache = void 0),
              (this.indexProperty = e);
          }
          x1Coord(e) {
            return void 0 !== e
              ? this.renderPassData.xCoordinateCalculator.getCoordinate(
                  this.x1Val(e)
                )
              : (void 0 !== this.x1CoordCache ||
                  (this.x1CoordCache =
                    this.renderPassData.xCoordinateCalculator.getCoordinate(
                      this.x1Val()
                    )),
                this.x1CoordCache);
          }
          get zeroXCoord() {
            return (
              this.zeroXCoordCache ||
                (this.zeroXCoordCache =
                  this.renderPassData.xCoordinateCalculator.getCoordinate(0)),
              this.zeroXCoordCache
            );
          }
          get zeroYCoord() {
            return (
              this.zeroYCoordCache ||
                (this.zeroYCoordCache =
                  this.renderPassData.yCoordinateCalculator.getCoordinate(0)),
              this.zeroYCoordCache
            );
          }
        }
        t.PolarColumnDataLabelState = a;
      },
      15518: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarColumnSeriesDataLabelProvider = void 0);
        const i = r(75772),
          o = r(60960),
          a = r(2963),
          s = r(62993),
          n = r(36420),
          l = r(8827),
          d = r(10572),
          h = r(1367),
          u = r(72979),
          c = r(19963);
        class p extends c.PolarDataLabelProvider {
          constructor(e) {
            var t, r;
            super(
              Object.assign(
                {
                  horizontalTextPosition: n.EHorizontalTextPosition.Center,
                  verticalTextPosition: n.EVerticalTextPosition.Center,
                  skipMode: s.EDataLabelSkipMode.ShowAll,
                },
                e
              )
            ),
              (this.type = a.EDataLabelProviderType.PolarColumn),
              (this.polarLabelModeProperty = l.EPolarLabelMode.Horizontal),
              (this.yPositionMultiplierProperty = 0.5),
              (this.labelYPositionModeProperty =
                h.EColumnDataLabelPosition.Outside),
              (this.polarLabelModeProperty =
                null !== (t = null == e ? void 0 : e.polarLabelMode) &&
                void 0 !== t
                  ? t
                  : this.polarLabelModeProperty),
              (this.yPositionMultiplierProperty =
                null == e ? void 0 : e.labelYPositionMultiplier),
              (this.labelYPositionModeProperty =
                null !== (r = null == e ? void 0 : e.labelYPositionMode) &&
                void 0 !== r
                  ? r
                  : this.labelYPositionModeProperty);
          }
          shouldSkipLabel(e, t) {
            return !1;
          }
          get polarLabelMode() {
            return this.polarLabelModeProperty;
          }
          set polarLabelMode(e) {
            (this.polarLabelModeProperty = e), this.invalidateParent();
          }
          get yPositionMultiplier() {
            return this.yPositionMultiplierProperty;
          }
          set yPositionMultiplier(e) {
            (this.yPositionMultiplierProperty = e), this.invalidateParent();
          }
          get labelYPositionMode() {
            return this.labelYPositionModeProperty;
          }
          set labelYPositionMode(e) {
            (this.labelYPositionModeProperty = e), this.invalidateParent();
          }
          getDataLabelState(e, t, r, i, o, a) {
            return new u.PolarColumnDataLabelState(e, t, r, i, o, a);
          }
          getPosition(e, t) {
            var r;
            const a = this.parentSeries,
              { columnXMode: s, defaultY1: n } = a,
              u = e.getYCoord(n);
            if (e.isVerticalChart) {
              const r = this.parentSeries.yAxis,
                { startAngle: a, flippedCoordinates: u } = r;
              let c = e.angleCoord();
              const p = c + a,
                g = e.getYCoord(n);
              let y;
              if (s === o.EColumnMode.Start) {
                const t = e.isFlipped ? -1 : 1;
                y = e.radiusCoord() + (t * e.columnWidth) / 2;
              } else if (s === o.EColumnMode.StartEnd) {
                const t = e.x1Coord();
                y = (e.radiusCoord() + t) / 2;
              } else if (s === o.EColumnMode.StartWidth) {
                const t = e.x1Coord() - e.zeroXCoord;
                y = e.radiusCoord() + t / 2;
              } else {
                if (s !== o.EColumnMode.Mid && s !== o.EColumnMode.MidWidth)
                  throw new Error(
                    `PolarColumnSeriesDataLabelProvider EColumnMode ${s} is not supported for vertical chart`
                  );
                y = e.radiusCoord();
              }
              let f = 0;
              if (this.polarLabelMode === l.EPolarLabelMode.Parallel)
                f = Math.atan2(t.m_fWidth, y);
              else if (this.polarLabelMode === l.EPolarLabelMode.Perpendicular)
                f = Math.atan2(t.m_fHeight, y);
              else {
                if (this.polarLabelMode !== l.EPolarLabelMode.Horizontal)
                  throw new Error(
                    `PolarColumnSeriesDataLabelProvider EPolarLabelMode ${this.polarLabelMode} is not supported for vertical chart`
                  );
                {
                  const e =
                    Math.abs(Math.sin(p)) * t.m_fWidth +
                    Math.abs(Math.cos(p)) * t.m_fHeight;
                  f = Math.atan2(e, y);
                }
              }
              this.labelYPositionMode === h.EColumnDataLabelPosition.Outside
                ? (c = u ? c - f : c + f)
                : this.labelYPositionMode === h.EColumnDataLabelPosition.Inside
                ? (c = u ? c + f : c - f)
                : this.labelYPositionMode ===
                    h.EColumnDataLabelPosition.Position &&
                  (c = g + (c - g) * this.yPositionMultiplier);
              let { x: v, y: m } = e.toCartesian(c, y);
              const S = new i.Point(v, m),
                P = d.labelHelper.getPolarLabelRotation(
                  this.polarLabelMode,
                  c + a
                );
              return (
                (v -= t.m_fWidth / 2),
                (m -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
                (m += t.m_fHeight / 2),
                {
                  position: new i.Point(v, m),
                  rotationCenter: S,
                  rotationAngle: P,
                }
              );
            }
            {
              const a = this.parentSeries.xAxis.startAngle,
                n =
                  null !== (r = this.yPositionMultiplier) && void 0 !== r
                    ? r
                    : 0.5;
              let c;
              if (s === o.EColumnMode.Start) {
                const t = e.isFlipped ? -1 : 1;
                c = e.angleCoord() + (t * e.columnWidth) / 2;
              } else if (s === o.EColumnMode.StartEnd) {
                const t = e.x1Coord();
                c = (e.angleCoord() + t) / 2;
              } else if (s === o.EColumnMode.StartWidth) {
                const t = e.x1Coord() - e.zeroXCoord;
                c = e.angleCoord() + t / 2;
              } else c = e.angleCoord();
              const p = c + a;
              let g,
                y = 0;
              if (this.polarLabelMode === l.EPolarLabelMode.Parallel)
                y = t.m_fHeight;
              else if (this.polarLabelMode === l.EPolarLabelMode.Perpendicular)
                y = t.m_fWidth;
              else {
                if (this.polarLabelMode !== l.EPolarLabelMode.Horizontal)
                  throw new Error(
                    `PolarColumnSeriesDataLabelProvider EPolarLabelMode ${this.polarLabelMode} is not supported for vertical chart`
                  );
                y =
                  Math.abs(Math.sin(p)) * t.m_fHeight +
                  Math.abs(Math.cos(p)) * t.m_fWidth;
              }
              this.labelYPositionMode === h.EColumnDataLabelPosition.Outside
                ? (g = e.radiusCoord() + y)
                : this.labelYPositionMode === h.EColumnDataLabelPosition.Inside
                ? (g = e.radiusCoord() - y)
                : this.labelYPositionMode ===
                    h.EColumnDataLabelPosition.Position &&
                  (g = u + (e.radiusCoord() - u) * n);
              let { x: f, y: v } = e.toCartesian(c, g);
              const m = new i.Point(f, v),
                S = d.labelHelper.getPolarLabelRotation(this.polarLabelMode, p);
              return (
                (f -= t.m_fWidth / 2),
                (v -= t.m_fHeight - t.GetLineBounds(0).m_fHeight),
                (v += t.m_fHeight / 2),
                {
                  position: new i.Point(f, v),
                  rotationCenter: m,
                  rotationAngle: S,
                }
              );
            }
          }
          toJSON() {
            const e = super.toJSON(),
              t = {
                polarLabelMode: this.polarLabelMode,
                labelYPositionMultiplier: this.yPositionMultiplier,
                labelYPositionMode: this.labelYPositionMode,
              };
            return Object.assign(e.options, t), e;
          }
          get useRotation() {
            return this.polarLabelMode !== l.EPolarLabelMode.Horizontal;
          }
        }
        t.PolarColumnSeriesDataLabelProvider = p;
      },
      19963: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarDataLabelProvider = void 0);
        const i = r(2963),
          o = r(96852),
          a = r(62652);
        class s extends o.DataLabelProvider {
          constructor() {
            super(...arguments),
              (this.type = i.EDataLabelProviderType.PolarDefault);
          }
          getDataLabelState(e, t, r, i, o, s) {
            return new a.PolarDataLabelState(e, t, r, i, o, s);
          }
        }
        t.PolarDataLabelProvider = s;
      },
      62652: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarDataLabelState = void 0);
        const i = r(31306),
          o = r(92415),
          a = r(86127),
          s = r(55172);
        class n extends s.DataLabelState {
          toCartesian(e, t) {
            const r = this.parentSeries.xAxis;
            return o.annotationHelpers.convertPolarToCartesian(
              r,
              !1,
              this.parentSeries.parentSurface.webAssemblyContext2D,
              i.ECoordinateMode.Pixel,
              e * a.DpiHelper.PIXEL_RATIO,
              t
            );
          }
          xCoord(e) {
            return this.updateCache(e), this.cartesianCache.x;
          }
          yCoord(e) {
            return this.updateCache(e), this.cartesianCache.y;
          }
          angleCoord(e) {
            return super.xCoord(e);
          }
          radiusCoord(e) {
            return super.yCoord(e);
          }
          updateCache(e) {
            const t = null != e ? e : this.index;
            if (!this.cartesianCache || this.cartesianCache.index !== t) {
              const e = super.xCoord(),
                r = super.yCoord(),
                { x: i, y: o } = this.toCartesian(e, r);
              this.cartesianCache = { index: t, x: i, y: o };
            }
          }
        }
        t.PolarDataLabelState = n;
      },
      192: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarHeatMapDataLabelProvider = void 0);
        const i = r(75772),
          o = r(31306),
          a = r(92415),
          s = r(8827),
          n = r(10572),
          l = r(86127),
          d = r(75933);
        class h extends d.HeatMapDataLabelProvider {
          constructor(e) {
            var t;
            super(e),
              (this.polarLabelModeProperty = s.EPolarLabelMode.Horizontal),
              (this.polarLabelModeProperty =
                null !== (t = null == e ? void 0 : e.polarLabelMode) &&
                void 0 !== t
                  ? t
                  : this.polarLabelModeProperty);
          }
          get polarLabelMode() {
            return this.polarLabelModeProperty;
          }
          set polarLabelMode(e) {
            (this.polarLabelModeProperty = e), this.invalidateParent();
          }
          shouldGenerate(e, t, r) {
            return !0;
          }
          shouldSkipLabel(e, t, r, i, o) {
            return !1;
          }
          toCartesian(e, t) {
            const r = this.parentSeries.xAxis;
            return a.annotationHelpers.convertPolarToCartesian(
              r,
              !1,
              this.parentSeries.parentSurface.webAssemblyContext2D,
              o.ECoordinateMode.Pixel,
              e * l.DpiHelper.PIXEL_RATIO,
              t
            );
          }
          getPosition(e, t, r, o, a, s, l, d) {
            const h = this.parentSeries,
              u = d.isVerticalChart ? h.yAxis : h.xAxis;
            let c = d.xCoordinateCalculator.getCoordinate(r);
            c -=
              ((d.xCoordinateCalculator.hasFlippedCoordinates ? -1 : 1) * s) /
              2;
            let p = d.yCoordinateCalculator.getCoordinate(o);
            p -=
              ((d.yCoordinateCalculator.hasFlippedCoordinates ? -1 : 1) * l) /
              2;
            let g = d.isVerticalChart ? p : c,
              y = d.isVerticalChart ? c : p,
              { x: f, y: v } = this.toCartesian(g, y);
            const m = new i.Point(f, v);
            (f -= a.width / 2), (v += a.height / 2);
            const S = n.labelHelper.getPolarLabelRotation(
              this.polarLabelMode,
              u.startAngle + g
            );
            return {
              position: new i.Point(f, v),
              rotationCenter: m,
              rotationAngle: S,
            };
          }
          get useRotation() {
            return this.polarLabelMode !== s.EPolarLabelMode.Horizontal;
          }
        }
        t.PolarHeatMapDataLabelProvider = h;
      },
      90262: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarBandSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(22950),
          a = r(8591),
          s = r(48008),
          n = r(51269),
          l = r(14184),
          d = r(20977),
          h = r(65043);
        class u extends h.BaseSeriesDrawingProvider {
          constructor(e, t, r, i) {
            super(e, t, r),
              (this.args =
                new this.webAssemblyContext.SCRTPolarBandDrawingParams()),
              (this.y1Selector = null != i ? i : (e) => e.y1Values),
              (this.fillBrushCache = new n.BrushCache(e)),
              (this.fillBrushY1Cache = new n.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries(),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTPolarBandSeriesDrawingProvider()),
              this.onSeriesPropertyChange(d.PROPERTY.FILL),
              (this.parentSeries.fillY1 ||
                this.parentSeries.fillLinearGradientY1) &&
                this.onSeriesPropertyChange(d.PROPERTY.FILL_Y1);
          }
          onDetachSeries() {
            super.onDetachSeries(), this.delete();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              (this.fillBrushY1Cache = (0, i.deleteSafe)(
                this.fillBrushY1Cache
              )),
              super.delete();
          }
          draw(e, t) {
            var r, i;
            const o = t.pointSeries;
            this.parentSeries.dataSeries.dataDistributionCalculator.containsNaN,
              this.args.Reset();
            const a = (0, n.getScrtBrushFromCache)(this.fillBrushCache);
            a && this.args.SetFillBrush(a);
            const s = (0, n.getScrtBrushFromCache)(this.fillBrushY1Cache);
            s && this.args.SetFillBrush1(s);
            const l = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              d = o.xValues,
              {
                fifoCapacity: h,
                fifoSweeping: u,
                fifoSweepingGap: c,
              } = this.parentSeries.dataSeries,
              p = o.fifoStartIndex;
            let g = l ? o.indexes : d,
              y = this.ySelector(o),
              f = this.y1Selector(o);
            const { startIndex: v, count: m } = this.getStartAndCount(t, g);
            (this.args.count = m),
              (this.args.startIndex = v),
              h > 0 &&
                u &&
                h === this.parentSeries.dataSeries.count() &&
                (this.args.count = p);
            const S = this.parentSeries.xAxis;
            this.args.SetCoordinateTransform(S.getTransform()),
              this.args.SetX(g),
              this.args.SetY(y),
              f
                ? this.args.SetY2(f)
                : (this.args.zeroLineY =
                    null !== (r = this.parentSeries.zeroLineY) && void 0 !== r
                      ? r
                      : 0),
              this.applyFillFillPaletting(
                this.parentSeries.fill,
                a,
                this.parentSeries.fillY1,
                s,
                this.parentSeries.opacity,
                v,
                m,
                o,
                g,
                y
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors),
              (this.args.scaleGradientToYRange =
                null !== (i = this.parentSeries.scaleGradientToYRange) &&
                void 0 !== i &&
                i),
              (this.args.isSmoothColors =
                this.palettingState.gradientPaletting);
            const P = e.getNativeContext();
            this.nativeDrawingProvider.DrawPoints(
              P,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              h > 0 &&
                u &&
                h === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(y.size(), p + c)),
                (this.args.count = Math.max(0, y.size() - p - c)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPoints(
                    P,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          applyFillFillPaletting(e, t, r, i, n, l, d, h, u, c) {
            var p;
            const g = this.parentSeries.hasFillPaletteProvider(),
              y = this.parentSeries.paletteProvider;
            if (g) {
              let p, g;
              const f = void 0 !== n;
              if (
                ((p =
                  e && f
                    ? (0, o.uintArgbColorMultiplyOpacity)(
                        (0, s.parseColorToUIntArgb)(e),
                        1
                      )
                    : 4294967295),
                (g =
                  r && f
                    ? (0, o.uintArgbColorMultiplyOpacity)(
                        (0, s.parseColorToUIntArgb)(r),
                        1
                      )
                    : 4294967295),
                isNaN(p))
              )
                throw Error(
                  "updatePalette(): fillColor " +
                    p +
                    " cannot be converted to a valid color"
                );
              if (isNaN(g))
                throw Error(
                  "updatePalette(): fillColor for y1 " +
                    g +
                    " cannot be converted to a valid color"
                );
              this.palettingState.palettedColors ||
                (this.palettingState.palettedColors =
                  new this.webAssemblyContext.UIntVector()),
                this.palettingState.paletteTextureCache.reset(),
                this.palettingState.palettedColors.clear(),
                this.palettingState.palettedColors.reserve(2 * d),
                t &&
                  ((this.palettingState.originalBrushColor = t.GetColor()),
                  t.SetColor(4294967295)),
                i &&
                  ((this.palettingState.originalBrushColory1 = i.GetColor()),
                  i.SetColor(4294967295));
              let v = 0;
              const m = this.parentSeries.dataSeries;
              for (let e = l; e < l + d; e++) {
                let t = h ? h.indexes.get(e) : e;
                t < 0 ? (t = 0) : t >= m.count() && (t = m.count() - 1);
                const r = u.get(e),
                  i = c.get(e),
                  o = m.getMetadataAt(t),
                  s = y.overrideFillArgb(r, i, t, n, o);
                this.palettingState.palettedColors.push_back(null != s ? s : p),
                  this.palettingState.palettedColors.push_back(
                    null != s ? s : g
                  ),
                  (v = (0, a.numericHashCode)(v, s));
              }
            } else
              this.palettingState.paletteTextureCache.reset(),
                null === (p = this.palettingState.palettedColors) ||
                  void 0 === p ||
                  p.clear(),
                t &&
                  this.palettingState.originalBrushColor &&
                  (t.SetColor(this.palettingState.originalBrushColor),
                  (this.palettingState.originalBrushColor = void 0)),
                i &&
                  this.palettingState.originalBrushColory1 &&
                  (i.SetColor(this.palettingState.originalBrushColory1),
                  (this.palettingState.originalBrushColory1 = void 0));
            this.palettingState.palettedColors ||
              (this.palettingState.palettedColors =
                new this.webAssemblyContext.UIntVector()),
              (this.palettingState.gradientPaletting =
                this.isGradientFillPaletting(this.parentSeries));
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
                fill: t,
                fillY1: r,
                opacity: i,
                fillLinearGradient: o,
                fillLinearGradientY1: a,
                parentSurface: s,
              } = this.parentSeries,
              h = (null == s ? void 0 : s.isCopyCanvasSurface)
                ? s.domCanvas2D.height /
                  l.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              u = (null == s ? void 0 : s.isCopyCanvasSurface)
                ? s.domCanvas2D.width /
                  l.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            (e !== d.PROPERTY.FILL &&
              e !== d.PROPERTY.OPACITY &&
              e !== d.PROPERTY.FILL_LINEAR_GRADIENT) ||
              (0, n.createBrushInCache)(this.fillBrushCache, t, i, h, u, o),
              (e !== d.PROPERTY.FILL_Y1 &&
                e !== d.PROPERTY.OPACITY &&
                e !== d.PROPERTY.FILL_LINEAR_GRADIENT) ||
                (0, n.createBrushInCache)(this.fillBrushY1Cache, r, i, h, u, a);
          }
        }
        t.PolarBandSeriesDrawingProvider = u;
      },
      77339: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarColumnSeriesDrawingProvider = void 0);
        const i = r(56744),
          o = r(51269),
          a = r(21915),
          s = r(20977),
          n = r(65043),
          l = r(60960),
          d = r(54624);
        class h extends n.BaseSeriesDrawingProvider {
          constructor(e, t) {
            super(e, t),
              (this.nativeDrawingProvider =
                new e.SCRTPolarColumnSeriesDrawingProvider()),
              (this.args =
                new this.webAssemblyContext.SCRTPolarColumnDrawingParams()),
              (this.strokePenCache = new a.Pen2DCache(e)),
              (this.strokePenFillColoredCache = new a.Pen2DCache(e)),
              (this.fillBrushCache = new o.BrushCache(e));
          }
          onAttachSeries() {
            super.onAttachSeries();
            const {
              stroke: e,
              strokeThickness: t,
              fill: r,
              opacity: i,
            } = this.parentSeries;
            (0, a.createPenInCache)(this.strokePenCache, e, t, i),
              0 === t &&
                (0, a.createPenInCache)(
                  this.strokePenFillColoredCache,
                  r,
                  1,
                  i
                ),
              this.createBrush();
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              (this.args = (0, i.deleteSafe)(this.args)),
              (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.strokePenFillColoredCache = (0, i.deleteSafe)(
                this.strokePenFillColoredCache
              )),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          draw(e, t) {
            const r = t.pointSeries,
              i = this.parentSeries.strokeThickness;
            this.args.Reset(),
              (this.args.verticalChart = t.isVerticalChart),
              (this.args.xMode = (0, l.convertColumnMode)(
                this.parentSeries.columnXMode,
                this.webAssemblyContext
              )),
              (this.args.defaultY2 = this.parentSeries.defaultY1),
              (this.args.columnWidth = this.parentSeries.getDataPointWidth(
                t.xCoordinateCalculator,
                this.parentSeries.dataPointWidth,
                this.parentSeries.dataPointWidthMode
              ));
            let s = this.strokePenCache;
            1 === this.args.columnWidth &&
              0 === i &&
              ((this.args.columnWidth = 0),
              (s = this.strokePenFillColoredCache));
            const n = (0, a.getScrtPenFromCache)(s);
            n && this.args.SetLinesPen(n);
            const h = (0, o.getScrtBrushFromCache)(this.fillBrushCache);
            h && this.args.SetFillBrush(h);
            const u = this.parentSeries.xAxis;
            this.args.SetCoordinateTransform(u.getTransform()),
              super.applyStrokeFillPaletting(
                this.parentSeries.stroke,
                n,
                this.parentSeries.fill,
                h,
                this.parentSeries.opacity,
                !1,
                void 0 !== this.parentSeries.fillLinearGradient
              ),
              this.args.SetPalettedColors(this.palettingState.palettedColors);
            const c = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
              p = this.xSelector(r),
              g = this.ySelector(r),
              y = c ? r.indexes : p,
              { startIndex: f, count: v } = this.getStartAndCount(t, y);
            (this.args.count = v), (this.args.startIndex = f);
            const {
                fifoCapacity: m,
                fifoSweeping: S,
                fifoSweepingGap: P,
              } = this.parentSeries.dataSeries,
              C = r.fifoStartIndex;
            if (
              (S &&
                m === this.parentSeries.dataSeries.count() &&
                (this.args.count = C),
              this.args.SetX(y),
              g && this.args.SetY(g),
              this.parentSeries.columnXMode === l.EColumnMode.MidWidth ||
                this.parentSeries.columnXMode === l.EColumnMode.StartEnd ||
                this.parentSeries.columnXMode === l.EColumnMode.StartWidth)
            ) {
              const e = r.getYValuesByName(d.EValueName.X1);
              if (!e)
                throw new Error(
                  `polarColumnMode ${this.parentSeries.columnXMode} requires an DataSeries with a yValue called ${d.EValueName.X1}`
                );
              this.args.SetX2(e);
            }
            const b = r.getYValuesByName(d.EValueName.Y1);
            b && this.args.SetY2(b), (this.args.segmentCount = 180);
            const x = e.getNativeContext();
            this.nativeDrawingProvider.DrawPoints(
              x,
              t.xCoordinateCalculator.nativeCalculator,
              t.yCoordinateCalculator.nativeCalculator,
              this.args
            ),
              S &&
                m === this.parentSeries.dataSeries.count() &&
                ((this.args.startIndex = Math.min(g.size(), C + P)),
                (this.args.count = Math.max(0, g.size() - C - P)),
                this.args.count > 0 &&
                  this.nativeDrawingProvider.DrawPoints(
                    x,
                    t.xCoordinateCalculator.nativeCalculator,
                    t.yCoordinateCalculator.nativeCalculator,
                    this.args
                  ));
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.onSeriesPropertyChange(s.PROPERTY.STROKE);
          }
          onSeriesPropertyChange(e) {
            super.onSeriesPropertyChange(e);
            const {
              stroke: t,
              strokeThickness: r,
              opacity: i,
              fill: o,
            } = this.parentSeries;
            (e !== s.PROPERTY.STROKE &&
              e !== s.PROPERTY.STROKE_THICKNESS &&
              e !== s.PROPERTY.OPACITY) ||
              (0, a.createPenInCache)(this.strokePenCache, t, r, i),
              (e !== s.PROPERTY.FILL &&
                e !== s.PROPERTY.OPACITY &&
                e !== s.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                this.createBrush(),
              0 !== r ||
                (e !== s.PROPERTY.STROKE_THICKNESS &&
                  e !== s.PROPERTY.STROKE &&
                  e !== s.PROPERTY.OPACITY &&
                  e !== s.PROPERTY.FILL) ||
                (0, a.createPenInCache)(
                  this.strokePenFillColoredCache,
                  o,
                  1,
                  i
                );
          }
          createBrush() {
            const {
              fill: e,
              opacity: t,
              fillLinearGradient: r,
              parentSurface: i,
              customTextureOptions: o,
            } = this.parentSeries;
            return this.fillBrushCache.create(e, t, 1, 1, r, o).scrtBrush;
          }
        }
        t.PolarColumnSeriesDrawingProvider = h;
      },
      40997: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarHeatmapDrawingProvider = void 0);
        const i = r(76566);
        class o extends i.UniformHeatmapDrawingProvider {
          draw(e, t) {
            var r, i, o;
            const a =
              null === (r = this.heatTextureCache) || void 0 === r
                ? void 0
                : r.value;
            if (a) {
              const r = this.parentSeries.dataSeries,
                s = r.xStart,
                n = t.xCoordinateCalculator.getCoordinate(s),
                l =
                  null !==
                    (o =
                      null === (i = r.getZValues()[0]) || void 0 === i
                        ? void 0
                        : i.length) && void 0 !== o
                    ? o
                    : 0,
                d = s + r.xStep * l,
                h = t.xCoordinateCalculator.getCoordinate(d),
                u = r.getNormalizedVector(
                  this.parentSeries.colorMap,
                  this.parentSeries.fillValuesOutOfRange
                );
              (this.packedFloatParams =
                this.webAssemblyContext.SCRTFillTextureFloat32(
                  a,
                  r.arrayWidth,
                  r.arrayHeight,
                  u
                )),
                (this.packedFloatParams.x = 0),
                (this.packedFloatParams.y = 1);
              const c = r.yRange,
                p = t.yCoordinateCalculator.getCoordinate(c.min),
                g = t.yCoordinateCalculator.getCoordinate(c.max),
                y = e.getNativeContext(),
                f = this.packedFloatParams,
                v = new this.webAssemblyContext.SCRTContourParams();
              this.recreatePalette();
              const m = this.parentSeries.xAxis.getTransform();
              y.DrawPolarHeatmap(
                m,
                p,
                g,
                n,
                this.paletteTexture.getTexture(),
                a,
                f,
                v,
                h
              ),
                v.delete(),
                f.delete();
            }
          }
        }
        t.PolarHeatmapDrawingProvider = o;
      },
      16556: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarLineSeriesDrawingProvider = void 0);
        const i = r(36898);
        class o extends i.LineSeriesDrawingProvider {
          updateArgs(e) {
            const t = this.parentSeries.xAxis;
            if (t.isAngular)
              return this.args.SetCoordinateTransform(t.getTransform());
            {
              const e = this.parentSeries.yAxis;
              return this.args.SetCoordinateTransform(e.getTransform());
            }
          }
        }
        t.PolarLineSeriesDrawingProvider = o;
      },
      37874: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarPointMarkerDrawingProvider = void 0);
        const i = r(94707);
        class o extends i.PointMarkerDrawingProvider {
          updateArgs(e) {
            const t = this.parentSeries.xAxis;
            if (t.isAngular)
              return this.args.SetCoordinateTransform(t.getTransform());
            {
              const e = this.parentSeries.yAxis;
              return this.args.SetCoordinateTransform(e.getTransform());
            }
          }
        }
        t.PolarPointMarkerDrawingProvider = o;
      },
      14082: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarDataPointHitTestProvider = void 0);
        const i = r(7541),
          o = r(35013),
          a = r(85414),
          s = r(46495);
        class n extends i.BaseHitTestProvider {
          hitTest(e, t, r = 10) {
            return this.hitTestDataPointInternal(e, t, r);
          }
          hitTestDataPoint(e, t, r) {
            const i = r > 0 ? r : 10;
            return this.hitTestDataPointInternal(e, t, i);
          }
          hitTestXSlice(e, t) {
            return this.hitTest(e, t, 10);
          }
          hitTestDataPointInternal(e, t, r) {
            const i = this.getTranslatedHitTestPoint(e, t);
            if (!i) return o.HitTestInfo.empty();
            const n = this.parentSeries.xAxis.reverseTransform(i.x, i.y),
              {
                xCoordinateCalculator: l,
                yCoordinateCalculator: d,
                isVerticalChart: h,
              } = this.currentRenderPassData,
              u = h ? n.y : n.x,
              c = h ? n.x : n.y,
              p = this.parentSeries.dataSeries;
            if (!p) return o.HitTestInfo.empty();
            const g = s.polarHitTestHelpers.getNearestPolarPoint(
                this.webAssemblyContext,
                l,
                d,
                p,
                u,
                c
              ),
              y = p.getNativeXValues(),
              f = p.getNativeYValues(),
              v = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                l,
                d,
                h,
                p,
                y,
                f,
                u,
                c,
                g.nearestPointIndex,
                r
              );
            return (v.isHit = g.distance < r), v;
          }
        }
        t.PolarDataPointHitTestProvider = n;
      },
      16256: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarLineSeriesHitTestProvider = void 0);
        const i = r(75772),
          o = r(35013),
          a = r(85414),
          s = r(92415),
          n = r(31306),
          l = r(21670),
          d = r(14082),
          h = r(86127);
        class u extends d.PolarDataPointHitTestProvider {
          hitTest(e, t, r = 10) {
            const d = this.getTranslatedHitTestPoint(e, t);
            if (!d) return o.HitTestInfo.empty();
            const {
                xCoordinateCalculator: u,
                yCoordinateCalculator: c,
                isVerticalChart: p,
              } = this.currentRenderPassData,
              g = d.x,
              y = d.y,
              f = this.parentSeries.dataSeries;
            if (!f) return o.HitTestInfo.empty();
            const v = f.getNativeXValues(),
              m = f.getNativeYValues(),
              S = this.parentSeries.xAxis,
              P = (e) => {
                const t = v.get(e),
                  r = m.get(e),
                  o = u.getCoordinate(t),
                  a = c.getCoordinate(r),
                  l = p ? a : o,
                  d = p ? o : a,
                  g = s.annotationHelpers.convertPolarToCartesian(
                    S,
                    !1,
                    this.webAssemblyContext,
                    n.ECoordinateMode.Pixel,
                    l * h.DpiHelper.PIXEL_RATIO,
                    d
                  );
                return new i.Point(g.x, g.y);
              };
            let C = Number.MAX_VALUE,
              b = -1,
              x = -1;
            const A = (e, t, r = -1) => {
              e < C && ((C = e), (b = t), (x = r));
            };
            if (f.count() > 0) {
              let e = P(0),
                t = (0, l.calcDistance)(g, y, e.x, e.y);
              A(t, 0);
              for (let r = 1; r < f.count(); r++) {
                const i = P(r),
                  o = (0, l.calcDistance)(e.x, e.y, i.x, i.y),
                  a = (0, l.calcDistance)(g, y, i.x, i.y);
                if ((A(a, r), t < o && a < o)) {
                  const o = (0, l.calcDistanceFromLine)(
                    g,
                    y,
                    e.x,
                    e.y,
                    i.x,
                    i.y
                  );
                  o < C && (t < a ? A(o, r - 1, r) : A(o, r, r - 1));
                }
                (e = i), (t = a);
              }
            }
            const T = S.reverseTransform(d.x, d.y),
              E = a.hitTestHelpers.createHitTestInfo(
                this.parentSeries,
                u,
                c,
                p,
                f,
                v,
                m,
                T.x,
                T.y,
                b,
                r
              );
            return (E.isHit = C < r), E;
          }
        }
        t.PolarLineSeriesHitTestProvider = u;
      },
      46495: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.polarHitTestHelpers = void 0);
        const i = r(56744);
        t.polarHitTestHelpers = {
          getNearestPolarPoint: function (e, t, r, o, a, s) {
            const n = t.isCategoryCoordinateCalculator
                ? o.getNativeIndexes()
                : o.getNativeXValues(),
              l = o.getNativeYValues();
            let d;
            try {
              return (
                (d = e.SCRTHitTestHelper.GetNearestPolarXyPoint(
                  t.nativeCalculator,
                  r.nativeCalculator,
                  n,
                  l,
                  a,
                  s,
                  !1,
                  !1
                )),
                { nearestPointIndex: d.minD, distance: d.maxD }
              );
            } finally {
              (0, i.deleteSafe)(d);
            }
          },
        };
      },
      83187: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarBandRenderableSeries = void 0);
        const i = r(49742),
          o = r(5337),
          a = r(20181),
          s = r(20782),
          n = r(87836),
          l = r(90262),
          d = r(16556),
          h = r(37874);
        class u extends a.BaseBandRenderableSeries {
          constructor(e, t) {
            var r, i, a, l;
            super(e, t),
              (this.isPolar = !0),
              (this.type = o.ESeriesType.PolarBandSeries),
              (this.lineType = s.ELineType.Normal),
              (this.clipToTotalAngle = !1),
              (this.interpolateLineProperty = !1),
              (this.renderDataTransformProperty =
                new n.PolarInterpolateBandRenderDataTransform(
                  this,
                  this.webAssemblyContext,
                  []
                )),
              (this.interpolateLine =
                null !== (r = null == t ? void 0 : t.interpolateLine) &&
                void 0 !== r
                  ? r
                  : this.interpolateLineProperty),
              (this.scaleGradientToYRangeProperty =
                null !== (i = null == t ? void 0 : t.scaleGradientToYRange) &&
                void 0 !== i
                  ? i
                  : this.scaleGradientToYRangeProperty),
              (null === (a = this.paletteProvider) || void 0 === a
                ? void 0
                : a.onAttached) &&
                (null === (l = this.paletteProvider) ||
                  void 0 === l ||
                  l.onAttached(this));
          }
          get isDigitalLine() {
            return !1;
          }
          get scaleGradientToYRange() {
            return this.scaleGradientToYRangeProperty;
          }
          set scaleGradientToYRange(e) {
            this.scaleGradientToYRangeProperty !== e &&
              ((this.scaleGradientToYRangeProperty = e),
              this.notifyPropertyChanged("SCALE_GRADIENT_TO_Y_RANGE"));
          }
          get interpolateLine() {
            return this.interpolateLineProperty;
          }
          set interpolateLine(e) {
            this.interpolateLineProperty !== e &&
              ((this.interpolateLineProperty = e),
              this.interpolateLineProperty
                ? (this.renderDataTransform.drawingProviders =
                    this.drawingProviders)
                : (this.renderDataTransform.drawingProviders = []),
              this.notifyPropertyChanged("interpolateLine"));
          }
          getIndicesRange(e, t) {
            return this.clipToTotalAngle
              ? super.getIndicesRange(e, t)
              : new i.NumberRange(0, this.dataSeries.count() - 1);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                scaleGradientToYRange: this.scaleGradientToYRange,
                interpolateLine: this.interpolateLine,
              };
            return Object.assign(t.options, r), t;
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new l.PolarBandSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new d.PolarLineSeriesDrawingProvider(e, this)
              );
            const r = new d.PolarLineSeriesDrawingProvider(
              e,
              this,
              (e) => e.y1Values
            );
            (r.getProperties = (e) => {
              const {
                strokeY1: t,
                strokeThickness: r,
                opacity: i,
                strokeY1DashArray: o,
                isDigitalLine: a,
                drawNaNAs: s,
                lineType: n,
              } = e;
              return {
                stroke: t,
                strokeThickness: r,
                opacity: i,
                strokeDashArray: o,
                isDigitalLine: a,
                drawNaNAs: s,
                lineType: n,
                containsNaN: void 0,
              };
            }),
              this.drawingProviders.push(r),
              this.drawingProviders.push(
                new h.PolarPointMarkerDrawingProvider(e, this)
              ),
              this.drawingProviders.push(
                new h.PolarPointMarkerDrawingProvider(
                  e,
                  this,
                  (e) => e.y1Values,
                  void 0
                )
              );
          }
        }
        t.PolarBandRenderableSeries = u;
      },
      38831: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarColumnRenderableSeries = void 0);
        const i = r(5337),
          o = r(79961),
          a = r(94707),
          s = r(77339),
          n = r(60960),
          l = r(27970),
          d = r(15518),
          h = r(16098),
          u = r(92762),
          c = r(20977);
        class p extends h.FastRectangleRenderableSeries {
          constructor(e, t) {
            var r, o, a;
            super(
              e,
              Object.assign(Object.assign({}, t), {
                dataLabelProvider:
                  null !== (r = null == t ? void 0 : t.dataLabelProvider) &&
                  void 0 !== r
                    ? r
                    : new d.PolarColumnSeriesDataLabelProvider(
                        null == t ? void 0 : t.dataLabels
                      ),
              })
            ),
              (this.type = i.ESeriesType.PolarColumnSeries),
              (this.isPolar = !0),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (a = this.paletteProvider) ||
                  void 0 === a ||
                  a.onAttached(this));
          }
          get defaultY1() {
            return this.defaultY1Property;
          }
          set defaultY1(e) {
            (this.defaultY1Property = e),
              this.notifyPropertyChanged(c.PROPERTY.DEFAULT_Y1);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new s.PolarColumnSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new a.PointMarkerDrawingProvider(e, this)
              );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e);
            return Object.assign(t.options, {}), t;
          }
          getDataPointWidth(e, t, r) {
            const i = this.dataSeries.getNativeXValues(),
              a = e.viewportDimension,
              s = e.isCategoryCoordinateCalculator;
            if (r === l.EDataPointWidthMode.Range) {
              const r = e.visibleMax - e.visibleMin;
              return (e.viewportDimension / r) * t;
            }
            return r === l.EDataPointWidthMode.Absolute
              ? t
              : (0, o.getDataPointWidth)(
                  i,
                  e,
                  a,
                  t,
                  s,
                  this.webAssemblyContext
                );
          }
          get columnYMode() {
            return n.EColumnYMode.TopBottom;
          }
          set columnYMode(e) {
            throw Error(
              "columnYMode is not supported for PolarColumnRenderableSeries"
            );
          }
          newHitTestProvider() {
            return new u.RectangleSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.PolarColumnRenderableSeries = p;
      },
      4455: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarLineRenderableSeries = void 0);
        const i = r(98140),
          o = r(5337),
          a = r(20782),
          s = r(19963),
          n = r(61566),
          l = r(16556),
          d = r(37874),
          h = r(16256);
        class u extends a.BaseLineRenderableSeries {
          constructor(e, t) {
            var r, i, a, l;
            super(e, t),
              (this.isPolar = !0),
              (this.type = o.ESeriesType.PolarLineSeries),
              (this.clipToTotalAngleProperty = !1),
              (this.interpolateLineProperty = !1),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new s.PolarDataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (i = this.paletteProvider) ||
                  void 0 === i ||
                  i.onAttached(this)),
              (this.renderDataTransformProperty =
                new n.PolarInterpolateLineRenderDataTransform(
                  this,
                  this.webAssemblyContext,
                  []
                )),
              (this.clipToTotalAngleProperty =
                null !== (a = null == t ? void 0 : t.clipToTotalAngle) &&
                void 0 !== a
                  ? a
                  : this.clipToTotalAngleProperty),
              (this.interpolateLine =
                null !== (l = null == t ? void 0 : t.interpolateLine) &&
                void 0 !== l
                  ? l
                  : this.interpolateLineProperty);
          }
          get interpolateLine() {
            return this.interpolateLineProperty;
          }
          set interpolateLine(e) {
            this.interpolateLineProperty !== e &&
              ((this.interpolateLineProperty = e),
              this.interpolateLineProperty
                ? (this.renderDataTransform.drawingProviders = [
                    this.drawingProviders[0],
                  ])
                : (this.renderDataTransform.drawingProviders = []),
              this.notifyPropertyChanged("interpolateLine"));
          }
          get clipToTotalAngle() {
            return this.clipToTotalAngleProperty;
          }
          set clipToTotalAngle(e) {
            this.clipToTotalAngleProperty !== e &&
              ((this.clipToTotalAngleProperty = e),
              this.notifyPropertyChanged("clipToTotalAngle"));
          }
          getIndicesRange(e, t) {
            return this.clipToTotalAngle
              ? super.getIndicesRange(e, t)
              : new i.NumberRange(0, this.dataSeries.count() - 1);
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                clipToTotalAngle: this.clipToTotalAngle,
                interpolateLine: this.interpolateLine,
              };
            return Object.assign(t.options, r), t;
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new l.PolarLineSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new d.PolarPointMarkerDrawingProvider(e, this)
              );
          }
          newHitTestProvider() {
            return new h.PolarLineSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.PolarLineRenderableSeries = u;
      },
      88409: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(84392),
          a = r(20782),
          s = r(36650),
          n = r(20977),
          l = r(61566),
          d = r(19963),
          h = r(90262),
          u = r(16556),
          c = r(37874),
          p = r(14082);
        class g extends s.BaseMountainRenderableSeries {
          constructor(e, t) {
            var r, o, s;
            super(e, t),
              (this.isPolar = !0),
              (this.type = i.ESeriesType.PolarMountainSeries),
              (this.lineType = a.ELineType.Normal),
              (this.interpolateLineProperty = !1),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new d.PolarDataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (this.interpolateLineProperty =
                null !== (r = null == t ? void 0 : t.interpolateLine) &&
                void 0 !== r
                  ? r
                  : this.interpolateLineProperty),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (s = this.paletteProvider) ||
                  void 0 === s ||
                  s.onAttached(this));
          }
          get isDigitalLine() {
            return !1;
          }
          onAttach(e) {
            super.onAttach(e),
              (this.renderDataTransformProperty =
                new l.PolarInterpolateLineRenderDataTransform(
                  this,
                  this.webAssemblyContext,
                  [this.drawingProviders[0], this.drawingProviders[1]]
                ));
          }
          get interpolateLine() {
            return this.interpolateLineProperty;
          }
          set interpolateLine(e) {
            this.interpolateLineProperty !== e &&
              ((this.interpolateLineProperty = e),
              this.notifyPropertyChanged("interpolateLine"));
          }
          get fillY1() {
            return (0, o.stripAutoColor)(this.fillY1Property);
          }
          set fillY1(e) {
            (this.fillY1Property = e),
              this.notifyPropertyChanged(n.PROPERTY.FILL_Y1);
          }
          get fillLinearGradient1() {
            return this.fillLinearGradient1Property;
          }
          set fillLinear1Gradient(e) {
            e !== this.fillLinearGradient1Property &&
              ((this.fillLinearGradient1Property = e),
              this.notifyPropertyChanged(n.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get zeroLineY() {
            return Math.max(
              this.zeroLineYProperty,
              this.xAxis.visibleRange.min
            );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { interpolateLine: this.interpolateLine };
            return Object.assign(t.options, r), t;
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new h.PolarBandSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new u.PolarLineSeriesDrawingProvider(e, this)
              ),
              this.drawingProviders.push(
                new c.PolarPointMarkerDrawingProvider(e, this)
              );
          }
          newHitTestProvider() {
            return new p.PolarDataPointHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.PolarMountainRenderableSeries = g;
      },
      2928: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarStackedColumnCollection = void 0);
        const i = r(98140),
          o = r(5337),
          a = r(11529);
        class s extends a.StackedXyCollection {
          constructor(e, t) {
            super(e, t),
              (this.isPolar = !0),
              (this.type = o.ESeriesType.PolarStackedColumnCollection);
          }
          getXRange() {
            return this.isEnoughDataToDraw()
              ? this.getFirstSeries().getXRange()
              : new i.NumberRange();
          }
          getYRange(e, t) {
            var r, o;
            const a = super.getYRange(e, t),
              s =
                null !==
                  (o =
                    null === (r = this.getFirstSeries()) || void 0 === r
                      ? void 0
                      : r.defaultY1) && void 0 !== o
                  ? o
                  : 0;
            return a.union(new i.NumberRange(s, s));
          }
        }
        t.PolarStackedColumnCollection = s;
      },
      2270: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarStackedColumnRenderableSeries = void 0);
        const i = r(56744),
          o = r(60960),
          a = r(27970),
          s = r(5337),
          n = r(88915),
          l = r(84392),
          d = r(14184),
          h = r(48335),
          u = r(20977),
          c = r(94707),
          p = r(20667),
          g = r(92762),
          y = r(77339);
        class f extends h.BaseStackedRenderableSeries {
          constructor(e, t) {
            var r, i, n, l, h;
            super(e, t),
              (this.type = s.ESeriesType.PolarStackedColumnSeries),
              (this.isPolar = !0),
              (this.fillProperty =
                d.SciChartSurfaceBase.DEFAULT_THEME.columnFillBrush),
              (this.polarColumnXModeProperty = o.EColumnMode.Mid),
              (this.polarColumnYModeProperty = o.EColumnYMode.TopBottom),
              (this.dataPointWidthProperty = 0.8),
              (this.dataPointWidthModeProperty = a.EDataPointWidthMode.Range),
              (this.fill =
                null !== (r = null == t ? void 0 : t.fill) && void 0 !== r
                  ? r
                  : this.fillProperty),
              (this.fillLinearGradientProperty =
                null !== (i = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== i
                  ? i
                  : this.fillLinearGradientProperty),
              (this.polarColumnXModeProperty =
                null !== (n = null == t ? void 0 : t.columnXMode) &&
                void 0 !== n
                  ? n
                  : this.polarColumnXModeProperty),
              (this.polarColumnYModeProperty =
                null !== (l = null == t ? void 0 : t.columnYMode) &&
                void 0 !== l
                  ? l
                  : this.polarColumnYModeProperty),
              (this.dataPointWidthModeProperty =
                null !== (h = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== h
                  ? h
                  : this.dataPointWidthModeProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new y.PolarColumnSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new c.PointMarkerDrawingProvider(e, this)
              );
          }
          get columnXMode() {
            return this.polarColumnXModeProperty;
          }
          set columnXMode(e) {
            this.polarColumnXModeProperty !== e &&
              ((this.polarColumnXModeProperty = e),
              this.notifyPropertyChanged("POLAR_COLUMN_MODE"));
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          get columnYMode() {
            return o.EColumnYMode.TopBottom;
          }
          set columnYMode(e) {
            throw Error(
              "columnYMode is not supported for PolarColumnRenderableSeries"
            );
          }
          get defaultY1() {
            return 0;
          }
          set defaultY1(e) {}
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.DATA_POINT_WIDTH);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(u.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          onAttachToParentCollection(e, t, r) {
            if (this.parentCollection)
              throw new Error(
                "Invalid operation in StackedMountainRenderableSeries.onAttachToParentCollection, this series has been already attached to collection. Please detach it from the collection before attaching to another"
              );
            (this.parentCollection = e),
              (this.getParentSurfaceFn = t),
              (this.notifyParentPropertyChangedFn = r);
          }
          onAttach(e) {
            if (this.invalidateParentCallback)
              throw new Error(
                "Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            (this.invalidateParentCallback = e.invalidateElement),
              this.drawingProviders.forEach((e) => e.onAttachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(
                e.invalidateElement
              );
          }
          onDetach() {
            (this.invalidateParentCallback = void 0),
              this.drawingProviders.forEach((e) => e.onDetachSeries()),
              this.rolloverModifierProps.setInvalidateParentCallback(void 0);
          }
          draw(e, t) {
            var r;
            (this.currentRenderPassData = t),
              null === (r = this.hitTestProvider) ||
                void 0 === r ||
                r.update(t);
            try {
              e.pushShaderEffect(this.effect),
                this.drawingProviders.forEach((r) => r.draw(e, t));
            } finally {
              e.popShaderEffect();
            }
          }
          onDpiChanged(e) {
            super.onDpiChanged(e),
              this.notifyPropertyChanged(u.PROPERTY.STROKE);
          }
          get fill() {
            return (0, l.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            this.fillProperty !== e &&
              ((this.fillProperty = e),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(u.PROPERTY.FILL)
              ),
              this.drawingProviders.forEach((e) =>
                e.onSeriesPropertyChange(u.PROPERTY.FILL_Y1)
              ),
              this.notifyPropertyChanged(u.PROPERTY.FILL));
          }
          set fillY1(e) {
            throw new Error(
              "Setting fillY1 property is not supported on StackedMountainRenderableSeries"
            );
          }
          getCurrentRenderPassData() {
            return this.currentRenderPassData;
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                columnXMode: this.columnXMode,
                columnYMode: this.columnYMode,
                dataPointWidthMode: this.dataPointWidthMode,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
                fill: this.fill,
                fillLinearGradient: this.fillLinearGradient,
              };
            return Object.assign(t.options, r), t;
          }
          delete() {
            this.drawingProviders.forEach((e) => e.delete()),
              (this.drawingProviders = []),
              (this.effect = (0, i.deleteSafe)(this.effect)),
              super.delete();
          }
          toPointSeries(e) {
            return new n.XyPointSeriesWrapped(this.dataSeries);
          }
          hasStrokePaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideStrokeArgb);
          }
          hasFillPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overrideFillArgb);
          }
          hasPointMarkerPaletteProvider() {
            const e = this.paletteProvider;
            return void 0 !== (null == e ? void 0 : e.overridePointMarkerArgb);
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(l.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = l.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          getXRange() {
            const e = this.dataSeries.xRange,
              t = this.dataSeries.count();
            return (0, p.getXRange)(e, t, this.dataPointWidth);
          }
          getDataPointWidth(e, t) {
            const r = this.dataSeries.getNativeXValues(),
              o = e.viewportDimension,
              a = e.isCategoryCoordinateCalculator;
            if (t < 0 || t > 1)
              throw new Error(
                "WidthFraction should be between 0.0 and 1.0 inclusive"
              );
            const s = r.size();
            let n = o;
            const l = s;
            if (l > 1) {
              let t = Number.NEGATIVE_INFINITY,
                o = Number.MAX_VALUE;
              if (a) (t = e.getCoordinate(s - 1)), (o = e.getCoordinate(0));
              else {
                let a;
                try {
                  (a = this.webAssemblyContext.NumberUtil.MinMax(r)),
                    (o = a.minD),
                    (t = a.maxD);
                } finally {
                  (0, i.deleteSafe)(a);
                }
                (t = e.getCoordinate(t)), (o = e.getCoordinate(o));
              }
              n = Math.abs(t - o) / (l - 1);
            } else 1 === l && (n = Math.min(n, 2 * e.getCoordinate(r.get(0))));
            return n * t;
          }
          newHitTestProvider() {
            return new g.RectangleSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.PolarStackedColumnRenderableSeries = f;
      },
      68584: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarStackedMountainCollection = void 0);
        const i = r(5337),
          o = r(71719);
        class a extends o.StackedMountainCollection {
          constructor() {
            super(...arguments),
              (this.type = i.ESeriesType.PolarStackedMountainCollection),
              (this.isPolar = !0);
          }
        }
        t.PolarStackedMountainCollection = a;
      },
      38595: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarStackedMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(84392),
          a = r(20782),
          s = r(20977),
          n = r(1391),
          l = r(90262),
          d = r(16556),
          h = r(37874);
        class u extends n.StackedMountainRenderableSeries {
          constructor(e, t) {
            var r, o, s;
            super(e, t),
              (this.isPolar = !0),
              (this.type = i.ESeriesType.PolarStackedMountainSeries),
              (this.lineType = a.ELineType.Normal),
              (this.curveSmoothnessProperty = 0),
              (this.curveSmoothnessProperty =
                null !== (r = null == t ? void 0 : t.curveSmoothness) &&
                void 0 !== r
                  ? r
                  : this.curveSmoothnessProperty),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (s = this.paletteProvider) ||
                  void 0 === s ||
                  s.onAttached(this));
          }
          get isDigitalLine() {
            return !1;
          }
          get curveSmoothness() {
            return this.curveSmoothnessProperty;
          }
          set curveSmoothness(e) {
            this.curveSmoothnessProperty !== e &&
              ((this.curveSmoothnessProperty = e),
              this.notifyPropertyChanged("CURVE_SMOOTHNESS"));
          }
          get fillY1() {
            return (0, o.stripAutoColor)(this.fillY1Property);
          }
          set fillY1(e) {
            (this.fillY1Property = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL_Y1);
          }
          get fillLinearGradient1() {
            return this.fillLinearGradient1Property;
          }
          set fillLinear1Gradient(e) {
            e !== this.fillLinearGradient1Property &&
              ((this.fillLinearGradient1Property = e),
              this.notifyPropertyChanged(s.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { curveSmoothness: this.curveSmoothness };
            return Object.assign(t.options, r), t;
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new l.PolarBandSeriesDrawingProvider(
                e,
                this,
                (e) => e.y1Values,
                (e) => e.yValues
              )
            ),
              this.drawingProviders.push(
                new d.PolarLineSeriesDrawingProvider(e, this, (e) => e.y1Values)
              ),
              this.drawingProviders.push(
                new h.PolarPointMarkerDrawingProvider(
                  e,
                  this,
                  (e) => e.y1Values
                )
              );
          }
        }
        t.PolarStackedMountainRenderableSeries = u;
      },
      10947: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarUniformHeatmapRenderableSeries = void 0);
        const i = r(84745),
          o = r(5337),
          a = r(70033),
          s = r(192),
          n = r(40997);
        class l extends a.UniformHeatmapRenderableSeries {
          constructor(e, t) {
            var r;
            const i =
              null !== (r = t.dataLabelProvider) && void 0 !== r
                ? r
                : new s.PolarHeatMapDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  );
            super(
              e,
              Object.assign(Object.assign({}, t), { dataLabelProvider: i })
            ),
              (this.isPolar = !0),
              (this.type = o.ESeriesType.PolarUniformHeatmapSeries);
          }
          addDrawingProviders(e, t) {
            i.IS_TEST_ENV ||
              this.drawingProviders.push(
                new n.PolarHeatmapDrawingProvider(e, this)
              );
          }
        }
        t.PolarUniformHeatmapRenderableSeries = l;
      },
      69773: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarXyScatterRenderableSeries = void 0);
        const i = r(98140),
          o = r(5337),
          a = r(61566),
          s = r(52954),
          n = r(19963),
          l = r(37874),
          d = r(14082);
        class h extends s.XyScatterRenderableSeries {
          constructor(e, t) {
            var r, i, s;
            super(
              e,
              Object.assign(Object.assign({}, t), {
                dataLabelProvider:
                  null !== (r = null == t ? void 0 : t.dataLabelProvider) &&
                  void 0 !== r
                    ? r
                    : new n.PolarDataLabelProvider(
                        null == t ? void 0 : t.dataLabels
                      ),
              })
            ),
              (this.isPolar = !0),
              (this.type = o.ESeriesType.PolarScatterSeries),
              (this.clipToTotalAngle = !1),
              (null === (i = this.paletteProvider) || void 0 === i
                ? void 0
                : i.onAttached) &&
                (null === (s = this.paletteProvider) ||
                  void 0 === s ||
                  s.onAttached(this)),
              (this.renderDataTransformProperty =
                new a.PolarInterpolateLineRenderDataTransform(
                  this,
                  this.webAssemblyContext,
                  []
                ));
          }
          getIndicesRange(e, t) {
            return this.clipToTotalAngle
              ? super.getIndicesRange(e, t)
              : new i.NumberRange(0, this.dataSeries.count() - 1);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new l.PolarPointMarkerDrawingProvider(e, this)
            );
          }
          newHitTestProvider() {
            return new d.PolarDataPointHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.PolarXyScatterRenderableSeries = h;
      },
      4450: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OhlcBaseRenderDataTransform =
            t.XyyBaseRenderDataTransform =
            t.XyBaseRenderDataTransform =
            t.BaseRenderDataTransform =
              void 0);
        const i = r(55023),
          o = r(56744),
          a = r(23866),
          s = r(98140),
          n = r(65052),
          l = r(58564),
          d = r(14023),
          h = r(48570);
        class u extends i.DeletableEntity {
          constructor(e, t, r) {
            super(),
              (this.requiresTransform = !0),
              (this.useForYRange = !1),
              (this.parentSeries = e),
              (this.wasmContext = t),
              this.parentSeries.dataSeries,
              (this.pointSeries = this.createPointSeries()),
              (this.drawingProviders = null != r ? r : []);
          }
          runTransform(e) {
            if (
              this.requiresTransform ||
              (e.indexRange && !e.indexRange.equals(this.lastIndexRange)) ||
              (e.resamplingHash && e.resamplingHash !== this.lastResamplingHash)
            ) {
              a.Guard.notNull(e, "renderPassData"),
                a.Guard.notNull(e.pointSeries, "renderPassData.pointSeries");
              const t = this.runTransformInternal(e);
              return (
                t === this.pointSeries && (this.requiresTransform = !1),
                (this.lastIndexRange = e.indexRange),
                (this.lastResamplingHash = e.resamplingHash),
                this.makeRenderPassData(e, t)
              );
            }
            return this.makeRenderPassData(e, this.pointSeries);
          }
          onDataChange(e) {
            this.requiresTransform = !0;
          }
          delete() {
            (this.pointSeries = (0, o.deleteSafe)(this.pointSeries)),
              (this.wasmContext = void 0);
          }
          makeRenderPassData(e, t) {
            const r = new s.NumberRange(0, t.xValues.size() - 1);
            return (
              (t.xRange = e.pointSeries.xRange),
              (t.fifoStartIndex = e.pointSeries.fifoStartIndex),
              new h.RenderPassData(
                r,
                e.getxCoordinateCalculator,
                e.getyCoordinateCalculator,
                e.isVerticalChart,
                t,
                e.resamplingHash
              )
            );
          }
        }
        (t.BaseRenderDataTransform = u),
          (t.XyBaseRenderDataTransform = class extends u {
            createPointSeries() {
              return new l.XyPointSeriesResampled(
                this.wasmContext,
                new s.NumberRange(0, 0)
              );
            }
            runTransformInternal(e) {
              throw new Error("runTransformInternal not implemented.");
            }
          }),
          (t.XyyBaseRenderDataTransform = class extends u {
            createPointSeries() {
              return new d.XyyPointSeriesResampled(
                this.wasmContext,
                new s.NumberRange(0, 0)
              );
            }
            runTransformInternal(e) {
              throw new Error("runTransformInternal not implemented.");
            }
          }),
          (t.OhlcBaseRenderDataTransform = class extends u {
            createPointSeries() {
              return new n.OhlcPointSeriesResampled(
                this.wasmContext,
                new s.NumberRange(0, 0)
              );
            }
            runTransformInternal(e) {
              throw new Error("runTransformInternal not implemented.");
            }
          });
      },
      89136: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SmoothStackedRenderDataTransform =
            t.XyyBezierRenderDataTransform =
            t.BezierRenderDataTransform =
            t.bezierTransform =
              void 0);
        const i = r(10276),
          o = r(98140),
          a = r(58564),
          s = r(14023),
          n = r(4450);
        t.bezierTransform = (e, t, r, o, a, s, n, l, d, h) => {
          var u, c;
          e.clear(), t.clear(), r.clear();
          const p = (e, t, r, i, o, a, s) => {
              if (i != i) return { xc: e, yc: t };
              if (e === r && t === i) return { xc: e, yc: t };
              let n,
                l,
                d = Number.MAX_VALUE;
              e !== r && (d = (t - i) / (e - r));
              const h = (o - e) * s;
              return (
                (n = e + h),
                (l = t + d * h),
                (l = Math.max(Math.min(l, Math.max(t, a)), Math.min(t, a))),
                { xc: n, yc: l }
              );
            },
            g = (e, t, r, i, o) => {
              const a = 1 - o;
              return (
                Math.pow(a, 3) * e +
                3 * a * a * o * t +
                3 * a * o * o * r +
                Math.pow(o, 3) * i
              );
            },
            y = (e) => ({ x: o.get(e), y: a.get(e) }),
            f = (e) => {
              const t = null == h ? void 0 : h.get(b);
              return void 0 === t || t != t ? 1 / 0 : t;
            };
          let v,
            m = y(Math.max(s - 1, 0)),
            S = y(s),
            P = y(s + 1),
            C = y(Math.min(s + 2, o.size() - 1)),
            b = 0;
          for (let a = s; a < n; a++) {
            e.push_back(S.x),
              r.push_back(b),
              t.push_back(Math.min(S.y, f())),
              b++;
            const n = p(
              S.x,
              S.y,
              null !== (u = null == v ? void 0 : v.xc) && void 0 !== u
                ? u
                : m.x,
              null !== (c = null == v ? void 0 : v.yc) && void 0 !== c
                ? c
                : m.y,
              P.x,
              P.y,
              d
            );
            v = p(P.x, P.y, C.x, C.y, S.x, S.y, d);
            for (let o = 1; o < l; o++) {
              const a = i.easing.inOutCubic(o / l),
                s = g(S.x, n.xc, v.xc, P.x, a),
                d = g(S.y, n.yc, v.yc, P.y, a);
              e.push_back(s),
                t.push_back(Math.min(d, f())),
                r.push_back(b),
                b++;
            }
            a > s && (m = S),
              (S = P),
              (P = C),
              a < o.size() - 3 && (C = y(a + 3));
          }
          e.push_back(P.x), t.push_back(Math.min(P.y, f())), r.push_back(b);
        };
        class l extends n.BaseRenderDataTransform {
          constructor(e, t, r, i) {
            var o, a;
            super(e, t, r),
              (this.interpolationPointsProperty = 20),
              (this.curvatureProperty = 0.5),
              (this.interpolationPointsProperty =
                null !== (o = null == i ? void 0 : i.interpolationPoints) &&
                void 0 !== o
                  ? o
                  : this.interpolationPoints),
              (this.curvatureProperty =
                null !== (a = null == i ? void 0 : i.curvature) && void 0 !== a
                  ? a
                  : this.curvature);
          }
          get interpolationPoints() {
            return this.interpolationPointsProperty;
          }
          set interpolationPoints(e) {
            var t, r;
            this.interpolationPointsProperty !== e &&
              ((this.interpolationPointsProperty = e),
              (this.requiresTransform = !0),
              (null === (t = this.parentSeries) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                (null === (r = this.parentSeries) ||
                  void 0 === r ||
                  r.invalidateParentCallback()));
          }
          get curvature() {
            return this.curvatureProperty;
          }
          set curvature(e) {
            var t, r;
            this.curvatureProperty !== e &&
              ((this.curvatureProperty = e),
              (this.requiresTransform = !0),
              (null === (t = this.parentSeries) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                (null === (r = this.parentSeries) ||
                  void 0 === r ||
                  r.invalidateParentCallback()));
          }
          createPointSeries() {
            return new a.XyPointSeriesResampled(
              this.wasmContext,
              new o.NumberRange(0, 0)
            );
          }
          runTransformInternal(e) {
            var r;
            let {
              xValues: i,
              yValues: o,
              indexes: a,
              resampled: s,
            } = e.pointSeries;
            const { xValues: n, yValues: l, indexes: d } = this.pointSeries,
              h = s ? 0 : e.indexRange.min,
              u = s
                ? i.size() - 1
                : null === (r = e.indexRange) || void 0 === r
                ? void 0
                : r.max;
            return 0 == i.size()
              ? e.pointSeries
              : ((0, t.bezierTransform)(
                  n,
                  l,
                  d,
                  i,
                  o,
                  h,
                  u,
                  this.interpolationPoints,
                  this.curvature
                ),
                this.pointSeries);
          }
        }
        t.BezierRenderDataTransform = l;
        class d extends n.BaseRenderDataTransform {
          constructor(e, t, r, i) {
            var o, a;
            super(e, t, r),
              (this.interpolationPointsProperty = 20),
              (this.curvatureProperty = 0.5),
              (this.forceYGreaterThanY1 = !1),
              (this.interpolationPointsProperty =
                null !== (o = null == i ? void 0 : i.interpolationPoints) &&
                void 0 !== o
                  ? o
                  : this.interpolationPoints),
              (this.curvatureProperty =
                null !== (a = null == i ? void 0 : i.curvature) && void 0 !== a
                  ? a
                  : this.curvature);
          }
          get interpolationPoints() {
            return this.interpolationPointsProperty;
          }
          set interpolationPoints(e) {
            var t, r;
            this.interpolationPointsProperty !== e &&
              ((this.interpolationPointsProperty = e),
              (this.requiresTransform = !0),
              (null === (t = this.parentSeries) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                (null === (r = this.parentSeries) ||
                  void 0 === r ||
                  r.invalidateParentCallback()));
          }
          get curvature() {
            return this.curvatureProperty;
          }
          set curvature(e) {
            var t, r;
            this.curvatureProperty !== e &&
              ((this.curvatureProperty = e),
              (this.requiresTransform = !0),
              (null === (t = this.parentSeries) || void 0 === t
                ? void 0
                : t.invalidateParentCallback) &&
                (null === (r = this.parentSeries) ||
                  void 0 === r ||
                  r.invalidateParentCallback()));
          }
          createPointSeries() {
            return new s.XyyPointSeriesResampled(
              this.wasmContext,
              new o.NumberRange(0, 0)
            );
          }
          runTransformInternal(e) {
            var r;
            let {
              xValues: i,
              yValues: o,
              y1Values: a,
              indexes: s,
              resampled: n,
            } = e.pointSeries;
            const {
                xValues: l,
                yValues: d,
                y1Values: h,
                indexes: u,
              } = this.pointSeries,
              c = n ? 0 : e.indexRange.min,
              p = n
                ? i.size() - 1
                : null === (r = e.indexRange) || void 0 === r
                ? void 0
                : r.max;
            return 0 == i.size()
              ? e.pointSeries
              : ((0, t.bezierTransform)(
                  l,
                  h,
                  u,
                  i,
                  a,
                  c,
                  p,
                  this.interpolationPoints,
                  this.curvature
                ),
                (0, t.bezierTransform)(
                  l,
                  d,
                  u,
                  i,
                  o,
                  c,
                  p,
                  this.interpolationPoints,
                  this.curvature,
                  this.forceYGreaterThanY1 ? h : void 0
                ),
                this.pointSeries);
          }
        }
        (t.XyyBezierRenderDataTransform = d),
          (t.SmoothStackedRenderDataTransform = class extends d {
            constructor() {
              super(...arguments), (this.forceYGreaterThanY1 = !0);
            }
          });
      },
      87836: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarInterpolateBandRenderDataTransform = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(16185),
          s = r(14023),
          n = r(4450);
        class l extends n.BaseRenderDataTransform {
          constructor() {
            super(...arguments), (this.pointsForWholeCircle = 360);
          }
          runTransform(e) {
            var t;
            const r =
                null !== (t = this.parentSeries.interpolateLine) &&
                void 0 !== t &&
                t,
              i = this.parentSeries.drawNaNAs === a.ELineDrawMode.PolyLine,
              o = this.parentSeries.xAxis.visibleRange.diff;
            return (
              (r === this.prevInterpolateLine &&
                this.prevDiff === o &&
                i === this.prevCloseNanGaps) ||
                ((this.requiresTransform = !0),
                (this.prevInterpolateLine = r),
                (this.prevDiff = o),
                (this.prevCloseNanGaps = i)),
              super.runTransform(e)
            );
          }
          createPointSeries() {
            const e = new s.XyyPointSeriesResampled(
              this.wasmContext,
              new o.NumberRange(0, 0)
            );
            return (
              (this.inParams =
                new this.wasmContext.SCRTPolarInterpolationParams()),
              (this.outParams =
                new this.wasmContext.SCRTPolarInterpolationParams()),
              this.outParams.SetIndexes(e.indexes),
              this.outParams.SetX(e.xValues),
              this.outParams.SetY(e.yValues),
              this.outParams.SetY1(e.y1Values),
              e
            );
          }
          runTransformInternal(e) {
            var t;
            return null !== (t = this.parentSeries.interpolateLine) &&
              void 0 !== t &&
              t
              ? (this.inParams.Reset(),
                this.inParams.SetIndexes(e.pointSeries.indexes),
                this.inParams.SetX(e.pointSeries.xValues),
                this.inParams.SetY(e.pointSeries.yValues),
                this.inParams.SetY1(e.pointSeries.y1Values),
                this.wasmContext.SCRTInterpolatePolarBand(
                  this.inParams,
                  this.outParams,
                  this.parentSeries.yAxis.getCurrentCoordinateCalculator()
                    .nativeCalculator,
                  this.parentSeries.xAxis.visibleRange.diff,
                  this.pointsForWholeCircle,
                  this.parentSeries.drawNaNAs === a.ELineDrawMode.PolyLine
                ),
                this.pointSeries)
              : e.pointSeries;
          }
          delete() {
            (this.inParams = (0, i.deleteSafe)(this.inParams)),
              (this.outParams = (0, i.deleteSafe)(this.outParams)),
              super.delete();
          }
        }
        t.PolarInterpolateBandRenderDataTransform = l;
      },
      61566: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PolarInterpolateLineRenderDataTransform = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(16185),
          s = r(58564),
          n = r(4450);
        class l extends n.BaseRenderDataTransform {
          constructor() {
            super(...arguments), (this.pointsForWholeCircle = 360);
          }
          runTransform(e) {
            var t;
            const r =
                null !== (t = this.parentSeries.interpolateLine) &&
                void 0 !== t &&
                t,
              i = this.parentSeries.drawNaNAs === a.ELineDrawMode.PolyLine,
              o = this.parentSeries.xAxis.visibleRange.diff;
            return (
              (r === this.previnterpolateLine &&
                this.prevDiff === o &&
                i === this.prevCloseNanGaps) ||
                ((this.requiresTransform = !0),
                (this.previnterpolateLine = r),
                (this.prevDiff = o),
                (this.prevCloseNanGaps = i)),
              super.runTransform(e)
            );
          }
          createPointSeries() {
            const e = new s.XyPointSeriesResampled(
              this.wasmContext,
              new o.NumberRange(0, 0)
            );
            return (
              (this.inParams =
                new this.wasmContext.SCRTPolarInterpolationParams()),
              (this.outParams =
                new this.wasmContext.SCRTPolarInterpolationParams()),
              this.outParams.SetIndexes(e.indexes),
              this.outParams.SetX(e.xValues),
              this.outParams.SetY(e.yValues),
              e
            );
          }
          runTransformInternal(e) {
            var t;
            if (
              null === (t = this.parentSeries.interpolateLine) ||
              void 0 === t ||
              !t
            )
              return e.pointSeries;
            this.inParams.Reset();
            const r = e.isVerticalChart
                ? e.pointSeries.xValues
                : e.pointSeries.yValues,
              i = e.isVerticalChart
                ? e.pointSeries.yValues
                : e.pointSeries.xValues;
            this.inParams.SetIndexes(e.pointSeries.indexes),
              this.inParams.SetX(i),
              this.inParams.SetY(r);
            const o = e.isVerticalChart
                ? this.parentSeries.xAxis
                : this.parentSeries.yAxis,
              s = e.isVerticalChart
                ? this.parentSeries.yAxis
                : this.parentSeries.xAxis;
            return (
              this.wasmContext.SCRTInterpolatePolarLine(
                this.inParams,
                this.outParams,
                o.getCurrentCoordinateCalculator().nativeCalculator,
                s.visibleRange.diff,
                this.pointsForWholeCircle,
                this.parentSeries.drawNaNAs === a.ELineDrawMode.PolyLine
              ),
              this.pointSeries
            );
          }
          delete() {
            (this.inParams = (0, i.deleteSafe)(this.inParams)),
              (this.outParams = (0, i.deleteSafe)(this.outParams)),
              super.delete();
          }
        }
        t.PolarInterpolateLineRenderDataTransform = l;
      },
      95103: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SplineRenderDataTransform = void 0);
        const i = r(98140),
          o = r(58564),
          a = r(4450);
        class s extends a.BaseRenderDataTransform {
          constructor() {
            super(...arguments),
              (this.interpolationPoints = 10),
              (this.warnOnSplineFailure = !0),
              (this.useForYRange = !0);
          }
          createPointSeries() {
            return new o.XyPointSeriesResampled(
              this.wasmContext,
              new i.NumberRange(0, 0)
            );
          }
          runTransformInternal(e) {
            const t = this.parentSeries.xAxis.isCategoryAxis
                ? e.pointSeries.indexes
                : e.pointSeries.xValues,
              r = t.size();
            if (0 == r || 1 === r) return e.pointSeries;
            const i = e.pointSeries.yValues,
              o =
                this.parentSeries.dataSeries.dataDistributionCalculator
                  .containsNaN;
            return (
              this.wasmContext.SCRTSplineHelperCubicSpline(
                t,
                i,
                this.pointSeries.xValues,
                this.pointSeries.yValues,
                r,
                this.interpolationPoints,
                this.parentSeries.dataSeries.dataDistributionCalculator
                  .containsNaN
              ),
              !o && isNaN(this.pointSeries.yValues.get(0))
                ? (this.warnOnSplineFailure &&
                    console.error(
                      "Could not calculate spline values.  X data may contain duplicates.  Falling back to original values.\n    To disable this warning set warnOnSplineFailure = false."
                    ),
                  e.pointSeries)
                : this.pointSeries
            );
          }
        }
        t.SplineRenderDataTransform = s;
      },
      69133: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyySplineRenderDataTransform = void 0);
        const i = r(98140),
          o = r(14023),
          a = r(4450);
        class s extends a.BaseRenderDataTransform {
          constructor() {
            super(...arguments),
              (this.interpolationPoints = 10),
              (this.warnOnSplineFailure = !0),
              (this.useForYRange = !0);
          }
          createPointSeries() {
            return new o.XyyPointSeriesResampled(
              this.wasmContext,
              new i.NumberRange(0, 0)
            );
          }
          runTransformInternal(e) {
            const t = this.parentSeries.xAxis.isCategoryAxis
                ? e.pointSeries.indexes
                : e.pointSeries.xValues,
              r = e.pointSeries.yValues,
              i = e.pointSeries.y1Values,
              o = t.size();
            if (0 == o) return e.pointSeries;
            const a =
              this.parentSeries.dataSeries.dataDistributionCalculator
                .containsNaN;
            return (
              this.wasmContext.SCRTSplineHelperCubicSpline(
                t,
                r,
                this.pointSeries.xValues,
                this.pointSeries.yValues,
                o,
                this.interpolationPoints,
                a
              ),
              !a && isNaN(this.pointSeries.yValues.get(0))
                ? (this.warnOnSplineFailure &&
                    console.warn(
                      "Could not calculate spline values.  X data may contain duplicates.  Falling back to original values.\n    To disable this warning set warnOnSplineFailure = false."
                    ),
                  e.pointSeries)
                : (this.wasmContext.SCRTSplineHelperCubicSpline(
                    t,
                    i,
                    this.pointSeries.xValues,
                    this.pointSeries.y1Values,
                    o,
                    this.interpolationPoints,
                    a
                  ),
                  this.pointSeries)
            );
          }
        }
        t.XyySplineRenderDataTransform = s;
      },
      54962: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RolloverModifierRenderableSeriesProps = void 0);
        const i = r(56744),
          o = r(14184),
          a = r(70142);
        t.RolloverModifierRenderableSeriesProps = class {
          constructor(e, t = !1) {
            (this.tooltipLegendOffsetX = 20),
              (this.tooltipLegendOffsetY = 20),
              (this.showsRolloverProperty = !0),
              (this.tooltipTextColorProperty =
                o.SciChartSurfaceBase.DEFAULT_THEME.textAnnotationForeground),
              (this.renderableSeries = e),
              (this.isY1 = t);
          }
          static copy(e, t) {
            (t.markerColorProperty = e.markerColor),
              (t.showsRolloverProperty = e.showRollover),
              (t.tooltipColorProperty = e.tooltipColor),
              (t.tooltipDataTemplateProperty = e.tooltipDataTemplate),
              (t.tooltipLabelX = e.tooltipLabelX),
              (t.tooltipLabelY = e.tooltipLabelY),
              (t.tooltipLegendOffsetX = e.tooltipLegendOffsetX),
              (t.tooltipLegendOffsetY = e.tooltipLegendOffsetY),
              (t.tooltipTemplate = e.tooltipTemplate),
              (t.tooltipTextColorProperty = e.tooltipTextColorProperty),
              (t.tooltipTitleProperty = e.tooltipTitle),
              (t.shadowColorProperty = e.shadowColorProperty),
              (t.invalidateParentCallback = e.invalidateParentCallback);
          }
          setInvalidateParentCallback(e) {
            this.invalidateParentCallback = e;
          }
          get showRollover() {
            return this.showsRolloverProperty;
          }
          set showRollover(e) {
            (this.showsRolloverProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.SHOWS_ROLLOVER);
          }
          get tooltipColor() {
            return this.tooltipColorProperty
              ? this.tooltipColorProperty
              : this.getRenderableSeriesStroke()
              ? this.getRenderableSeriesStroke()
              : o.SciChartSurfaceBase.DEFAULT_THEME.textAnnotationBackground;
          }
          set tooltipColor(e) {
            (this.tooltipColorProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.TOOLTIP_COLOR);
          }
          get tooltipTextColor() {
            return this.tooltipTextColorProperty;
          }
          set tooltipTextColor(e) {
            (this.tooltipTextColorProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.TOOLTIP_TEXT_COLOR);
          }
          get tooltipTitle() {
            return this.tooltipTitleProperty;
          }
          set tooltipTitle(e) {
            (this.tooltipTitleProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.TOOLTIP_TITLE);
          }
          get markerColor() {
            return this.markerColorProperty
              ? this.markerColorProperty
              : this.getRenderableSeriesStroke()
              ? this.getRenderableSeriesStroke()
              : o.SciChartSurfaceBase.DEFAULT_THEME.textAnnotationBackground;
          }
          set markerColor(e) {
            (this.markerColorProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.MARKER_COLOR);
          }
          get shadowColor() {
            return this.shadowColorProperty;
          }
          set shadowColor(e) {
            (this.shadowColorProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.TOOLTIP_SHADOW_COLOR);
          }
          get tooltipDataTemplate() {
            return this.tooltipDataTemplateProperty;
          }
          set tooltipDataTemplate(e) {
            (this.tooltipDataTemplateProperty = e),
              this.notifyPropertyChanged(a.PROPERTY.TOOLTIP_DATA_TEMPLATE);
          }
          get tooltipLegendTemplate() {
            return this.tooltipLegendTemplateProperty;
          }
          set tooltipLegendTemplate(e) {
            console.warn(
              "tooltipLegendTemplate property on the RolloverModifierRenderableSeriesProps will be removed in version 2.0, please set tooltipLegendTemplate on the RolloverModifier instead"
            ),
              (this.tooltipLegendTemplateProperty = e);
          }
          delete() {
            var e, t;
            (this.rolloverModifier = void 0),
              (null === (e = this.marker) || void 0 === e
                ? void 0
                : e.isDeleted) ||
                (this.marker = (0, i.deleteSafe)(this.marker)),
              (this.marker = void 0),
              (null === (t = this.tooltip) || void 0 === t
                ? void 0
                : t.isDeleted) ||
                (this.tooltip = (0, i.deleteSafe)(this.tooltip)),
              (this.tooltip = void 0);
          }
          notifyPropertyChanged(e) {
            this.invalidateParentCallback && this.invalidateParentCallback();
          }
          getRenderableSeriesStroke() {
            return this.isY1
              ? this.renderableSeries.strokeY1Property
              : this.renderableSeries.strokeProperty;
          }
        };
      },
      70142: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).MARKER_COLOR = "MARKER_COLOR"),
          (r.SHOWS_ROLLOVER = "SHOWS_ROLLOVER"),
          (r.TOOLTIP_COLOR = "TOOLTIP_COLOR"),
          (r.TOOLTIP_DATA_TEMPLATE = "TOOLTIP_DATA_TEMPLATE"),
          (r.TOOLTIP_TEXT_COLOR = "TOOLTIP_TEXT_COLOR"),
          (r.TOOLTIP_TITLE = "TOOLTIP_TITLE"),
          (r.TOOLTIP_SHADOW_COLOR = "TOOLTIP_SHADOW_COLOR");
      },
      9150: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SelectionChangedArgs = void 0),
          (t.SelectionChangedArgs = class {
            constructor(e, t, r, i) {
              (this.source = e),
                (this.selectedSeries = t),
                (this.allSeries = r),
                (this.hitTestInfo = i);
            }
          });
      },
      57318: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesHoveredArgs = void 0),
          (t.SeriesHoveredArgs = class {
            constructor(e, t) {
              (this.sourceSeries = e), (this.hovered = t);
            }
          });
      },
      29593: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesSelectedArgs = void 0),
          (t.SeriesSelectedArgs = class {
            constructor(e, t) {
              (this.sourceSeries = e), (this.isSelected = t);
            }
          });
      },
      72469: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesVisibleChangedArgs = void 0),
          (t.SeriesVisibleChangedArgs = class {
            constructor(e, t) {
              (this.sourceSeries = e), (this.isVisible = t);
            }
          });
      },
      93545: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ShaderEffect = void 0);
        const i = r(84745),
          o = r(56744),
          a = r(3214),
          s = r(23866),
          n = r(75772),
          l = r(50605),
          d = r(48008),
          h = r(11727),
          u = r(20977),
          c = r(98353),
          p = r(55023);
        class g extends p.DeletableEntity {
          constructor(e, t, r) {
            super(),
              s.Guard.notNull(e, "webAssemblyContext"),
              i.IS_TEST_ENV || s.Guard.notNull(t, "seriesEffect"),
              (this.webAssemblyContext = e),
              (this.propertyChanged = new a.EventHandler()),
              (this.nativeEffect = t),
              (this.intensity = (null == r ? void 0 : r.intensity) || 1),
              (this.range = (null == r ? void 0 : r.range) || 0),
              (this.offset =
                (null == r ? void 0 : r.offset) || new n.Point(0, 0)),
              (this.color = (null == r ? void 0 : r.color) || "#444444");
          }
          delete() {
            (this.nativeEffect = (0, o.deleteSafe)(this.nativeEffect)),
              (this.webAssemblyContext = void 0);
          }
          getNativeEffect() {
            return this.nativeEffect;
          }
          get intensity() {
            return this.intensityProperty;
          }
          set intensity(e) {
            (this.intensityProperty = e),
              this.nativeEffect.SetIntensity(e),
              this.notifyPropertyChanged(u.PROPERTY.INTENSITY);
          }
          get offset() {
            return this.offsetProperty;
          }
          set offset(e) {
            s.Guard.notNull(e, "offset"), (this.offsetProperty = e);
            const t = new this.webAssemblyContext.TSRVector2(e.x, e.y);
            this.nativeEffect.SetOffset(t),
              t.delete(),
              this.notifyPropertyChanged(u.PROPERTY.OFFSET);
          }
          get color() {
            return this.colorProperty;
          }
          set color(e) {
            this.colorProperty = e;
            const t = (0, d.parseColorToTArgb)(e),
              r = (0, c.getVector4)(this.webAssemblyContext, 0, 0, 0, 0);
            (0, h.updateTsrVector4)(t, r),
              this.nativeEffect.SetColor(r),
              this.notifyPropertyChanged(u.PROPERTY.COLOR);
          }
          get range() {
            return this.rangeProperty;
          }
          set range(e) {
            (this.rangeProperty = e),
              this.nativeEffect.SetRange(e),
              this.notifyPropertyChanged(u.PROPERTY.RANGE);
          }
          notifyPropertyChanged(e) {
            var t;
            null === (t = this.propertyChanged) ||
              void 0 === t ||
              t.raiseEvent(new l.PropertyChangedEventArgs(e));
          }
          toJSON() {
            const e = {
              color: this.color,
              intensity: this.intensity,
              offset: this.offset,
              range: this.range,
            };
            return { type: this.type, options: e };
          }
        }
        t.ShaderEffect = g;
      },
      68264: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ShadowEffect = void 0);
        const i = r(75772),
          o = r(75323),
          a = r(93545);
        class s extends a.ShaderEffect {
          constructor(e, t) {
            super(e, new e.SCRTShadowEffect(), {
              offset: (null == t ? void 0 : t.offset) || new i.Point(10, 10),
              range: (null == t ? void 0 : t.range) || 1,
              color: t
                ? `rgba(${(null == t ? void 0 : t.brightness) || 68},${
                    (null == t ? void 0 : t.brightness) || 68
                  },${(null == t ? void 0 : t.brightness) || 68},1)`
                : "#444444",
            }),
              (this.type = o.EShaderEffectType.Shadow);
          }
        }
        t.ShadowEffect = s;
      },
      56664: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SmoothStackedMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(89136),
          a = r(1391);
        class s extends a.StackedMountainRenderableSeries {
          constructor(e, t) {
            var r, a;
            super(e, t),
              (this.type = i.ESeriesType.SmoothStackedMountainSeries);
            const s = new o.SmoothStackedRenderDataTransform(this, e, []);
            (s.interpolationPoints =
              null !== (r = null == t ? void 0 : t.interpolationPoints) &&
              void 0 !== r
                ? r
                : s.interpolationPoints),
              (s.curvature =
                null !== (a = null == t ? void 0 : t.curvature) && void 0 !== a
                  ? a
                  : s.curvature),
              (this.renderDataTransform = s);
          }
        }
        t.SmoothStackedMountainRenderableSeries = s;
      },
      78146: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SplineBandRenderableSeries = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(5337),
          s = r(72934),
          n = r(24933),
          l = r(51885),
          d = r(2354),
          h = r(48570),
          u = r(20181),
          c = r(20977),
          p = r(69133);
        class g extends u.BaseBandRenderableSeries {
          constructor(e, t) {
            var r, i, o;
            super(e, t),
              (this.type = a.ESeriesType.SplineBandSeries),
              (this.isSplineProperty = !0),
              (this.interpolationPointsProperty = 10),
              (this.interpolationPointsProperty =
                null !== (r = null == t ? void 0 : t.interpolationPoints) &&
                void 0 !== r
                  ? r
                  : this.interpolationPointsProperty),
              (this.renderDataTransform = new p.XyySplineRenderDataTransform(
                this,
                e,
                [this.drawingProviders[0]]
              )),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (null === (i = this.paletteProvider) || void 0 === i
                ? void 0
                : i.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this));
          }
          get isSpline() {
            return this.isSplineProperty;
          }
          get interpolationPoints() {
            return this.interpolationPointsProperty;
          }
          set interpolationPoints(e) {
            (this.interpolationPointsProperty = e),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (this.renderDataTransform.requiresTransform = !0),
              this.notifyPropertyChanged(c.PROPERTY.INTERPOLATION_POINTS);
          }
          get xSplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.xValues;
          }
          get ySplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.yValues;
          }
          get y1SplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.y1Values;
          }
          get warnOnSplineFailure() {
            return this.renderDataTransform.warnOnSplineFailure;
          }
          set warnOnSplineFailure(e) {
            this.renderDataTransform.warnOnSplineFailure = e;
          }
          updateTransformedValues() {
            var e;
            if (this.dataSeries && this.parentSurface) {
              if (!this.currentRenderPassData) {
                const t = (
                  null === (e = this.resamplingParams) || void 0 === e
                    ? void 0
                    : e.resampleRequired
                )
                  ? this.pointSeries
                  : new d.XyyPointSeriesWrapped(this.dataSeries, void 0);
                this.currentRenderPassData = new h.RenderPassData(
                  this.getIndicesRange(
                    this.xAxis.visibleRange,
                    this.xAxis.isCategoryAxis
                  ),
                  this.xAxis.getCurrentCoordinateCalculator,
                  this.yAxis.getCurrentCoordinateCalculator,
                  this.xAxis.isVerticalChart,
                  t
                );
              }
              this.transformedRenderPassData =
                this.renderDataTransform.runTransform(
                  this.currentRenderPassData
                );
            }
          }
          updateSplineValues() {
            this.updateTransformedValues();
          }
          onSplineFailure() {}
          getYRange(e, t = !1) {
            var r;
            if (this.isRunningAnimation)
              return this.dataSeries.getWindowedYRange(
                e,
                !0,
                t,
                l.EDataSeriesValueType.Default,
                this.yRangeMode
              );
            this.updateSplineValues();
            const a = this.xSplineValues,
              d = this.ySplineValues,
              h = this.y1SplineValues;
            if (1 === a.size()) {
              const e = Math.min(d.get(0), h.get(0)),
                t = Math.max(d.get(0), h.get(0));
              return new o.NumberRange(e, t);
            }
            const u = t
                ? e
                : (0, n.getIndicesRange)(
                    this.webAssemblyContext,
                    a,
                    e,
                    null === (r = this.dataSeries) || void 0 === r
                      ? void 0
                      : r.dataDistributionCalculator.isSortedAscending
                  ),
              c = Math.max(Math.floor(u.min), 0),
              p = Math.min(Math.ceil(u.max), a.size() - 1);
            if (p < c) return;
            let g, y;
            try {
              if (
                ((g = this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                  d,
                  c,
                  p - c + 1
                )),
                !(0, s.isRealNumber)(g.minD) || !(0, s.isRealNumber)(g.maxD))
              )
                return;
              if (
                ((y = this.webAssemblyContext.NumberUtil.MinMaxWithIndex(
                  h,
                  c,
                  p - c + 1
                )),
                !(0, s.isRealNumber)(y.minD) || !(0, s.isRealNumber)(y.maxD))
              )
                return;
              return new o.NumberRange(
                Math.min(g.minD, y.minD),
                Math.max(g.maxD, y.maxD)
              );
            } finally {
              (0, i.deleteSafe)(g), (0, i.deleteSafe)(y);
            }
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { interpolationPoints: this.interpolationPoints };
            return Object.assign(t.options, r), t;
          }
        }
        t.SplineBandRenderableSeries = g;
      },
      32471: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SplineLineRenderableSeries = void 0);
        const i = r(5337),
          o = r(20782),
          a = r(20977),
          s = r(33802),
          n = r(95103);
        class l extends o.BaseLineRenderableSeries {
          constructor(e, t) {
            var r, o, a;
            super(e, t),
              (this.type = i.ESeriesType.SplineLineSeries),
              (this.isSplineProperty = !0),
              (this.interpolationPointsProperty = 10),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new s.LineSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (this.interpolationPointsProperty =
                null !== (r = null == t ? void 0 : t.interpolationPoints) &&
                void 0 !== r
                  ? r
                  : this.interpolationPointsProperty),
              (this.renderDataTransform = new n.SplineRenderDataTransform(
                this,
                e,
                [this.drawingProviders[0]]
              )),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (a = this.paletteProvider) ||
                  void 0 === a ||
                  a.onAttached(this));
          }
          get xSplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.xValues;
          }
          get ySplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.yValues;
          }
          get isSpline() {
            return this.isSplineProperty;
          }
          get interpolationPoints() {
            return this.interpolationPointsProperty;
          }
          set interpolationPoints(e) {
            (this.interpolationPointsProperty = e),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (this.renderDataTransform.requiresTransform = !0),
              this.notifyPropertyChanged(a.PROPERTY.INTERPOLATION_POINTS);
          }
          get warnOnSplineFailure() {
            return this.renderDataTransform.warnOnSplineFailure;
          }
          set warnOnSplineFailure(e) {
            this.renderDataTransform.warnOnSplineFailure = e;
          }
          updateSplineValues() {
            this.updateTransformedValues();
          }
          onSplineFailure() {}
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { interpolationPoints: this.interpolationPoints };
            return Object.assign(t.options, r), t;
          }
        }
        t.SplineLineRenderableSeries = l;
      },
      86109: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SplineMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(36650),
          a = r(20977),
          s = r(96852),
          n = r(95103);
        class l extends o.BaseMountainRenderableSeries {
          constructor(e, t) {
            var r, o, a;
            super(e, t),
              (this.type = i.ESeriesType.SplineMountainSeries),
              (this.isSplineProperty = !0),
              (this.interpolationPointsProperty = 10),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new s.DataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (this.interpolationPointsProperty =
                null !== (r = null == t ? void 0 : t.interpolationPoints) &&
                void 0 !== r
                  ? r
                  : this.interpolationPointsProperty),
              (this.renderDataTransform = new n.SplineRenderDataTransform(
                this,
                e,
                [this.drawingProviders[0]]
              )),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (a = this.paletteProvider) ||
                  void 0 === a ||
                  a.onAttached(this));
          }
          get isSpline() {
            return this.isSplineProperty;
          }
          get interpolationPoints() {
            return this.interpolationPointsProperty;
          }
          set interpolationPoints(e) {
            (this.interpolationPointsProperty = e),
              (this.renderDataTransform.interpolationPoints =
                this.interpolationPoints),
              (this.renderDataTransform.requiresTransform = !0),
              this.notifyPropertyChanged(a.PROPERTY.INTERPOLATION_POINTS);
          }
          get xSplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.xValues;
          }
          get ySplineValues() {
            if (!this.transformedRenderPassData)
              throw Error(
                "Spline values are not available until after first render, or call updateSplineValues"
              );
            return this.transformedRenderPassData.pointSeries.yValues;
          }
          get warnOnSplineFailure() {
            return this.renderDataTransform.warnOnSplineFailure;
          }
          set warnOnSplineFailure(e) {
            this.renderDataTransform.warnOnSplineFailure = e;
          }
          updateSplineValues() {
            this.updateTransformedValues();
          }
          onSplineFailure() {}
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = { interpolationPoints: this.interpolationPoints };
            return Object.assign(t.options, r), t;
          }
        }
        t.SplineMountainRenderableSeries = l;
      },
      1406: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedColumnCollection = void 0);
        const i = r(56744),
          o = r(98140),
          a = r(5337),
          s = r(48570),
          n = r(79961),
          l = r(35246),
          d = r(20977),
          h = r(88915),
          u = r(93752),
          c = r(27970),
          p = r(16602);
        class g extends l.BaseStackedCollection {
          constructor(e, t) {
            var r, i, o, s, n;
            super(e, t),
              (this.type = a.ESeriesType.StackedColumnCollection),
              (this.seriesGroups = {}),
              (this.dataPointWidthProperty = 0.5),
              (this.dataPointWidthModeProperty =
                c.EDataPointWidthMode.Relative),
              (this.zeroLineYProperty = 0),
              (this.dataPointWidthProperty =
                null !== (r = null == t ? void 0 : t.dataPointWidth) &&
                void 0 !== r
                  ? r
                  : this.dataPointWidthProperty),
              (this.dataPointWidthMode =
                null !== (i = null == t ? void 0 : t.dataPointWidthMode) &&
                void 0 !== i
                  ? i
                  : this.dataPointWidthModeProperty),
              (this.zeroLineYProperty =
                null !== (o = null == t ? void 0 : t.zeroLineY) && void 0 !== o
                  ? o
                  : this.zeroLineYProperty),
              (this.spacingProperty =
                null !==
                  (n =
                    null !== (s = null == t ? void 0 : t.spacing) &&
                    void 0 !== s
                      ? s
                      : this.spacingProperty) && void 0 !== n
                  ? n
                  : 0),
              (this.getColumnWidth = this.getColumnWidth.bind(this)),
              (this.detachChildSeries = this.detachChildSeries.bind(this)),
              (this.attachChildSeries = this.attachChildSeries.bind(this)),
              this.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach(this.detachChildSeries),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach(this.attachChildSeries);
              }),
              (this.dataLabelProvider =
                new u.StackedCollectionDataLabelProvider()),
              this.dataLabelProviderProperty.onAttach(
                this.webAssemblyContext,
                this
              );
          }
          delete() {
            (this.nativeDrawingProvider = (0, i.deleteSafe)(
              this.nativeDrawingProvider
            )),
              super.delete();
          }
          updateAccumulatedVectors() {
            const e = this.getDataSeriesValuesCount();
            if (!this.isAccumulatedVectorDirty || !e) return;
            this.checkXValuesCorrect(),
              (this.isAccumulatedVectorDirty = !1),
              this.clearAccumulatedVectors(e),
              this.updateGroups();
            const t = this.seriesGroups,
              r = this.getGroupsCount();
            Object.keys(t).forEach((e, i) => {
              t[e].forEach((e) => {
                e.setGroupsCount(r), e.setGroupIndex(i);
              });
            });
            for (let r = 0; r < e; r++)
              this.accumulatedValues0.push_back(this.zeroLineY),
                Object.keys(t).forEach((e) => {
                  const i = t[e];
                  let o;
                  this.isOneHundredPercent &&
                    (o = i.reduce(
                      (e, t) => e + t.dataSeries.getNativeYValues().get(r),
                      0
                    ));
                  let a = 0;
                  i.forEach((e) => {
                    let t = e.dataSeries.getNativeYValues().get(r);
                    this.isOneHundredPercent && (t = (100 * t) / o);
                    const i = a + t;
                    e.accumulatedValues.push_back(i), (a = i);
                  });
                });
          }
          draw(e, t) {
            var r, i, o;
            if (this.canDraw) {
              if ((this.updateHitTestProviders(t), !this.isEnoughDataToDraw()))
                return;
              const a = p.PerformanceDebugHelper.mark(
                p.EPerformanceMarkType.DrawCollectionSeriesStart,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (r = this.parentSurface) || void 0 === r
                      ? void 0
                      : r.id,
                  level: p.EPerformanceDebugLevel.Verbose,
                }
              );
              this.updateAccumulatedVectors();
              const n = t.xCoordinateCalculator.isCategoryCoordinateCalculator,
                l = this.getFirstSeries().dataSeries,
                d = this.parentSurface.seriesViewRect;
              if (null == l ? void 0 : l.fifoCapacity)
                throw new Error(
                  "Sorry, fifo is not currently supported for stacked series"
                );
              const {
                  isVerticalChart: u,
                  xCoordinateCalculator: c,
                  yCoordinateCalculator: g,
                } = t,
                f = n ? l.getNativeIndexes() : l.getNativeXValues(),
                v = this.seriesGroups,
                m = this.getGroupsCount(),
                S = this.getColumnWidth(c);
              Object.keys(v).forEach((t, r) => {
                let i;
                v[t].forEach((t, o) => {
                  var a;
                  const n =
                      0 === o ? this.accumulatedValues0 : i.accumulatedValues,
                    l = t.accumulatedValues;
                  this.setDataLabelProviderProperties(
                    t.dataLabelProvider,
                    l,
                    r,
                    m,
                    S,
                    this.spacingProperty,
                    this.isOneHundredPercent
                  ),
                    t.dataLabelProvider.generateDataLabels(
                      e,
                      new s.RenderPassData(
                        null === (a = t.dataSeries) || void 0 === a
                          ? void 0
                          : a.getIndicesRange(
                              this.xAxis.visibleRange,
                              this.xAxis.isCategoryAxis
                            ),
                        this.xAxis.getCurrentCoordinateCalculator,
                        this.yAxis.getCurrentCoordinateCalculator,
                        this.xAxis.isVerticalChart,
                        new h.XyPointSeriesWrapped(t.dataSeries)
                      )
                    ),
                    y(
                      this.webAssemblyContext,
                      e,
                      c,
                      g,
                      u,
                      this.nativeDrawingProvider,
                      f,
                      n,
                      l,
                      t.getFillBrush(),
                      t.getStrokePen(),
                      d,
                      S,
                      this.spacingProperty,
                      m,
                      r
                    ),
                    (i = t);
                });
              }),
                p.PerformanceDebugHelper.mark(
                  p.EPerformanceMarkType.DrawCollectionSeriesEnd,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (i = this.parentSurface) || void 0 === i
                        ? void 0
                        : i.id,
                    relatedId:
                      null === (o = null == a ? void 0 : a.detail) ||
                      void 0 === o
                        ? void 0
                        : o.relatedId,
                    level: p.EPerformanceDebugLevel.Verbose,
                  }
                );
            }
          }
          getXRange() {
            if (!this.isEnoughDataToDraw()) return new o.NumberRange();
            const e = this.getFirstSeries().dataSeries.xRange,
              t = this.getFirstSeries().dataSeries.count();
            let r = this.dataPointWidth / 2;
            return (
              this.dataPointWidthMode === c.EDataPointWidthMode.Relative &&
                (r =
                  t > 1 ? ((e.diff / (t - 1)) * this.dataPointWidth) / 2 : 0),
              this.dataPointWidthMode === c.EDataPointWidthMode.Absolute &&
                (r =
                  this.xAxis
                    .getCurrentCoordinateCalculator()
                    .getDataWidth(this.dataPointWidth) / 2),
              new o.NumberRange(e.min - r, e.max + r)
            );
          }
          getYRange(e, t) {
            const r = super.getYRange(e, t);
            return new o.NumberRange(
              Math.min(r.min, this.zeroLineY),
              Math.max(r.max, this.zeroLineY)
            );
          }
          onAttach(e) {
            super.onAttach(e),
              (this.nativeDrawingProvider =
                new this.webAssemblyContext.SCRTStackedColumnSeriesDrawingProvider());
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              (e !== d.PROPERTY.DATA_SERIES &&
                e !== d.PROPERTY.IS_VISIBLE &&
                e !== d.PROPERTY.IS_ONE_HUNDRED_PERCENT &&
                e !== d.PROPERTY.STACKED_GROUP_ID) ||
                (this.isAccumulatedVectorDirty = !0);
          }
          hasDataSeriesValues() {
            return this.isEnoughDataToDraw();
          }
          getColumnWidth(e) {
            const t = this.dataPointWidth,
              r = this.dataPointWidthMode,
              i = this.getFirstSeries().dataSeries,
              o = e.isCategoryCoordinateCalculator,
              a = o ? i.getNativeIndexes() : i.getNativeXValues(),
              s = this.parentSurface.seriesViewRect,
              l = this.getGroupsCount();
            if (r === c.EDataPointWidthMode.Range) {
              const r = e.visibleMax - e.visibleMin;
              return ((e.viewportDimension / r) * t) / l;
            }
            return r === c.EDataPointWidthMode.Absolute
              ? t / l
              : (0, n.getDataPointWidth)(
                  a,
                  e,
                  s.width,
                  t,
                  o,
                  this.webAssemblyContext
                ) / l;
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                dataPointWidth: this.dataPointWidth,
                dataPointWidthMode: this.dataPointWidthMode,
                zeroLineY: this.zeroLineY,
                spacing: this.spacingProperty,
              };
            return Object.assign(t.options, r), t;
          }
          get dataPointWidth() {
            return this.dataPointWidthProperty;
          }
          set dataPointWidth(e) {
            (this.dataPointWidthProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.DATA_POINT_WIDTH);
          }
          get dataPointWidthMode() {
            return this.dataPointWidthModeProperty;
          }
          set dataPointWidthMode(e) {
            (this.dataPointWidthModeProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.DATA_POINT_WIDTH_MODE);
          }
          get zeroLineY() {
            return this.zeroLineYProperty;
          }
          set zeroLineY(e) {
            (this.zeroLineYProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.ZERO_LINE_Y);
          }
          get spacing() {
            return this.spacingProperty;
          }
          set spacing(e) {
            (this.spacingProperty = e),
              this.notifyPropertyChanged(d.PROPERTY.SPACING);
          }
          detachChildSeries(e) {
            e.onDetachFromParentCollection(),
              (this.isAccumulatedVectorDirty = !0),
              this.invalidateParent();
          }
          attachChildSeries(e) {
            e.onAttachToParentCollection(
              this,
              this.getParentSurface,
              this.notifyPropertyChanged,
              this.getColumnWidth
            ),
              (this.isAccumulatedVectorDirty = !0),
              this.invalidateParent();
          }
          checkXValuesCorrect() {
            const e = this.getDataSeriesValuesCount();
            this.getVisibleSeries().forEach((t) => {
              var r;
              if (
                (null === (r = t.dataSeries) || void 0 === r
                  ? void 0
                  : r.count()) !== e
              )
                throw Error(
                  "All stacked series in on collection should have the same amount of X Values"
                );
            });
          }
          setDataLabelProviderProperties(e, t, r, i, o, a, s) {
            (e.topVector = t),
              (e.groupIndex = r),
              (e.groupSize = i),
              (e.columnWidth = o),
              (e.spacing = a),
              (e.isOneHundredPercent = s);
          }
          clearAccumulatedVectors(e) {
            this.accumulatedValues0.clear(),
              this.accumulatedValues0.reserve(e),
              this.asArray().forEach((t) => {
                t.accumulatedValues.clear(), t.accumulatedValues.reserve(e);
              });
          }
          getLastVisibleSeries() {
            const [e] = this.getVisibleSeries().slice(-1);
            return e;
          }
          updateGroups() {
            const e = {};
            this.getVisibleSeries().forEach((t) => {
              const r = t.stackedGroupId;
              e[r] || (e[r] = []), e[r].push(t);
            }),
              (this.seriesGroups = e);
          }
          getGroupsCount() {
            return Object.keys(this.seriesGroups).length;
          }
        }
        t.StackedColumnCollection = g;
        const y = (e, t, r, i, o, a, s, n, l, d, h, u, c, p, g, y) => {
          const f = new e.SCRTStackedColumnDrawingParams();
          (f.count = s.size()),
            (f.columnWidth = c <= 0 ? 1 : c),
            (f.spacing = p),
            (f.viewportWidth = u.width),
            (f.viewportHeight = u.height),
            (f.verticalChart = o),
            (f.stackedGroupCount = g),
            (f.stackedGroupIndex = y),
            (f.forceShaderMethod = !0),
            h && f.SetLinesPen(h),
            d && f.SetFillBrush(d);
          const v = t.getNativeContext();
          a.DrawPointsVec(
            v,
            s,
            l,
            n,
            r.nativeCalculator,
            i.nativeCalculator,
            f
          ),
            f.delete();
        };
      },
      83262: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedColumnRenderableSeries = void 0);
        const i = r(56744),
          o = r(5337),
          a = r(51269),
          s = r(21915),
          n = r(84392),
          l = r(14184),
          d = r(48335),
          h = r(20977),
          u = r(51825),
          c = r(74026);
        class p extends d.BaseStackedRenderableSeries {
          constructor(e, t) {
            var r, i, n, d, h, u, p, g;
            super(e, t),
              (this.type = o.ESeriesType.StackedColumnSeries),
              (this.fillProperty = "#7e8486"),
              (this.spacingProperty = 0),
              (this.stackedGroupIdProperty = "default"),
              (this.getGroupIndex = this.getGroupIndex.bind(this)),
              (this.getGroupsCount = this.getGroupsCount.bind(this)),
              (this.getColumnWidth = this.getColumnWidth.bind(this)),
              (this.fillBrushCache = new a.BrushCache(e)),
              (this.strokePenCache = new s.Pen2DCache(e)),
              (this.isOneHundredPercent =
                null !==
                  (i =
                    null === (r = this.parentCollection) || void 0 === r
                      ? void 0
                      : r.isOneHundredPercent) &&
                void 0 !== i &&
                i),
              (this.fill =
                null !== (n = null == t ? void 0 : t.fill) && void 0 !== n
                  ? n
                  : this.fillProperty),
              (this.stroke =
                null !== (d = null == t ? void 0 : t.stroke) && void 0 !== d
                  ? d
                  : l.SciChartSurfaceBase.DEFAULT_THEME.mountainLineColor),
              (this.strokeThickness =
                null !== (h = null == t ? void 0 : t.strokeThickness) &&
                void 0 !== h
                  ? h
                  : 1),
              (this.spacingProperty =
                null !== (u = null == t ? void 0 : t.spacing) && void 0 !== u
                  ? u
                  : this.spacingProperty),
              (this.stackedGroupIdProperty =
                null !== (p = null == t ? void 0 : t.stackedGroupId) &&
                void 0 !== p
                  ? p
                  : this.stackedGroupIdProperty),
              (this.fillLinearGradientProperty =
                null !== (g = null == t ? void 0 : t.fillLinearGradient) &&
                void 0 !== g
                  ? g
                  : this.fillLinearGradientProperty),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new c.StackedColumnSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                ));
          }
          delete() {
            (this.strokePenCache = (0, i.deleteSafe)(this.strokePenCache)),
              (this.fillBrushCache = (0, i.deleteSafe)(this.fillBrushCache)),
              super.delete();
          }
          onAttachToParentCollection(e, t, r, i) {
            if (this.parentCollection)
              throw new Error(
                "Invalid operation in StackedColumnRenderableSeries.onAttachToParentCollection, this series has been already attached to collection. Please detach it from the collection before attaching to another"
              );
            (this.parentCollection = e),
              (this.getParentSurfaceFn = t),
              (this.notifyParentPropertyChangedFn = r),
              (this.getColumnWidthFn = i);
            const { stroke: o, strokeThickness: a, fill: n, opacity: l } = this;
            (0, s.createPenInCache)(this.strokePenCache, o, a, l),
              this.createBrush();
          }
          getFillBrush() {
            return (0, a.getScrtBrushFromCache)(this.fillBrushCache);
          }
          getStrokePen() {
            const { stroke: e, strokeThickness: t, opacity: r } = this;
            return (0, s.createPenInCache)(this.strokePenCache, e, t, r);
          }
          getGroupIndex() {
            return this.groupIndex;
          }
          setGroupIndex(e) {
            this.groupIndex = e;
          }
          getGroupsCount() {
            return this.groupsCount;
          }
          setGroupsCount(e) {
            this.groupsCount = e;
          }
          getColumnWidth(e) {
            return this.getColumnWidthFn(e);
          }
          onDpiChanged(e) {
            this.notifyPropertyChanged(h.PROPERTY.STROKE);
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              (e !== h.PROPERTY.STROKE &&
                e !== h.PROPERTY.STROKE_THICKNESS &&
                e !== h.PROPERTY.OPACITY) ||
                (0, s.createPenInCache)(
                  this.strokePenCache,
                  this.stroke,
                  this.strokeThickness,
                  this.opacity
                ),
              (e !== h.PROPERTY.FILL &&
                e !== h.PROPERTY.OPACITY &&
                e !== h.PROPERTY.FILL_LINEAR_GRADIENT &&
                e !== h.PROPERTY.CUSTOM_TEXTURE_OPTIONS) ||
                this.createBrush();
          }
          get fill() {
            return (0, n.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.FILL);
          }
          get drawingProviders() {
            return [];
          }
          set drawingProviders(e) {}
          get effect() {}
          set effect(e) {}
          get spacing() {
            return this.spacingProperty;
          }
          set spacing(e) {
            (this.spacingProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.SPACING);
          }
          get stackedGroupId() {
            return this.stackedGroupIdProperty;
          }
          set stackedGroupId(e) {
            (this.stackedGroupIdProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.STACKED_GROUP_ID);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(h.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                stroke: this.stroke,
                strokeThickness: this.strokeThickness,
                spacing: this.spacing,
                stackedGroupId: this.stackedGroupId,
                fillLinearGradient: this.fillLinearGradient,
              };
            return Object.assign(t.options, r), t;
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(n.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = n.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          newHitTestProvider() {
            return new u.StackedColumnSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
          createBrush() {
            var e, t;
            const r = (
                null === (e = this.parentSurface) || void 0 === e
                  ? void 0
                  : e.isCopyCanvasSurface
              )
                ? this.parentSurface.domCanvas2D.height /
                  l.SciChartSurfaceBase.domMasterCanvas.height
                : 1,
              i = (
                null === (t = this.parentSurface) || void 0 === t
                  ? void 0
                  : t.isCopyCanvasSurface
              )
                ? this.parentSurface.domCanvas2D.width /
                  l.SciChartSurfaceBase.domMasterCanvas.width
                : 1;
            (0, a.createBrushInCache)(
              this.fillBrushCache,
              this.fill,
              this.opacity,
              r,
              i,
              this.fillLinearGradient,
              this.customTextureOptions
            );
          }
        }
        t.StackedColumnRenderableSeries = p;
      },
      71719: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedMountainCollection = void 0);
        const i = r(5337),
          o = r(11529);
        class a extends o.StackedXyCollection {
          constructor(e, t) {
            super(e, t), (this.type = i.ESeriesType.StackedMountainCollection);
          }
        }
        t.StackedMountainCollection = a;
      },
      1391: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedMountainRenderableSeries = void 0);
        const i = r(5337),
          o = r(73124);
        class a extends o.BaseStackedMountainRenderableSeries {
          constructor(e, t) {
            super(e, t), (this.type = i.ESeriesType.StackedMountainSeries);
          }
        }
        t.StackedMountainRenderableSeries = a;
      },
      11529: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StackedXyCollection = void 0);
        const i = r(98140),
          o = r(46544),
          a = r(16602),
          s = r(2354),
          n = r(48570),
          l = r(35246),
          d = r(20977);
        class h extends l.BaseStackedCollection {
          constructor(e, t) {
            super(e, t),
              (this.detachChildSeries = this.detachChildSeries.bind(this)),
              (this.attachChildSeries = this.attachChildSeries.bind(this)),
              this.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach(this.detachChildSeries),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach(this.attachChildSeries);
              });
          }
          updateAccumulatedVectors() {
            const e = this.getDataSeriesValuesCount();
            if (this.isAccumulatedVectorDirty && e) {
              this.checkXValuesCorrect(),
                (this.isAccumulatedVectorDirty = !1),
                this.clearAccumulatedVectors(e);
              for (let t = 0; t < e; t++) {
                this.accumulatedValues0.push_back(0);
                let e,
                  r = 0;
                this.isOneHundredPercent &&
                  (e = this.getVisibleSeries().reduce(
                    (e, r) => e + r.dataSeries.getNativeYValues().get(t),
                    0
                  )),
                  this.getVisibleSeries().forEach((i) => {
                    let o = i.dataSeries.getNativeYValues().get(t);
                    this.isOneHundredPercent && (o = (100 * o) / e);
                    const a = r + o;
                    i.accumulatedValues.push_back(a),
                      (r = a),
                      i.renderDataTransform &&
                        (i.renderDataTransform.requiresTransform = !0);
                  });
              }
            }
          }
          draw(e, t) {
            var r, i, l, d;
            if (this.canDraw) {
              if ((this.updateHitTestProviders(t), !this.isEnoughDataToDraw()))
                return;
              if (
                null === (r = this.getFirstSeries().dataSeries) || void 0 === r
                  ? void 0
                  : r.fifoCapacity
              )
                throw new Error(
                  "Sorry, fifo is not currently supported for stacked series"
                );
              const h = a.PerformanceDebugHelper.mark(
                a.EPerformanceMarkType.DrawCollectionSeriesStart,
                {
                  contextId: this.id,
                  parentContextId:
                    null === (i = this.parentSurface) || void 0 === i
                      ? void 0
                      : i.id,
                  level: a.EPerformanceDebugLevel.Verbose,
                }
              );
              this.updateAccumulatedVectors();
              const u = this.xAxis,
                c = this.getVisibleSeries();
              c.reduceRight((r, i, a, l) => {
                const d = i.accumulatedValues,
                  h =
                    0 === a
                      ? this.accumulatedValues0
                      : l[a - 1].accumulatedValues,
                  p = new s.XyyPointSeriesWrapped(i.dataSeries, h, d),
                  g = new n.RenderPassData(
                    i.getIndicesRange(u.visibleRange),
                    t.getxCoordinateCalculator,
                    t.getyCoordinateCalculator,
                    u.isVerticalChart,
                    p
                  );
                if (i.renderDataTransform) {
                  let r = new n.RenderPassData(
                    i.getIndicesRange(u.visibleRange),
                    t.getxCoordinateCalculator,
                    t.getyCoordinateCalculator,
                    u.isVerticalChart,
                    p
                  );
                  return (
                    (r = i.renderDataTransform.runTransform(r)),
                    a < c.length - 1 &&
                      (0, o.copyDoubleVector)(
                        l[a + 1].renderDataTransform.pointSeries.yValues,
                        r.pointSeries.y1Values,
                        this.webAssemblyContext
                      ),
                    "strokeY1" in i &&
                      ((i.strokeY1 = 0 === a ? "transparent" : l[a - 1].stroke),
                      (i.strokeY1DashArray =
                        0 === a ? [] : l[a - 1].strokeDashArray)),
                    i.drawingProviders[0].draw(e, r),
                    i
                  );
                }
                return (
                  "strokeY1" in i &&
                    ((i.strokeY1 = 0 === a ? "transparent" : l[a - 1].stroke),
                    (i.strokeY1DashArray =
                      0 === a ? [] : l[a - 1].strokeDashArray)),
                  i.draw(e, g),
                  i
                );
              }, void 0),
                a.PerformanceDebugHelper.mark(
                  a.EPerformanceMarkType.DrawCollectionSeriesEnd,
                  {
                    contextId: this.id,
                    parentContextId:
                      null === (l = this.parentSurface) || void 0 === l
                        ? void 0
                        : l.id,
                    relatedId:
                      null === (d = null == h ? void 0 : h.detail) ||
                      void 0 === d
                        ? void 0
                        : d.relatedId,
                    level: a.EPerformanceDebugLevel.Verbose,
                  }
                );
            }
          }
          getXRange() {
            return this.isEnoughDataToDraw()
              ? this.getFirstSeries().dataSeries.xRange
              : new i.NumberRange();
          }
          onAttach(e) {
            super.onAttach(e),
              this.getVisibleSeries().forEach((t) => {
                t.onAttach(e);
              });
          }
          onDetach() {
            this.getVisibleSeries().forEach((e) => {
              e.onDetach();
            }),
              super.onDetach();
          }
          notifyPropertyChanged(e) {
            super.notifyPropertyChanged(e),
              (e !== d.PROPERTY.DATA_SERIES &&
                e !== d.PROPERTY.IS_VISIBLE &&
                e !== d.PROPERTY.IS_ONE_HUNDRED_PERCENT) ||
                (this.isAccumulatedVectorDirty = !0);
          }
          hasDataSeriesValues() {
            return this.isEnoughDataToDraw();
          }
          detachChildSeries(e) {
            e.onDetachFromParentCollection(),
              (this.isAccumulatedVectorDirty = !0),
              this.invalidateParent();
          }
          attachChildSeries(e) {
            e.onAttachToParentCollection(
              this,
              this.getParentSurface,
              this.notifyPropertyChanged
            ),
              this.parentSurface && e.onAttach(this.parentSurface),
              (this.isAccumulatedVectorDirty = !0),
              this.invalidateParent();
          }
          checkXValuesCorrect() {
            const e = this.getDataSeriesValuesCount();
            this.getVisibleSeries().forEach((t) => {
              if (t.dataSeries.count() !== e)
                throw Error(
                  "All stacked series in on collection should have the same amount of X Values"
                );
            });
          }
          clearAccumulatedVectors(e) {
            this.accumulatedValues0.clear(),
              this.accumulatedValues0.reserve(e),
              this.asArray().forEach((t) => {
                t.accumulatedValues.clear(), t.accumulatedValues.reserve(e);
              });
          }
          getLastVisibleSeries() {
            const [e] = this.getVisibleSeries().slice(-1);
            return e;
          }
        }
        t.StackedXyCollection = h;
      },
      51852: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TriangleRenderableSeries = void 0);
        const i = r(5337),
          o = r(95808),
          a = r(84392),
          s = r(14184),
          n = r(79961),
          l = r(20977),
          d = r(33802),
          h = r(94707),
          u = r(74397),
          c = r(22735),
          p = r(43808);
        class g extends n.BaseRenderableSeries {
          constructor(e, t) {
            var r, a, n;
            super(e, t),
              (this.type = i.ESeriesType.TriangleSeries),
              (this.drawModeProperty = o.ETriangleSeriesDrawMode.List),
              (this.polygonVerticesProperty = 0),
              (this.fillProperty =
                s.SciChartSurfaceBase.DEFAULT_THEME.columnFillBrush),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new d.LineSeriesDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (this.drawModeProperty =
                null !== (r = null == t ? void 0 : t.drawMode) && void 0 !== r
                  ? r
                  : this.drawModeProperty),
              (this.polygonVerticesProperty =
                null !== (a = null == t ? void 0 : t.polygonVertices) &&
                void 0 !== a
                  ? a
                  : this.polygonVerticesProperty),
              (this.fillProperty =
                null !== (n = null == t ? void 0 : t.fill) && void 0 !== n
                  ? n
                  : this.fillProperty),
              (this.fillLinearGradientProperty =
                null == t ? void 0 : t.fillLinearGradient),
              (this.customTextureOptionsProperty =
                null == t ? void 0 : t.customTextureOptions);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new u.TriangleSeriesDrawingProvider(e, this)
            ),
              this.drawingProviders.push(
                new h.PointMarkerDrawingProvider(e, this)
              );
          }
          get drawMode() {
            return this.drawModeProperty;
          }
          set drawMode(e) {
            (this.drawModeProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.TRIANGLE_DRAW_MODE);
          }
          get polygonVertices() {
            return this.polygonVerticesProperty;
          }
          set polygonVertices(e) {
            (this.polygonVerticesProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.POLYGON_VERTICES);
          }
          get fill() {
            return (0, a.stripAutoColor)(this.fillProperty);
          }
          set fill(e) {
            (this.fillProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.FILL);
          }
          get fillLinearGradient() {
            return this.fillLinearGradientProperty;
          }
          set fillLinearGradient(e) {
            e !== this.fillLinearGradientProperty &&
              ((this.fillLinearGradientProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.FILL_LINEAR_GRADIENT));
          }
          get customTextureOptions() {
            return this.customTextureOptionsProperty;
          }
          set customTextureOptions(e) {
            e !== this.customTextureOptionsProperty &&
              ((this.customTextureOptionsProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.CUSTOM_TEXTURE_OPTIONS));
          }
          resolveAutoColors(e, t, r) {
            if (
              (super.resolveAutoColors(e, t, r),
              this.fillProperty.startsWith(a.AUTO_COLOR))
            ) {
              const i = r.getFillColor(e, t, this.webAssemblyContext);
              this.fill = a.AUTO_COLOR + this.adjustAutoColor("fill", i);
            }
          }
          getSeriesInfo(e) {
            return new p.TriangleSeriesInfo(
              this,
              e,
              this.drawMode,
              this.polygonVertices
            );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e),
              r = {
                fill: this.fill,
                drawMode: this.drawMode,
                polygonVertices: this.polygonVertices,
                customTextureOptions: this.customTextureOptions,
                fillLinearGradient: this.fillLinearGradient,
              };
            return Object.assign(t.options, r), t;
          }
          newHitTestProvider() {
            return new c.TriangleSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.TriangleRenderableSeries = g;
      },
      88189: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformContoursRenderableSeries =
            t.EContourColorMapMode =
            t.COLOR_MAP_PREFIX =
              void 0);
        const i = r(5337),
          o = r(72934),
          a = r(79961),
          s = r(20977),
          n = r(9488),
          l = r(9184),
          d = r(60981);
        var h;
        (t.COLOR_MAP_PREFIX = "colorMap."),
          ((h =
            t.EContourColorMapMode ||
            (t.EContourColorMapMode = {})).AlternateColors = "AlternateColors"),
          (h.GradientColors = "GradientColors");
        class u extends a.BaseRenderableSeries {
          constructor(e, t) {
            var r, o, a;
            super(e, t),
              (this.type = i.ESeriesType.UniformContoursSeries),
              (this.colorMapPropertyChanged =
                this.colorMapPropertyChanged.bind(this)),
              (null == t ? void 0 : t.colorMap) &&
                ("toJSON" in t.colorMap ||
                  (t.colorMap = new d.HeatmapColorMap(t.colorMap))),
              (this.colorMap = null == t ? void 0 : t.colorMap),
              (this.dataSeries = null == t ? void 0 : t.dataSeries),
              (this.xAxisId = null == t ? void 0 : t.xAxisId),
              (this.yAxisId = null == t ? void 0 : t.yAxisId),
              (this.zMin = (null == t ? void 0 : t.zMin) || NaN),
              (this.zMax = (null == t ? void 0 : t.zMax) || NaN),
              (this.zStep = (null == t ? void 0 : t.zStep) || NaN),
              (this.xOffsetProperty =
                null !== (r = null == t ? void 0 : t.zOffset) && void 0 !== r
                  ? r
                  : 0),
              (this.majorLineStyle =
                (null == t ? void 0 : t.majorLineStyle) ||
                u.DEFAULT_MAJOR_LINE_STYLE),
              (this.minorLineStyle =
                (null == t ? void 0 : t.minorLineStyle) ||
                u.DEFAULT_MINOR_LINE_STYLE),
              (this.minorsPerMajor =
                (null == t ? void 0 : t.minorsPerMajor) || 0),
              (this.majorLineStyleProperty =
                null == t ? void 0 : t.majorLineStyle),
              (this.minorLineStyleProperty =
                null == t ? void 0 : t.minorLineStyle),
              (null === (o = this.paletteProvider) || void 0 === o
                ? void 0
                : o.onAttached) &&
                (null === (a = this.paletteProvider) ||
                  void 0 === a ||
                  a.onAttached(this)),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new n.ContoursDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (this.drawingProviders = []),
              this.drawingProviders.push(
                new l.UniformContoursDrawingProvider(e, this)
              );
          }
          get zMin() {
            return this.zMinProperty;
          }
          set zMin(e) {
            (this.zMinProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.Z_MIN);
          }
          get zMax() {
            return this.zMaxProperty;
          }
          set zMax(e) {
            (this.zMaxProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.Z_MAX);
          }
          get zStep() {
            return this.zStepProperty;
          }
          set zStep(e) {
            (this.zStepProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.Z_STEP);
          }
          get zOffset() {
            return this.xOffsetProperty;
          }
          set zOffset(e) {
            (this.xOffsetProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.Z_OFFSET);
          }
          get colorMap() {
            return this.colorMapProperty;
          }
          set colorMap(e) {
            var t, r;
            null === (t = this.colorMapProperty) ||
              void 0 === t ||
              t.propertyChanged.unsubscribe(this.colorMapPropertyChanged),
              (this.colorMapProperty = e),
              null === (r = this.colorMapProperty) ||
                void 0 === r ||
                r.propertyChanged.subscribe(this.colorMapPropertyChanged),
              this.notifyPropertyChanged(s.PROPERTY.COLOR_MAP);
          }
          get colorMapMode() {
            return this.colorMapModeProperty;
          }
          set colorMapMode(e) {
            (this.colorMapModeProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTOUR_COLOR_MAP_MODE);
          }
          get majorLineStyle() {
            return this.majorLineStyleProperty;
          }
          set majorLineStyle(e) {
            (this.majorLineStyleProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTOUR_MAJOR_LINE_STYLE);
          }
          get minorLineStyle() {
            return this.minorLineStyleProperty;
          }
          set minorLineStyle(e) {
            (this.minorLineStyleProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTOUR_MINOR_LINE_STYLE);
          }
          get minorsPerMajor() {
            return this.minorsPerMajorProperty;
          }
          set minorsPerMajor(e) {
            (this.minorsPerMajorProperty = e),
              this.notifyPropertyChanged(s.PROPERTY.CONTOUR_MINORS_PER_MAJOR);
          }
          getContourDrawingParams() {
            var e, t;
            const r = this.dataSeries,
              i = r.zRange;
            let a =
                this.zMin && (0, o.isRealNumber)(this.zMin) ? this.zMin : i.min,
              s =
                this.zMax && (0, o.isRealNumber)(this.zMax) ? this.zMax : i.max;
            (a = Math.max(a, i.min)), (s = Math.min(s, i.max));
            const n =
                this.zStep && (0, o.isRealNumber)(this.zStep)
                  ? this.zStep
                  : Math.abs(s - a) / u.DEFAULT_CONTOURS_COUNT,
              l =
                this.minorsPerMajor && this.minorsPerMajor > 0
                  ? n / (this.minorsPerMajor + 1)
                  : n,
              d =
                null !== (e = this.minorLineStyle) && void 0 !== e
                  ? e
                  : {
                      strokeThickness: this.strokeThickness,
                      color: this.stroke,
                    },
              h =
                null !== (t = this.majorLineStyle) && void 0 !== t
                  ? t
                  : {
                      strokeThickness: this.strokeThickness,
                      color: this.stroke,
                    };
            return {
              xMax: r.xMax,
              yMin: r.yMin,
              yMax: r.yMax,
              xMin: r.xMin,
              zMin: a,
              zMax: s,
              majorStepZ: n,
              minorStepZ: l,
              minorLineStyle: d,
              majorLineStyle: h,
              zOffset: this.zOffset,
            };
          }
          toPointSeries(e) {}
          toJSON(e = !1) {
            var t;
            const r = super.toJSON(e),
              i = {
                colorMap:
                  null === (t = this.colorMap) || void 0 === t
                    ? void 0
                    : t.toJSON(),
                majorLineStyle: this.majorLineStyle,
                minorLineStyle: this.minorLineStyle,
                zMax: this.zMax,
                zMin: this.zMin,
                zOffset: this.zOffset,
                zStep: this.zStep,
                minorsPerMajor: this.minorsPerMajor,
              };
            return Object.assign(r.options, i), r;
          }
          colorMapPropertyChanged(e) {
            this.notifyPropertyChanged(t.COLOR_MAP_PREFIX + e.propertyName);
          }
          newHitTestProvider() {}
        }
        (t.UniformContoursRenderableSeries = u),
          (u.DEFAULT_CONTOURS_COUNT = 15),
          (u.DEFAULT_MAJOR_LINE_STYLE = { strokeThickness: 2, color: "white" }),
          (u.DEFAULT_MINOR_LINE_STYLE = { strokeThickness: 1, color: "white" });
      },
      70033: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UniformHeatmapRenderableSeries = void 0);
        const i = r(84745),
          o = r(5337),
          a = r(53904),
          s = r(75933),
          n = r(76566),
          l = r(3798);
        class d extends a.BaseHeatmapRenderableSeries {
          constructor(e, t) {
            super(e, t),
              (this.type = o.ESeriesType.UniformHeatmapSeries),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty =
                  new s.HeatMapDataLabelProvider(
                    null == t ? void 0 : t.dataLabels
                  )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                ));
          }
          addDrawingProviders(e, t) {
            i.IS_TEST_ENV ||
              this.drawingProviders.push(
                new n.UniformHeatmapDrawingProvider(e, this)
              );
          }
          newHitTestProvider() {
            return new l.UniformHeatmapHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
        }
        t.UniformHeatmapRenderableSeries = d;
      },
      52954: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.XyScatterRenderableSeries = void 0);
        const i = r(5337),
          o = r(33240),
          a = r(10749),
          s = r(79961),
          n = r(20977),
          l = r(96852),
          d = r(94707),
          h = r(64485);
        class u extends s.BaseRenderableSeries {
          constructor(e, t) {
            var r, o, s;
            super(e, t),
              (this.type = i.ESeriesType.ScatterSeries),
              (this.scatterOpacityProperty = 1),
              this.pointMarker ||
                (this.pointMarker = new a.EllipsePointMarker(e, {
                  width: 10,
                  height: 10,
                })),
              (null == t ? void 0 : t.animation) &&
                this.animationQueue.push(t.animation),
              this.dataLabelProviderProperty ||
                ((this.dataLabelProviderProperty = new l.DataLabelProvider(
                  null == t ? void 0 : t.dataLabels
                )),
                this.dataLabelProviderProperty.onAttach(
                  this.webAssemblyContext,
                  this
                )),
              (null === (r = this.paletteProvider) || void 0 === r
                ? void 0
                : r.onAttached) &&
                (null === (o = this.paletteProvider) ||
                  void 0 === o ||
                  o.onAttached(this)),
              (this.scatterOpacityProperty =
                null !== (s = null == t ? void 0 : t.opacity) && void 0 !== s
                  ? s
                  : this.scatterOpacityProperty);
          }
          addDrawingProviders(e, t) {
            this.drawingProviders.push(
              new d.PointMarkerDrawingProvider(e, this)
            );
          }
          needsResampling(e) {
            return (
              !!this.dataSeries.fifoCapacity &&
              ((e.resamplingMode = o.EResamplingMode.None),
              this.resamplerHelper.resetAndFillBasicNativeArgs(
                e,
                this.getNativeXValues()
              ),
              !0)
            );
          }
          newHitTestProvider() {
            return new h.ScatterSeriesHitTestProvider(
              this,
              this.webAssemblyContext
            );
          }
          get opacity() {
            return this.scatterOpacityProperty;
          }
          set opacity(e) {
            (this.scatterOpacityProperty = e),
              this.notifyPropertyChanged(n.PROPERTY.OPACITY),
              this.pointMarker &&
                ((this.pointMarker.opacity = e),
                this.notifyPropertyChanged(n.PROPERTY.POINT_MARKER));
          }
        }
        t.XyScatterRenderableSeries = u;
      },
      20977: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).BOTTOM_CORNER_RADIUS =
            "BOTTOM_CORNER_RADIUS"),
          (r.BOX_SERIES_CAP = "BOX_SERIES_CAP"),
          (r.BOX_SERIES_WHISKERS = "BOX_SERIES_WHISKERS"),
          (r.BOX_SERIES_MEDIAN = "BOX_SERIES_MEDIAN"),
          (r.BRUSH_UP = "BRUSH_UP"),
          (r.BRUSH_DOWN = "BRUSH_DOWN"),
          (r.COLOR = "COLOR"),
          (r.COLOR_MAP = "COLOR_MAP"),
          (r.CONTOUR_DRAWING_MODE = "CONTOUR_DRAWING_MODE"),
          (r.CONTOUR_MINORS_PER_MAJOR = "CONTOUR_MINORS_PER_MAJOR"),
          (r.CONTOUR_MINOR_LINE_STYLE = "CONTOUR_MINOR_LINE_STYLE"),
          (r.CONTOUR_MAJOR_LINE_STYLE = "CONTOUR_MAJOR_LINE_STYLE"),
          (r.CONTOUR_COLOR_MAP_MODE = "CONTOUR_COLOR_MAP_MODE"),
          (r.CORNER_RADIUS = "CORNER_RADIUS"),
          (r.DATA_POINT_WIDTH = "dataPointWidth"),
          (r.DATA_POINT_WIDTH_MODE = "DATA_POINT_WIDTH_MODE"),
          (r.DATA_SERIES = "dataSeries"),
          (r.DEFAULT_Y1 = "DEFAULT_Y1"),
          (r.DRAWING_PROVIDERS = "DRAWING_PROVIDERS"),
          (r.DRAW_NAN_AS = "drawNaNAs"),
          (r.DRAW_CONNECTOR = "DRAW_CONNECTOR"),
          (r.DRAW_WHISKERS = "DRAW_WHISKERS"),
          (r.EFFECT = "EFFECT"),
          (r.ENABLE_DRAWING_OPTIMISATIONS = "ENABLE_DRAWING_OPTIMISATIONS"),
          (r.ERROR_DIRECTION = "ERROR_DIRECTION"),
          (r.ERROR_MODE = "ERROR_MODE"),
          (r.FILL = "fill"),
          (r.FILL_Y1 = "FILL_Y1"),
          (r.FILL_LINEAR_GRADIENT = "FILL_LINEAR_GRADIENT"),
          (r.FILL_LINEAR_GRADIENT_Y1 = "FILL_LINEAR_GRADIENT_Y1"),
          (r.FILL_VALUES_OUT_OF_RANGE = "FILL_VALUES_OUT_OF_RANGE"),
          (r.GRADIENT_STOPS = "GRADIENT_STOPS"),
          (r.HOVERED = "HOVERED"),
          (r.INTERPOLATION_POINTS = "INTERPOLATION_POINTS"),
          (r.IS_DIGITAL_LINE = "IS_DIGITAL_LINE"),
          (r.IS_ONE_HUNDRED_PERCENT = "IS_ONE_HUNDRED_PERCENT"),
          (r.IS_SELECTED = "IS_SELECTED"),
          (r.IS_VISIBLE = "IS_VISIBLE"),
          (r.INTENSITY = "INTENSITY"),
          (r.LINE_TYPE = "LINE_TYPE"),
          (r.MAXIMUM = "MAXIMUM"),
          (r.MINIMUM = "MINIMUM"),
          (r.OFFSET = "OFFSET"),
          (r.OPACITY = "OPACITY"),
          (r.PALETTE_PROVIDER = "PALETTE_PROVIDER"),
          (r.PARENT_SURFACE = "PARENT_SURFACE"),
          (r.POINT_MARKER = "pointMarker"),
          (r.POLYGON_VERTICES = "POLYGON_VERTICES"),
          (r.RANGE = "RANGE"),
          (r.RESAMPLING_MODE = "RESAMPLING_MODE"),
          (r.RESAMPLING_PRECISION = "RESAMPLING_PRECISION"),
          (r.SERIES_NAME = "SERIES_NAME"),
          (r.SPACING = "SPACING"),
          (r.STACKED_GROUP_ID = "STACKED_GROUP_ID"),
          (r.STROKE = "STROKE"),
          (r.STROKE_Y1 = "STROKE_Y1"),
          (r.STROKE_DASH_ARRAY = "STROKE_DASH_ARRAY"),
          (r.STROKE_Y1_DASH_ARRAY = "STROKE_Y1_DASH_ARRAY"),
          (r.STROKE_DOWN = "STROKE_DOWN"),
          (r.STROKE_UP = "STROKE_UP"),
          (r.STROKE_THICKNESS = "STROKE_THICKNESS"),
          (r.TOP_CORNER_RADIUS = "TOP_CORNER_RADIUS"),
          (r.TRIANGLE_DRAW_MODE = "TRIANGLE_DRAW_MODE"),
          (r.USE_LINEAR_TEXTURE_FILTERING = "USE_LINEAR_TEXTURE_FILTERING"),
          (r.XAXIS_ID = "XAXIS_ID"),
          (r.YAXIS_ID = "YAXIS_ID"),
          (r.ZERO_LINE_Y = "ZERO_LINE_Y"),
          (r.Z_MAX = "Z_MAX"),
          (r.Z_MIN = "Z_MIN"),
          (r.Z_OFFSET = "Z_OFFSET"),
          (r.Z_STEP = "Z_STEP"),
          (r.Z_MULTIPLIER = "Z_MULTIPLIER"),
          (r.Z_LABEL_PROVIDER = "Z_LABEL_PROVIDER"),
          (r.Z_LIMITS = "Z_LIMITS"),
          (r.SERIES_TEXT_PROVIDER = "SERIES_TEXT_PROVIDER"),
          (r.CLIPTOYRANGE = "CLIPTOYRANGE"),
          (r.YRANGEMODE = "YRANGEMODE"),
          (r.IS_REVERSE_HEIGHT = "IS_REVERSE_HEIGHT"),
          (r.CUSTOM_TEXTURE_OPTIONS = "CUSTOM_TEXTURE_OPTIONS"),
          (r.YARRAYFILTER = "YARRAYFILTER"),
          (r.SURFACE_RENDER_ORDER = "SURFACE_RENDER_ORDER"),
          (r.RENDER_LAYER = "RENDER_LAYER");
      },
      90182: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RubberBandSvgRect = void 0);
        const i = r(55023),
          o = r(86572);
        class a extends i.DeletableEntity {
          constructor(e, t, r, i) {
            super(),
              (this.svgTemplate = s),
              (this.x1Property = 0),
              (this.x2Property = 0),
              (this.y1Property = 0),
              (this.y2Property = 0),
              (this.isHiddenProperty = !0),
              (this.svgRoot = e),
              this.create(t, r, i);
          }
          get x1() {
            return this.x1Property;
          }
          set x1(e) {
            (this.x1Property = e), this.notifyPropertyChanged(o.PROPERTY.X1);
          }
          get x2() {
            return this.x2Property;
          }
          set x2(e) {
            (this.x2Property = e), this.notifyPropertyChanged(o.PROPERTY.X2);
          }
          get y1() {
            return this.y1Property;
          }
          set y1(e) {
            (this.y1Property = e), this.notifyPropertyChanged(o.PROPERTY.Y1);
          }
          get y2() {
            return this.y2Property;
          }
          set y2(e) {
            (this.y2Property = e), this.notifyPropertyChanged(o.PROPERTY.Y2);
          }
          get isHidden() {
            return this.isHiddenProperty;
          }
          set isHidden(e) {
            (this.isHiddenProperty = e),
              this.notifyPropertyChanged(o.PROPERTY.IS_HIDDEN);
          }
          clear() {
            this.svgRoot.removeChild(this.svg);
          }
          delete() {
            this.clear();
          }
          create(e, t, r) {
            if ((this.svg && this.clear(), this.svgRoot)) {
              const i = this.svgTemplate(e, t, r, 0, 0);
              this.svgRoot.appendChild(i),
                (this.svg = i),
                this.svg.setAttribute("x", "100px"),
                this.svg.setAttribute("y", "100px");
            }
          }
          update(e) {
            if (this.svgRoot) {
              if (
                (e === o.PROPERTY.IS_HIDDEN &&
                  (this.svg.style.display = this.isHidden ? "none" : "block"),
                e === o.PROPERTY.X1 || e === o.PROPERTY.X2)
              ) {
                const e = Math.abs(this.x2 - this.x1);
                this.svg.setAttribute("x", this.x1.toString()),
                  this.svg.setAttribute("width", `${e}px`);
              }
              if (e === o.PROPERTY.Y1 || e === o.PROPERTY.Y2) {
                const e = Math.abs(this.y2 - this.y1);
                this.svg.setAttribute("y", this.y1.toString()),
                  this.svg.setAttribute("height", `${e}px`);
              }
            }
          }
          notifyPropertyChanged(e) {
            this.update(e);
          }
        }
        t.RubberBandSvgRect = a;
        const s = (e, t, r, i = 0, o = 0) => {
          const a = "http://www.w3.org/2000/svg",
            s = document.createElementNS(a, "svg");
          s.setAttributeNS(null, "width", i.toString()),
            s.setAttributeNS(null, "height", o.toString()),
            (s.style.display = "none");
          const n = document.createElementNS(a, "rect");
          return (
            s.appendChild(n),
            n.setAttributeNS(null, "width", "100%"),
            n.setAttributeNS(null, "height", "100%"),
            n.setAttributeNS(null, "fill", e),
            n.setAttributeNS(null, "stroke", t),
            n.setAttributeNS(null, "stroke-width", r.toString()),
            s
          );
        };
      },
      86572: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).IS_HIDDEN = "IS_HIDDEN"),
          (r.X1 = "X1"),
          (r.X2 = "X2"),
          (r.Y1 = "Y1"),
          (r.Y2 = "Y2");
      },
      85479: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartDefaults = void 0);
        const i = r(24149);
        class o {}
        (t.SciChartDefaults = o),
          (o.useSharedCache = !1),
          (o.debugDisableResampling = !1),
          (o.performanceWarnings = !0),
          (o.useNativeText = !0),
          (o.nativeFontTimeout = 2e3),
          (o.watermarkPosition = i.EWatermarkPosition.BottomLeft),
          (o.watermarkRelativeToCanvas = !1),
          (o.wasmBufferSizesKb = 8192),
          (o.createSuspended = !1);
      },
      36544: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartOverview = void 0);
        const o = r(12193),
          a = r(55023),
          s = r(98140),
          n = r(12785),
          l = r(2192),
          d = r(55526),
          h = r(59516),
          u = r(51392),
          c = r(54948),
          p = r(84626);
        class g extends a.DeletableEntity {
          constructor(e, t, r, i, o, a) {
            super(),
              (this.overviewXAxisProperty = o),
              (this.overviewYAxisProperty = a),
              (this.rangeSelectionModifierProperty = i),
              (this.parentSciChartSurfaceProperty = e),
              (this.overviewSciChartSurfaceProperty = t),
              (this.overviewWasmContext = r);
          }
          static create(e, t, r) {
            return i(this, void 0, void 0, function* () {
              const {
                sciChartSurface: i,
                wasmContext: o,
                rangeSelectionModifier: a,
                xAxis: s,
                yAxis: n,
              } = yield y(e, t, r);
              return new g(e, i, o, a, s, n);
            });
          }
          get overviewSciChartSurface() {
            return this.overviewSciChartSurfaceProperty;
          }
          get parentSciChartSurface() {
            return this.parentSciChartSurfaceProperty;
          }
          get rangeSelectionModifier() {
            return this.rangeSelectionModifierProperty;
          }
          get overviewXAxis() {
            return this.overviewXAxisProperty;
          }
          get overviewYAxis() {
            return this.overviewYAxisProperty;
          }
          applyTheme(e) {
            this.overviewSciChartSurface.applyTheme(e);
          }
          delete() {
            this.overviewSciChartSurface &&
              !this.overviewSciChartSurface.isDeleted &&
              this.overviewSciChartSurface.delete(),
              (this.overviewWasmContext = void 0);
          }
        }
        t.SciChartOverview = g;
        const y = (e, t, r) =>
          i(void 0, void 0, void 0, function* () {
            var i, a, g, y;
            const { wasmContext: f, sciChartSurface: v } =
                yield p.SciChartSurface.create(t, r),
              m = null == r ? void 0 : r.mainAxisId,
              S = null == r ? void 0 : r.secondaryAxisId,
              P =
                null !== (i = e.getXAxisById(m)) && void 0 !== i
                  ? i
                  : e.getDefaultXAxis(),
              C =
                null !== (a = e.getYAxisById(S)) && void 0 !== a
                  ? a
                  : e.getDefaultYAxis();
            if (!P)
              throw new Error(
                `Could not find a main axis with id ${m}.` +
                  ((null == r ? void 0 : r.mainAxisId)
                    ? ""
                    : "Please specify mainAxisId in the options")
              );
            if (!P)
              throw new Error(
                `Could not find a secondary axis with id ${S}.` +
                  ((null == r ? void 0 : r.secondaryAxisId)
                    ? ""
                    : "Please specify secondaryAxisId in the options")
              );
            const b = P.isXAxis ? P : C,
              x = P.isXAxis ? C : P,
              A = Object.assign(
                {
                  axisAlignment: b.axisAlignment,
                  isVisible: !1,
                  autoRange: n.EAutoRange.Always,
                  visibleRange: b.visibleRange,
                },
                null == r ? void 0 : r.overviewXAxisOptions
              ),
              T = Object.assign(
                {
                  axisAlignment: x.axisAlignment,
                  isVisible: !1,
                  autoRange: n.EAutoRange.Always,
                  visibleRange: x.visibleRange,
                },
                null == r ? void 0 : r.overviewYAxisOptions
              ),
              E = b.isCategoryAxis
                ? new h.CategoryAxis(f, A)
                : b.type === l.EAxisType.LogarithmicAxis
                ? new u.LogarithmicAxis(f, A)
                : new c.NumericAxis(f, A),
              R = x.isCategoryAxis
                ? new h.CategoryAxis(f, T)
                : b.type === l.EAxisType.LogarithmicAxis
                ? new u.LogarithmicAxis(f, T)
                : new c.NumericAxis(f, T),
              D = P.isXAxis ? E : R,
              w = e.renderableSeries
                .asArray()
                .map(
                  null !==
                    (g = null == r ? void 0 : r.transformRenderableSeries) &&
                    void 0 !== g
                    ? g
                    : (e) => {
                        var t, r;
                        if (
                          (null === (t = e.xAxis) || void 0 === t
                            ? void 0
                            : t.id) !== b.id ||
                          (null === (r = e.yAxis) || void 0 === r
                            ? void 0
                            : r.id) !== x.id
                        )
                          return;
                        const [i] = (0, o.buildSeries)(f, e.toJSON(!0));
                        return (
                          i.dataSeries.delete(),
                          (i.dataSeries = e.dataSeries),
                          (i.xAxisId = E.id),
                          (i.yAxisId = R.id),
                          i
                        );
                      }
                )
                .filter((e) => e);
            v.xAxes.add(E),
              v.yAxes.add(R),
              v.renderableSeries.add(...w),
              v.zoomExtents();
            const M =
              null !==
                (y = null == r ? void 0 : r.customRangeSelectionModifier) &&
              void 0 !== y
                ? y
                : new d.OverviewRangeSelectionModifier();
            return (
              (M.xAxisId = E.id),
              (M.yAxisId = R.id),
              (M.onSelectedAreaChanged = (e) => {
                e.equals(P.visibleRange) || P.setVisibleRangeWithLimits(e);
              }),
              (M.selectedArea = new s.NumberRange(
                Math.max(E.visibleRange.min, P.visibleRange.min),
                Math.min(E.visibleRange.max, P.visibleRange.max)
              )),
              v.chartModifiers.add(M),
              void 0 !==
                (null == r ? void 0 : r.rangeSelectionAnnotationSvgString) &&
                (M.rangeSelectionAnnotation.svgString =
                  r.rangeSelectionAnnotationSvgString),
              E.visibleRangeChanged.subscribe(({ visibleRange: e }) => {
                const t = P.visibleRange.clip(e);
                M.selectedArea = t;
              }),
              P.visibleRangeChanged.subscribe(({ visibleRange: e }) => {
                const t = e.clip(D.visibleRange);
                !t.equals(M.selectedArea) && (M.selectedArea = t);
              }),
              {
                sciChartSurface: v,
                xAxis: E,
                yAxis: R,
                rangeSelectionModifier: M,
                wasmContext: f,
              }
            );
          });
      },
      57419: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PieSegment = void 0);
        const i = r(45921),
          o = r(75772),
          a = r(11043),
          s = r(73538),
          n = r(92596),
          l = r(79423);
        t.PieSegment = class {
          constructor(e) {
            var t, r, n, l, d, h, u, c, p, g;
            (this.colorProperty = "grey"),
              (this.isSelectedProperty = !1),
              (this.textProperty = ""),
              (this.deltaProperty = 15),
              (this.shiftProperty = 0),
              (this.labelOffsetProperty = new o.Point(0, 0)),
              (this.radiusAdjustmentProperty = 1),
              (this.id =
                null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                  ? t
                  : (0, s.generateGuid)()),
              (this.colorProperty =
                null !== (r = null == e ? void 0 : e.color) && void 0 !== r
                  ? r
                  : this.colorProperty),
              (this.colorLinearGradientProperty =
                null !== (n = null == e ? void 0 : e.colorLinearGradient) &&
                void 0 !== n
                  ? n
                  : this.colorLinearGradientProperty),
              (this.isSelectedProperty =
                null !== (l = null == e ? void 0 : e.isSelected) && void 0 !== l
                  ? l
                  : this.isSelectedProperty),
              (this.textProperty =
                null !== (d = null == e ? void 0 : e.text) && void 0 !== d
                  ? d
                  : this.textProperty),
              (this.valueProperty =
                null !== (h = null == e ? void 0 : e.value) && void 0 !== h
                  ? h
                  : this.valueProperty),
              (this.deltaProperty =
                null !== (u = null == e ? void 0 : e.delta) && void 0 !== u
                  ? u
                  : this.deltaProperty),
              (this.showLabelProperty =
                null === (c = null == e ? void 0 : e.showLabel) ||
                void 0 === c ||
                c),
              (null == e ? void 0 : e.labelProvider) &&
                ("getSegmentText" in (null == e ? void 0 : e.labelProvider) ||
                  (e.labelProvider = (0, i.createType)(
                    a.EBaseType.LabelProvider,
                    e.labelProvider.type,
                    void 0,
                    e.labelProvider.options
                  ))),
              (this.labelProviderProperty =
                null == e ? void 0 : e.labelProvider),
              (this.labelOffsetProperty =
                null !== (p = null == e ? void 0 : e.labelOffset) &&
                void 0 !== p
                  ? p
                  : this.labelOffsetProperty),
              (this.labelStyleProperty = null == e ? void 0 : e.labelStyle),
              (this.radiusAdjustmentProperty =
                null !== (g = null == e ? void 0 : e.radiusAdjustment) &&
                void 0 !== g
                  ? g
                  : this.radiusAdjustmentProperty);
          }
          onAttach(e) {
            (this.parentSurface = e),
              this.labelProviderProperty &&
                this.labelProviderProperty.attachedToSurface(e),
              (this.invalidateParentCallback = e.invalidateElement);
          }
          onDetach() {
            this.invalidateParentCallback = void 0;
          }
          get showLabel() {
            return this.showLabelProperty;
          }
          set showLabel(e) {
            (this.showLabelProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.SHOW_LABEL);
          }
          get colorLinearGradient() {
            return this.colorLinearGradientProperty;
          }
          set colorLinearGradient(e) {
            (this.colorLinearGradientProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.COLOR_LINEAR_GRADIENT);
          }
          get color() {
            return this.colorProperty;
          }
          set color(e) {
            (this.colorProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.COLOR);
          }
          get isSelected() {
            return this.isSelectedProperty;
          }
          set isSelected(e) {
            this.isSelectedProperty !== e &&
              ((this.isSelectedProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.IS_SELECTED));
          }
          get text() {
            return this.textProperty;
          }
          set text(e) {
            (this.textProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.TEXT);
          }
          get labelProvider() {
            return (
              void 0 === this.labelProviderProperty &&
                (this.labelProvider = new n.PieLabelProvider()),
              this.labelProviderProperty
            );
          }
          set labelProvider(e) {
            (this.labelProviderProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.LABEL_PROVIDER);
          }
          getPercentage(e) {
            return (100 * this.value) / e;
          }
          get value() {
            return this.valueProperty;
          }
          set value(e) {
            (this.oldValueProperty = this.valueProperty),
              (this.valueProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.VALUE);
          }
          get oldValue() {
            return this.oldValueProperty;
          }
          get delta() {
            return this.deltaProperty;
          }
          set delta(e) {
            this.deltaProperty !== e &&
              ((this.deltaProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.DELTA));
          }
          get shift() {
            return this.shiftProperty;
          }
          set shift(e) {
            this.shiftProperty !== e &&
              ((this.shiftProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.SHIFT));
          }
          get labelStyle() {
            var e;
            return Object.assign(
              Object.assign(
                {},
                null === (e = this.parentSurface) || void 0 === e
                  ? void 0
                  : e.labelStyle
              ),
              this.labelStyleProperty
            );
          }
          set labelStyle(e) {
            (this.labelStyleProperty = Object.assign(
              Object.assign({}, this.labelStyleProperty),
              e
            )),
              this.notifyPropertyChanged(l.PROPERTY.LABEL_STYLE);
          }
          get labelOffset() {
            return this.labelOffsetProperty;
          }
          set labelOffset(e) {
            var t, r;
            (null === (t = this.labelOffsetProperty) || void 0 === t
              ? void 0
              : t.x) !== e.x &&
              (null === (r = this.labelOffsetProperty) || void 0 === r
                ? void 0
                : r.y) !== e.y &&
              ((this.labelOffsetProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.LABEL_OFFSET));
          }
          get radiusAdjustment() {
            return this.radiusAdjustmentProperty;
          }
          set radiusAdjustment(e) {
            (this.radiusAdjustmentProperty = e),
              this.notifyPropertyChanged(l.PROPERTY.RADIUS_ADJUSTMENT);
          }
          toJSON() {
            var e;
            return {
              id: this.id,
              color: this.color,
              colorLinearGradient: this.colorLinearGradient,
              isSelected: this.isSelected,
              delta: this.delta,
              text: this.text,
              value: this.value,
              labelProvider:
                null === (e = this.labelProviderProperty) || void 0 === e
                  ? void 0
                  : e.toJSON(),
              labelOffset: this.labelOffset,
              labelStyle: this.labelStyle,
              radiusAdjustment: this.radiusAdjustment,
            };
          }
          getLabelText(e) {
            return this.labelProviderProperty
              ? this.labelProvider.getSegmentText(this, e)
              : this.parentSurface.labelProvider.getSegmentText(this, e);
          }
          notifyPropertyChanged(e) {
            e === l.PROPERTY.LABEL_PROVIDER &&
              this.labelProviderProperty &&
              this.labelProviderProperty.attachedToSurface(this.parentSurface),
              this.invalidateParentCallback && this.invalidateParentCallback(e);
          }
        };
      },
      79423: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).COLOR = "COLOR"),
          (r.COLOR_LINEAR_GRADIENT = "COLOR_LINEAR_GRADIENT"),
          (r.DELTA = "DELTA"),
          (r.IS_SELECTED = "IS_SELECTED"),
          (r.PERCENTAGE = "PERCENTAGE"),
          (r.TEXT = "TEXT"),
          (r.VALUE = "VALUE"),
          (r.SHIFT = "SHIFT"),
          (r.LABEL_PROVIDER = "LABEL_PROVIDER"),
          (r.LABEL_STYLE = "LABEL_STYLE"),
          (r.LABEL_OFFSET = "LABEL_OFFSET"),
          (r.RADIUS_ADJUSTMENT = "RADIUS_ADJUSTMENT"),
          (r.SHOW_LABEL = "SHOW_LABEL");
      },
      79548: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.addEventListenerToPieSegment =
            t.SciChartPieSurface =
            t.EPieValueMode =
            t.EPieType =
            t.ESizingMode =
              void 0);
        const i = r(45921),
          o = r(84745),
          a = r(10276),
          s = r(55023),
          n = r(56744),
          l = r(3214),
          d = r(99263),
          h = r(37796),
          u = r(87459),
          c = r(11043),
          p = r(91465),
          g = r(52578),
          y = r(73538),
          f = r(99016),
          v = r(92415),
          m = r(92596),
          S = r(28243),
          P = r(25606),
          C = r(14184),
          b = r(86127),
          x = r(6340),
          A = r(79423),
          T = Math.PI / 180;
        var E, R, D;
        !(function (e) {
          (e.Absolute = "Absolute"), (e.Relative = "Relative");
        })((E = t.ESizingMode || (t.ESizingMode = {}))),
          (function (e) {
            (e.Pie = "Pie"), (e.Donut = "Donut");
          })((R = t.EPieType || (t.EPieType = {}))),
          (function (e) {
            (e.Percentage = "Percentage"), (e.Raw = "Raw");
          })((D = t.EPieValueMode || (t.EPieValueMode = {})));
        class w extends s.DeletableEntity {
          constructor(e = {}, t) {
            var r, a, s, n, d, p, v, x, A, T, w, M, L, O, I, k;
            super(),
              (this.animate = !0),
              (this.animationFrames = 30),
              (this.rendered = new l.EventHandler()),
              (this.pieTypeProperty = R.Pie),
              (this.holeRadiusProperty = 0.5),
              (this.holeRadiusSizingModeProperty = E.Relative),
              (this.seriesSpacingProperty = 0),
              (this.labelRadiusProperty = 1),
              (this.titleDivs = []),
              (this.sweepAnimationDone = !1),
              (this.suspendUpdate = !1),
              (this.themeProviderProperty = new f.SciChartJSDarkTheme()),
              (this.previousThemeProviderProperty =
                new f.SciChartJSDarkTheme()),
              (this.deletables = []),
              (this.valueModeProperty = D.Percentage),
              (this.labelStyleProperty = {
                fontSize: 14,
                fontFamily: g.DEFAULT_FONT_FAMILY,
                color: "#1e323d",
                fontWeight: "bold",
              }),
              (this.id =
                null !== (r = null == t ? void 0 : t.id) && void 0 !== r
                  ? r
                  : (0, y.generateGuid)()),
              (this.domChartRoot = e.domChartRoot),
              (this.domCanvas2D = e.domCanvas2D),
              (this.domSvgContainer = e.domSvgContainer),
              (this.domSvgAdornerLayer = e.domSvgAdornerLayer),
              (this.domDivContainer = e.domDivContainer),
              (this.domBackgroundSvgContainer = e.domBackgroundSvgContainer);
            const _ = this.domCanvas2D.width / b.DpiHelper.PIXEL_RATIO,
              V = this.domCanvas2D.height / b.DpiHelper.PIXEL_RATIO;
            (this.viewRectProperty = new u.Rect(0, 0, _, V)),
              o.IS_TEST_ENV ||
                (this.resizeSubscriptionToken = P.default.subscribeToResize(
                  e.domCanvas2D,
                  e.aspect,
                  this
                )),
              (this.drawChart = this.drawChart.bind(this)),
              (this.deleteInternals = this.deleteInternals.bind(this)),
              (this.invalidateElement = this.invalidateElement.bind(this)),
              (this.detachPieSegment = this.detachPieSegment.bind(this)),
              (this.attachPieSegment = this.attachPieSegment.bind(this)),
              (this.pieSegments = new h.ObservableArray()),
              o.IS_TEST_ENV ||
                this.pieSegments.collectionChanged.subscribe((e) => {
                  var t, r;
                  null === (t = e.getOldItems()) ||
                    void 0 === t ||
                    t.forEach(this.detachPieSegment),
                    null === (r = e.getNewItems()) ||
                      void 0 === r ||
                      r.forEach(this.attachPieSegment),
                    this.invalidateElement();
                }),
              this.applySciChartBackground(
                C.SciChartSurfaceBase.DEFAULT_THEME.sciChartBackground
              ),
              (this.legend = new S.SciChartPieLegend()),
              this.legend.setRootDiv(this.domDivContainer),
              this.legend.setPieSegmentArray(this.pieSegments.asArray()),
              this.legend.setInvalidateParentSurface(this.invalidateElement),
              this.legend.setParentSurface(this),
              (this.heightAspect =
                null !== (a = null == t ? void 0 : t.heightAspect) &&
                void 0 !== a
                  ? a
                  : 0),
              (this.widthAspect =
                null !== (s = null == t ? void 0 : t.widthAspect) &&
                void 0 !== s
                  ? s
                  : 0),
              (this.pieTypeProperty =
                null !== (n = null == t ? void 0 : t.pieType) && void 0 !== n
                  ? n
                  : this.pieType),
              (this.holeRadiusProperty =
                null !== (d = null == t ? void 0 : t.holeRadius) && void 0 !== d
                  ? d
                  : this.holeRadius),
              (this.animate =
                null !== (p = null == t ? void 0 : t.animate) && void 0 !== p
                  ? p
                  : this.animate),
              (this.holeRadiusSizingModeProperty =
                null !== (v = null == t ? void 0 : t.holeRadiusSizingMode) &&
                void 0 !== v
                  ? v
                  : this.holeRadiusSizingModeProperty),
              (this.seriesSpacingProperty =
                null !== (x = null == t ? void 0 : t.seriesSpacing) &&
                void 0 !== x
                  ? x
                  : this.seriesSpacingProperty),
              (this.labelRadiusProperty =
                null !== (A = null == t ? void 0 : t.labelRadiusAdjustment) &&
                void 0 !== A
                  ? A
                  : this.labelRadiusProperty),
              (this.legend.showLegend =
                null !== (T = null == t ? void 0 : t.showLegend) && void 0 !== T
                  ? T
                  : this.legend.showLegend),
              (this.legend.animate =
                null !== (w = null == t ? void 0 : t.animateLegend) &&
                void 0 !== w
                  ? w
                  : this.legend.animate),
              (this.legend.showCheckboxes =
                null !== (M = null == t ? void 0 : t.showLegendCheckBoxes) &&
                void 0 !== M
                  ? M
                  : this.legend.showCheckboxes),
              (this.legend.showSeriesMarkers =
                null !== (L = null == t ? void 0 : t.showLegendSeriesMarkers) &&
                void 0 !== L
                  ? L
                  : this.legend.showSeriesMarkers),
              (this.paddingProperty =
                null !== (O = null == t ? void 0 : t.padding) && void 0 !== O
                  ? O
                  : this.paddingProperty),
              (null == t ? void 0 : t.labelProvider) &&
                ("getSegmentText" in (null == t ? void 0 : t.labelProvider) ||
                  (t.labelProvider = (0, i.createType)(
                    c.EBaseType.LabelProvider,
                    t.labelProvider.type,
                    void 0,
                    t.labelProvider.options
                  ))),
              (this.labelProvider =
                null !== (I = null == t ? void 0 : t.labelProvider) &&
                void 0 !== I
                  ? I
                  : new m.PieLabelProvider()),
              (this.valueModeProperty =
                null !== (k = null == t ? void 0 : t.valueMode) && void 0 !== k
                  ? k
                  : this.valueModeProperty);
          }
          static create(e, t) {
            var r, i;
            const o = P.default.initCanvas(
              e,
              null !== (r = null == t ? void 0 : t.widthAspect) && void 0 !== r
                ? r
                : 0,
              null !== (i = null == t ? void 0 : t.heightAspect) && void 0 !== i
                ? i
                : 0,
              P.default.ECanvasType.svg,
              void 0,
              null == t ? void 0 : t.touchAction
            );
            return new Promise((e) => {
              var r, i, a;
              [
                ...d.sciChartDestinations,
                ...d.sciChart3DDestinations,
                ...d.sciChartSingleDestinations,
                ...d.sciChartPieDestinations,
              ]
                .filter(
                  (e) => e.sciChartSurface.domChartRoot.id === o.domChartRoot.id
                )
                .forEach((e) => e.sciChartSurface.delete()),
                (t = C.SciChartSurfaceBase.resolveOptions(t));
              const s = new w(o, t);
              s.applyTheme(null == t ? void 0 : t.theme),
                d.sciChartPieDestinations.push({
                  canvasElementId:
                    null === (r = o.domCanvas2D) || void 0 === r
                      ? void 0
                      : r.id,
                  sciChartSurface: s,
                  width:
                    null === (i = o.domCanvas2D) || void 0 === i
                      ? void 0
                      : i.width,
                  height:
                    null === (a = o.domCanvas2D) || void 0 === a
                      ? void 0
                      : a.height,
                }),
                s.setDestinations(d.sciChartPieDestinations),
                setTimeout(() => e(s), 0);
            });
          }
          get isDeleted() {
            return this.isDeletedProperty;
          }
          get labelProvider() {
            return this.labelProviderProperty;
          }
          set labelProvider(e) {
            e &&
              this.labelProviderProperty !== e &&
              ((this.labelProviderProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.LABEL_PROVIDER));
          }
          get labelStyle() {
            return this.labelStyleProperty;
          }
          set labelStyle(e) {
            (this.labelStyleProperty = Object.assign(
              Object.assign({}, this.labelStyle),
              e
            )),
              this.notifyPropertyChanged(x.PROPERTY.TEXT_STYLE);
          }
          applyTheme(e) {
            (this.previousThemeProviderProperty = this.themeProviderProperty),
              (this.themeProviderProperty = e),
              this.applySciChartBackground(e.sciChartBackground),
              this.labelStyle.color ===
                this.previousThemeProvider.tickTextBrush &&
                (this.labelStyle = { color: e.tickTextBrush }),
              this.invalidateElement();
          }
          get themeProvider() {
            return this.themeProviderProperty;
          }
          get previousThemeProvider() {
            return this.previousThemeProviderProperty;
          }
          setDestinations(e) {
            this.destinations = e;
          }
          get otherSurfaces() {
            return this.destinations
              ? this.destinations
                  .map((e) => e.sciChartSurface)
                  .filter((e) => e !== this)
              : [];
          }
          invalidateElement(e) {
            this.isValidToDraw() &&
              ("string" == typeof e &&
                e === A.PROPERTY.VALUE &&
                (this.sweepAnimationDone = !1),
              this.update());
          }
          update() {
            var e;
            this.suspendUpdate ||
              (this.draw(),
              null === (e = this.legend) || void 0 === e || e.update());
          }
          delete() {
            var e;
            this.deleteInternals(),
              (this.legend = (0, n.deleteSafe)(this.legend)),
              (this.labelProvider = (0, n.deleteSafe)(this.labelProvider)),
              (this.resizeSubscriptionToken = (0, n.deleteSafe)(
                this.resizeSubscriptionToken
              ));
            const t =
              null === (e = this.destinations) || void 0 === e
                ? void 0
                : e.findIndex((e) => e.sciChartSurface.id === this.id);
            t >= 0 && this.destinations.splice(t, 1),
              (this.isDeletedProperty = !0);
          }
          deleteInternals(e) {
            this.svg &&
              (this.domSvgContainer.removeChild(this.svg), (this.svg = void 0)),
              e ||
                (this.titleDivs.forEach((e) => {
                  this.domDivContainer.removeChild(e);
                }),
                (this.titleDivs = []));
            for (const e of this.deletables) (0, n.deleteSafe)(e);
            this.deletables = [];
          }
          addDeletable(e) {
            this.deletables.push(e);
          }
          changeViewportSize(e, t) {
            const r = e,
              i = t;
            (this.viewRectProperty = new u.Rect(0, 0, e, t)),
              this.changeDomViewportSize(r, i),
              this.invalidateElement();
          }
          get pieType() {
            return this.pieTypeProperty;
          }
          set pieType(e) {
            (this.pieTypeProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.PIE_TYPE);
          }
          get holeRadius() {
            return this.holeRadiusProperty;
          }
          set holeRadius(e) {
            (this.holeRadiusProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.HOLE_RADIUS);
          }
          get holeRadiusSizingMode() {
            return this.holeRadiusSizingModeProperty;
          }
          set holeRadiusSizingMode(e) {
            (this.holeRadiusSizingModeProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.HOLE_RADIUS_SIZING_MODE);
          }
          get padding() {
            return this.paddingProperty;
          }
          set padding(e) {
            this.paddingProperty !== e &&
              ((this.paddingProperty = e),
              this.updateLegendMargin(),
              this.notifyPropertyChanged(x.PROPERTY.PADDING));
          }
          get canvasBorder() {
            return this.canvasBorderProperty;
          }
          set canvasBorder(e) {
            this.canvasBorderProperty !== e &&
              ((this.canvasBorderProperty = e),
              this.updateLegendMargin(),
              this.notifyPropertyChanged(x.PROPERTY.PADDING));
          }
          get seriesSpacing() {
            return this.seriesSpacingProperty;
          }
          set seriesSpacing(e) {
            this.seriesSpacingProperty !== e &&
              ((this.seriesSpacingProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.SERIES_SPACING));
          }
          get valueMode() {
            return this.valueModeProperty;
          }
          set valueMode(e) {
            (this.valueModeProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.VALUE_MODE);
          }
          get labelRadiusAdjustment() {
            return this.labelRadiusProperty;
          }
          set labelRadiusAdjustment(e) {
            (this.labelRadiusProperty = e),
              this.notifyPropertyChanged(x.PROPERTY.VALUE_MODE);
          }
          get chartModifierGroups() {
            throw Error(
              "chartModifierGroups property is not supported for SciChartPieSurface"
            );
          }
          get seriesViewRect() {
            throw Error(
              "seriesViewRect property is not supported for SciChartPieSurface"
            );
          }
          get clipRect() {
            throw Error(
              "clipRect property is not supported for SciChartPieSurface"
            );
          }
          get viewRect() {
            return this.viewRectProperty;
          }
          get mouseManager() {
            throw Error(
              "mouseManager property is not supported for SciChartPieSurface"
            );
          }
          set mouseManager(e) {
            throw Error(
              "mouseManager property is not supported for SciChartPieSurface"
            );
          }
          get domCanvasWebGL() {
            throw Error(
              "domCanvasWebGL property is not supported for SciChartPieSurface"
            );
          }
          set domCanvasWebGL(e) {
            throw Error(
              "domCanvasWebGL property is not supported for SciChartPieSurface"
            );
          }
          get background() {
            throw Error(
              "background property is not supported for SciChartPieSurface"
            );
          }
          set background(e) {
            throw Error(
              "background property is not supported for SciChartPieSurface"
            );
          }
          get annotations() {
            throw Error(
              "annotations property is not supported for SciChartPieSurface"
            );
          }
          get chartModifiers() {
            throw Error(
              "chartModifiers property is not supported for SciChartPieSurface"
            );
          }
          setIsInitialized() {
            throw Error(
              "setIsInitialized method is not supported for SciChartPieSurface"
            );
          }
          getMainCanvas() {
            throw Error(
              "getMainCanvas method is not supported for SciChartPieSurface"
            );
          }
          getOptions() {
            let e;
            return (
              (e =
                "toJSON" in this.themeProvider
                  ? this.themeProvider.toJSON()
                  : this.themeProvider),
              {
                animate: this.animate,
                animateLegend: this.legend.animate,
                heightAspect: this.heightAspect,
                widthAspect: this.widthAspect,
                holeRadius: this.holeRadius,
                holeRadiusSizingMode: this.holeRadiusSizingMode,
                pieType: this.pieType,
                showLegend: this.legend.showLegend,
                showLegendCheckBoxes: this.legend.showCheckboxes,
                showLegendSeriesMarkers: this.legend.showSeriesMarkers,
                padding: this.padding,
                canvasBorder: this.canvasBorder,
                seriesSpacing: this.seriesSpacing,
                labelProvider: this.labelProvider.toJSON(),
                valueMode: this.valueMode,
                labelRadiusAdjustment: this.labelRadiusAdjustment,
                animationFrames: this.animationFrames,
                theme: e,
              }
            );
          }
          toJSON(e = !1) {
            const t = this.getOptions();
            return {
              type: p.ESciChartSurfaceType.Pie2D,
              surface: t,
              onCreated: this.onCreatedName,
              segments: e
                ? void 0
                : this.pieSegments.asArray().map((e) => e.toJSON()),
            };
          }
          calcTitlePosition(e, t, r, i, o, a, s, n, l) {
            const d = i < r / 2 ? (2 * r) / 3 + i / 6 : (r + i) / 2,
              h = (o + a) / 2;
            return {
              left:
                e +
                Math.cos(T * h) * (d * this.labelRadiusProperty + s) -
                n / 2,
              top:
                t +
                Math.sin(T * h) * (d * this.labelRadiusProperty + s) -
                l / 2,
            };
          }
          changeDomViewportSize(e, t) {
            this.domSvgContainer &&
              (this.domSvgContainer.setAttribute("width", e.toString()),
              this.domSvgContainer.setAttribute("height", t.toString())),
              this.domSvgAdornerLayer &&
                (this.domSvgAdornerLayer.setAttribute("width", e.toString()),
                this.domSvgAdornerLayer.setAttribute("height", t.toString()));
          }
          notifyPropertyChanged(e) {
            this.invalidateElement(),
              e === x.PROPERTY.LABEL_PROVIDER &&
                this.labelProviderProperty &&
                this.labelProviderProperty.attachedToSurface(this);
          }
          isValidToDraw() {
            return !0;
          }
          detachPieSegment(e) {
            e.onDetach();
          }
          attachPieSegment(e) {
            e.onAttach(this);
          }
          updateLegendMargin() {
            var e, t, r;
            const i =
                (null === (e = this.padding) || void 0 === e
                  ? void 0
                  : e.top) || 0,
              o =
                (null === (t = this.canvasBorder) || void 0 === t
                  ? void 0
                  : t.border) ||
                (null === (r = this.canvasBorder) || void 0 === r
                  ? void 0
                  : r.borderTop) ||
                0;
            this.legend.margin = i + o + 10;
          }
          calculateViewRectWidth(e) {
            var t, r, i, o, a;
            return (
              (null === (t = this.padding) || void 0 === t ? void 0 : t.left) &&
                (e -= this.padding.left),
              (null === (r = this.padding) || void 0 === r
                ? void 0
                : r.right) && (e -= this.padding.right),
              (
                null === (i = this.canvasBorder) || void 0 === i
                  ? void 0
                  : i.border
              )
                ? (e -= 2 * this.canvasBorder.border)
                : ((null === (o = this.canvasBorder) || void 0 === o
                    ? void 0
                    : o.borderLeft) && (e -= this.canvasBorder.borderLeft),
                  (null === (a = this.canvasBorder) || void 0 === a
                    ? void 0
                    : a.borderRight) && (e -= this.canvasBorder.borderRight)),
              e
            );
          }
          calculateViewRectHeight(e) {
            var t, r, i, o, a;
            return (
              (null === (t = this.padding) || void 0 === t ? void 0 : t.top) &&
                (e -= this.padding.top),
              (null === (r = this.padding) || void 0 === r
                ? void 0
                : r.bottom) && (e -= this.padding.bottom),
              (
                null === (i = this.canvasBorder) || void 0 === i
                  ? void 0
                  : i.border
              )
                ? (e -= 2 * this.canvasBorder.border)
                : ((null === (o = this.canvasBorder) || void 0 === o
                    ? void 0
                    : o.borderTop) && (e -= this.canvasBorder.borderTop),
                  (null === (a = this.canvasBorder) || void 0 === a
                    ? void 0
                    : a.borderBottom) && (e -= this.canvasBorder.borderBottom)),
              e
            );
          }
          draw() {
            if (0 !== this.pieSegments.size()) {
              if (this.sweepAnimationDone || !this.animate)
                this.deleteInternals(), this.drawChart();
              else {
                const e = this.animationFrames;
                this.suspendUpdate = !0;
                const t = () => (this.suspendUpdate = !1),
                  r = () => (this.sweepAnimationDone = !0),
                  i = this.invalidateElement,
                  o = this.drawChart,
                  a = this.deleteInternals;
                !(function s(n) {
                  setTimeout(() => {
                    const l = n / e;
                    a(!0), o(l), n === e && (t(), r(), i()), ++n <= e && s(n);
                  }, 20);
                })(1);
              }
              o.IS_TEST_ENV ||
                this.pieSegments.asArray().forEach((e) => {
                  const r = this.domChartRoot.querySelector(`[id='${e.id}']`);
                  if (r) {
                    const i = (0, t.addEventListenerToPieSegment)(
                      e,
                      r,
                      this.animate
                    );
                    this.addDeletable(i);
                  }
                }),
                this.rendered.raiseEvent();
            }
          }
          drawChart(e = 1) {
            const t = this.pieSegmentsTotalValue();
            if (!t) return;
            const r = this.themeProviderProperty.sciChartBackground,
              i = this.pieSegments.asArray(),
              o = this.pieSegmentsTotalOldValue(),
              s =
                (0.8 *
                  Math.min(
                    this.calculateViewRectWidth(this.viewRect.width),
                    this.calculateViewRectHeight(this.viewRect.height)
                  )) /
                2;
            let n = 0;
            this.pieType === R.Donut &&
              (n =
                this.holeRadiusSizingMode === E.Absolute
                  ? this.holeRadius
                  : s * this.holeRadius);
            const l = this.calculateViewRectWidth(this.viewRect.width) / 2,
              d = this.calculateViewRectHeight(this.viewRect.height) / 2;
            let h = "<defs>",
              u = "",
              c = 0,
              p = 0;
            i.forEach((i, g) => {
              var y;
              if (0 === i.value) return;
              const f = null !== (y = i.oldValue) && void 0 !== y ? y : 0,
                v = (360 * c) / t - 90,
                m = (360 * (c + i.value)) / t - 90 - 1e-4,
                S = (360 * p) / o - 90,
                P = (360 * (p + f)) / o - 90;
              (c += i.value), (p += f);
              const C = S + (v - S) * a.easing.inOutCubic(e),
                b = P + (m - P) * a.easing.inOutCubic(e),
                x = !!i.colorLinearGradient,
                A = `grad${i.id}`;
              if (x) {
                let e = `<linearGradient id="${A}" x1="${
                  100 * i.colorLinearGradient.startPoint.x
                }%" y1="${100 * i.colorLinearGradient.startPoint.y}%" x2="${
                  100 * i.colorLinearGradient.endPoint.x
                }%" y2="${100 * i.colorLinearGradient.endPoint.y}%">`;
                i.colorLinearGradient.gradientStops.forEach((t) => {
                  const r = 100 * t.offset;
                  e += `<stop offset="${r}%" style="stop-color:${t.color};stop-opacity:1" />`;
                }),
                  (e += "</linearGradient>"),
                  (h += e);
              }
              const T =
                  this.pieType === R.Donut
                    ? L(
                        l,
                        d,
                        s * i.radiusAdjustment,
                        n,
                        C,
                        b,
                        i.shift + this.seriesSpacing
                      )
                    : M(
                        l,
                        d,
                        s * i.radiusAdjustment,
                        C,
                        b,
                        i.shift + this.seriesSpacing
                      ),
                E = x
                  ? `<g fill="url(#${A})"><path id="${i.id}" stroke="${r}" stroke-width="2" d="${T}" /></g>`
                  : `<path id="${i.id}" stroke="${r}" stroke-width="2" d="${T}" fill="${i.color}" />`;
              (u += E),
                (1 === e || i.oldValue) &&
                  this.drawSegmentLabel(
                    i,
                    g,
                    t,
                    C,
                    b,
                    l,
                    d,
                    s * i.radiusAdjustment,
                    n
                  );
            }),
              (h += "</defs>"),
              this.adjustDomContainer();
            const g = `<svg width="${this.calculateViewRectWidth(
                this.viewRect.width
              )}" height="${this.calculateViewRectHeight(
                this.viewRect.height
              )}">${h}${u}</svg>`,
              y = v.annotationHelpers.createSvg(g, this.domSvgContainer);
            this.svg = y;
          }
          adjustDomContainer() {
            var e, t, r, i, o, a;
            this.padding &&
              this.padding.left &&
              (this.domSvgContainer.style.paddingLeft =
                this.padding.left + "px"),
              this.padding &&
                this.padding.right &&
                (this.domSvgContainer.style.paddingRight =
                  this.padding.right + "px"),
              this.padding &&
                this.padding.top &&
                (this.domSvgContainer.style.paddingTop =
                  this.padding.top + "px"),
              this.padding &&
                this.padding.bottom &&
                (this.domSvgContainer.style.paddingBottom =
                  this.padding.bottom + "px"),
              this.canvasBorder &&
                (this.domSvgContainer.style.borderStyle = "solid"),
              (null === (e = this.canvasBorder) || void 0 === e
                ? void 0
                : e.border) &&
                (this.domSvgContainer.style.borderWidth =
                  this.canvasBorder.border + "px"),
              (null === (t = this.canvasBorder) || void 0 === t
                ? void 0
                : t.color) &&
                (this.domSvgContainer.style.borderColor =
                  this.canvasBorder.color),
              (null === (r = this.canvasBorder) || void 0 === r
                ? void 0
                : r.borderBottom) &&
                (this.domSvgContainer.style.borderBottomWidth =
                  this.canvasBorder.borderBottom + "px"),
              (null === (i = this.canvasBorder) || void 0 === i
                ? void 0
                : i.borderTop) &&
                (this.domSvgContainer.style.borderTopWidth =
                  this.canvasBorder.borderTop + "px"),
              (null === (o = this.canvasBorder) || void 0 === o
                ? void 0
                : o.borderLeft) &&
                (this.domSvgContainer.style.borderLeftWidth =
                  this.canvasBorder.borderLeft + "px"),
              (null === (a = this.canvasBorder) || void 0 === a
                ? void 0
                : a.borderRight) &&
                (this.domSvgContainer.style.borderRightWidth =
                  this.canvasBorder.borderRight + "px");
          }
          drawSegmentLabel(e, t, r, i, o, a, s, n, l) {
            var d, h, u, c, p, y, f, v, m, S, P;
            if (!1 === e.showLabel) return;
            const C = "segment" + t;
            let b = this.titleDivs.find((e) => e.id === C);
            b ||
              ((b = document.createElement("div")),
              (b.className = "scichart-pie-text-container"),
              (b.id = C),
              (b.style.position = "absolute"),
              (b.style.pointerEvents = "none"),
              (b.style.padding = "5px"),
              (b.style.borderRadius = "3px"),
              this.titleDivs.push(b),
              this.domDivContainer.appendChild(b),
              (b.style.display = "block")),
              (b.style.color = e.labelStyle.color),
              (b.style.fontWeight = e.labelStyle.fontWeight),
              (b.style.fontFamily = (0, g.getFontFamily)(
                e.labelStyle.fontFamily,
                !1
              )),
              (b.style.fontSize = e.labelStyle.fontSize.toString() + "px"),
              (b.innerHTML = e.getLabelText(r));
            const x = b.offsetWidth,
              A = b.offsetHeight;
            let T = 0,
              E = 0;
            (null === (d = this.padding) || void 0 === d ? void 0 : d.left) &&
              (T +=
                null === (h = this.padding) || void 0 === h ? void 0 : h.left),
              (null === (u = this.padding) || void 0 === u ? void 0 : u.top) &&
                (E +=
                  null === (c = this.padding) || void 0 === c ? void 0 : c.top),
              (
                null === (p = this.canvasBorder) || void 0 === p
                  ? void 0
                  : p.border
              )
                ? ((T +=
                    null === (y = this.canvasBorder) || void 0 === y
                      ? void 0
                      : y.border),
                  (E +=
                    null === (f = this.canvasBorder) || void 0 === f
                      ? void 0
                      : f.border))
                : ((null === (v = this.canvasBorder) || void 0 === v
                    ? void 0
                    : v.borderLeft) &&
                    (T +=
                      null === (m = this.canvasBorder) || void 0 === m
                        ? void 0
                        : m.borderLeft),
                  (null === (S = this.canvasBorder) || void 0 === S
                    ? void 0
                    : S.borderTop) &&
                    (T +=
                      null === (P = this.canvasBorder) || void 0 === P
                        ? void 0
                        : P.borderTop));
            const R = this.calcTitlePosition(
              a + T,
              s + E,
              n,
              l,
              i,
              o,
              e.shift + this.seriesSpacing,
              x,
              A
            );
            (b.style.left = `${R.left + e.labelOffset.x}px`),
              (b.style.top = `${R.top + e.labelOffset.y}px`);
          }
          pieSegmentsTotalValue() {
            return this.pieSegments.asArray().reduce((e, t) => e + t.value, 0);
          }
          pieSegmentsTotalOldValue() {
            const e = this.pieSegments.asArray().reduce((e, t) => {
              var r;
              return e + (null !== (r = t.oldValue) && void 0 !== r ? r : 0);
            }, 0);
            return e > 0 ? e : 1;
          }
          applySciChartBackground(e) {
            this.domCanvas2D.style.background = e;
          }
        }
        t.SciChartPieSurface = w;
        const M = (e, t, r, i, o, a) => {
            const s = Math.abs(o - i) > 180 ? 1 : 0,
              n = (i + o) / 2,
              l = Math.cos(T * n) * a,
              d = Math.sin(T * n) * a,
              h = Math.cos(T * o) * r + e + l,
              u = Math.sin(T * o) * r + t + d;
            let c = Math.cos(T * i) * r + e + l;
            const p = Math.sin(T * i) * r + t + d;
            return (
              Math.abs(h - c) < 1e-4 && (c += 0.001),
              `M${e + l} ${t + d} ${h} ${u} A${r} ${r} 0 ${s} 0 ${c} ${p}Z`
            );
          },
          L = (e, t, r, i, o, a, s) => {
            const n = Math.abs(a - o) > 180 ? 1 : 0,
              l = (o + a) / 2,
              d = Math.cos(T * l) * s,
              h = Math.sin(T * l) * s,
              u = Math.cos(T * a) * r + e + d,
              c = Math.sin(T * a) * r + t + h,
              p = Math.cos(T * o) * r + e + d,
              g = Math.sin(T * o) * r + t + h,
              y = Math.cos(T * a) * i + e + d,
              f = Math.sin(T * a) * i + t + h;
            return `M${u} ${c} A${r} ${r} 0 ${n} 0 ${p} ${g} L${
              Math.cos(T * o) * i + e + d
            } ${Math.sin(T * o) * i + t + h} A${i} ${i} 0 ${n} 1 ${y} ${f}Z`;
          };
        let O = !1;
        t.addEventListenerToPieSegment = (e, t, r) => {
          const i = (t) => {
            if (r) {
              if (!O) {
                const t = 10,
                  r = e.isSelected,
                  i = r ? e.delta : 0,
                  o = r ? -e.delta / t : e.delta / t;
                (O = !0),
                  (e.isSelected = !e.isSelected),
                  (function r(a) {
                    setTimeout(() => {
                      (e.shift = i + o * a),
                        a === t && (O = !1),
                        ++a <= t && r(a);
                    }, 20);
                  })(1);
              }
            } else e.isSelected = !e.isSelected;
          };
          return (
            t.addEventListener("click", i),
            {
              eventListener: i,
              eventType: "click",
              element: t,
              delete: () => t.removeEventListener("click", i),
            }
          );
        };
      },
      6340: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PROPERTY = void 0),
          ((r = t.PROPERTY || (t.PROPERTY = {})).HOLE_RADIUS = "HOLE_RADIUS"),
          (r.HOLE_RADIUS_SIZING_MODE = "HOLE_RADIUS_SIZING_MODE"),
          (r.PIE_TYPE = "PIE_TYPE"),
          (r.SERIES_SPACING = "SERIES_SPACING"),
          (r.PADDING = "PADDING"),
          (r.CANVAS_BORDER = "CANVAS_BORDER"),
          (r.LABEL_PROVIDER = "LABEL_PROVIDER"),
          (r.VALUE_MODE = "VALUE_MODE"),
          (r.LABEL_RADIUS = "LABEL_RADIUS"),
          (r.TEXT_STYLE = "TEXT_STYLE");
      },
      8320: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartPolarSubSurface = void 0);
        const i = r(87459),
          o = r(87108),
          a = r(91465),
          s = r(22022),
          n = r(7171),
          l = r(32873),
          d = r(51269),
          h = r(31306),
          u = r(94416),
          c = r(75112),
          p = r(84626);
        class g extends u.SciChartPolarSurface {
          constructor(e, t) {
            var r, o, a, s, n, l, u, c, p, g, y, f, v, m, S;
            super(e, t),
              (this.isSubSurface = !0),
              (this.topSectionClass = "top-section"),
              (this.leftSectionClass = "left-section"),
              (this.bottomSectionClass = "bottom-section"),
              (this.rightSectionClass = "right-section"),
              (this.isTransparentProperty = !0),
              (this.subPositionProperty = new i.Rect(0, 0, 1, 1)),
              (this.coordinateModeProperty = h.ECoordinateMode.Relative),
              (this.isVisibleProperty = !0),
              (this.sectionScaleProperty = 1),
              (this.parentSurfaceProperty = t.parentSurface),
              (this.subChartContainerId =
                null === (r = t.subSurfaceOptions) || void 0 === r
                  ? void 0
                  : r.subChartContainerId),
              (this.isTransparentProperty =
                null !==
                  (a =
                    null === (o = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === o
                      ? void 0
                      : o.isTransparent) && void 0 !== a
                  ? a
                  : this.isTransparent),
              (this.coordinateModeProperty =
                null !==
                  (n =
                    null === (s = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === s
                      ? void 0
                      : s.coordinateMode) && void 0 !== n
                  ? n
                  : this.coordinateMode),
              (this.parentXAxisIdProperty =
                null !==
                  (u =
                    null === (l = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === l
                      ? void 0
                      : l.parentXAxisId) && void 0 !== u
                  ? u
                  : this.parentXAxisId),
              (this.parentYAxisIdProperty =
                null !==
                  (p =
                    null === (c = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === c
                      ? void 0
                      : c.parentYAxisId) && void 0 !== p
                  ? p
                  : this.parentYAxisId),
              (this.sectionScaleProperty =
                null !==
                  (y =
                    null === (g = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === g
                      ? void 0
                      : g.sectionScale) && void 0 !== y
                  ? y
                  : this.sectionScaleProperty),
              (this.isVisible =
                null !==
                  (v =
                    null === (f = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === f
                      ? void 0
                      : f.isVisible) && void 0 !== v
                  ? v
                  : this.isVisible),
              this.subChartContainerId &&
                (this.subChartContainer =
                  "string" == typeof this.subChartContainerId
                    ? document.querySelector(
                        `[id='${this.subChartContainerId}']`
                      )
                    : this.subChartContainerId),
              this.applyOptions(t.subSurfaceOptions),
              (this.subPosition =
                null !==
                  (S =
                    null === (m = t.subSurfaceOptions) || void 0 === m
                      ? void 0
                      : m.position) && void 0 !== S
                  ? S
                  : this.subPositionProperty),
              (this.backgroundFillBrushCache = new d.BrushCache(e));
          }
          static createSubSurface(e, t) {
            const r = c.sciChartSubSurfaceCommon.createSubSurfaceCanvases(e),
              i = new g(e.webAssemblyContext2D, {
                canvases: r,
                parentSurface: e,
                subSurfaceOptions: p.SciChartSurface.resolveOptions(t),
              });
            return (
              (null == t ? void 0 : t.theme) && i.applyTheme(t.theme),
              e.addSubChartInternal(i),
              i
            );
          }
          get viewRect() {
            return this.getSubChartRect();
          }
          get isTransparent() {
            return this.isTransparentProperty;
          }
          set isTransparent(e) {
            this.isTransparentProperty !== e &&
              ((this.isTransparentProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("isTransparent"));
          }
          get coordinateMode() {
            return this.coordinateModeProperty;
          }
          set coordinateMode(e) {
            this.coordinateMode !== e &&
              ((this.coordinateModeProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("coordinateMode"));
          }
          get parentXAxisId() {
            return this.parentXAxisIdProperty;
          }
          set parentXAxisId(e) {
            this.parentXAxisIdProperty !== e &&
              ((this.parentXAxisIdProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("parentXAxisId"));
          }
          get parentYAxisId() {
            return this.parentYAxisIdProperty;
          }
          set parentYAxisId(e) {
            this.parentYAxisIdProperty !== e &&
              ((this.parentYAxisIdProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("parentYAxisId"));
          }
          get subPosition() {
            return this.subPositionProperty;
          }
          set subPosition(e) {
            if (this.subPositionProperty !== e) {
              if (!this.parentSurface)
                throw new Error(
                  "subPosition can only be changed for subCharts."
                );
              (0, n.areEqual)(this.subPositionProperty, e) ||
                ((this.subPositionProperty = e),
                (this.offset = void 0),
                this.notifyPropertyChanged("subPosition"));
            }
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            this.isVisibleProperty !== e &&
              ((this.isVisibleProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("isVisible"));
          }
          get sectionScale() {
            return this.sectionScaleProperty;
          }
          set sectionScale(e) {
            this.sectionScaleProperty !== e &&
              ((this.sectionScaleProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("sectionScale"));
          }
          updateSubLayout() {
            if (
              !this.offset ||
              this.coordinateMode === h.ECoordinateMode.DataValue ||
              this.coordinateMode.includes(h.ECoordinateMode.DataValue)
            ) {
              const e = this.calcPadding(),
                t = new o.Thickness(
                  (0, l.translateToNotScaled)(e.top),
                  (0, l.translateToNotScaled)(e.right),
                  (0, l.translateToNotScaled)(e.bottom),
                  (0, l.translateToNotScaled)(e.left)
                );
              this.updateWrapper(t);
              const r = this.getOffsets(this.subChartContainer);
              this.offset = o.Thickness.mergeAdd(e, r);
            }
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          changeViewportSize(e, t) {
            (this.offset = void 0),
              (this.renderSurface.viewportSize = new s.Size(e, t));
          }
          getSubChartContainer() {
            return this.subChartContainer;
          }
          getSubChartRect() {
            return c.sciChartSubSurfaceCommon.getSubChartRect(this);
          }
          delete(e = !0) {
            c.sciChartSubSurfaceCommon.deleteSubChart(this, e),
              super.delete(!1);
          }
          getOptions() {
            var e;
            let t;
            t =
              "toJSON" in this.themeProvider
                ? this.themeProvider.toJSON()
                : this.themeProvider;
            const r = super.getOptions(),
              i = {
                surfaceType: a.ESciChartSurfaceType.Polar2D,
                isTransparent: this.isTransparent,
                isVisible: this.isVisible,
                sectionScale: this.sectionScale,
                position: this.subPosition,
                subChartContainerId:
                  "string" == typeof this.subChartContainerId
                    ? this.subChartContainerId
                    : null === (e = this.subChartContainerId) || void 0 === e
                    ? void 0
                    : e.id,
                coordinateMode: this.coordinateMode,
                parentXAxisId: this.parentXAxisId,
                parentYAxisId: this.parentYAxisId,
              };
            return Object.assign(r, i);
          }
          toJSON(e = !1) {
            const t = this.getOptions();
            return {
              type: a.ESciChartSurfaceType.Polar2D,
              surface: t,
              xAxes: this.xAxes.asArray().map((e) => e.toJSON()),
              yAxes: this.yAxes.asArray().map((e) => e.toJSON()),
              series: this.renderableSeries.asArray().map((t) => t.toJSON(e)),
              modifiers: this.chartModifiers.asArray().map((e) => e.toJSON()),
              annotations: this.annotations.asArray().map((e) => e.toJSON()),
            };
          }
          calcPadding() {
            return c.sciChartSubSurfaceCommon.calcPadding(this);
          }
          applySciChartBackground(e, t) {
            c.sciChartSubSurfaceCommon.applySciChartBackground(this, e, t);
          }
          updateWrapper(e) {
            c.sciChartSubSurfaceCommon.updateWrapper(this, e);
          }
          getOffsets(e) {
            return c.sciChartSubSurfaceCommon.getOffsets(this, e);
          }
        }
        t.SciChartPolarSubSurface = g;
      },
      94416: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartPolarSurface = void 0);
        const i = r(84745),
          o = r(91465),
          a = r(19145),
          s = r(24696),
          n = r(23447),
          l = r(43937),
          d = r(25606),
          h = r(84626);
        class u extends h.SciChartSurface {
          constructor(e, t) {
            super(e, t), (this.layoutManager = new s.PolarLayoutManager());
          }
          static create(e, t) {
            if (((t = h.SciChartSurface.resolveOptions(t)), i.IS_TEST_ENV))
              return this.createPolarTest(e, t);
            {
              const r = (e, t) => new u(e, t);
              return (0, n.createMultichart)(e, r, t).then(
                (e) => (e.sciChartSurface.applyOptions(t), e)
              );
            }
          }
          static createSingle(e, t) {
            if (((t = h.SciChartSurface.resolveOptions(t)), i.IS_TEST_ENV))
              return this.createPolarTest(e, t);
            {
              const r = (e, t) => new u(e, t);
              return (0, l.createSingleInternal)(e, r, t).then(
                (e) => (e.sciChartSurface.applyOptions(t), e)
              );
            }
          }
          get surfaceType() {
            return a.ESurfaceType.SciChartPolarSurfaceType;
          }
          static createPolarTest(e, t) {
            var r, i;
            const o = d.default.initCanvas(
                e,
                null !== (r = null == t ? void 0 : t.widthAspect) &&
                  void 0 !== r
                  ? r
                  : 0,
                null !== (i = null == t ? void 0 : t.heightAspect) &&
                  void 0 !== i
                  ? i
                  : 0,
                d.default.ECanvasType.canvas2D
              ),
              a = new u(h.sciChartConfig.testWasm, { canvases: o });
            return (
              a.applyTheme(null == t ? void 0 : t.theme),
              a.applyOptions(t),
              new Promise((e) =>
                e({ wasmContext: a.webAssemblyContext2D, sciChartSurface: a })
              )
            );
          }
          toJSON(e = !1) {
            const t = super.toJSON(e);
            return (t.type = o.ESciChartSurfaceType.Polar2D), t;
          }
        }
        t.SciChartPolarSurface = u;
      },
      25610: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartSubSurface = void 0);
        const i = r(87459),
          o = r(87108),
          a = r(91465),
          s = r(22022),
          n = r(7171),
          l = r(16602),
          d = r(32873),
          h = r(51269),
          u = r(31306),
          c = r(75112),
          p = r(84626);
        class g extends p.SciChartSurface {
          constructor(e, t) {
            var r, o, a, s, n, l, d, c, p, g, y, f, v, m, S;
            super(e, t),
              (this.isSubSurface = !0),
              (this.topSectionClass = "top-section"),
              (this.leftSectionClass = "left-section"),
              (this.bottomSectionClass = "bottom-section"),
              (this.rightSectionClass = "right-section"),
              (this.isTransparentProperty = !0),
              (this.subPositionProperty = new i.Rect(0, 0, 1, 1)),
              (this.coordinateModeProperty = u.ECoordinateMode.Relative),
              (this.isVisibleProperty = !0),
              (this.sectionScaleProperty = 1),
              (this.parentSurfaceProperty = t.parentSurface),
              (this.subChartContainerId =
                null === (r = t.subSurfaceOptions) || void 0 === r
                  ? void 0
                  : r.subChartContainerId),
              (this.isTransparentProperty =
                null !==
                  (a =
                    null === (o = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === o
                      ? void 0
                      : o.isTransparent) && void 0 !== a
                  ? a
                  : this.isTransparent),
              (this.coordinateModeProperty =
                null !==
                  (n =
                    null === (s = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === s
                      ? void 0
                      : s.coordinateMode) && void 0 !== n
                  ? n
                  : this.coordinateMode),
              (this.parentXAxisIdProperty =
                null !==
                  (d =
                    null === (l = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === l
                      ? void 0
                      : l.parentXAxisId) && void 0 !== d
                  ? d
                  : this.parentXAxisId),
              (this.parentYAxisIdProperty =
                null !==
                  (p =
                    null === (c = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === c
                      ? void 0
                      : c.parentYAxisId) && void 0 !== p
                  ? p
                  : this.parentYAxisId),
              (this.sectionScaleProperty =
                null !==
                  (y =
                    null === (g = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === g
                      ? void 0
                      : g.sectionScale) && void 0 !== y
                  ? y
                  : this.sectionScaleProperty),
              (this.isVisible =
                null !==
                  (v =
                    null === (f = null == t ? void 0 : t.subSurfaceOptions) ||
                    void 0 === f
                      ? void 0
                      : f.isVisible) && void 0 !== v
                  ? v
                  : this.isVisible),
              this.subChartContainerId &&
                (this.subChartContainer =
                  "string" == typeof this.subChartContainerId
                    ? document.querySelector(
                        `[id='${this.subChartContainerId}']`
                      )
                    : this.subChartContainerId),
              this.applyOptions(t.subSurfaceOptions),
              (this.subPosition =
                null !==
                  (S =
                    null === (m = t.subSurfaceOptions) || void 0 === m
                      ? void 0
                      : m.position) && void 0 !== S
                  ? S
                  : this.subPositionProperty),
              (this.backgroundFillBrushCache = new h.BrushCache(e));
          }
          static createSubSurface(e, t) {
            var r;
            const i = l.PerformanceDebugHelper.mark(
                l.EPerformanceMarkType.AddSubSurfaceStart,
                {
                  contextId: null == t ? void 0 : t.id,
                  parentContextId: e.id,
                  level: l.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = c.sciChartSubSurfaceCommon.createSubSurfaceCanvases(e),
              a = new g(e.webAssemblyContext2D, {
                canvases: o,
                parentSurface: e,
                subSurfaceOptions: p.SciChartSurface.resolveOptions(t),
              });
            return (
              (null == t ? void 0 : t.theme) && a.applyTheme(t.theme),
              e.addSubChartInternal(a),
              l.PerformanceDebugHelper.mark(
                l.EPerformanceMarkType.AddSubSurfaceEnd,
                {
                  contextId: a.id,
                  relatedId:
                    null === (r = null == i ? void 0 : i.detail) || void 0 === r
                      ? void 0
                      : r.relatedId,
                  parentContextId: e.id,
                  level: l.EPerformanceDebugLevel.Verbose,
                }
              ),
              a
            );
          }
          get viewRect() {
            return this.getSubChartRect();
          }
          get clipRect() {
            return this.parentSurface.viewRect;
          }
          get isTransparent() {
            return this.isTransparentProperty;
          }
          set isTransparent(e) {
            this.isTransparentProperty !== e &&
              ((this.isTransparentProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("isTransparent"));
          }
          get coordinateMode() {
            return this.coordinateModeProperty;
          }
          set coordinateMode(e) {
            this.coordinateMode !== e &&
              ((this.coordinateModeProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("coordinateMode"));
          }
          get parentXAxisId() {
            return this.parentXAxisIdProperty;
          }
          set parentXAxisId(e) {
            this.parentXAxisIdProperty !== e &&
              ((this.parentXAxisIdProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("parentXAxisId"));
          }
          get parentYAxisId() {
            return this.parentYAxisIdProperty;
          }
          set parentYAxisId(e) {
            this.parentYAxisIdProperty !== e &&
              ((this.parentYAxisIdProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("parentYAxisId"));
          }
          get subPosition() {
            return this.subPositionProperty;
          }
          set subPosition(e) {
            if (this.subPositionProperty !== e) {
              if (!this.parentSurface)
                throw new Error(
                  "subPosition can only be changed for subCharts."
                );
              (0, n.areEqual)(this.subPositionProperty, e) ||
                ((this.subPositionProperty = e),
                (this.offset = void 0),
                this.notifyPropertyChanged("subPosition"));
            }
          }
          get isVisible() {
            return this.isVisibleProperty;
          }
          set isVisible(e) {
            this.isVisibleProperty !== e &&
              ((this.isVisibleProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("isVisible"));
          }
          get sectionScale() {
            return this.sectionScaleProperty;
          }
          set sectionScale(e) {
            this.sectionScaleProperty !== e &&
              ((this.sectionScaleProperty = e),
              (this.offset = void 0),
              this.notifyPropertyChanged("sectionScale"));
          }
          updateSubLayout() {
            if (
              !this.offset ||
              this.coordinateMode === u.ECoordinateMode.DataValue ||
              this.coordinateMode.includes(u.ECoordinateMode.DataValue)
            ) {
              const e = this.calcPadding(),
                t = new o.Thickness(
                  (0, d.translateToNotScaled)(e.top),
                  (0, d.translateToNotScaled)(e.right),
                  (0, d.translateToNotScaled)(e.bottom),
                  (0, d.translateToNotScaled)(e.left)
                );
              this.updateWrapper(t);
              const r = this.getOffsets(this.subChartContainer);
              this.offset = o.Thickness.mergeAdd(e, r);
            }
          }
          get parentSurface() {
            return this.parentSurfaceProperty;
          }
          changeViewportSize(e, t) {
            (this.offset = void 0),
              (this.renderSurface.viewportSize = new s.Size(e, t));
          }
          getSubChartContainer() {
            return this.subChartContainer;
          }
          getSubChartRect() {
            return c.sciChartSubSurfaceCommon.getSubChartRect(this);
          }
          delete(e = !0) {
            c.sciChartSubSurfaceCommon.deleteSubChart(this, e),
              super.delete(!1);
          }
          getOptions() {
            var e;
            const t = super.getOptions(),
              r = {
                surfaceType: a.ESciChartSurfaceType.Default2D,
                isTransparent: this.isTransparent,
                isVisible: this.isVisible,
                sectionScale: this.sectionScale,
                position: this.subPosition,
                subChartContainerId:
                  "string" == typeof this.subChartContainerId
                    ? this.subChartContainerId
                    : null === (e = this.subChartContainerId) || void 0 === e
                    ? void 0
                    : e.id,
                coordinateMode: this.coordinateMode,
                parentXAxisId: this.parentXAxisId,
                parentYAxisId: this.parentYAxisId,
              };
            return Object.assign(t, r);
          }
          toJSON(e = !1) {
            const t = this.getOptions();
            return {
              type: a.ESciChartSurfaceType.Default2D,
              surface: t,
              xAxes: this.xAxes.asArray().map((e) => e.toJSON()),
              yAxes: this.yAxes.asArray().map((e) => e.toJSON()),
              series: this.renderableSeries.asArray().map((t) => t.toJSON(e)),
              modifiers: this.chartModifiers.asArray().map((e) => e.toJSON()),
              annotations: this.annotations.asArray().map((e) => e.toJSON()),
            };
          }
          calcPadding() {
            return c.sciChartSubSurfaceCommon.calcPadding(this);
          }
          applySciChartBackground(e, t) {
            c.sciChartSubSurfaceCommon.applySciChartBackground(this, e, t);
          }
          updateWrapper(e) {
            c.sciChartSubSurfaceCommon.updateWrapper(this, e);
          }
          getOffsets(e) {
            return c.sciChartSubSurfaceCommon.getOffsets(this, e);
          }
        }
        t.SciChartSubSurface = g;
      },
      84626: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SciChartSurface = t.sciChartConfig = void 0);
        const o = r(45921),
          a = r(84745),
          s = r(10276),
          n = r(34238),
          l = r(56744),
          d = r(21079),
          h = r(3214),
          u = r(37796),
          c = r(87459),
          p = r(87108),
          g = r(39922),
          y = r(11043),
          f = r(5337),
          v = r(22022),
          m = r(14379),
          S = r(93113),
          P = r(77186),
          C = r(78623),
          b = r(45481),
          x = r(23059),
          A = r(5102),
          T = r(23447),
          E = r(43937),
          R = r(94389),
          D = r(98353),
          w = r(1406),
          M = r(71719),
          L = r(25606),
          O = r(14184),
          I = r(86127),
          k = r(75772),
          _ = r(85479),
          V = r(3434),
          N = r(71238),
          B = r(36420),
          F = r(99263),
          H = r(38051),
          Y = r(883),
          z = r(9254),
          j = r(16602),
          X = r(19145),
          G = r(66405),
          W = r(38215),
          U = r(52578),
          $ = r(91465);
        t.sciChartConfig = {};
        class Z extends O.SciChartSurfaceBase {
          constructor(e, t) {
            var r, i, o, s, n;
            super(e, null == t ? void 0 : t.canvases),
              (this.preRender = new h.EventHandler()),
              (this.preRenderAll = new h.EventHandler()),
              (this.stepBetweenLayers = 10),
              (this.isSubSurface = !1),
              (this.renderNativeAxisLabelsImmediately = !1),
              (this.watermarkPosition = _.SciChartDefaults.watermarkPosition),
              (this.watermarkRelativeToCanvas = !1),
              (this.animationList = []),
              (this.titleStyleProperty = {
                fontSize: 60,
                fontFamily: U.DEFAULT_FONT_FAMILY,
                color: O.SciChartSurfaceBase.DEFAULT_THEME.chartTitleColor,
                fontWeight: "normal",
                fontStyle: "normal",
                lineSpacing: 1.1,
                padding: p.Thickness.fromString("10 4 10 4"),
                multilineAlignment: B.EMultiLineAlignment.Center,
                rotation: void 0,
                alignment: N.ETextAlignment.Center,
                position: N.ETitlePosition.Top,
                placeWithinChart: !1,
                useNativeText: _.SciChartDefaults.useNativeText,
              }),
              (this.getPaddingProxy = (e) =>
                new Proxy(e, {
                  set: (e, t, r) => (
                    e[t] !== r && ((e[t] = r), this.invalidateElement()), !0
                  ),
                })),
              (this.paddingProperty = this.getPaddingProxy(
                p.Thickness.fromNumber(10)
              )),
              (this.zoomStateProperty = m.EZoomState.AtExtents),
              (this.viewportBorderProperty = {
                borderBottom: void 0,
                borderLeft: void 0,
                borderRight: void 0,
                borderTop: void 0,
                color: "#00000000",
                border: void 0,
              }),
              (this.canvasBorderProperty = {
                borderBottom: void 0,
                borderLeft: void 0,
                borderRight: void 0,
                borderTop: void 0,
                color: "#00000000",
                border: void 0,
              }),
              (this.subChartsProperty = []),
              (this.drawSeriesBehindAxisProperty = !1),
              (this.autoColorModeProperty = g.EAutoColorMode.OnAddRemoveSeries),
              (this.autoColorRequired = !0),
              (this.xCoordSvgTrans = 0),
              (this.yCoordSvgTrans = 0),
              (this.subChartCounterProperty = 1),
              (this.surfaceRenderOrderProperty = void 0),
              (this.resolvedSurfaceRenderOrder = 0);
            const l =
                null !==
                  (i =
                    null === (r = this.domCanvas2D) || void 0 === r
                      ? void 0
                      : r.width) && void 0 !== i
                  ? i
                  : a.DEFAULT_WIDTH,
              d =
                null !==
                  (s =
                    null === (o = this.domCanvas2D) || void 0 === o
                      ? void 0
                      : o.height) && void 0 !== s
                  ? s
                  : a.DEFAULT_HEIGHT;
            if (((this.webAssemblyContext2D = e), !a.IS_TEST_ENV)) {
              const t = l / I.DpiHelper.PIXEL_RATIO,
                r = d / I.DpiHelper.PIXEL_RATIO;
              this.isCopyCanvasSurface
                ? this.changeMasterCanvasViewportSize(e, t, r)
                : this.changeWebGLCanvasViewportSize(e, t, r);
            }
            (this.invalidateElement = this.invalidateElement.bind(this)),
              (this.onRenderSurfaceDraw = this.onRenderSurfaceDraw.bind(this));
            const c = this.domCanvas2D
              ? new v.Size(l, d)
              : new v.Size(a.DEFAULT_WIDTH, a.DEFAULT_HEIGHT);
            (this.renderSurface = new P.RenderSurface(
              e,
              c,
              null === (n = this.domCanvas2D) || void 0 === n ? void 0 : n.id
            )),
              (this.renderSurface.handleDraw = this.onRenderSurfaceDraw),
              (this.sciChartRenderer = new x.SciChartRenderer(this)),
              (this.chartTitleRendererProperty = new V.ChartTitleRenderer(
                this.webAssemblyContext2D
              )),
              (this.layoutManager = new b.LayoutManager()),
              (this.detachSeries = this.detachSeries.bind(this)),
              (this.attachSeries = this.attachSeries.bind(this)),
              (this.renderableSeries = new u.ObservableArray()),
              this.renderableSeries.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach(this.detachSeries),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach(this.attachSeries);
              }),
              (this.detachAxis = this.detachAxis.bind(this)),
              (this.attachAxis = this.attachAxis.bind(this)),
              (this.xAxes = new u.ObservableArray()),
              (this.yAxes = new u.ObservableArray());
            const y = (e, t) => {
              var r, i;
              null === (r = e.getOldItems()) ||
                void 0 === r ||
                r.forEach((e) => {
                  e.visibleRangeChanged.unsubscribeAll(), this.detachAxis(e);
                }),
                null === (i = e.getNewItems()) ||
                  void 0 === i ||
                  i.forEach((e) => this.attachAxis(e, t));
            };
            this.xAxes.collectionChanged.subscribe((e) => y(e, !0)),
              this.yAxes.collectionChanged.subscribe((e) => y(e, !1)),
              (this.adornerLayer = new A.AdornerLayer(this)),
              (this.solidBrushCacheViewportBorder = new C.SolidBrushCache(e)),
              (this.solidBrushCacheCanvasBorder = new C.SolidBrushCache(e)),
              a.IS_TEST_ENV ||
                ((this.watermarkProperties = new e.SCRTWaterMarkProperties()),
                (this.watermarkPropertyPosition = new e.TSRVector2(0, 0)),
                this.watermarkProperties.SetPosition(
                  this.watermarkPropertyPosition
                ),
                this.watermarkProperties.SetOpacity(0.5),
                e.SCRTSetWaterMarkProperties(this.watermarkProperties));
          }
          static create(e, t) {
            const r = j.PerformanceDebugHelper.mark(
              j.EPerformanceMarkType.InitializationStart,
              { contextId: null == t ? void 0 : t.id }
            );
            if (((t = Z.resolveOptions(t)), a.IS_TEST_ENV))
              return this.createTest(e, t);
            {
              const i = (e, t) => new Z(e, t);
              return (0, T.createMultichart)(e, i, t).then((e) => {
                var i;
                return (
                  e.sciChartSurface.applyOptions(t),
                  j.PerformanceDebugHelper.mark(
                    j.EPerformanceMarkType.InitializationEnd,
                    {
                      parentContextId: e.sciChartSurface.domCanvas2D.id,
                      contextId: e.sciChartSurface.id,
                      relatedId:
                        null === (i = null == r ? void 0 : r.detail) ||
                        void 0 === i
                          ? void 0
                          : i.relatedId,
                    }
                  ),
                  e
                );
              });
            }
          }
          static disposeSharedWasmContext() {
            0 === F.sciChart3DDestinations.length &&
              0 === F.sciChartDestinations.length &&
              ((0, T.disposeMultiChart)(), (0, H.disposeMultiChart3d)()),
              super.disposeSharedWasmContext();
          }
          static createSingle(e, t) {
            const r = j.PerformanceDebugHelper.mark(
              j.EPerformanceMarkType.InitializationStart,
              { contextId: null == t ? void 0 : t.id }
            );
            if (((t = Z.resolveOptions(t)), a.IS_TEST_ENV))
              return this.createTest(e, t);
            {
              const i = (e, t) => new Z(e, t);
              return (0, E.createSingleInternal)(e, i, t).then((e) => {
                var i;
                return (
                  e.sciChartSurface.applyOptions(t),
                  j.PerformanceDebugHelper.mark(
                    j.EPerformanceMarkType.InitializationEnd,
                    {
                      parentContextId: e.sciChartSurface.domCanvas2D.id,
                      contextId: e.sciChartSurface.id,
                      relatedId:
                        null === (i = null == r ? void 0 : r.detail) ||
                        void 0 === i
                          ? void 0
                          : i.relatedId,
                    }
                  ),
                  e
                );
              });
            }
          }
          static configure(e) {
            var r;
            t.sciChartConfig.wasmUrl =
              null !== (r = null == e ? void 0 : e.wasmUrl) && void 0 !== r
                ? r
                : void 0;
          }
          static useWasmFromCDN() {
            t.sciChartConfig.wasmUrl = `https://cdn.jsdelivr.net/npm/scichart@${n.libraryVersion}/_wasm/scichart2d.wasm`;
          }
          static useWasmLocal() {
            Z.configure(void 0);
          }
          static loadWasmFromCDN() {
            return Z.useWasmFromCDN();
          }
          static loadWasmLocal() {
            return Z.useWasmLocal();
          }
          static isSubSurface(e) {
            return e.isSubSurface;
          }
          static createTest(e, r) {
            var i, o;
            const a = L.default.initCanvas(
                e,
                null !== (i = null == r ? void 0 : r.widthAspect) &&
                  void 0 !== i
                  ? i
                  : 0,
                null !== (o = null == r ? void 0 : r.heightAspect) &&
                  void 0 !== o
                  ? o
                  : 0,
                L.default.ECanvasType.canvas2D
              ),
              s = new Z(t.sciChartConfig.testWasm, { canvases: a });
            return (
              s.applyTheme(null == r ? void 0 : r.theme),
              s.applyOptions(r),
              new Promise((e) =>
                e({ wasmContext: s.webAssemblyContext2D, sciChartSurface: s })
              )
            );
          }
          get subChartCounter() {
            return this.subChartCounterProperty;
          }
          addSubChartInternal(e) {
            var t;
            if (this.isSubSurface)
              throw new Error("Can not add subChart to subChart.");
            this.subChartCounterProperty++,
              null === (t = e.mouseManager) || void 0 === t || t.unsubscribe(),
              this.subChartsProperty.push(e),
              this.onAttachSubSurface(e),
              e.setIsInitialized();
          }
          removeSubChart(e) {
            const t = this.subChartsProperty.findIndex((t) => t === e);
            t > -1 && (this.subChartsProperty.splice(t, 1), e.delete(!0));
          }
          get subCharts() {
            return this.subChartsProperty;
          }
          get surfaceType() {
            return X.ESurfaceType.SciChartSurfaceType;
          }
          get layoutManager() {
            return this.layoutManagerProperty;
          }
          set layoutManager(e) {
            this.layoutManagerProperty &&
              (this.layoutManagerProperty.sciChartSurface = void 0),
              (this.layoutManagerProperty = e),
              (this.layoutManagerProperty.sciChartSurface = this),
              this.invalidateElement();
          }
          get chartTitleRenderer() {
            return this.chartTitleRendererProperty;
          }
          set chartTitleRenderer(e) {
            var t;
            null === (t = this.chartTitleRendererProperty) ||
              void 0 === t ||
              t.delete(),
              (this.chartTitleRendererProperty = e),
              this.invalidateElement();
          }
          get dataLabelLayoutManager() {
            return this.dataLabelLayoutManagerProperty;
          }
          set dataLabelLayoutManager(e) {
            (this.dataLabelLayoutManagerProperty = e), this.invalidateElement();
          }
          get title() {
            return this.titleProperty;
          }
          set title(e) {
            this.titleProperty !== e &&
              ((this.titleProperty = e), this.invalidateElement());
          }
          get titleStyle() {
            return this.titleStyleProperty;
          }
          set titleStyle(e) {
            this.titleStyleProperty !== e &&
              ((this.titleStyleProperty = Object.assign(
                {},
                this.titleStyleProperty,
                e
              )),
              this.invalidateElement());
          }
          get padding() {
            return this.paddingProperty;
          }
          set padding(e) {
            p.Thickness.areEqual(this.paddingProperty, e) ||
              ((this.paddingProperty = this.getPaddingProxy(e)),
              this.invalidateElement());
          }
          get adjustedPadding() {
            return I.DpiHelper.adjustThickness(this.padding);
          }
          get debugRendering() {
            return this.debugRenderingProperty;
          }
          set debugRendering(e) {
            (this.debugRenderingProperty = e), this.invalidateElement();
          }
          get autoColorMode() {
            return this.autoColorModeProperty;
          }
          set autoColorMode(e) {
            (this.autoColorModeProperty = e),
              e === g.EAutoColorMode.Never || this.autoColorRequired
                ? e === g.EAutoColorMode.Never && (this.autoColorRequired = !1)
                : (this.autoColorRequired = !0),
              this.invalidateElement();
          }
          get isInvalidated() {
            var e;
            return null === (e = this.sciChartRenderer) || void 0 === e
              ? void 0
              : e.isInvalidated;
          }
          applyTheme(e) {
            const t = this.previousThemeProvider;
            this.titleStyle.color === t.chartTitleColor &&
              (this.titleStyle = { color: e.chartTitleColor }),
              super.applyTheme(e),
              this.renderableSeries.asArray().forEach((t) => t.applyTheme(e)),
              this.xAxes.asArray().forEach((t) => t.applyTheme(e)),
              this.yAxes.asArray().forEach((t) => t.applyTheme(e));
          }
          changeViewportSize(e, t) {
            if (
              (z.Logger.debug("changeViewportSize"), !e || !t || this.isDeleted)
            )
              return;
            const r = e * I.DpiHelper.PIXEL_RATIO,
              i = t * I.DpiHelper.PIXEL_RATIO;
            (this.renderSurface.viewportSize = new v.Size(r, i)),
              this.isCopyCanvasSurface
                ? (this.changeMasterCanvasViewportSize(
                    this.webAssemblyContext2D,
                    e,
                    t
                  ),
                  this.domCanvas2D &&
                    I.DpiHelper.setSize(this.domCanvas2D, e, t))
                : this.changeWebGLCanvasViewportSize(
                    this.webAssemblyContext2D,
                    e,
                    t
                  );
            for (const e of this.subChartsProperty) e.changeViewportSize(r, i);
            this.invalidateElement({ force: !0 });
          }
          invalidateElement(e) {
            var t, r;
            if (
              (z.Logger.debug(
                `Invalidating ${
                  null !==
                    (r =
                      null === (t = this.domChartRoot) || void 0 === t
                        ? void 0
                        : t.id) && void 0 !== r
                    ? r
                    : this.id
                }: force=${null == e ? void 0 : e.force} isSuspended=${
                  this.isSuspended
                } isInitialized=${this.isInitialized}.`
              ),
              ((null == e ? void 0 : e.force) ||
                (!this.isSuspended && !this.isDeleted && this.isInitialized)) &&
                (j.PerformanceDebugHelper.mark(
                  this.sciChartRenderer.isInvalidated
                    ? j.EPerformanceMarkType.Invalidate
                    : j.EPerformanceMarkType.LeadingInvalidate,
                  { contextId: this.id }
                ),
                !this.sciChartRenderer.isInvalidated))
            ) {
              this.sciChartRenderer.isInvalidated = !0;
              const e = this.domCanvas2D
                ? this.domCanvas2D.id
                : "undefinedCanvasId";
              this.renderSurface.invalidateElement(e);
            }
          }
          doDrawingLoop(e) {
            var t;
            if (this.isDeleted) return;
            const r = j.PerformanceDebugHelper.mark(
              j.EPerformanceMarkType.DrawingLoopStart,
              { contextId: this.id, level: j.EPerformanceDebugLevel.Verbose }
            );
            (e = null != e ? e : this.renderSurface.getRenderContext()),
              (this.currentWebGlRenderContextProperty = e);
            try {
              const t = this.suspender.lock();
              try {
                this.autoColorRequired &&
                  ((this.themeProvider.strokePalette &&
                    this.themeProvider.strokePalette.length > 0) ||
                    (this.themeProvider.fillPalette &&
                      this.themeProvider.fillPalette.length > 0)) &&
                  (this.resolveAutoColors(),
                  this.autoColorMode !== g.EAutoColorMode.Always &&
                    (this.autoColorRequired = !1)),
                  this.preRender.raiseEvent(e);
              } catch (e) {
                (null == e ? void 0 : e.message) &&
                  console.error(null == e ? void 0 : e.message),
                  console.error(e);
              } finally {
                t();
              }
              this.sciChartRenderer.render(e);
              const r = this.isInvalidated;
              j.PerformanceDebugHelper.mark(
                r
                  ? j.EPerformanceMarkType.Rendered
                  : j.EPerformanceMarkType.FullStateRendered,
                { contextId: this.id }
              ),
                this.rendered.raiseEvent(r);
            } catch (e) {
              if ("BindingError" === e.name)
                console.error(e),
                  console.warn(
                    "Binding errors can occur if a previous chart using the same div id was not deleted correctly, or if you try to share data or series between charts that use different webassembly contexts."
                  ),
                  (0, D.freeCache)(this.webAssemblyContext2D).delete();
              else {
                if (!this.domChartRoot) throw e;
                console.error(
                  `Error from chart in div ${this.domChartRoot.id}:`,
                  e
                );
              }
            }
            j.PerformanceDebugHelper.mark(
              j.EPerformanceMarkType.DrawingLoopEnd,
              {
                contextId: this.id,
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                level: j.EPerformanceDebugLevel.Verbose,
              }
            );
          }
          delete(e = !0) {
            if (this.isDeleted);
            else {
              for (const e of this.subChartsProperty) e.delete(!0);
              (this.subChartsProperty = []),
                this.layoutManagerProperty.type ===
                  Y.ELayoutManagerType.Synchronised &&
                  (this.layoutManagerProperty.verticalGroup &&
                    this.layoutManagerProperty.verticalGroup.removeSurface(
                      this
                    ),
                  this.layoutManagerProperty.horizontalGroup &&
                    this.layoutManagerProperty.horizontalGroup.removeSurface(
                      this
                    )),
                (this.layoutManagerProperty.sciChartSurface = void 0),
                (this.layoutManagerProperty = void 0),
                this.renderableSeries.asArray().forEach((e) => e.delete()),
                this.renderableSeries.clear(),
                this.xAxes.asArray().forEach((e) => e.delete()),
                this.yAxes.asArray().forEach((e) => e.delete()),
                (this.solidBrushCacheViewportBorder = (0, l.deleteSafe)(
                  this.solidBrushCacheViewportBorder
                )),
                (this.solidBrushCacheCanvasBorder = (0, l.deleteSafe)(
                  this.solidBrushCacheCanvasBorder
                )),
                (this.watermarkProperties = (0, l.deleteSafe)(
                  this.watermarkProperties
                )),
                (this.watermarkPropertyPosition = (0, l.deleteSafe)(
                  this.watermarkPropertyPosition
                )),
                (this.chartTitleRendererProperty = (0, l.deleteSafe)(
                  this.chartTitleRenderer
                )),
                (this.sciChartRenderer = void 0),
                (this.renderSurface = void 0),
                this.clearRootElement(e),
                super.delete();
            }
          }
          onDpiChanged(e) {
            var t, r;
            j.PerformanceDebugHelper.mark(j.EPerformanceMarkType.DpiChange, {
              contextId: this.id,
            }),
              z.Logger.debug("onDpiChanged"),
              this.renderableSeries.asArray().forEach((t) => t.onDpiChanged(e)),
              this.xAxes.asArray().forEach((e) => e.onDpiChanged()),
              this.yAxes.asArray().forEach((e) => e.onDpiChanged()),
              this.isSubSurface ||
                this.changeViewportSize(
                  null === (t = this.getMainCanvas()) || void 0 === t
                    ? void 0
                    : t.clientWidth,
                  null === (r = this.getMainCanvas()) || void 0 === r
                    ? void 0
                    : r.clientHeight
                ),
              super.onDpiChanged(e);
          }
          getXAxisById(e) {
            return this.xAxes.getById(e);
          }
          getDefaultXAxis() {
            return this.xAxes.get(0);
          }
          getYAxisById(e) {
            return this.yAxes.getById(e);
          }
          getDefaultYAxis() {
            return this.yAxes.get(0);
          }
          updateStackedCollectionAccumulatedVectors() {
            this.renderableSeries
              .asArray()
              .filter((e) => e.isStacked && "size" in e)
              .forEach((e) => e.updateAccumulatedVectors());
          }
          zoomExtents(
            e = 0,
            t = s.easing.outExpo,
            r = () => {},
            i = () => !0,
            o = () => !0
          ) {
            this.updateStackedCollectionAccumulatedVectors();
            const a = void 0 === this.xAxes ? 0 : this.xAxes.size(),
              n = void 0 === this.yAxes ? 0 : this.yAxes.size();
            if (0 === a || 0 === n)
              throw new Error(
                "Cannot ZoomExtents when XAxes or YAxes is undefined or empty"
              );
            const l = this.zoomExtentsXInternal(e, t, i, r);
            this.zoomExtentsYInternal(l, e, t, o, r);
          }
          zoomExtentsX(e = 0, t = s.easing.outExpo, r = () => !0) {
            this.zoomExtentsXInternal(e, t, r);
          }
          zoomExtentsY(e = 0, t = s.easing.outExpo, r = () => !0) {
            this.zoomExtentsYInternal(void 0, e, t, r);
          }
          updateWatermark(e, t) {
            var r;
            if (!a.IS_TEST_ENV) {
              (this.watermarkPropertyPosition.x = e),
                (this.watermarkPropertyPosition.y = t),
                (this.watermarkProperties.m_fCanvasWidth =
                  this.renderSurface.viewportSize.width),
                this.watermarkProperties.SetPosition(
                  this.watermarkPropertyPosition
                );
              const i =
                null === (r = this.themeProvider) || void 0 === r
                  ? void 0
                  : r.isLightBackground;
              (this.watermarkProperties.m_bIsDarkBackground =
                void 0 !== i && !i),
                this.webAssemblyContext2D.SCRTSetWaterMarkProperties(
                  this.watermarkProperties
                );
            }
          }
          setZoomState(e) {
            this.zoomStateProperty = e;
          }
          get zoomState() {
            return this.zoomStateProperty;
          }
          get viewportBorder() {
            return this.viewportBorderProperty;
          }
          set viewportBorder(e) {
            (this.viewportBorderProperty = Object.assign(
              Object.assign({}, this.viewportBorderProperty),
              e
            )),
              this.notifyPropertyChanged("ViewportBorder");
          }
          get canvasBorder() {
            return this.canvasBorderProperty;
          }
          set canvasBorder(e) {
            (this.canvasBorderProperty = Object.assign(
              Object.assign({}, this.canvasBorderProperty),
              e
            )),
              this.notifyPropertyChanged("canvasBorder");
          }
          getSurfaceRenderOrder() {
            var e;
            return null !== (e = this.surfaceRenderOrderProperty) &&
              void 0 !== e
              ? e
              : this.resolvedSurfaceRenderOrder;
          }
          setSurfaceRenderOrder(e) {
            this.surfaceRenderOrderProperty != e &&
              ((this.surfaceRenderOrderProperty = e),
              this.notifyPropertyChanged("surfaceRenderOrder"));
          }
          drawBorder(e) {
            (0, R.drawBorder)(
              e,
              this.webAssemblyContext2D,
              this.solidBrushCacheViewportBorder,
              this.seriesViewRect,
              this.clipRect,
              this.leftViewportBorder,
              this.topViewportBorder,
              this.rightViewportBorder,
              this.bottomViewportBorder,
              this.viewportBorder.color
            );
            const t = e.viewportSize,
              r = Z.isSubSurface(this)
                ? this.getSubChartRect()
                : c.Rect.create(
                    this.leftCanvasBorder,
                    this.topCanvasBorder,
                    Math.floor(
                      t.width - this.leftCanvasBorder - this.rightCanvasBorder
                    ),
                    Math.floor(
                      t.height - this.topCanvasBorder - this.bottomCanvasBorder
                    )
                  );
            (0, R.drawBorder)(
              e,
              this.webAssemblyContext2D,
              this.solidBrushCacheCanvasBorder,
              r,
              this.clipRect,
              this.leftCanvasBorder,
              this.topCanvasBorder,
              this.rightCanvasBorder,
              this.bottomCanvasBorder,
              this.canvasBorder.color
            );
          }
          get leftViewportBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.viewportBorder.borderLeft) && void 0 !== e
                  ? e
                  : this.viewportBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get rightViewportBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.viewportBorder.borderRight) && void 0 !== e
                  ? e
                  : this.viewportBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get topViewportBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.viewportBorder.borderTop) && void 0 !== e
                  ? e
                  : this.viewportBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get bottomViewportBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.viewportBorder.borderBottom) && void 0 !== e
                  ? e
                  : this.viewportBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get leftCanvasBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.canvasBorder.borderLeft) && void 0 !== e
                  ? e
                  : this.canvasBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get rightCanvasBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.canvasBorder.borderRight) && void 0 !== e
                  ? e
                  : this.canvasBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get topCanvasBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.canvasBorder.borderTop) && void 0 !== e
                  ? e
                  : this.canvasBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get bottomCanvasBorder() {
            var e, t;
            return null !==
              (t =
                null !== (e = this.canvasBorder.borderBottom) && void 0 !== e
                  ? e
                  : this.canvasBorder.border) && void 0 !== t
              ? t
              : 0;
          }
          get currentWebGlRenderContext() {
            return this.currentWebGlRenderContextProperty;
          }
          get chartViewRect() {
            const e = this.renderSurface.viewportSize;
            return new c.Rect(0, 0, e.width, e.height);
          }
          updateBackground(e) {
            var t;
            this.applySciChartBackground(
              null !== (t = this.background) && void 0 !== t
                ? t
                : this.themeProvider.sciChartBackground,
              e
            );
          }
          onAnimate(e) {
            this.renderableSeries.asArray().forEach((t) => t.onAnimate(e));
            const t = [];
            for (let r = 0; r < this.animationList.length; r++) {
              const i = this.animationList[r];
              i.isComplete || (i.update(e), i.isComplete || t.push(i));
            }
            this.animationList = t;
          }
          getAnimations() {
            return this.animationList;
          }
          addAnimation(...e) {
            void 0 !== e &&
              (e.forEach((e) => this.animationList.push(e)),
              this.invalidateElement());
          }
          get isRunningAnimation() {
            for (let e = 0; e < this.renderableSeries.size(); e++)
              if (this.renderableSeries.get(e).isRunningAnimation) return !0;
            return this.animationList.some((e) => !e.isComplete);
          }
          getSeriesViewRectPadding(e = !0) {
            if (!this.seriesViewRect)
              throw new Error(
                "Cannot get seriesViewRect before layout has ocurred. Move code that calls to be triggered by sciChartSurface.rendered"
              );
            const t = e ? 1 : I.DpiHelper.PIXEL_RATIO,
              r = this.seriesViewRect,
              i = r.left / t,
              o = r.top / t,
              a = (this.domCanvas2D.width - r.right) / t,
              s = (this.domCanvas2D.height - r.bottom) / t;
            return new p.Thickness(o, a, s, i);
          }
          resolveAutoColors(e) {
            if (!e) {
              const t = this.renderableSeries
                .asArray()
                .filter((e) => e.isStacked && "size" in e);
              e = this.renderableSeries.size() - t.length;
              for (const r of t) e += r.size();
            }
            let t = 0;
            for (let r = 0; r < this.renderableSeries.size(); r++) {
              const i = this.renderableSeries.get(r);
              i && i.resolveAutoColors(t, e, this.themeProvider),
                i.isStacked && "size" in i ? (t += i.size()) : (t += 1);
            }
          }
          registerFont(e, t) {
            return i(this, void 0, void 0, function* () {
              return (
                e.includes(".") || (e += ".ttf"),
                new Promise((r, i) => {
                  const o =
                    this.webAssemblyContext2D.SCRTFileLoadCallbackInterface.implement(
                      {
                        OnLoadComplete(i, o) {
                          i
                            ? r(!0)
                            : (console.error(
                                `Failed to load ${e} from ${t}.  Error: ${o}`
                              ),
                              r(!1));
                        },
                      }
                    );
                  this.webAssemblyContext2D.SCRTRegisterFile(e, t, o);
                })
              );
            });
          }
          setCoordSvgTranslation(e, t) {
            (this.xCoordSvgTrans = e), (this.yCoordSvgTrans = t);
          }
          getCoordSvgTranslation() {
            return new k.Point(this.xCoordSvgTrans, this.yCoordSvgTrans);
          }
          getOptions() {
            var e;
            let t;
            return (
              (t =
                "toJSON" in this.themeProvider
                  ? this.themeProvider.toJSON()
                  : this.themeProvider),
              {
                id: this.id,
                title: this.title,
                titleStyle: this.titleStyle,
                background: this.background,
                canvasBorder: this.canvasBorder,
                heightAspect: this.heightAspect,
                widthAspect: this.widthAspect,
                layoutManager:
                  null === (e = this.layoutManager) || void 0 === e
                    ? void 0
                    : e.toJSON(),
                padding: this.padding,
                theme: t,
                viewportBorder: this.viewportBorder,
                loader: this.loaderJson,
                drawSeriesBehindAxis: this.drawSeriesBehindAxis,
                disableAspect: this.disableAspect,
                createSuspended: this.createSuspended,
                autoColorMode: this.autoColorMode,
                touchAction: this.touchActionProperty,
                freezeWhenOutOfView: this.freezeWhenOutOfView,
              }
            );
          }
          toJSON(e = !1) {
            const t = this.getOptions();
            return {
              type: $.ESciChartSurfaceType.Default2D,
              surface: t,
              xAxes: this.xAxes.asArray().map((e) => e.toJSON()),
              yAxes: this.yAxes.asArray().map((e) => e.toJSON()),
              series: this.renderableSeries.asArray().map((t) => t.toJSON(e)),
              modifiers: this.chartModifiers.asArray().map((e) => e.toJSON()),
              annotations: this.annotations.asArray().map((e) => e.toJSON()),
              onCreated: this.onCreatedName,
              subCharts: this.subCharts.map((e) => e.toJSON(!1)),
              createSingle: !this.isCopyCanvasSurface,
            };
          }
          getNextState(e = !1) {
            return i(this, void 0, void 0, function* () {
              return (
                yield this.nextStateRender({
                  resumeBefore: !0,
                  invalidateOnResume: !0,
                  suspendAfter: !0,
                }),
                this.toJSON(e)
              );
            });
          }
          validateAndLink() {
            const e = [];
            return (
              this.renderableSeries.size() > 0 &&
                (0 === this.xAxes.size() &&
                  e.push("Chart must have at least one X axis"),
                0 === this.yAxes.size() &&
                  e.push("Chart must have at least one Y axis"),
                this.renderableSeries.asArray().forEach((t, r) => {
                  t.linkAxes();
                  const i = t.xAxis;
                  i ||
                    e.push(
                      `${t.type}, index ${r}, id ${t.id} references xAxisId ${t.xAxisId} which does not exist on the surface`
                    );
                  const o = t.yAxis;
                  o ||
                    e.push(
                      `${t.type}, index ${r}, id ${t.id} references yAxisId ${t.yAxisId} which does not exist on the surface`
                    ),
                    i &&
                      o &&
                      (i.isVerticalChart &&
                        ![
                          W.EAxisAlignment.Top,
                          W.EAxisAlignment.Bottom,
                        ].includes(o.axisAlignment) &&
                        e.push(
                          `For vertical chart (chart with X Axis alignment Left or Right) Y Axis alignment should be Top or Bottom, X Axis ID = ${i.id}`
                        ),
                      (0, W.getIsVertical)(i.axisAlignment) &&
                        (0, W.getIsVertical)(o.axisAlignment) &&
                        e.push(
                          "Both x and y axes can't have vertical alignment"
                        ),
                      (0, W.getIsHorizontal)(i.axisAlignment) &&
                        (0, W.getIsHorizontal)(o.axisAlignment) &&
                        e.push(
                          "Both x and y axes can't have horizontal alignment"
                        ));
                })),
              e
            );
          }
          applyOptions(e) {
            super.applyOptions(e),
              (null == e ? void 0 : e.layoutManager) &&
                ("layoutChart" in e.layoutManager ||
                  (e.layoutManager = (0, o.createType)(
                    y.EBaseType.LayoutManager,
                    e.layoutManager.type,
                    null,
                    e.layoutManager.options
                  )),
                (this.layoutManager = e.layoutManager)),
              (null == e ? void 0 : e.padding) && (this.padding = e.padding),
              (null == e ? void 0 : e.viewportBorder) &&
                (this.viewportBorder = e.viewportBorder),
              (null == e ? void 0 : e.canvasBorder) &&
                (this.canvasBorder = e.canvasBorder),
              (null == e ? void 0 : e.loader) && "toJSON" in e.loader
                ? (this.loaderJson = e.loader.toJSON())
                : !1 === (null == e ? void 0 : e.loader) &&
                  (this.loaderJson = !1),
              (null == e ? void 0 : e.drawSeriesBehindAxis) &&
                (this.drawSeriesBehindAxisProperty = e.drawSeriesBehindAxis),
              (null == e ? void 0 : e.autoColorMode) &&
                (this.autoColorMode = e.autoColorMode),
              (null == e ? void 0 : e.title) && (this.title = e.title),
              (null == e ? void 0 : e.titleStyle) &&
                (this.titleStyle = e.titleStyle),
              (null == e ? void 0 : e.background) &&
                (this.background = e.background),
              (null == e ? void 0 : e.touchAction) &&
                (this.touchActionProperty = e.touchAction);
          }
          resolveSurfaceOrders() {
            var e;
            if (this.isSubSurface)
              throw new Error(
                "resolveSurfaceOrders should only be called on a parent surface"
              );
            const t = [this, ...this.subCharts.filter((e) => e.isVisible)],
              r = [];
            for (const i of t) {
              i.resolvedSurfaceRenderOrder = void 0;
              const t =
                null !== (e = i.getSurfaceRenderOrder()) && void 0 !== e
                  ? e
                  : r.length;
              (i.resolvedSurfaceRenderOrder = t), r.push(i);
            }
            return (
              r.sort(
                (e, t) => e.getSurfaceRenderOrder() - t.getSurfaceRenderOrder()
              ),
              r
            );
          }
          detachChartModifier(e) {
            super.detachChartModifier(e),
              this.subCharts.forEach((t) => {
                e.onDetachSubSurface(t);
              });
          }
          attachChartModifier(e) {
            super.attachChartModifier(e),
              e.modifierType !== G.EModifierType.MultiChart2DModifier &&
                (e.setParentSurface(this),
                (e.invalidateParentCallback = this.invalidateElement),
                e.onAttach(),
                this.subCharts.forEach((t) => {
                  e.onAttachSubSurface(t);
                }),
                this.invalidateElement());
          }
          applySciChartBackground(e, t) {
            const r = t.getNativeContext();
            this.domChartRoot && (this.domChartRoot.style.background = e),
              r && (r.SetClearColor(0, 0, 0, 0), r.Clear());
          }
          setClearAlphaParams(e, t) {
            this.webAssemblyContext2D.SCRTSetClearAlphaParams(e, t);
          }
          zoomExtentsYInternal(
            e,
            t = 0,
            r = s.easing.outExpo,
            i = () => !0,
            o = () => {}
          ) {
            this.yAxes.asArray().forEach((a) => {
              if (i(a)) {
                const i = a.getWindowedYRange(e);
                i && a.animateVisibleRange(i, t, r, o);
              }
            });
          }
          zoomExtentsXInternal(
            e = 0,
            t = s.easing.outExpo,
            r = () => !0,
            i = () => {}
          ) {
            const o = new d.Dictionary();
            return (
              this.xAxes.asArray().forEach((a) => {
                if (r(a)) {
                  const r = a.getMaximumRange();
                  a.animateVisibleRange(r, e, t, i), o.add(a.id, r);
                }
              }),
              o
            );
          }
          onRenderSurfaceDraw() {
            var e, t;
            const r = j.PerformanceDebugHelper.mark(
              j.EPerformanceMarkType.RenderSurfaceDrawStart,
              { contextId: this.id }
            );
            if (
              (this.preRenderAll.raiseEvent(),
              this.subChartsProperty.length > 0)
            ) {
              const t = new S.BatchRenderContext(
                  this.webAssemblyContext2D,
                  this.renderSurface.viewportSize,
                  null === (e = this.domCanvas2D) || void 0 === e
                    ? void 0
                    : e.id
                ),
                r = this.resolveSurfaceOrders();
              r.forEach((e, i) => {
                i === r.length - 1 && (t.doDraw = !0), e.doDrawingLoop(t);
              });
            } else this.doDrawingLoop();
            this.renderedToWebGl.raiseEvent(
              this.sciChartRenderer.isInvalidated
            ),
              this.isCopyCanvasSurface ||
                this.renderedToDestination.raiseEvent(
                  this.sciChartRenderer.isInvalidated
                ),
              (this.painted.handlers.length > 0 ||
                j.PerformanceDebugHelper.enableDebug) &&
                (0, j.runAfterFramePaint)(() => {
                  j.PerformanceDebugHelper.mark(
                    j.EPerformanceMarkType.Painted,
                    { contextId: this.id }
                  ),
                    this.painted.raiseEvent(
                      this.sciChartRenderer.isInvalidated
                    );
                }),
              (this.currentWebGlRenderContextProperty = (0, l.deleteSafe)(
                this.currentWebGlRenderContext
              )),
              j.PerformanceDebugHelper.mark(
                j.EPerformanceMarkType.RenderSurfaceDrawEnd,
                {
                  contextId: this.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                }
              );
          }
          detachSeries(e) {
            e.type !== f.ESeriesType.StackedColumnSeries &&
              e.type !== f.ESeriesType.StackedMountainSeries &&
              (this.chartModifiers.asArray().forEach((t) => {
                t.onDetachSeries(e);
              }),
              e.onDetach(),
              this.autoColorMode === g.EAutoColorMode.OnAddRemoveSeries &&
                (this.autoColorRequired = !0),
              this.invalidateElement());
          }
          attachSeries(e) {
            if (e.type === f.ESeriesType.StackedColumnSeries) {
              let t = this.renderableSeries
                .asArray()
                .find((e) => e.type === f.ESeriesType.StackedColumnCollection);
              if (!t) {
                t = new w.StackedColumnCollection(this.webAssemblyContext2D);
                const r = this.renderableSeries
                  .asArray()
                  .findIndex((t) => t === e);
                this.renderableSeries.insert(r, t);
              }
              return t.add(e), void this.renderableSeries.remove(e);
            }
            if (e.type === f.ESeriesType.StackedMountainSeries) {
              let t = this.renderableSeries
                .asArray()
                .find(
                  (e) => e.type === f.ESeriesType.StackedMountainCollection
                );
              if (!t) {
                t = new M.StackedMountainCollection(this.webAssemblyContext2D);
                const r = this.renderableSeries
                  .asArray()
                  .findIndex((t) => t === e);
                this.renderableSeries.insert(r, t);
              }
              t.add(e), this.renderableSeries.remove(e);
            }
            (e.isStacked && !("size" in e)) || e.onAttach(this),
              this.themeProviderProperty &&
                e.applyTheme(this.themeProviderProperty),
              this.chartModifiers.asArray().forEach((t) => {
                t.onAttachSeries(e);
              }),
              this.autoColorMode === g.EAutoColorMode.OnAddRemoveSeries &&
                (this.autoColorRequired = !0),
              this.invalidateElement();
          }
          detachAxis(e) {
            e.onDetach(), this.invalidateElement();
          }
          checkAxisIdUniqueness(e, t) {
            t &&
              !this.xAxes.checkIdUniqueness(e) &&
              console.error(`The X axis Id ${e} is not unique`),
              t ||
                this.yAxes.checkIdUniqueness(e) ||
                console.error(`The Y axis Id ${e} is not unique`);
          }
          attachAxis(e, t) {
            if (e.invalidateParentCallback)
              throw new Error(
                "Invalid operation in sciChartSurface.attachAxis, this axis has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            this.checkAxisIdUniqueness(e.id, t);
            let r = !1;
            t && !this.xAxes.asArray().some((e) => e.isPrimaryAxis) && (r = !0),
              t ||
                this.yAxes.asArray().some((e) => e.isPrimaryAxis) ||
                (r = !0),
              e.onAttach(this, t, r),
              this.themeProviderProperty &&
                e.applyTheme(this.themeProviderProperty),
              (e.invalidateParentCallback = this.invalidateElement),
              this.invalidateElement();
          }
          onAttachSubSurface(e) {
            this.chartModifiers.asArray().forEach((t) => {
              t.onAttachSubSurface(e);
            });
          }
          onDetachSubSurface(e) {
            this.chartModifiers.asArray().forEach((t) => {
              t.onDetachSubSurface(e);
            });
          }
          get drawSeriesBehindAxis() {
            return this.drawSeriesBehindAxisProperty;
          }
          set drawSeriesBehindAxis(e) {
            (this.drawSeriesBehindAxisProperty = e), this.invalidateElement();
          }
        }
        t.SciChartSurface = Z;
      },
      14184: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getLocateFile =
            t.getMasterCanvas =
            t.createChartDestination =
            t.SciChartSurfaceBase =
            t.DebugForDpi =
              void 0);
        const o = r(45921),
          a = r(84518),
          s = r(43621),
          n = r(84745),
          l = r(55023),
          d = r(56744),
          h = r(3214),
          u = r(99263),
          c = r(23866),
          p = r(85258),
          g = r(37796),
          y = r(40593),
          f = r(50605),
          v = r(62049),
          m = r(11043),
          S = r(66405),
          P = r(19145),
          C = r(45215),
          b = r(73538),
          x = (r(27307), r(2705)),
          A = r(86127),
          T = r(83823);
        t.DebugForDpi = !1;
        class E extends l.DeletableEntity {
          constructor(e, t = {}) {
            if (
              (super(),
              (this.suspender = new T.UpdateSuspender()),
              (this.layoutMeasured = new h.EventHandler()),
              (this.genericAnimationsRun = new h.EventHandler()),
              (this.renderedToWebGl = new h.EventHandler()),
              (this.rendered = new h.EventHandler()),
              (this.renderedToDestination = new h.EventHandler()),
              (this.painted = new h.EventHandler()),
              (this.themeProviderProperty = E.DEFAULT_THEME),
              (this.previousThemeProviderProperty = E.DEFAULT_THEME),
              (this.isInitializedProperty = !1),
              (this.isDeletedProperty = !1),
              (this.idProperty = (0, b.generateGuid)()),
              (this.deletables = []),
              (this.freezeWhenOutOfViewProperty = !1),
              c.Guard.notNull(e, "webAssemblyContext"),
              (this.domChartRoot = t.domChartRoot),
              (this.domCanvasWebGL = t.domCanvasWebGL),
              (this.domCanvas2D = t.domCanvas2D),
              (this.domSvgContainer = t.domSvgContainer),
              (this.domSvgAdornerLayer = t.domSvgAdornerLayer),
              (this.domBackgroundSvgContainer = t.domBackgroundSvgContainer),
              (this.domSeriesBackground = t.domSeriesBackground),
              (this.domDivContainer = t.domDivContainer),
              (this.sharedWasmContext = e),
              (this.propertyChanged = new h.EventHandler()),
              e.TSRSetDrawRequestsEnabled(!0),
              (this.detachChartModifier = this.detachChartModifier.bind(this)),
              (this.attachChartModifier = this.attachChartModifier.bind(this)),
              (this.chartModifiers = new g.ObservableArray()),
              this.chartModifiers.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach((e) => this.detachChartModifier(e)),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach((e) => this.attachChartModifier(e));
              }),
              (this.detachAnnotation = this.detachAnnotation.bind(this)),
              (this.attachAnnotation = this.attachAnnotation.bind(this)),
              (this.annotations = new g.ObservableArray()),
              (this.modifierAnnotations = new g.ObservableArray()),
              this.annotations.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach((e) => this.detachAnnotation(e)),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach((e) => this.attachAnnotation(e));
              }),
              this.modifierAnnotations.collectionChanged.subscribe((e) => {
                var t, r;
                null === (t = e.getOldItems()) ||
                  void 0 === t ||
                  t.forEach((e) => this.detachAnnotation(e)),
                  null === (r = e.getNewItems()) ||
                    void 0 === r ||
                    r.forEach((e) => this.attachAnnotation(e));
              }),
              (this.mouseManager = new p.MouseManager(this)),
              t.domCanvasWebGL
                ? this.mouseManager.subscribe(t.domCanvasWebGL)
                : t.domCanvas2D && this.mouseManager.subscribe(t.domCanvas2D),
              (this.onDpiChanged = this.onDpiChanged.bind(this)),
              A.DpiHelper.dpiChanged.subscribe(this.onDpiChanged),
              !n.IS_TEST_ENV && E.invalidateOnTabVisible)
            ) {
              const e = () => {
                "visible" === document.visibilityState &&
                  this.invalidateElement({ force: !0 });
              };
              document.addEventListener("visibilitychange", e),
                this.addDeletable({
                  delete: () =>
                    document.removeEventListener("visibilitychange", e),
                });
            }
          }
          static disposeSharedWasmContext() {
            0 === u.sciChart3DDestinations.length &&
              0 === u.sciChartDestinations.length &&
              E.domMasterCanvas &&
              (document.body.removeChild(E.domMasterCanvas),
              (E.domMasterCanvas = void 0)),
              (0, a.forceReapplyLicense2D)(),
              (0, s.forceReapplyLicense3D)();
          }
          static setRuntimeLicenseKey(e) {
            a.licenseManager.setRuntimeLicenseKey(e);
          }
          static UseCommunityLicense() {
            a.licenseManager.setRuntimeLicenseKey("community");
          }
          static setServerLicenseEndpoint(e) {
            a.licenseManager.setServerLicenseEndpoint(e);
          }
          static setLicenseCallback(e) {
            a.licenseManager.setLicenseCallback(e);
          }
          static resolveOptions(e) {
            if ((null == e ? void 0 : e.theme) && "type" in e.theme) {
              if (!("applyOverrides" in e.theme)) {
                const t = (0, o.createType)(
                  m.EBaseType.ThemeProvider,
                  e.theme.type,
                  null,
                  e.theme
                );
                "applyOverrides" in t && t.applyOverrides(e.theme),
                  (e.theme = t);
              }
            } else
              e
                ? (e.theme = E.DEFAULT_THEME)
                : (e = { theme: E.DEFAULT_THEME });
            return (
              (null == e ? void 0 : e.loader) &&
                ("addChartLoader" in e.loader ||
                  (e.loader = (0, o.createType)(
                    m.EBaseType.Loader,
                    e.loader.type,
                    null,
                    e.loader
                  ))),
              e
            );
          }
          get id() {
            return this.idProperty;
          }
          set id(e) {
            this.idProperty = e;
          }
          get background() {
            return this.backgroundProperty;
          }
          set background(e) {
            this.backgroundProperty !== e &&
              ((this.backgroundProperty = e),
              this.notifyPropertyChanged("Background"));
          }
          get isCopyCanvasSurface() {
            return !this.domCanvasWebGL && this.domCanvas2D;
          }
          get seriesViewRect() {
            return this.seriesViewRectProperty;
          }
          get viewRect() {
            return this.chartViewRect;
          }
          get clipRect() {
            return this.viewRect;
          }
          get otherSurfaces() {
            return this.destinations
              ? this.destinations
                  .map((e) => e.sciChartSurface)
                  .filter((e) => e !== this)
              : [];
          }
          get isInitialized() {
            return this.isInitializedProperty;
          }
          get isDeleted() {
            return this.isDeletedProperty;
          }
          get isSuspended() {
            return this.suspender.isSuspended;
          }
          resumeUpdates(e) {
            var t;
            this.suspender.resume(null == e ? void 0 : e.force),
              (null === (t = null == e ? void 0 : e.invalidateOnResume) ||
                void 0 === t ||
                t) &&
                this.invalidateElement();
          }
          suspendUpdates() {
            this.suspender.suspend();
          }
          applyTheme(e) {
            (this.previousThemeProviderProperty = this.themeProviderProperty),
              (this.themeProviderProperty = e),
              this.chartModifiers.asArray().forEach((t) => t.applyTheme(e)),
              this.invalidateElement();
          }
          get themeProvider() {
            return this.themeProviderProperty;
          }
          get previousThemeProvider() {
            return this.previousThemeProviderProperty;
          }
          get isPolar() {
            return this.surfaceType === P.ESurfaceType.SciChartPolarSurfaceType;
          }
          set freezeWhenOutOfView(e) {
            var t, r;
            (this.freezeWhenOutOfViewProperty = e),
              e && !this.visibilityObserver
                ? (this.visibilityObserver = y.VisibilityObserver.observe(
                    this.domChartRoot,
                    (e) => {
                      e || this.cleanupLockToken
                        ? e &&
                          this.cleanupLockToken &&
                          (this.cleanupLockToken(),
                          (this.cleanupLockToken = void 0))
                        : (this.cleanupLockToken = this.suspender.lock());
                    }
                  ))
                : !e &&
                  this.visibilityObserver &&
                  (null === (t = this.visibilityObserver) ||
                    void 0 === t ||
                    t.disconnect(),
                  (this.visibilityObserver = void 0),
                  null === (r = this.cleanupLockToken) ||
                    void 0 === r ||
                    r.call(this));
          }
          get freezeWhenOutOfView() {
            return this.freezeWhenOutOfViewProperty;
          }
          delete(e = !0) {
            var t, r;
            this.isDeletedProperty = !0;
            const i =
              null === (t = this.destinations) || void 0 === t
                ? void 0
                : t.findIndex((e) => e.sciChartSurface.id === this.id);
            i >= 0 && this.destinations.splice(i, 1),
              A.DpiHelper.dpiChanged.unsubscribe(this.onDpiChanged),
              this.mouseManager.unsubscribe(),
              (this.mouseManager = void 0),
              this.chartModifiers.asArray().forEach((e) => e.delete()),
              this.modifierAnnotations.asArray().forEach((e) => e.delete()),
              this.annotations.asArray().forEach((e) => e.delete()),
              (this.adornerLayer = void 0);
            for (const e of this.deletables) (0, d.deleteSafe)(e);
            (this.domChartRoot = void 0),
              (this.domCanvasWebGL = void 0),
              (this.domCanvas2D = void 0),
              (this.domSvgContainer = void 0),
              (this.domSvgAdornerLayer = void 0),
              (this.domBackgroundSvgContainer = void 0),
              (this.domSeriesBackground = void 0),
              (this.domDivContainer = void 0),
              (this.sharedWasmContext = void 0),
              (this.deletables = []),
              null === (r = this.visibilityObserver) ||
                void 0 === r ||
                r.disconnect(),
              (this.visibilityObserver = void 0);
          }
          addDeletable(e) {
            this.deletables.push(e);
          }
          getMainCanvas() {
            return this.domCanvasWebGL || this.domCanvas2D;
          }
          setSeriesViewRect(e) {
            this.seriesViewRectProperty = e;
          }
          setDestinations(e) {
            this.destinations = e;
          }
          setIsInitialized() {
            this.isInitializedProperty = !0;
          }
          onDpiChanged(e) {
            this.annotations.asArray().forEach((t) => t.onDpiChanged(e)),
              this.modifierAnnotations
                .asArray()
                .forEach((t) => t.onDpiChanged(e)),
              this.invalidateElement();
          }
          nextStateRender(e) {
            return i(this, void 0, void 0, function* () {
              return new Promise((t, r) => {
                const i = (o) => {
                  try {
                    if (!o) {
                      if (null == e ? void 0 : e.suspendAfter) {
                        const e = this.suspendUpdates();
                        t(e);
                      } else t(null);
                      this.rendered.unsubscribe(i);
                    }
                  } catch (e) {
                    console.error(e), r(e);
                  }
                };
                this.rendered.subscribe(i),
                  (null == e ? void 0 : e.resumeBefore) &&
                    (this.resumeUpdates(),
                    (null == e ? void 0 : e.invalidateOnResume) &&
                      this.invalidateElement());
              });
            });
          }
          get chartModifierGroups() {
            const e = this.chartModifiers
              .asArray()
              .filter((e) => void 0 !== e.modifierGroup)
              .map((e) => e.modifierGroup);
            return (0, C.getUniqueValues)(e);
          }
          clearRootElement(e) {
            if (e && this.domChartRoot) {
              const e = this.domChartRoot.style;
              e && ((e.background = ""), (e.position = "")),
                this.domChartRoot.hasOwnProperty("replaceChildren")
                  ? this.domChartRoot.replaceChildren()
                  : (this.domChartRoot.innerHTML = "");
            }
          }
          applyOptions(e) {
            var t, r;
            (this.idProperty =
              null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                ? t
                : this.idProperty),
              (this.widthAspect = null == e ? void 0 : e.widthAspect),
              (this.heightAspect = null == e ? void 0 : e.heightAspect),
              (this.disableAspect = null == e ? void 0 : e.disableAspect),
              (this.freezeWhenOutOfView =
                null !== (r = null == e ? void 0 : e.freezeWhenOutOfView) &&
                void 0 !== r &&
                r);
          }
          detachChartModifier(e) {
            e.modifierType !== S.EModifierType.MultiChart2DModifier &&
              ((e.invalidateParentCallback = void 0),
              e.onDetach(),
              e.setParentSurface(void 0),
              this.invalidateElement());
          }
          attachChartModifier(e) {
            if (e.modifierType === S.EModifierType.MultiChart2DModifier) {
              if (
                this.chartModifiers.asArray().filter((t) => t === e).length > 1
              )
                throw Error(
                  "Invalid operation in sciChartSurface.attachChartModifier, this FinChartModifier has already been attached to this SciChartSurface."
                );
            } else if (e.invalidateParentCallback)
              throw Error(
                "Invalid operation in sciChartSurface.attachChartModifier, this chartModifier has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            this.themeProviderProperty &&
              e.applyTheme(this.themeProviderProperty);
          }
          notifyPropertyChanged(e) {
            var t;
            null === (t = this.propertyChanged) ||
              void 0 === t ||
              t.raiseEvent(new f.PropertyChangedEventArgs(e)),
              this.invalidateElement();
          }
          changeMasterCanvasViewportSize(e, t, r) {
            if (!E.domMasterCanvas) return;
            let i = t,
              o = r;
            const a = E.domMasterCanvas.width / A.DpiHelper.PIXEL_RATIO,
              s = E.domMasterCanvas.height / A.DpiHelper.PIXEL_RATIO;
            a > i && (i = a),
              s > o && (o = s),
              A.DpiHelper.setSize(E.domMasterCanvas, i, o);
            const n = E.domMasterCanvas.width,
              l = E.domMasterCanvas.height;
            e.SCRTSetMainWindowSize(n, l);
          }
          changeWebGLCanvasViewportSize(e, t, r) {
            if (!this.domCanvasWebGL) return;
            const i = t * A.DpiHelper.PIXEL_RATIO,
              o = r * A.DpiHelper.PIXEL_RATIO;
            A.DpiHelper.setSize(this.domCanvasWebGL, t, r),
              e.SCRTSetMainWindowSize(i, o);
          }
          setSvgClipPathDefinitions(e, t, r) {
            let i = e.querySelector("defs");
            const o = `seriesViewRectClip_${this.id}`,
              a = `surfaceViewRectClip_${this.id}`;
            if (!i || !i.querySelector(`[id='${o}']`)) {
              const t = "http://www.w3.org/2000/svg";
              i = document.createElementNS(t, "defs");
              const r = document.createElementNS(t, "clipPath");
              r.setAttribute("id", o);
              const s = document.createElementNS(t, "rect");
              r.appendChild(document.createElementNS(t, "rect")),
                r.appendChild(s),
                i.appendChild(r);
              const n = document.createElementNS(t, "clipPath");
              n.setAttribute("id", a);
              const l = document.createElementNS(t, "rect");
              n.appendChild(document.createElementNS(t, "rect")),
                n.appendChild(l),
                i.appendChild(n),
                e.appendChild(i);
            }
            const s = i.querySelector(`[id='${o}']`).firstElementChild,
              n = i.querySelector(`[id='${a}']`).firstElementChild;
            s.setAttribute("x", `${t.x}`),
              s.setAttribute("y", `${t.y}`),
              s.setAttribute("width", `${t.width}`),
              s.setAttribute("height", `${t.height}`),
              n.setAttribute("x", `${r.x}`),
              n.setAttribute("y", `${r.y}`),
              n.setAttribute("width", `${r.width}`),
              n.setAttribute("height", `${r.height}`);
          }
          detachAnnotation(e) {
            e.onDetach(),
              (e.invalidateParentCallback = void 0),
              (e.parentSurface = void 0),
              this.invalidateElement();
          }
          attachAnnotation(e) {
            if (e.invalidateParentCallback)
              throw new Error(
                "Invalid operation in sciChartSurface.attachAnnotation, this annotation has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another"
              );
            (e.parentSurface = this),
              (e.invalidateParentCallback = this.invalidateElement),
              e.onAttach(this),
              this.invalidateElement();
          }
        }
        (t.SciChartSurfaceBase = E),
          (E.DEFAULT_THEME = new x.SciChartJSDarkv2Theme()),
          (E.AntiAliasWebGlBackbuffer = !1),
          (E.wasmContextDisposeTimeout = 0),
          (E.autoDisposeWasmContext = !1),
          (E.invalidateOnTabVisible = !0),
          (t.createChartDestination = (e) => {
            if (e)
              return {
                canvas: e,
                GetHeight() {
                  return this.canvas.height;
                },
                GetWidth() {
                  return this.canvas.width;
                },
                GetID() {
                  return this.canvas.id;
                },
              };
          }),
          (t.getMasterCanvas = () => {
            if (!E.domMasterCanvas) {
              const e = document.createElement("canvas");
              (e.id = "SciChartMasterCanvas"),
                (e.style.display = "none"),
                (e.style.position = "absolute"),
                (e.style.left = "0"),
                (e.style.top = "0"),
                t.DebugForDpi &&
                  ((e.style.background = "#00000077"),
                  (e.style.pointerEvents = "none"),
                  (e.style.left = ""),
                  (e.style.top = ""),
                  (e.style.display = "inline")),
                e.addEventListener(
                  "webglcontextcreationerror",
                  (e) => {
                    console.warn(
                      "WebGL Context creation error: ",
                      e.statusMessage || "Unknown error"
                    );
                  },
                  !1
                ),
                document.body.appendChild(e),
                v.WebGlHelper.getContext(e, {
                  premultipliedAlpha: !0,
                  antialias: E.AntiAliasWebGlBackbuffer,
                }),
                (E.domMasterCanvas = e);
            }
            return E.domMasterCanvas;
          }),
          (t.getLocateFile = (e) => (t, r) =>
            t.endsWith(".wasm") && e.wasmUrl ? e.wasmUrl : r + t);
      },
      35992: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CanvasTexture = void 0);
        const i = r(84745),
          o = r(56744),
          a = r(80445),
          s = r(23866),
          n = r(55023);
        class l extends n.DeletableEntity {
          constructor(e, t, r) {
            super(),
              (this.width = Math.floor(t)),
              (this.height = Math.floor(r)),
              s.Guard.isTrue(
                this.width > 0,
                "CanvasTexture.width must be greater than zero"
              ),
              s.Guard.isTrue(
                this.height > 0,
                "CanvasTexture.height must be greater than zero"
              ),
              i.IS_TEST_ENV ||
                ((this.canvas = document.createElement("canvas")),
                (this.canvas.width = this.width),
                (this.canvas.height = this.height)),
              (this.wasmContext = e),
              (this.intermediateVector = new this.wasmContext.UIntVector()),
              this.intermediateVector.resize(this.height * this.width, 0),
              (this.originalIntermediateVector =
                new this.wasmContext.UIntVector()),
              this.originalIntermediateVector.resize(
                this.height * this.width,
                0
              );
            const o =
              this.wasmContext.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8;
            (this.tsrTextureCache = new a.TextureCache(e)),
              this.tsrTextureCache.create(this.width, this.height, o);
          }
          getContext() {
            return this.canvas.getContext("2d", { willReadFrequently: !0 });
          }
          getTexture() {
            return this.tsrTextureCache.value;
          }
          clear() {
            this.getContext().clearRect(0, 0, this.width, this.height),
              this.intermediateVector.fill(0),
              this.originalIntermediateVector.fill(0);
          }
          delete() {
            (this.intermediateVector = (0, o.deleteSafe)(
              this.intermediateVector
            )),
              (this.originalIntermediateVector = (0, o.deleteSafe)(
                this.originalIntermediateVector
              )),
              (this.tsrTextureCache = (0, o.deleteSafe)(this.tsrTextureCache)),
              (this.wasmContext = void 0);
          }
          copyTexture() {
            var e;
            const t = this.width * this.height;
            if (
              !this.intermediateVector ||
              this.intermediateVector.size() !== t
            )
              throw new Error(
                `CanvasTexture.ts: IntermediateVector size is ${
                  null === (e = this.intermediateVector) || void 0 === e
                    ? void 0
                    : e.size()
                } and expected ${t}`
              );
            const r = this.getContext().getImageData(
                0,
                0,
                this.width,
                this.height
              ).data,
              i = this.width * this.height;
            for (let e = 0; e < i; e++) {
              const t = 4 * e,
                i = r[t + 3];
              if (0 !== i) {
                const o = (i << 24) | (r[t] << 16) | (r[t + 1] << 8) | r[t + 2];
                this.intermediateVector.set(e, o >>> 0),
                  this.originalIntermediateVector.set(e, o >>> 0);
              }
            }
            const o = this.tsrTextureCache.value;
            this.wasmContext.SCRTFillTextureAbgr(
              o,
              this.width,
              this.height,
              this.intermediateVector
            );
          }
          applyOpacity(e) {
            this.wasmContext.SCRTMultiplyColorVectorOpacity(
              this.originalIntermediateVector,
              this.intermediateVector,
              e
            );
            const t = this.tsrTextureCache.value;
            this.wasmContext.SCRTFillTextureAbgr(
              t,
              this.width,
              this.height,
              this.intermediateVector
            );
          }
        }
        t.CanvasTexture = l;
      },
      86127: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DpiHelper = void 0);
        const i = r(84745),
          o = r(3214),
          a = r(87108),
          s = r(14184);
        class n {
          static initialize() {
            n.initialized ||
              ((n.PIXEL_RATIO = 1),
              n.IsDpiScaleEnabled &&
                "undefined" != typeof window &&
                window.devicePixelRatio &&
                (n.PIXEL_RATIO = window.devicePixelRatio),
              s.DebugForDpi &&
                console.log(
                  "Initializing Dpi Helper. Scaling factor = " + n.PIXEL_RATIO
                ),
              n.IsDpiScaleEnabled &&
                !i.IS_TEST_ENV &&
                window.addEventListener("resize", () => {
                  const e = window.devicePixelRatio || 1,
                    t = n.PIXEL_RATIO;
                  t !== e &&
                    (s.DebugForDpi &&
                      console.log(`Dpi Changing, was ${t}, now ${e}`),
                    (n.PIXEL_RATIO = e),
                    n.dpiChanged.raiseEvent({ newValue: e, oldValue: t }));
                }),
              (n.initialized = !0));
          }
          static createCanvas(e = 0, t = 0) {
            const r = document.createElement("canvas");
            return e && t && n.setSize(r, e, t), r;
          }
          static setSize(e, t, r) {
            n.setWidth(e, t), n.setHeight(e, r);
          }
          static setWidth(e, t) {
            s.DebugForDpi &&
              console.log(
                `setWidth ${e.id} backBuffer=${t * n.PIXEL_RATIO} display=${t}`
              ),
              (e.width = t * n.PIXEL_RATIO);
          }
          static setHeight(e, t) {
            s.DebugForDpi &&
              console.log(
                `setHeight ${e.id} backBuffer=${t * n.PIXEL_RATIO} display=${t}`
              ),
              (e.height = t * n.PIXEL_RATIO);
          }
          static adjustLineStyle(e, t = n.PIXEL_RATIO) {
            const r = Object.assign({}, e);
            return (r.end *= t), (r.start *= t), (r.strokeThickness *= t), r;
          }
          static adjustTextStyle(e, t = n.PIXEL_RATIO) {
            const r = Object.assign({}, e);
            return (
              (r.fontSize = Math.round(r.fontSize * t)),
              e.padding && (r.padding = n.adjustThickness(e.padding, t)),
              r
            );
          }
          static adjustStrokeSize(e, t = n.PIXEL_RATIO) {
            var r;
            const i = Object.assign({}, e),
              o = Math.round(e.strokeThickness * t);
            return (
              (i.strokeDashArray =
                null === (r = e.strokeDashArray) || void 0 === r
                  ? void 0
                  : r.map((e) => Math.round(e * t))),
              (i.strokeThickness = o > 0 || 0 === e.strokeThickness ? o : 1),
              i
            );
          }
          static adjustThickness(e, t = n.PIXEL_RATIO) {
            return new a.Thickness(
              Math.round(e.top * t),
              Math.round(e.right * t),
              Math.round(e.bottom * t),
              Math.round(e.left * t)
            );
          }
        }
        (t.DpiHelper = n),
          (n.IsDpiScaleEnabled = !0),
          (n.dpiChanged = new o.EventHandler());
      },
      76829: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.measureTextWidth =
            t.measureTextHeight =
            t.TextureManager =
              void 0);
        const i = r(84745),
          o = r(55023),
          a = r(38215),
          s = r(63415),
          n = r(52578),
          l = r(48008),
          d = r(98353),
          h = r(86127);
        class u extends o.DeletableEntity {
          constructor(e) {
            super(),
              (this.webAssemblyContext = e),
              i.IS_TEST_ENV ||
                ((this.canvas = document.createElement("canvas")),
                (this.canvas.width = 1920),
                (this.canvas.height = 1080),
                (this.ctx = this.canvas.getContext("2d", {
                  willReadFrequently: !0,
                })));
          }
          createSimpleTextTexture(e, t, r, i, o, a) {
            let s = 0;
            return (
              i && (s = o ? 90 : -90),
              this.createTextTexture([e], t, s, void 0, r, a)
            );
          }
          createTextTextureNative(e, t, r, i, o, a) {
            const {
                fontStyle: s,
                fontWeight: n,
                fontFamily: h,
                fontSize: u,
                padding: c,
                alignment: p,
                color: g,
              } = t,
              y = this.webAssemblyContext.SCRTGetMainRenderContext2D(),
              f = (0, d.getFontKey)(this.webAssemblyContext, {
                fontFamily: h,
                fontSize: null != u ? u : 12,
              }),
              v = o ? (0, l.parseColorToUIntArgb)(o) : 0;
            let m = y.CreateTextTextureColored(
              f,
              e.join("\n"),
              (0, l.parseColorToUIntArgb)(g),
              v
            );
            this.webAssemblyContext.SCRTSetTextureLinearSamplerEnabled(m, !1);
            const S = m.GetWidth(),
              P = m.GetHeight();
            return { bitmapTexture: m, textureWidth: S, textureHeight: P };
          }
          createTextTexture(e, r, o, a, l, d) {
            var h;
            if (i.IS_TEST_ENV)
              return {
                bitmapTexture: void 0,
                textureWidth: 1,
                textureHeight: 1,
              };
            const {
              fontStyle: u,
              fontWeight: c,
              fontFamily: p,
              fontSize: g,
              padding: y,
              alignment: f,
              color: v,
            } = r;
            this.ctx.save(),
              (this.ctx.globalAlpha = null != d ? d : 1),
              (this.ctx.textBaseline = "alphabetic"),
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height),
              l &&
                ((this.ctx.fillStyle = l),
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)),
              (this.ctx.fillStyle = v),
              (this.ctx.font = (0, n.getFontString)(u, c, g, p));
            let m = 0,
              S = y.top + y.bottom,
              P = 0,
              C = 0;
            const b = [];
            for (let t = 0; t < e.length; t++) {
              const r = e[t],
                i = this.ctx.measureText(r),
                o = Math.round(
                  i.actualBoundingBoxAscent + i.actualBoundingBoxDescent
                );
              b.push(o),
                o > P && (P = o),
                0 === t && (C = i.actualBoundingBoxAscent);
              const a = Math.round(i.width + y.left + y.right);
              a > m && (m = a), (S += o);
            }
            const x = Math.round(P * ((null != a ? a : 1.1) - 1));
            S += (e.length - 1) * x;
            let A = y.top + C,
              T = y.left;
            if (!m || !S)
              return {
                bitmapTexture: void 0,
                textureWidth: m,
                textureHeight: S,
              };
            let E = m,
              R = S;
            if (o) {
              const e = (o * Math.PI) / 180;
              (E = Math.round(
                m * Math.abs(Math.cos(e)) + S * Math.abs(Math.sin(e))
              )),
                (R = Math.round(
                  m * Math.abs(Math.sin(e)) + S * Math.abs(Math.cos(e))
                )),
                this.ctx.translate(E / 2, R / 2),
                this.ctx.rotate(e),
                this.ctx.translate(-m / 2, -S / 2);
            }
            const D =
                null !== (h = r.multilineAlignment) && void 0 !== h ? h : f,
              w = m - y.right - y.left;
            for (let r = 0; r < e.length; r++) {
              const i = e[r];
              if (
                D === s.ELabelAlignment.Center ||
                D === s.ELabelAlignment.Right
              ) {
                const e = (0, t.measureTextWidth)(this.ctx, i);
                T =
                  D === s.ELabelAlignment.Right
                    ? m - e - y.right
                    : (w - e) / 2 + y.left;
              }
              this.ctx.fillText(i, Math.round(T), Math.round(A)),
                (A += b[r] + x);
            }
            return (
              (this.ctx.strokeStyle = v),
              this.ctx.restore(),
              this.createTextureFromCtxBuffer(E, R)
            );
          }
          createAxisMarkerTexture(e, r, i, o, s, l, d, h = 0, u, p) {
            (this.ctx.globalAlpha = null != p ? p : 1),
              (this.ctx.textBaseline = "top"),
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height),
              (this.ctx.font = (0, n.getFontString)(i, o, s, l));
            const g = (0, t.measureTextWidth)(this.ctx, r) + 4 * h,
              y = (0, t.measureTextHeight)(s) + 2 * h,
              {
                angle: f,
                alignmentLeft: v,
                alignmentTop: m,
                finalTextureWidth: S,
                finalTextureHeight: P,
                halfHeight: C,
              } = c(y, g, r, e);
            if (
              (this.ctx.save(),
              this.ctx.translate((g + C) / 2, y / 2),
              this.ctx.rotate(f),
              this.ctx.translate(v, m),
              u)
            ) {
              const e = new Path2D(),
                t = y,
                r = g;
              e.moveTo(0, 0),
                e.lineTo(r, 0),
                e.lineTo(C + r, C),
                e.lineTo(r, t),
                e.lineTo(0, t),
                e.closePath(),
                (this.ctx.fillStyle = u),
                this.ctx.fill(e);
            }
            return (
              e !== a.EAxisAlignment.Right &&
                ((this.ctx.fillStyle = d), this.ctx.fillText(r, 2 * h, h)),
              this.ctx.restore(),
              e === a.EAxisAlignment.Right &&
                ((this.ctx.fillStyle = d), this.ctx.fillText(r, 2 * h + C, h)),
              this.createTextureFromCtxBuffer(S, P)
            );
          }
          createTextureFromImage(e, t, r) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const i = (null != t ? t : e.width) * h.DpiHelper.PIXEL_RATIO,
              o = (null != r ? r : e.height) * h.DpiHelper.PIXEL_RATIO;
            return (
              this.ctx.drawImage(e, 0, 0, i, o),
              this.createTextureFromCtxBuffer(i, o)
            );
          }
          getTextureContext(e, t) {
            if (!i.IS_TEST_ENV)
              return (
                e > this.canvas.width && (this.canvas.width = e),
                t > this.canvas.height && (this.canvas.height = t),
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height),
                this.ctx
              );
          }
          createTextureFromCtxBuffer(e, t) {
            const r = this.ctx.getImageData(0, 0, e, t);
            return this.createTextureFromImageData(r, e, t);
          }
          createTextureFromImageData(e, t, r) {
            const i =
                this.webAssemblyContext.eTSRTextureFormat
                  .TSR_TEXTUREFORMAT_A8B8G8R8,
              o = this.webAssemblyContext.SCRTCreateBitmapTexture(t, r, i);
            let a;
            try {
              const i = e.data;
              this.webAssemblyContext.SCRTSetActiveTexture(o),
                (a = this.webAssemblyContext._malloc(i.length)),
                this.webAssemblyContext.HEAP8.set(i, a),
                this.webAssemblyContext.ccall(
                  "SCRTFillActiveTextureCharArray",
                  null,
                  ["number", "number", "number"],
                  [t, r, a]
                );
            } catch (e) {
              console.error(e);
            } finally {
              this.webAssemblyContext._free(a),
                this.webAssemblyContext.SCRTSetTextureLinearSamplerEnabled(
                  o,
                  !1
                );
            }
            return { bitmapTexture: o, textureWidth: t, textureHeight: r };
          }
          delete() {
            (this.canvas = void 0),
              (this.ctx = void 0),
              (this.webAssemblyContext = void 0);
          }
          createTextureFromCtx(e, t) {
            const r = this.ctx.getImageData(0, 0, e, t).data,
              i = e * t,
              o = new this.webAssemblyContext.UIntVector();
            o.resize(i, 0);
            for (let e = 0; e < i; e++) {
              const t = 4 * e,
                i = r[t + 3];
              if (0 !== i) {
                const a = r[t],
                  s = r[t + 1],
                  n = (i << 24) | (r[t + 2] << 16) | (s << 8) | a;
                o.set(e, n >>> 0);
              }
            }
            const a =
                this.webAssemblyContext.eTSRTextureFormat
                  .TSR_TEXTUREFORMAT_A8B8G8R8,
              s = this.webAssemblyContext.SCRTCreateBitmapTexture(e, t, a);
            return (
              this.webAssemblyContext.SCRTFillTextureAbgr(s, e, t, o),
              o.delete(),
              { bitmapTexture: s, textureWidth: e, textureHeight: t }
            );
          }
        }
        (t.TextureManager = u),
          (t.measureTextHeight = (e) => e),
          (t.measureTextWidth = (e, t) => {
            if (i.IS_TEST_ENV) return 1;
            const r = e.measureText(t);
            return Math.ceil(r.width);
          });
        const c = (e, t, r, i) => {
          const o = Math.ceil(e / 2);
          let s = 0,
            n = 0,
            l = 0,
            d = t + o,
            h = e;
          switch (i) {
            case a.EAxisAlignment.Left:
              (s = 0), (n = -(t + o) / 2), (l = -e / 2);
              break;
            case a.EAxisAlignment.Top:
              (s = 0.5 * Math.PI),
                (n = -e / 2),
                (l = (t + o) / 2 - e),
                (d = e),
                (h = t + o);
              break;
            case a.EAxisAlignment.Right:
              (s = Math.PI), (n = -(t + o) / 2), (l = -e / 2);
              break;
            case a.EAxisAlignment.Bottom:
              (s = 1.5 * Math.PI),
                (n = -t),
                (l = -(t + o) / 2),
                (d = e),
                (h = t + o);
          }
          return {
            angle: s,
            alignmentLeft: n,
            alignmentTop: l,
            finalTextureWidth: d,
            finalTextureHeight: h,
            halfHeight: o,
          };
        };
      },
      83823: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UpdateSuspender = void 0);
        const i = r(3214);
        t.UpdateSuspender = class {
          constructor() {
            (this.onResumed = new i.EventHandler()),
              (this.suspendCounter = 0),
              (this.locks = new Set());
          }
          get isSuspended() {
            return this.suspendCounter > 0 || this.locks.size > 0;
          }
          suspend() {
            this.suspendCounter++;
          }
          resume(e = !1) {
            (this.suspendCounter = e
              ? 0
              : Math.max(this.suspendCounter - 1, 0)),
              0 === this.suspendCounter && this.onResumed.raiseEvent();
          }
          lock() {
            const e = () => this.locks.delete(e);
            return this.locks.add(e), e;
          }
        };
      },
      13639: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.copyToCanvas = void 0);
        const i = r(9254),
          o = r(16602);
        t.copyToCanvas = (e, t) => (r) => {
          var a;
          i.Logger.debug("copyToCanvas");
          const s = o.PerformanceDebugHelper.mark(
              o.EPerformanceMarkType.CopyToCanvasStart,
              { parentContextId: r, level: o.EPerformanceDebugLevel.Verbose }
            ),
            n = t(r),
            l = null == n ? void 0 : n.sciChartSurface,
            d = null == n ? void 0 : n.sciChartSurface.domCanvas2D;
          if (d) {
            const t = d.getContext("2d");
            (t.globalCompositeOperation = "copy"),
              t.drawImage(e, 0, 0, d.width, d.height, 0, 0, d.width, d.height),
              o.PerformanceDebugHelper.mark(
                o.EPerformanceMarkType.CopyToCanvasEnd,
                {
                  contextId: l.id,
                  parentContextId: r,
                  relatedId:
                    null === (a = null == s ? void 0 : s.detail) || void 0 === a
                      ? void 0
                      : a.relatedId,
                  level: o.EPerformanceDebugLevel.Verbose,
                }
              );
            const i = l.isInvalidated;
            l.renderedToDestination.raiseEvent(i);
          }
        };
      },
      23447: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.monitorWebGL =
            t.disposeMultiChart =
            t.initializeChartEngine2D =
            t.getSharedWasmContext =
            t.createMultichart =
              void 0);
        const o = r(84215),
          a = r(34238),
          s = r(23866),
          n = r(16185),
          l = r(84518),
          d = r(66570),
          h = r(85479),
          u = r(25606),
          c = r(84626),
          p = r(14184),
          g = r(99263),
          y = r(55023),
          f = r(98353),
          v = r(16155),
          m = (r(27307), r(62049)),
          S = r(9254),
          P = r(13639),
          C = r(16602),
          b = r(73538),
          x = {
            id: void 0,
            wasmContext: void 0,
            getChildSurfaces: void 0,
            createChildSurface: void 0,
          };
        let A, T;
        (t.createMultichart = (e, r, o) =>
          i(void 0, void 0, void 0, function* () {
            var i, a, s, n, l;
            u.default.checkChartDivExists(e);
            const c = u.default.initCanvas(
                e,
                null !== (i = null == o ? void 0 : o.widthAspect) &&
                  void 0 !== i
                  ? i
                  : 0,
                null !== (a = null == o ? void 0 : o.heightAspect) &&
                  void 0 !== a
                  ? a
                  : 0,
                u.default.ECanvasType.canvas2D,
                null == o ? void 0 : o.disableAspect,
                null == o ? void 0 : o.touchAction
              ),
              p =
                null !== (s = null == o ? void 0 : o.loader) && void 0 !== s
                  ? s
                  : new d.DefaultSciChartLoader();
            let g =
              null === (n = p.addChartLoader) || void 0 === n
                ? void 0
                : n.call(p, c.domDivContainer, null == o ? void 0 : o.theme);
            try {
              yield (0,
              t.initializeChartEngine2D)({ destinationCanvas: c.domCanvas2D });
              const { createChildSurface: e, wasmContext: i } = x,
                a = e(
                  c ? c.domChartRoot.id : "divElementId",
                  c,
                  null == o ? void 0 : o.theme,
                  r
                );
              return new Promise((e) => {
                setTimeout(() => {
                  var t, r;
                  (null !== (t = null == o ? void 0 : o.createSuspended) &&
                  void 0 !== t
                    ? t
                    : h.SciChartDefaults.createSuspended) && a.suspendUpdates(),
                    null === (r = p.removeChartLoader) ||
                      void 0 === r ||
                      r.call(p, c.domDivContainer, g),
                    (g = void 0),
                    a.setIsInitialized(),
                    e({ wasmContext: i, sciChartSurface: a });
                }, 0);
              });
            } catch (e) {
              return (
                console.error(e),
                null === (l = p.removeChartLoader) ||
                  void 0 === l ||
                  l.call(p, c.domDivContainer, g),
                (g = void 0),
                Promise.reject(e)
              );
            }
          })),
          (t.getSharedWasmContext = () =>
            i(void 0, void 0, void 0, function* () {
              const { wasmContext: e } = yield (0, t.initializeChartEngine2D)();
              return e;
            })),
          (t.initializeChartEngine2D = (e) =>
            i(void 0, void 0, void 0, function* () {
              var r, i;
              const o =
                  null === (r = null == e ? void 0 : e.destinationCanvas) ||
                  void 0 === r
                    ? void 0
                    : r.id,
                s = C.PerformanceDebugHelper.mark(
                  C.EPerformanceMarkType.EngineInitStart,
                  { parentContextId: o }
                );
              if (
                (m.WebGlHelper.initialize(),
                !x.wasmContext || !x.createChildSurface || !x.getChildSurfaces)
              ) {
                A || ((0, l.forceReapplyLicense2D)(), (A = E()));
                const e = yield A;
                (x.id = e.id),
                  (x.wasmContext = e.wasmContext),
                  (0, a.checkBuildStamp)(e.wasmContext),
                  (x.createChildSurface = e.createChildSurface),
                  (x.getChildSurfaces = e.getChildSurfaces),
                  (0, t.monitorWebGL)(e.wasmContext);
              }
              return (
                C.PerformanceDebugHelper.mark(
                  C.EPerformanceMarkType.EngineInitEnd,
                  {
                    relatedId:
                      null === (i = null == s ? void 0 : s.detail) ||
                      void 0 === i
                        ? void 0
                        : i.relatedId,
                    contextId: x.id,
                    parentContextId: o,
                  }
                ),
                A
              );
            })),
          (t.disposeMultiChart = () => {
            T && T(),
              (x.createChildSurface = void 0),
              (x.getChildSurfaces = void 0),
              (x.wasmContext = void 0),
              (x.id = void 0),
              (A = void 0),
              l.licenseManager.clear();
          }),
          (t.monitorWebGL = (e) => {
            e.canvas.addEventListener(
              "webglcontextlost",
              (t) => {
                console.warn("WebGL context lost: ", t.statusMessage),
                  t.preventDefault(),
                  n.WebGlRenderContext2D.webGlResourcesRefs.forEach((e) => {
                    e.invalidateCache();
                  }),
                  v.labelCache.resetCache(),
                  (0, f.deleteCache)(e),
                  e.SCRTShutdownEngine2D();
              },
              !1
            ),
              e.canvas.addEventListener(
                "webglcontextrestored",
                (t) => {
                  console.warn("WebGL context restored: ", t.statusMessage),
                    e.SCRTInitEngine2D(),
                    e.TSRSetDrawRequestsEnabled(!0);
                },
                !1
              );
          });
        const E = () => {
            const e = (e, t, r, i, o, a) => {
              const s = (0, p.createChartDestination)(r.domCanvas2D);
              if (!s) return void r.delete();
              const n = e.SCRTSurfaceDestination.implement(s);
              a.AddDestination(n),
                a.SetFPSCounterEnabled(!1),
                g.sciChartDestinations.push({
                  canvasElementId: t,
                  sciChartSurface: r,
                  width: i,
                  height: o,
                });
            };
            return new Promise((t, r) => {
              const i = (0, p.getMasterCanvas)(),
                a = (0, p.getLocateFile)(c.sciChartConfig);
              new o({ locateFile: a, noInitialRun: !0 })
                .then((r, o) => {
                  const a = (0, b.generateGuid)();
                  let n = (0, y.createWasmContextRevocableProxy)(r, a);
                  const d = n.proxy;
                  T = () => {
                    v.labelCache.resetCache(),
                      d.TSRRequestExit(),
                      m.delete(),
                      d
                        .SCRTGetGlobalSampleChartInterface()
                        .SetFrameRenderer(null),
                      d.SCRTGetGlobalSampleChartInterface().delete(),
                      d.SCRTSetGlobalSampleChartInterface(null),
                      (0, f.deleteCache)(d),
                      C.delete(),
                      d.SCRTSetGlobalCopyToDestinationInterface(null),
                      n.revoke(),
                      (n = void 0),
                      (T = void 0);
                  };
                  const m = new d.SCRTFrameRenderer2D(),
                    C = d.SCRTCopyToDestinationInterface.implement({
                      CopyToDestination: (0, P.copyToCanvas)(
                        p.SciChartSurfaceBase.domMasterCanvas,
                        R
                      ),
                    }),
                    x = () =>
                      g.sciChartDestinations.map((e) => e.sciChartSurface),
                    A = (t, r, i, o) => {
                      s.Guard.notNull(i, "theme");
                      const a = u.default.getCanvas2dId(t),
                        n = g.sciChartDestinations.filter(
                          (e) => e.canvasElementId === a
                        ),
                        h = g.sciChartDestinations.filter(
                          (e) => e.canvasElementId !== a
                        );
                      for (
                        D.ClearDestinations();
                        g.sciChartDestinations.length > 0;

                      )
                        g.sciChartDestinations.pop();
                      h.forEach((t) =>
                        e(
                          d,
                          t.canvasElementId,
                          t.sciChartSurface,
                          t.width,
                          t.height,
                          D
                        )
                      );
                      const p = ((e, t, r, i) => {
                        s.Guard.notNull(i, "theme");
                        const o = r(e, { canvases: t });
                        o.applyTheme(i);
                        const a = u.default.subscribeToResize(
                          t.domChartRoot,
                          t.aspect,
                          o,
                          t.disableAspect
                        );
                        return (
                          o.addDeletable(a),
                          o.setDestinations(g.sciChartDestinations),
                          o
                        );
                      })(d, r, o, i);
                      return (
                        p.addDeletable({
                          delete: () => {
                            c.SciChartSurface.autoDisposeWasmContext &&
                              0 === p.otherSurfaces.length &&
                              (c.SciChartSurface.wasmContextDisposeTimeout
                                ? setTimeout(() => {
                                    0 === g.sciChartDestinations.length &&
                                      c.SciChartSurface.disposeSharedWasmContext();
                                  }, c.SciChartSurface.wasmContextDisposeTimeout)
                                : c.SciChartSurface.disposeSharedWasmContext());
                          },
                        }),
                        e(
                          d,
                          a,
                          p,
                          r.domCanvas2D.width,
                          r.domCanvas2D.height,
                          D
                        ),
                        n.forEach((e) => e.sciChartSurface.delete(!1)),
                        l.licenseManager.applyLicense2D(d, p, !1),
                        p
                      );
                    };
                  d.canvas = i;
                  const E = {
                      InitializeChart() {
                        S.Logger.debug("InitializeChart"),
                          t({
                            id: a,
                            getChildSurfaces: x,
                            createChildSurface: A,
                            wasmContext: d,
                          });
                      },
                      Draw(e) {
                        S.Logger.debug("Draw", e);
                        const t = g.sciChartDestinations.find(
                          (t) => t.canvasElementId === e
                        );
                        t &&
                          t.sciChartSurface.renderSurface.onRenderTimeElapsed();
                      },
                      Update(e) {
                        S.Logger.debug("sciChartInitCommon.ts Update", e);
                      },
                      ShutDownChart() {
                        S.Logger.debug("sciChartInitCommon.ts ShutDownChart");
                      },
                    },
                    D = d.SCRTSampleChartInterface.implement(E);
                  D.SetFrameRenderer(m),
                    D.SetWasmBufferSizesKb(
                      h.SciChartDefaults.wasmBufferSizesKb
                    ),
                    d.SCRTSetGlobalSampleChartInterface(D),
                    d.SCRTSetGlobalCopyToDestinationInterface(C),
                    d.TSRSetDrawRequestsEnabled(!0),
                    p.SciChartSurfaceBase.domMasterCanvas &&
                      d.SCRTSetMainWindowSize(
                        p.SciChartSurfaceBase.domMasterCanvas.width,
                        p.SciChartSurfaceBase.domMasterCanvas.height
                      ),
                    d.callMain();
                })
                .catch((e) => {
                  console.error(e),
                    r(
                      "Could not load SciChart WebAssembly module.\n                Check your build process and ensure that your scichart2d.wasm, scichart2d.data and scichart2d.js files are from the same version"
                    );
                });
            });
          },
          R = (e) =>
            g.sciChartDestinations.find((t) => t.canvasElementId === e);
      },
      43937: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.initDrawEngineSingleChart = t.createSingleInternal = void 0);
        const i = r(84215),
          o = r(34238),
          a = r(23866),
          s = r(62049),
          n = r(9254),
          l = r(84518),
          d = r(66570),
          h = r(85479),
          u = r(25606),
          c = r(84626),
          p = r(14184),
          g = r(98353),
          y = r(55023),
          f = r(99263),
          v = r(16155),
          m = r(23447),
          S = r(16602);
        (t.createSingleInternal = (e, r, a) =>
          new Promise((l, g) => {
            var f, v;
            const P = u.default.initCanvas(
                e,
                null == a ? void 0 : a.widthAspect,
                null == a ? void 0 : a.heightAspect,
                void 0,
                null == a ? void 0 : a.disableAspect,
                null == a ? void 0 : a.touchAction
              ),
              C =
                null !== (f = null == a ? void 0 : a.loader) && void 0 !== f
                  ? f
                  : new d.DefaultSciChartLoader(),
              b =
                null === (v = C.addChartLoader) || void 0 === v
                  ? void 0
                  : v.call(C, P.domDivContainer, null == a ? void 0 : a.theme),
              x = S.PerformanceDebugHelper.mark(
                S.EPerformanceMarkType.EngineInitStart,
                { parentContextId: P.domCanvas2D.id }
              ),
              A = s.WebGlHelper.getWebGlSupport();
            if (A !== s.EWebGLSupport.WebGL2 && A !== s.EWebGLSupport.WebGL1)
              throw Error("Sorry Your browser does not support WebGL.");
            {
              const e = (0, p.getLocateFile)(c.sciChartConfig);
              new i({ locateFile: e, noInitialRun: !0 })
                .then((e) => {
                  var i;
                  null === (i = C.removeChartLoader) ||
                    void 0 === i ||
                    i.call(C, P.domDivContainer, b),
                    (e.doNotCaptureKeyboard = !0);
                  let s = (0, y.createWasmContextRevocableProxy)(
                    e,
                    P.domCanvas2D.id
                  );
                  (0, t.initDrawEngineSingleChart)(
                    s.proxy,
                    P,
                    (e) => {
                      var t;
                      (null !== (t = null == a ? void 0 : a.createSuspended) &&
                      void 0 !== t
                        ? t
                        : h.SciChartDefaults.createSuspended) &&
                        e.sciChartSurface.suspendUpdates(),
                        e.sciChartSurface.addDeletable({
                          delete: () => {
                            s.revoke(), (s = void 0);
                          },
                        }),
                        S.PerformanceDebugHelper.mark(
                          S.EPerformanceMarkType.EngineInitEnd,
                          {
                            relatedId: null == x ? void 0 : x.detail.relatedId,
                            contextId: e.sciChartSurface.id,
                            parentContextId: P.domCanvas2D.id,
                          }
                        ),
                        l(e);
                    },
                    null == a ? void 0 : a.theme,
                    r
                  ),
                    (0, o.checkBuildStamp)(e),
                    (0, m.monitorWebGL)(e);
                })
                .catch((e) => {
                  var t;
                  n.Logger.debug(e),
                    null === (t = C.removeChartLoader) ||
                      void 0 === t ||
                      t.call(C, P.domDivContainer, b),
                    g(
                      "Could not load SciChart WebAssembly module.\n                    Check your build process and ensure that your scichart2d.wasm, scichart2d.data and scichart2d.js files are from the same version"
                    );
                });
            }
          })),
          (t.initDrawEngineSingleChart = (e, t, r, i, o) => {
            a.Guard.notNull(i, "theme");
            const s = t.domCanvas2D.width,
              n = t.domCanvas2D.height;
            let d;
            e.canvas = t.domCanvasWebGL;
            const c = new e.SCRTFrameRenderer2D(),
              p = t.domCanvasWebGL.id,
              y = {
                InitializeChart() {
                  (d = o(e, { canvases: t })),
                    d.applyTheme(i),
                    f.sciChartSingleDestinations.push({
                      canvasElementId: p,
                      sciChartSurface: d,
                      width: s,
                      height: n,
                    }),
                    d.setDestinations(f.sciChartSingleDestinations),
                    d.addDeletable({
                      delete: () => {
                        e.TSRRequestExit(),
                          c.delete(),
                          e
                            .SCRTGetGlobalSampleChartInterface()
                            .SetFrameRenderer(null),
                          e.SCRTGetGlobalSampleChartInterface().delete(),
                          e.SCRTSetGlobalSampleChartInterface(null),
                          v.labelCache.resetCache();
                      },
                    }),
                    setTimeout(() => {
                      d.invalidateElement(),
                        l.licenseManager.applyLicense2D(e, d, !0);
                      const i = u.default.subscribeToResize(
                        t.domChartRoot,
                        t.aspect,
                        d,
                        t.disableAspect
                      );
                      d.addDeletable(i),
                        d.addDeletable((0, g.freeCache)(e)),
                        d.setIsInitialized(),
                        r({ wasmContext: e, sciChartSurface: d });
                    }, 0);
                },
                Draw(e) {
                  d.renderSurface.onRenderTimeElapsed();
                },
                Update(e) {},
                ShutDownChart() {},
              },
              m = e.SCRTSampleChartInterface.implement(y);
            m.SetFrameRenderer(c),
              m.SetFPSCounterEnabled(!1),
              m.SetWasmBufferSizesKb(h.SciChartDefaults.wasmBufferSizesKb),
              e.SCRTSetGlobalSampleChartInterface(m),
              e.callMain();
          });
      },
      84518: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__awaiter) ||
          function (e, t, r, i) {
            return new (r || (r = Promise))(function (o, a) {
              function s(e) {
                try {
                  l(i.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function n(e) {
                try {
                  l(i.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                var t;
                e.done
                  ? o(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(s, n);
              }
              l((i = i.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.licenseManager =
            t.updateLicenseDisplay =
            t.getLicenseInfo =
            t.applyLicense =
            t.forceReapplyLicense2D =
            t.getLicenseCookie =
            t.setCallbacks3D =
            t.setUseLicenseWizard =
            t.setRuntimeLicenseKey =
            t.setLicenseCallback =
            t.setIsDebugLicensing =
            t.setDependencies =
              void 0);
        const o = r(84745),
          a = r(34238),
          s = r(21079),
          n = r(99263),
          l = r(31601),
          d = r(33519),
          h = r(72072),
          u = r(48125),
          c = r(41670),
          p = r(2056);
        let g = 24278,
          y = 24279;
        const f = l.localStorageApi.getLicenseWizardPort();
        f && ((g = f), (y = g + 1));
        let v = {
          fetchFromWizard: (e) => {
            return (
              (t = e),
              i(void 0, void 0, void 0, function* () {
                try {
                  const e = "http://localhost:" + g.toString() + t;
                  return yield fetch(e);
                } catch (e) {
                  if (
                    (S(
                      "Could not connect to license wizard on port " +
                        g.toString()
                    ),
                    "undefined" != typeof localStorage)
                  ) {
                    const e = l.localStorageApi.getLicenseWizardMaxPort();
                    if (e)
                      for (; y <= e; )
                        try {
                          const e = "http://localhost:" + y.toString() + t,
                            r = yield fetch(e);
                          return (g = y), r;
                        } catch (e) {
                          S(
                            "Could not connect to license wizard on port " +
                              y.toString()
                          ),
                            (y += 1);
                        }
                  }
                  throw e;
                }
              })
            );
            var t;
          },
          setCookie: (e, t, r) => (0, c.setCookie)(e, t, r),
          getCookie: (e) => (0, c.getCookie)(e),
          fetchForChallenge: (e) => fetch(e),
          updateLicenseDisplay: (e, t, r, i) => ee(e, t, r, i),
          debug: (e) => console.log(e),
        };
        t.setDependencies = (e) => (v = e);
        let m = null;
        t.setIsDebugLicensing = (e, t = !1) => {
          (m = e), (!t && e) || l.localStorageApi.setIsLicenseDebug(e);
        };
        const S = (e) => {
          null === m && (m = l.localStorageApi.getIsLicenseDebug()),
            (o.IS_TEST_ENV || m) && v.debug(e);
        };
        let P;
        S("SciChart version " + a.libraryVersion),
          (t.setLicenseCallback = (e) => {
            P = e;
          });
        let C = "";
        const b = () => C;
        t.setRuntimeLicenseKey = (e) => {
          const r = C;
          if (
            ((C = e), C !== r && "" !== C && n.sciChartDestinations.length > 0)
          ) {
            const e = n.sciChartDestinations[0].sciChartSurface;
            (0, t.applyLicense)(e.sharedWasmContext, e);
          }
        };
        let x = !0;
        t.setUseLicenseWizard = (e) => {
          x = e;
        };
        const A = o.IS_TEST_ENV ? 0.1 : 5,
          T = o.IS_TEST_ENV ? 12 : 10;
        let E,
          R,
          D = "api/license",
          w = 0;
        const M = {
          getLicenseChallenge3D: () => {},
          setChallengeResponse3D: (e) => {},
          setNewLicense3D: (e) => {},
          updateLicenseDisplay3D: () => {},
        };
        let L = M;
        t.setCallbacks3D = (e) => (L = e);
        const O = (e, r) =>
            i(void 0, void 0, void 0, function* () {
              if (!r.isDeleted) {
                try {
                  if (
                    F !== u.LicenseCheckStatus.StartLookingForLicenseWizard &&
                    F !== u.LicenseCheckStatus.LookingForLicenseWizard &&
                    F !== u.LicenseCheckStatus.NoLicenseInWizard
                  )
                    return;
                  let t;
                  if (
                    (S("Trying to get license from local license wizard"),
                    (t = yield v.fetchFromWizard("/license")),
                    t.ok)
                  ) {
                    const i = yield t.text(),
                      { requiresValidation: o, trialExpired: a } = j(i, e, r);
                    o
                      ? (S(
                          "Got a developer license from local license wizard.  Validating..."
                        ),
                        (F = u.LicenseCheckStatus.ValidatingDeveloperLicense),
                        V(e, r))
                      : a
                      ? ((F = u.LicenseCheckStatus.NoLicenseInWizard),
                        S(
                          `No valid license available in licensing wizard. Trying again in ${A} seconds`
                        ),
                        (E = setTimeout(() => O(e, r), 1e3 * A)))
                      : (S("Got a valid license from local license wizard."),
                        (F = u.LicenseCheckStatus.LicenseOK));
                  } else
                    (F = u.LicenseCheckStatus.NoLicenseInWizard),
                      S(
                        `No license available in licensing wizard. Trying again in ${A} seconds`
                      ),
                      (E = setTimeout(() => O(e, r), 1e3 * A));
                } catch (t) {
                  (F = u.LicenseCheckStatus.LookingForLicenseWizard),
                    (w += 1),
                    w < T
                      ? (S(
                          `Could not find licensing wizard. Trying again in ${A} seconds`
                        ),
                        (E = setTimeout(() => O(e, r), 1e3 * A)))
                      : (console.log(
                          "Failed to connect to licensing wizard. Refresh page to retry."
                        ),
                        (w = 0),
                        (F = u.LicenseCheckStatus.FailedToFindLicenseWizard));
                }
                void 0 === e ||
                  r.isDeleted ||
                  ((0, t.updateLicenseDisplay)(
                    (0, t.getLicenseInfo)(e),
                    r,
                    !0,
                    !0
                  ),
                  L.updateLicenseDisplay3D());
              }
            }),
          I = (e, t, r, i) => {
            const o = `${e},${t},${r},${i}`;
            return v.setCookie("scLicense", o, 365);
          };
        t.getLicenseCookie = () => {
          let e;
          e = v.getCookie("scLicense");
          const t = e.split(",");
          return 4 === t.length
            ? {
                key: t[0],
                token: t[1],
                expiry: new Date(1e3 * Number.parseInt(t[2], 10)),
                lastValidated: new Date(1e3 * Number.parseInt(t[3], 10)),
              }
            : { key: t[0], token: null, expiry: null, lastValidated: null };
        };
        const k = (e, t) => {
          let r = -1;
          void 0 !== t && (r = t.SCRTCredentials.ApplyLicenseResponse(e));
          const i = L.setChallengeResponse3D(e);
          return void 0 !== i && i > 0 ? i : r;
        };
        let _ = 0;
        const V = (e, r) =>
          i(void 0, void 0, void 0, function* () {
            if (r.isDeleted) return;
            const i = p.licenseManager2dState.getIsDev()
              ? "license wizard"
              : "server";
            try {
              if (F !== u.LicenseCheckStatus.ValidatingDeveloperLicense) return;
              let o, a, s;
              S(`Attempting to validate license with ${i}`),
                void 0 !== e
                  ? ((o = e.SCRTCredentials.GetLicenseChallenge()),
                    (a = e.SCRTCredentials.GetOrderId()))
                  : ({ challenge: o, orderId: a } = L.getLicenseChallenge3D());
              const n = `orderid=${a}&challenge=${o}`;
              if (p.licenseManager2dState.getIsDev()) {
                const e = `/validate?${n}`;
                s = yield v.fetchFromWizard(e);
              } else if (void 0 !== P) s = yield P(n);
              else {
                const e = "/" + D + (D.indexOf("?") > 0 ? "&" : "?") + n;
                s = yield v.fetchForChallenge(e);
              }
              if (s.ok) {
                const i = yield s.text();
                if (i.startsWith("Error"))
                  S("Server rejected the license challenge: " + i),
                    (F = u.LicenseCheckStatus.FailedToValidateDeveloperLicense);
                else {
                  const o = k(i, e);
                  if (o > 0) {
                    let a = (0, t.getLicenseCookie)().key;
                    a || (a = b());
                    const s = Math.floor(new Date().getTime() / 1e3);
                    I(a, i, o, s),
                      S("License validated"),
                      (F = u.LicenseCheckStatus.LicenseOK);
                    const n = o - s;
                    (_ = 0),
                      (R = setTimeout(
                        () => V(e, r),
                        Math.floor(0.95 * n * 1e3)
                      ));
                  } else
                    S(`license challenge response was invalid: ${i} ${o}`),
                      (F =
                        u.LicenseCheckStatus.FailedToValidateDeveloperLicense);
                }
              } else {
                if (!p.licenseManager2dState.getIsDev())
                  throw new Error(s.statusText);
                console.warn(
                  "Error during license validation: " + s.statusText
                ),
                  (F = u.LicenseCheckStatus.FailedToValidateDeveloperLicense);
              }
            } catch (o) {
              if (!p.licenseManager2dState.getIsDev()) {
                if (
                  (console.warn(
                    "Server license validation failed.  Looking for local developer license"
                  ),
                  (C = ""),
                  (F = u.LicenseCheckStatus.NoLicense),
                  e.SCRTCredentials.ResetRuntimeLicense(),
                  (H = !1),
                  p.licenseManager2dState.setIsDev(!0),
                  (F = u.LicenseCheckStatus.StartLookingForLicenseWizard),
                  O(e, r),
                  n.sciChartDestinations.length > 0 && !r.isDeleted)
                ) {
                  const e = n.sciChartDestinations[0].sciChartSurface;
                  (0, t.updateLicenseDisplay)(
                    (0, t.getLicenseInfo)(e.sharedWasmContext),
                    e,
                    !0,
                    !1
                  ),
                    L.updateLicenseDisplay3D();
                }
                return;
              }
              if (((_ += 1), _ < T))
                S(`Could not find ${i}/${D}. Trying again in ${A} seconds`),
                  (R = setTimeout(() => V(e, r), 1e3 * A));
              else {
                const e = (0, t.getLicenseCookie)().expiry,
                  r = p.licenseManager2dState.getIsDev()
                    ? "Please run the license wizard, ensure your license is activated, then refresh page to retry."
                    : "Please check that the endpoint is configured correctly.";
                console.error(
                  `Failed to connect to ${i}/${D}.  License must be revalidated before ${e.toLocaleString()}. ${r}`
                ),
                  (_ = 0),
                  new Date() > e &&
                    (F = u.LicenseCheckStatus.FailedToFindLicenseWizard);
              }
            }
            void 0 === e ||
              r.isDeleted ||
              ((0, t.updateLicenseDisplay)((0, t.getLicenseInfo)(e), r, !0, !0),
              L.updateLicenseDisplay3D());
          });
        let N = !0;
        t.forceReapplyLicense2D = () => {
          N = !0;
        };
        let B,
          F = u.LicenseCheckStatus.NoLicense,
          H = !1,
          Y = !1;
        t.applyLicense = (e, r) => {
          var i, s, n, l;
          S("applyLicense running");
          let d = "",
            h = e.SCRTCredentials.GetLicenseType();
          S("Initial license status is " + u.LicenseType[q(h, e)]);
          const g = b();
          if (
            (F === u.LicenseCheckStatus.NoLicense ||
              F === u.LicenseCheckStatus.LicenseOK ||
              F === u.LicenseCheckStatus.StartLookingForLicenseWizard ||
              F === u.LicenseCheckStatus.LookingForLicenseWizard) &&
            g
          ) {
            S("Runtime license found");
            const t = g.indexOf(";");
            if (t > 0) {
              const e = Math.floor(new Date().getTime() / 1e3),
                r = g.substring(t + 1);
              I(g.substr(0, t), r, e + 60, e);
            } else {
              e.SCRTCredentials.SetRuntimeLicenseKeyW(g),
                (h = e.SCRTCredentials.GetLicenseType());
              const t = q(h, e);
              if (
                (S("Runtime license status is " + u.LicenseType[t]),
                h === e.SCRTLicenseType.LICENSE_TYPE_FULL ||
                  h === e.SCRTLicenseType.LICENSE_TYPE_TRIAL ||
                  h === e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY ||
                  h === e.SCRTLicenseType.LICENSE_TYPE_REQUIRES_VALIDATION)
              )
                (H = !0), (d = g);
              else {
                const t = e.SCRTCredentials.GetLicenseErrors();
                (window &&
                  (null === (i = window.location) || void 0 === i
                    ? void 0
                    : i.hostname) &&
                  !(null ===
                    (n =
                      null === (s = window.location) || void 0 === s
                        ? void 0
                        : s.hostname) || void 0 === n
                    ? void 0
                    : n.includes("localhost"))) ||
                !t.startsWith("License is not valid for this domain")
                  ? m
                    ? S("Runtime license is invalid: " + t)
                    : console.warn(
                        "Runtime license is invalid.  Call setIsDebugLicensing(true) for details."
                      )
                  : S("Runtime license is invalid: " + t),
                  (d = "");
              }
            }
          }
          const y = (0, t.getLicenseCookie)();
          if (
            ("" === d && y && "" !== y.key
              ? (S("Found license in cookie."),
                (d = y.key),
                e.SCRTCredentials.SetRuntimeLicenseKeyW(d),
                (h = e.SCRTCredentials.GetLicenseType()),
                h !== e.SCRTLicenseType.LICENSE_TYPE_FULL &&
                  h !== e.SCRTLicenseType.LICENSE_TYPE_TRIAL &&
                  h !== e.SCRTLicenseType.LICENSE_TYPE_REQUIRES_VALIDATION &&
                  (S(
                    "License cookie is invalid. " +
                      e.SCRTCredentials.GetLicenseErrors()
                  ),
                  (0, c.deleteCookie)("scLicense"),
                  (d = ""),
                  (h = e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY)))
              : F === u.LicenseCheckStatus.FetchingFromServer &&
                (F = u.LicenseCheckStatus.NoLicense),
            "" !== d)
          )
            if (
              (h === e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY &&
                (e.SCRTCredentials.SetRuntimeLicenseKeyW(d),
                (h = e.SCRTCredentials.GetLicenseType())),
              p.licenseManager2dState.setIsDev(
                e.SCRTCredentials.GetAllowDebugging()
              ),
              h === e.SCRTLicenseType.LICENSE_TYPE_FULL ||
                h === e.SCRTLicenseType.LICENSE_TYPE_TRIAL ||
                h === e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY)
            ) {
              if (
                ((F = u.LicenseCheckStatus.LicenseOK),
                S("license ok"),
                h === e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY && H && !Y)
              ) {
                console.log(
                  "Using SciChart Community Edition. To use a license from the License Wizard, remove the call to UseCommunityLicense"
                );
                const t = e.SCRTCredentials.GetLicenseDaysRemaining();
                console.log(
                  `The community license is valid for 6 months from the date the version in use was released.  This version ${
                    a.libraryVersion
                  } has ${t} day${1 === t ? "" : "s"} remaining`
                ),
                  (Y = !0);
              }
            } else if (e.SCRTCredentials.RequiresValidation())
              if (
                (S("license requires validation"),
                H && p.licenseManager2dState.getIsDev())
              )
                e.SCRTCredentials.ResetRuntimeLicense(),
                  (0, c.deleteCookie)("scLicense"),
                  (F = u.LicenseCheckStatus.DevKeyInRuntimeKey);
              else if (y.expiry > new Date() && y.key === d) {
                S("current token in cookie");
                const t = k(y.token, e);
                (h = e.SCRTCredentials.GetLicenseType()),
                  (h !== e.SCRTLicenseType.LICENSE_TYPE_FULL &&
                    h !== e.SCRTLicenseType.LICENSE_TYPE_TRIAL) ||
                    (F = u.LicenseCheckStatus.LicenseOK);
                const i = Math.floor(new Date().getTime() / 1e3);
                1e3 * t > y.expiry.getTime() && I(d, y.token, t, i);
                const o = 86400,
                  a = (new Date().getTime() - y.lastValidated.getTime()) / 1e3;
                S(
                  `License expires in ${
                    t - i
                  } seconds.  Last validated ${a} seconds ago`
                ),
                  a > o &&
                    F !== u.LicenseCheckStatus.ValidatingDeveloperLicense &&
                    ((F = u.LicenseCheckStatus.ValidatingDeveloperLicense),
                    V(e, r));
              } else
                F === u.LicenseCheckStatus.NoLicense &&
                  ((F = u.LicenseCheckStatus.ValidatingDeveloperLicense),
                  V(e, r));
            else
              S("license is invalid: " + e.SCRTCredentials.GetLicenseErrors());
          if (
            (S("checkstatus: " + u.LicenseCheckStatus[F]),
            F === u.LicenseCheckStatus.NoLicense)
          ) {
            if (h === e.SCRTLicenseType.LICENSE_TYPE_COMMUNITY && !Y) {
              console.log(
                "Defaulting to SciChart Community Edition. Usage constitutes acceptance of our EULA and terms at https://www.scichart.com/community-licensing. See https://store.scichart.com for commercial licensing options."
              );
              const t = e.SCRTCredentials.GetLicenseDaysRemaining();
              console.log(
                `The community license is valid for 6 months from the date the version in use was released.  This version ${
                  a.libraryVersion
                } has ${t} day${1 === t ? "" : "s"} remaining`
              ),
                !o.IS_TEST_ENV &&
                  (null ===
                    (l =
                      null === document || void 0 === document
                        ? void 0
                        : document.location) || void 0 === l
                    ? void 0
                    : l.hostname.startsWith("localhost")) &&
                  x &&
                  console.log(
                    "SciChart is looking for a paid developer activation from the scichart licensing wizard... To disable this call SciChartSurface.UseCommunityLicense()"
                  ),
                (Y = !0);
            }
            void 0 === E &&
              x &&
              ((F = u.LicenseCheckStatus.StartLookingForLicenseWizard),
              p.licenseManager2dState.setIsDev(!0),
              O(e, r));
          }
          void 0 !== e &&
            ((0, t.updateLicenseDisplay)((0, t.getLicenseInfo)(e), r, !0, !1),
            L.updateLicenseDisplay3D());
        };
        let z = () => {
          console.error("Modal not initialized");
        };
        const j = (e, r, i) => {
            let o,
              a = !1;
            B && (B.style.display = "none"),
              (H = !1),
              I(e, null, null, null),
              void 0 !== r &&
                (r.SCRTCredentials.SetRuntimeLicenseKeyW(e),
                (a = r.SCRTCredentials.RequiresValidation()),
                (o =
                  r.SCRTCredentials.GetLicenseType() ===
                  r.SCRTLicenseType.LICENSE_TYPE_TRIAL_EXPIRED),
                (0, t.updateLicenseDisplay)(
                  (0, t.getLicenseInfo)(r),
                  i,
                  !0,
                  !0
                ));
            const s = L.setNewLicense3D(e);
            return (
              void 0 !== s &&
                ((a = s.requiresValidation), (o = s.trialExpired)),
              { requiresValidation: a, trialExpired: o }
            );
          },
          X = new s.Dictionary(),
          G = (e, t) => {
            if (X.containsKey(e)) return;
            const r = document.styleSheets;
            if (0 === r.length) {
              const e = document.createElement("style");
              e.appendChild(document.createTextNode("")),
                document.head.appendChild(e);
            }
            const i = r[r.length - 1],
              o = i.insertRule(t, i.cssRules.length);
            X.add(e, o);
          },
          W = "licenseMessage";
        let U = null,
          $ = null;
        const Z = (e, t) => {
            if (!e) return;
            const r = t.cloneNode(!0),
              i = e.getElementsByClassName(W);
            if (i.length > 0) {
              const t = i[0];
              e.replaceChild(r, t);
            } else e.appendChild(r);
            x && (r.onclick = z);
          },
          q = (e, t) => {
            let r = u.LicenseType.NoLicense;
            switch (e) {
              case t.SCRTLicenseType.LICENSE_TYPE_NO_LICENSE:
                r = u.LicenseType.NoLicense;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_TRIAL:
                r = u.LicenseType.Trial;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_COMMUNITY:
                r = u.LicenseType.Community;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_FULL:
                r = u.LicenseType.Full;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_FULL_EXPIRED:
                r = u.LicenseType.Full_Expired;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_TRIAL_EXPIRED:
                r = u.LicenseType.Trial_Expired;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_SUBSCRIPTION_EXPIRED:
                r = u.LicenseType.Subscription_Expired;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_INVALID_DEVELOPER_LICENSE:
                r = u.LicenseType.Invalid_Developer;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_REQUIRES_VALIDATION:
                r = u.LicenseType.Requres_Validation;
                break;
              case t.SCRTLicenseType.LICENSE_TYPE_INVALID_LICENSE:
                r = u.LicenseType.Invalid;
            }
            return r;
          };
        let K, J, Q;
        t.getLicenseInfo = (e) => {
          const t = e.SCRTCredentials.GetLicenseType(),
            r = q(t, e),
            i = e.SCRTCredentials.GetLicenseDaysRemaining();
          if (
            (F === u.LicenseCheckStatus.LicenseOK ||
              r === u.LicenseType.Community) &&
            p.licenseManager2dState.getLicenseType() !== r
          ) {
            r === u.LicenseType.Community
              ? p.licenseManager2dState.setOrderId("Community")
              : p.licenseManager2dState.setOrderId(
                  e.SCRTCredentials.GetEncryptedOrderId()
                ),
              p.licenseManager2dState.setProductCode(
                e.SCRTCredentials.GetProductCode()
              ),
              p.licenseManager2dState.setLicenseType(r),
              p.licenseManager2dState.setDevCount(
                e.SCRTCredentials.GetDeveloperCount()
              );
            const t = e.SCRTCredentials.HasFeature("TE");
            p.licenseManager2dState.setTelemetry(
              t === e.SCRTLicenseType.LICENSE_TYPE_FULL ||
                t === e.SCRTLicenseType.LICENSE_TYPE_TRIAL
            );
          }
          return (
            m && S(e.SCRTCredentials.Dump()),
            {
              licenseType: r,
              daysRemaining: i,
              error: e.SCRTCredentials.GetLicenseErrors(),
            }
          );
        };
        const ee = (e, r, i, o) => {
          null == U &&
            ((U = document.createElement("div")),
            (U.className = W),
            ($ = document.createElement("div")),
            ($.className = "licenseMessageChild"),
            ($.innerHTML = ""),
            U.appendChild($));
          let a = "",
            s = "",
            n = "";
          const { licenseType: l, daysRemaining: c, error: g } = e;
          if ((i && l !== K) || (!i && l !== J) || F !== Q) {
            if (
              ((Q = F),
              i ? (K = l) : (J = l),
              S((i ? "2D" : "3D") + " license status changed"),
              r.invalidateElement(),
              r.otherSurfaces.map((e) => e.invalidateElement()),
              F === u.LicenseCheckStatus.StartLookingForLicenseWizard)
            )
              return;
            const e =
                '<a href="https://www.scichart.com/licensing-scichart-js"  target="_blank" style="color: white">www.scichart.com/licensing-scichart-js</a>',
              o =
                '<a href="https://www.scichart.com/contact-us/"  target="_blank" style="color: orange">contact support</a>';
            l === u.LicenseType.NoLicense
              ? ((a = "You need to have a license to use SciChart.  "),
                (n = `Instructions can be seen at ${e}`))
              : l === u.LicenseType.Invalid
              ? ((a = g.startsWith("License is not valid for this domain")
                  ? `Sorry! The runtime license key is not valid for this domain</br>\n                Please ${o} with your OrderID if you believe this to be incorrect. <u>Click for more information</u></br>\n                For local development, make sure the Licensing Wizard is running and activated.</br>\n                To use Community Edition, remove the call to setRuntimeLicenseKey`
                  : g.startsWith(
                      "This version of SciChart can no longer be trialed"
                    )
                  ? "Sorry! This version of SciChart is too old to be trialed.  Please update to the latest version"
                  : g.startsWith(
                      "This version of SciChart can no longer be used for the community edition"
                    )
                  ? "Sorry! This version of SciChart is too old to be used for the community edition.  Please update to the latest version"
                  : `Sorry! Your license key appears to be invalid</br>Please ${o} with your OrderID if you believe this to be incorrect.`),
                (n = `Instructions can be seen at ${e}`))
              : l === u.LicenseType.Invalid_Developer
              ? ((a =
                  "Sorry! You need a developer license to use SciChart on a domain not included in your runtime key."),
                (n = `Instructions can be seen at ${e}</br>\n                    Please ${o} with your OrderID if you are experiencing issues.`))
              : l === u.LicenseType.Requres_Validation
              ? ((a = p.licenseManager2dState.getIsDev()
                  ? "Your developer license must be validated by the SciChart Licensing Wizard running locally"
                  : "This runtime key must be validated by a server side key."),
                (n = `Instructions can be seen at ${e}</br>\n                    Please ${o} with your OrderID if you are experiencing issues.`))
              : l === u.LicenseType.Subscription_Expired
              ? ((a = "Sorry! Your support subscription has expired.<br>"),
                (n = `Please ${o} if you would like to renew your subscription.`))
              : l === u.LicenseType.Trial_Expired && c < 1
              ? ((a = "Sorry! Your trial has expired."),
                (n = `Please ${o} if you require an extension.`))
              : l === u.LicenseType.Trial_Expired && c > 1
              ? ((a = "This version is too old to trial."),
                (n = `Please ${o} if you require an extension.`))
              : l === u.LicenseType.Trial && c <= 7
              ? (a = `You have ${c} day${
                  1 === c ? "" : "s"
                } remaining of the trial.`)
              : l === u.LicenseType.Community && c <= 7
              ? (a = `You have ${c} day${
                  1 === c ? "" : "s"
                } remaining on the community license for this version.  Please update to the latest version of SciChart`)
              : (l === u.LicenseType.Full ||
                  ((l === u.LicenseType.Trial ||
                    l === u.LicenseType.Community) &&
                    c > 7)) &&
                ((U.style.display = "none"), ($.innerHTML = "")),
              F !== u.LicenseCheckStatus.LicenseOK
                ? (F === u.LicenseCheckStatus.FetchingFromServer &&
                    (s = "<br>Fetching license from server..."),
                  F === u.LicenseCheckStatus.LookingForLicenseWizard
                    ? (l === u.LicenseType.Community && (0, d.sendTelemetry)(),
                      (s = "<br>Looking for Licensing Wizard..."))
                    : F === u.LicenseCheckStatus.FailedToFindLicenseWizard
                    ? (s = p.licenseManager2dState.getIsDev()
                        ? "<br><u>Could not connect to the Licensing Wizard.  Please run it, then reload this page.</u>"
                        : "<br><u>Could not connect to the server licensing endpoint</u>")
                    : F === u.LicenseCheckStatus.ValidatingDeveloperLicense
                    ? (s = p.licenseManager2dState.getIsDev()
                        ? "<br><u>Trying to validate your license..."
                        : "<br><u>Trying to validate your license with the server...</u>.")
                    : F ===
                      u.LicenseCheckStatus.FailedToValidateDeveloperLicense
                    ? (s = p.licenseManager2dState.getIsDev()
                        ? "<br><u>Failed to validate your developer license with the Licensing Wizard.  If you have changed your activated license, try clearing your cookies for this site.</u>."
                        : "<br><u>Failed to validate the runtime license with the server</u>.")
                    : F === u.LicenseCheckStatus.NoLicenseInWizard &&
                      l === u.LicenseType.NoLicense
                    ? (s =
                        "<br><u>Please use the Licensing wizard to start a trial or activate a serial key.  Click for more information</u>.")
                    : F === u.LicenseCheckStatus.DevKeyInRuntimeKey
                    ? (s =
                        "<br><u>You have set a developer key as a runtime key, which will not work on any other machine.  Click for more information</u>")
                    : l === u.LicenseType.Trial_Expired && c > 1
                    ? (s =
                        "<br><u>Please update to the latest version of SciChart. Click for more information</u>.")
                    : F === u.LicenseCheckStatus.NoLicenseInWizard &&
                      l === u.LicenseType.Trial_Expired &&
                      (s =
                        "<br><u>Please activate a serial key in the Licensing Wizard, or contact sales for an extension.  Click for more information</u>."),
                  a &&
                    ((U.style.width = "100%"),
                    (U.style.height = "100%"),
                    (U.style.top = "0"),
                    (U.style.left = "0"),
                    (U.style.position = "absolute"),
                    (U.style.pointerEvents = "auto"),
                    (U.style.cursor = "pointer"),
                    (U.style.background = h.EColor.BackgroundColor),
                    (U.style.zIndex = "10"),
                    ($.style.display = "block"),
                    ($.style.color = "orange"),
                    ($.style.width = "80%"),
                    ($.style.position = "absolute"),
                    ($.style.left = "50%"),
                    ($.style.top = "50%"),
                    ($.style.transform = "translate(-50%, -50%)"),
                    ($.style.textAlign = "center"),
                    ($.style.pointerEvents = "auto"),
                    x
                      ? (($.innerHTML = a + s),
                        ((e, r) => {
                          (B = document.createElement("div")),
                            (B.id = "scichartLicenseModal"),
                            (B.style.display = "none"),
                            (B.style.position = "fixed"),
                            (B.style.zIndex = "100"),
                            (B.style.left = "0"),
                            (B.style.top = "0"),
                            (B.style.width = "100%"),
                            (B.style.height = "100%"),
                            (B.style.overflow = "auto"),
                            (B.style.backgroundColor = "rgb(0,0,0)"),
                            (B.style.backgroundColor = "rgba(0,0,0,0.4)");
                          const i = document.createElement("div");
                          (i.style.backgroundColor = "#fefefe"),
                            (i.style.position = "absolute"),
                            (i.style.left = "50%"),
                            (i.style.top = "50%"),
                            (i.style.transform = "translate(-50%, -50%)"),
                            (i.style.borderRadius = "4px"),
                            (i.style.padding = "20px"),
                            (i.style.maxWidth = "460px"),
                            B.appendChild(i);
                          const o = document.createElement("div");
                          (o.style.display = "block"), i.appendChild(o);
                          const a = document.createElement("div");
                          (a.style.display = "none"),
                            i.appendChild(a),
                            (z = () => {
                              (B.style.display = "block"),
                                (o.style.display = "block"),
                                (a.style.display = "none");
                            });
                          const s = document.createElement("div");
                          (s.style.display = "flex"),
                            (s.style.padding = "8px 16px"),
                            (s.style.backgroundColor = "#5cb85c"),
                            (s.style.color = "white"),
                            o.appendChild(s);
                          const n = document.createElement("div");
                          (n.style.flexGrow = "1"),
                            (n.innerHTML = e),
                            s.appendChild(n),
                            G(
                              "licenseModalClose",
                              ".licenseModalClose {\n        color: #aaa;\n        float: right;\n        font-size: 28px;\n        font-weight: bold;\n      }"
                            ),
                            G(
                              "licenseModalClose:hover",
                              ".licenseModalClose:hover {\n        color: black;\n        text-decoration: none;\n        cursor: pointer;\n      }"
                            ),
                            G(
                              "licenseModalClose:focus",
                              ".licenseModalClose:focus {\n        color: black;\n        text-decoration: none;\n        cursor: pointer;\n      }"
                            );
                          const l = document.createElement("span");
                          (l.innerHTML = "&times;"),
                            (l.className = "licenseModalClose"),
                            s.appendChild(l);
                          const d = document.createElement("div");
                          d.innerHTML =
                            "If you contact support with a licensing issue, we will ask you to send us the license debug log.\n    To toggle License debug mode use the button below and refresh the page, then check the console output.  \n    When copying the log, make sure to start from the beginning, indicated by the reported version number";
                          const h = document.createElement("button");
                          h.style.margin = "10px";
                          const u = () => {
                            h.textContent = m
                              ? "Disable licensing debug mode"
                              : "Enable licensing debug mode";
                          };
                          u(),
                            (h.onclick = () => {
                              (0, t.setIsDebugLicensing)(!m, !0), u();
                            }),
                            o.appendChild(d),
                            o.appendChild(h);
                          const c = document.createElement("div");
                          (c.innerHTML = r),
                            (c.style.padding = "8px 16px"),
                            (c.style.backgroundColor = "#5cb85c"),
                            (c.style.color = "white"),
                            o.appendChild(c),
                            (window.onclick = (e) => {
                              e.target === B && (B.style.display = "none");
                            });
                          const p = document.querySelector(`[id='${B.id}']`);
                          null == p
                            ? document.body.appendChild(B)
                            : document.body.replaceChild(B, p),
                            (l.onclick = () => {
                              B.style.display = "none";
                            });
                        })(a, n))
                      : ($.innerHTML =
                          a +
                          '<br><a href="https://www.scichart.com/licensing-scichart-js/"  target="_blank" style="color: white">Click here for licensing information</a>')))
                : (0, d.sendTelemetry)();
          }
          Z(r.domDivContainer, U),
            o &&
              r.otherSurfaces.forEach((e) => {
                Z(e.domDivContainer, U);
              });
        };
        (t.updateLicenseDisplay = (e, t, r, i) =>
          v.updateLicenseDisplay(e, t, r, i)),
          (t.licenseManager = {
            clear: () => {
              n.sciChartDestinations.length ||
                n.sciChartSingleDestinations.length ||
                n.sciChart3DDestinations.length ||
                (clearTimeout(E),
                clearTimeout(R),
                (0, t.setCallbacks3D)(M),
                ($ = null),
                (U = null));
            },
            setRuntimeLicenseKey: (e) => (0, t.setRuntimeLicenseKey)(e),
            setIsDebugLicensing: (e) => (0, t.setIsDebugLicensing)(e),
            setLicenseCallback: (e) => (0, t.setLicenseCallback)(e),
            setServerLicenseEndpoint: (e) =>
              ((e) => {
                D = e;
              })(e),
            applyLicense2D: (e, r, i) =>
              ((e, r, i) => {
                S("applyLicense 2D"),
                  i || N
                    ? (0, t.applyLicense)(e, r)
                    : F !== u.LicenseCheckStatus.LicenseOK &&
                      (0, t.updateLicenseDisplay)(
                        (0, t.getLicenseInfo)(e),
                        r,
                        !0,
                        !1
                      ),
                  i || (N = !1);
              })(e, r, i),
          });
      },
      2056: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.licenseManager2dState = void 0);
        const i = r(48125);
        let o = !1,
          a = "",
          s = "",
          n = 1,
          l = i.LicenseType.NoLicense,
          d = !1;
        t.licenseManager2dState = {
          getIsDev: () => o,
          setIsDev: (e) => {
            o = e;
          },
          getOrderId: () => a,
          setOrderId: (e) => {
            a = e;
          },
          getProductCode: () => s,
          setProductCode: (e) => {
            s = e;
          },
          getLicenseType: () => l,
          setLicenseType: (e) => {
            l = e;
          },
          getDevCount: () => n,
          setDevCount: (e) => {
            n = e;
          },
          getTelemetry: () => d,
          setTelemetry: (e) => {
            d = e;
          },
        };
      },
      66570: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DefaultSciChartLoader = void 0);
        const i = r(23866);
        class o {
          addChartLoader(e, t) {
            this.addLoaderStyles(),
              i.Guard.notNull(e, "domDivContainer"),
              i.Guard.notNull(t, "theme");
            const r = document.createElement("div");
            (r.style.background = t.loadingAnimationBackground),
              (r.style.height = "100%"),
              (r.style.width = "100%"),
              (r.style.position = "relative"),
              (r.style.zIndex = "11");
            const o = document.createElement("div"),
              a = `<div><span style="background: ${t.loadingAnimationForeground}"/></div>`;
            return (
              (o.innerHTML = a.repeat(8)),
              o.classList.add("scichart_loader"),
              r.appendChild(o),
              e.appendChild(r),
              r
            );
          }
          removeChartLoader(e, t) {
            try {
              e.removeChild(t);
            } catch (e) {
              console.error(e);
            }
          }
          toJSON() {
            return { type: this.type };
          }
          addLoaderStyles() {
            if (o.hasStyles) return;
            const e = document.head,
              t = document.createElement("style");
            (t.id = o.sciChartLoaderStylesId),
              e.appendChild(t),
              t.appendChild(document.createTextNode(a)),
              (o.hasStyles = !0);
          }
        }
        (t.DefaultSciChartLoader = o),
          (o.hasStyles = !1),
          (o.sciChartLoaderStylesId = "scichart_default_loader_styles_id");
        const a =
          "\n    .scichart_loader {\n      display: inline-block;\n      position: relative;\n      width: 80px;\n      height: 80px;\n      top: 50%;\n      transform: translateY(-50%);\n    }\n    .scichart_loader div {\n      animation: scichart_loader 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n      transform-origin: 40px 40px;\n    }\n    .scichart_loader div span {\n      display: block;\n      position: absolute;\n      width: 7px;\n      height: 7px;\n      border-radius: 50%;\n      margin: -4px 0 0 -4px;\n    }\n    .scichart_loader div:nth-child(1) {\n      animation-delay: -0.036s;\n    }\n    .scichart_loader div:nth-child(1) span {\n      top: 63px;\n      left: 63px;\n    }\n    .scichart_loader div:nth-child(2) {\n      animation-delay: -0.072s;\n    }\n    .scichart_loader div:nth-child(2) span {\n      top: 68px;\n      left: 56px;\n    }\n    .scichart_loader div:nth-child(3) {\n      animation-delay: -0.108s;\n    }\n    .scichart_loader div:nth-child(3) span {\n      top: 71px;\n      left: 48px;\n    }\n    .scichart_loader div:nth-child(4) {\n      animation-delay: -0.144s;\n    }\n    .scichart_loader div:nth-child(4) span {\n      top: 72px;\n      left: 40px;\n    }\n    .scichart_loader div:nth-child(5) {\n      animation-delay: -0.18s;\n    }\n    .scichart_loader div:nth-child(5) span {\n      top: 71px;\n      left: 32px;\n    }\n    .scichart_loader div:nth-child(6) {\n      animation-delay: -0.216s;\n    }\n    .scichart_loader div:nth-child(6) span {\n      top: 68px;\n      left: 24px;\n    }\n    .scichart_loader div:nth-child(7) {\n      animation-delay: -0.252s;\n    }\n    .scichart_loader div:nth-child(7) span {\n      top: 63px;\n      left: 17px;\n    }\n    .scichart_loader div:nth-child(8) {\n      animation-delay: -0.288s;\n    }\n    .scichart_loader div:nth-child(8) span {\n      top: 56px;\n      left: 12px;\n    }\n    @keyframes scichart_loader {\n      0% {\n        transform: rotate(0deg);\n      }\n      100% {\n        transform: rotate(360deg);\n      }\n    }\n";
      },
      25606: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createSvgLayer = t.ELayerClass = void 0);
        const i = r(62049),
          o = r(16602),
          a = r(14184),
          s = r(86127);
        var n, l;
        !(function (e) {
          (e[(e.canvasWebGL = 0)] = "canvasWebGL"),
            (e[(e.canvas2D = 1)] = "canvas2D"),
            (e[(e.svg = 2)] = "svg");
        })(n || (n = {})),
          (function (e) {
            (e.DIV_ROOT = "div-root"),
              (e.SVG_ROOT = "svg-root"),
              (e.BACK_DIV_ROOT = "back-div-root"),
              (e.FRONT_DIV_ROOT = "front-div-root"),
              (e.BACK_SVG_ROOT = "back-svg-root"),
              (e.FRONT_SVG_ROOT = "front-svg-root"),
              (e.ADORNER_SVG_ROOT = "adorner-svg-root"),
              (e.CANVAS_ROOT = "canvas-root");
          })((l = t.ELayerClass || (t.ELayerClass = {})));
        const d = (e) => `${e}_2D`,
          h = (e) => {
            const t = e.style.maxHeight;
            if (t && t.includes("px")) {
              const e = parseInt(t.replace("px", ""), 10);
              if (!isNaN(e)) return e;
            }
          };
        t.createSvgLayer = (e, t, r) => {
          const i = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          return (
            (i.id = e),
            i.setAttribute("width", t.toString()),
            i.setAttribute("height", r.toString()),
            i.setAttribute("role", "img"),
            i.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            (i.style.position = "absolute"),
            (i.style.display = "block"),
            i.classList.add(l.SVG_ROOT),
            i
          );
        };
        const u = {
          checkChartDivExists: (e) => {
            if ("string" == typeof e) {
              const t = document.querySelectorAll(`[id=${e}]`).length;
              t > 1
                ? console.error(
                    `Please provide a unique ID for each chart div element, "${e}" it is not a unique identifier`
                  )
                : 0 === t &&
                  console.error(
                    `Chart div element with the ID "${e}" is not present in the DOM`
                  );
            } else if (!e)
              throw new Error("Provided div element doesn't exist!");
          },
          ECanvasType: n,
          getCanvas2dId: d,
          initCanvas: (e, r, u, c = n.canvasWebGL, p, g) => {
            var y;
            const f = o.PerformanceDebugHelper.mark(
              o.EPerformanceMarkType.CanvasInitializationStart,
              { level: o.EPerformanceDebugLevel.Verbose }
            );
            i.WebGlHelper.initialize(), s.DpiHelper.initialize();
            const v = ((e) => {
              const t =
                "string" == typeof e ? document.querySelector(`#${e}`) : e;
              if (!t)
                throw new Error(`Check div element with id "${t.id}" exists`);
              if ("div" !== t.nodeName.toLowerCase())
                throw new Error(
                  `Element with id "${t.id}" should be of type div`
                );
              return t;
            })(e);
            (v.innerHTML = ""),
              "" === v.style.position && (v.style.position = "relative"),
              "" === v.style.overflow && (v.style.overflow = "hidden");
            const m = v.id,
              { offsetWidth: S, offsetHeight: P } = v,
              C = h(v),
              {
                width: b,
                height: x,
                aspectRatio: A,
              } = ((e, t, r, i = 0, o = 0) => {
                let a;
                a = i && o ? i / o : e && t ? void 0 : 1.5;
                const s = Math.round(e || 600);
                if (a) {
                  let e = Math.round(s / a);
                  return (
                    e > r && (e = r), { width: s, height: e, aspectRatio: a }
                  );
                }
                return { width: s, height: Math.round(t), aspectRatio: a };
              })(S, P, C, r, u);
            !p && A && (v.style.aspectRatio = `${A}`);
            const T = document.createElement("div");
            (T.id = `${m}_background_div`),
              T.classList.add(l.DIV_ROOT, l.BACK_DIV_ROOT),
              (T.style.width = "100%"),
              (T.style.height = "100%"),
              (T.style.position = "absolute"),
              (T.style.pointerEvents = "none"),
              v.appendChild(T);
            const E = (0, t.createSvgLayer)(`${m}_BACKGROUND_SVG`, b, x);
            let R;
            (E.style.width = "100%"),
              (E.style.height = "100%"),
              (E.style.pointerEvents = "none"),
              E.classList.add(l.BACK_SVG_ROOT),
              v.appendChild(E),
              c === n.canvasWebGL &&
                ((R = document.createElement("canvas")),
                (R.id = `${m}_WebGL`),
                R.classList.add(l.CANVAS_ROOT),
                (R.style.position = "absolute"),
                (R.style.display = "block"),
                (R.style.width = "100%"),
                (R.style.height = "100%"),
                i.WebGlHelper.getContext(R, {
                  premultipliedAlpha: !0,
                  antialias: a.SciChartSurfaceBase.AntiAliasWebGlBackbuffer,
                }),
                v.appendChild(R));
            const D = document.createElement("canvas");
            (D.id = d(m)),
              D.classList.add(l.CANVAS_ROOT),
              (D.style.width = "100%"),
              (D.style.height = "100%"),
              s.DpiHelper.setSize(D, b, x),
              (D.style.position = "absolute"),
              c !== n.canvas2D && (D.style.pointerEvents = "none"),
              c === n.canvasWebGL
                ? (D.style.display = "none")
                : (D.style.display = "block"),
              v.appendChild(D),
              (D.style.touchAction = null != g ? g : "none"),
              (D.onselectstart = () => !1);
            const w = (0, t.createSvgLayer)(`${m}_SVG`, b, x);
            (w.style.width = "100%"),
              (w.style.height = "100%"),
              c !== n.svg && (w.style.pointerEvents = "none"),
              w.classList.add(l.FRONT_SVG_ROOT),
              v.appendChild(w);
            const M = (0, t.createSvgLayer)(`${m}_Adorner`, b, x);
            (M.style.pointerEvents = "none"),
              (M.style.width = "100%"),
              (M.style.height = "100%"),
              (M.style.zIndex = "1"),
              M.classList.add(l.ADORNER_SVG_ROOT),
              v.appendChild(M);
            const L = document.createElement("div");
            return (
              (L.id = `${m}_div`),
              L.classList.add(l.DIV_ROOT, l.FRONT_DIV_ROOT),
              (L.style.width = "100%"),
              (L.style.height = "100%"),
              (L.style.position = "relative"),
              (L.style.pointerEvents = "none"),
              (L.style.textAlign = "center"),
              v.appendChild(L),
              c === n.canvasWebGL &&
                R.addEventListener(
                  "webglcontextlost",
                  (e) => {
                    console.warn("WebGL context lost. Reloading the page."),
                      e.preventDefault(),
                      location.reload();
                  },
                  !1
                ),
              o.PerformanceDebugHelper.mark(
                o.EPerformanceMarkType.CanvasInitializationEnd,
                {
                  level: o.EPerformanceDebugLevel.Verbose,
                  contextId: D.id,
                  relatedId:
                    null === (y = null == f ? void 0 : f.detail) || void 0 === y
                      ? void 0
                      : y.relatedId,
                }
              ),
              {
                domChartRoot: v,
                domCanvasWebGL: R,
                domCanvas2D: D,
                domSvgContainer: w,
                domSvgAdornerLayer: M,
                domDivContainer: L,
                domSeriesBackground: T,
                domBackgroundSvgContainer: E,
                aspect: A,
                disableAspect: p,
              }
            );
          },
          subscribeToResize: (e, t, r, i) => {
            const a = new ResizeObserver((t) => {
              for (const i of t) {
                let t, a;
                i.contentRect
                  ? ((t = i.contentRect.width), (a = i.contentRect.height))
                  : i.contentBoxSize
                  ? i.contentBoxSize.inlineSize
                    ? (t = i.contentBoxSize.inlineSize)
                    : i.contentBoxSize[0] &&
                      (t = i.contentBoxSize[0].inlineSize)
                  : (console.error("ResizeObserver is not supported"),
                    (t = 900));
                const n = h(e);
                n && a > n && (a = n);
                const l = 0 !== t && 0 !== a,
                  d =
                    r.domCanvas2D.width !== t * s.DpiHelper.PIXEL_RATIO ||
                    r.domCanvas2D.height !== a * s.DpiHelper.PIXEL_RATIO;
                l &&
                  d &&
                  setTimeout(() => {
                    o.PerformanceDebugHelper.mark(
                      o.EPerformanceMarkType.Resize,
                      { contextId: r.id }
                    ),
                      r.changeViewportSize(t, a);
                  }, 0);
              }
            });
            return (
              a.observe(e, { box: "border-box" }),
              { delete: () => a.disconnect() }
            );
          },
        };
        t.default = u;
      },
      75112: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sciChartSubSurfaceCommon = void 0);
        const i = r(41493),
          o = r(56744),
          a = r(87459),
          s = r(87108),
          n = r(64669),
          l = r(7171),
          d = r(48008),
          h = r(32873),
          u = r(51269),
          c = r(31306),
          p = r(63458),
          g = r(98353);
        t.sciChartSubSurfaceCommon = {
          createSubSurfaceCanvases: function (e) {
            return {
              domChartRoot: e.domChartRoot,
              domCanvasWebGL: e.domCanvasWebGL,
              domCanvas2D: e.domCanvas2D,
              domSvgContainer: e.domSvgContainer,
              domSvgAdornerLayer: e.domSvgAdornerLayer,
              domDivContainer: e.domDivContainer,
              domBackgroundSvgContainer: e.domBackgroundSvgContainer,
              domSeriesBackground: e.domSeriesBackground,
            };
          },
          getSubChartRect: function (e) {
            const { width: t, height: r } = e.renderSurface.viewportSize,
              { top: i, left: o, bottom: s, right: n } = e.offset,
              l = t - o - n > 0 ? t - o - n : 0,
              d = r - i - s > 0 ? r - i - s : 0;
            return new a.Rect(o, i, l, d);
          },
          deleteSubChart: function (e, t) {
            e.backgroundFillBrushCache = (0, o.deleteSafe)(
              e.backgroundFillBrushCache
            );
          },
          calcPadding: function (e) {
            const { width: t, height: r } = e.parentSurface.viewRect,
              i = Array.isArray(e.coordinateMode)
                ? e.coordinateMode
                : [
                    e.coordinateMode,
                    e.coordinateMode,
                    e.coordinateMode,
                    e.coordinateMode,
                  ],
              o =
                e.coordinateMode === c.ECoordinateMode.DataValue ||
                e.coordinateMode.includes(c.ECoordinateMode.DataValue),
              a = e.subPosition,
              d = (0, l.hasProperties)(a, n.xywhFormatRequiredFieldNames),
              h = (0, l.hasProperties)(a, n.ltrbFormatRequiredFieldNames),
              u = (0, l.hasProperties)(a, n.polygonFormatRequiredFieldNames),
              { left: p, top: g } = e.parentSurface.seriesViewRect,
              {
                horizontalCalc: m,
                verticalCalc: S,
                xFlipped: P,
                yFlipped: C,
              } = y(e);
            if (d && o) {
              const [e, o, n, l] = i,
                { x: d, y: h, width: u, height: c } = a,
                y = f(d, e, t, m, p),
                b = f(h, o, r, S, g),
                x = v(y, n, t, m, p),
                A = f(P ? x - u : x + u, n, t, m, p),
                T = v(b, l, r, S, g),
                E = f(C ? T + c : T - c, l, r, S, g);
              return new s.Thickness(b, t - A, r - E, y);
            }
            if (d && !o) {
              const [e, o, n, l] = i,
                { x: d, y: h, width: u, height: c } = a,
                p = f(d, e, t),
                g = f(h, o, r),
                y = p + f(u, n, t),
                v = g + f(c, l, r);
              return new s.Thickness(g, t - y, r - v, p);
            }
            if (h) {
              const [e, o, n, l] = i,
                { left: d, top: h, right: u, bottom: c } = a,
                y = f(d, e, t, m, p),
                v = f(h, o, r, S, g),
                P = f(u, n, t, m, p),
                C = f(c, l, r, S, g);
              return new s.Thickness(v, t - P, r - C, y);
            }
            if (u) {
              const [e, o, n, l] = i,
                { x1: d, y1: h, x2: u, y2: c } = a,
                y = f(d, e, t, m, p),
                v = f(h, o, r, S, g),
                P = f(u, n, t, m, p),
                C = f(c, l, r, S, g),
                b = Math.min(y, P),
                x = Math.min(v, C),
                A = Math.max(y, P),
                T = Math.max(v, C);
              return new s.Thickness(x, t - A, r - T, b);
            }
            throw new Error(
              `Unexpected position format or coordinate mode ${e.coordinateMode}!`
            );
          },
          applySciChartBackground: function (e, t, r) {
            if (!e.isTransparent && e.isSubSurface) {
              const o = r.getNativeContext(),
                s = e.viewRect,
                n = a.Rect.intersect(s, e.clipRect);
              o.SetClipRect(n.left, n.top, n.width, n.height),
                o.SetClearColor(0, 0, 0, 0),
                o.Clear();
              try {
                (0, d.parseColorToUIntArgb)(t);
                const i = (0, g.getVectorRectVertex)(e.webAssemblyContext2D);
                i.push_back(
                  (0, p.createNativeRect)(
                    e.webAssemblyContext2D,
                    s.left,
                    s.top,
                    s.right,
                    s.bottom
                  )
                );
                const o = (0, u.createBrushInCache)(
                  e.backgroundFillBrushCache,
                  t,
                  1
                );
                r.drawRects(i, o, n, 0, 0);
              } catch (e) {
                i.performanceWarnings.subchartBackgroundNotSimpleColor.warn();
              }
            }
          },
          updateWrapper: function (e, t) {
            if (!e.parentSurface || !e.subChartContainer) return;
            const { width: r, height: i } = e.parentSurface.viewRect;
            (e.subChartContainer.style.left = (0, h.convertToHtmlPx)(t.left)),
              (e.subChartContainer.style.top = (0, h.convertToHtmlPx)(t.top)),
              (e.subChartContainer.style.width = (0, h.convertToHtmlPx)(
                r - t.left - t.right
              )),
              (e.subChartContainer.style.height = (0, h.convertToHtmlPx)(
                i - t.top - t.bottom
              ));
          },
          getOffsets: function (e, t) {
            var r, i, o, a;
            if (!t) return s.Thickness.fromNumber(0);
            const n = t.getElementsByClassName(e.leftSectionClass)[0],
              l = t.getElementsByClassName(e.topSectionClass)[0],
              d = t.getElementsByClassName(e.rightSectionClass)[0],
              u = t.getElementsByClassName(e.bottomSectionClass)[0],
              c =
                null !== (r = null == n ? void 0 : n.clientWidth) &&
                void 0 !== r
                  ? r
                  : 0,
              p =
                null !== (i = null == l ? void 0 : l.clientHeight) &&
                void 0 !== i
                  ? i
                  : 0,
              g =
                null !== (o = null == d ? void 0 : d.clientWidth) &&
                void 0 !== o
                  ? o
                  : 0,
              y =
                null !== (a = null == u ? void 0 : u.clientHeight) &&
                void 0 !== a
                  ? a
                  : 0;
            return new s.Thickness(
              (0, h.translateToScaled)(p * e.sectionScale),
              (0, h.translateToScaled)(g * e.sectionScale),
              (0, h.translateToScaled)(y * e.sectionScale),
              (0, h.translateToScaled)(c * e.sectionScale)
            );
          },
        };
        const y = (e) => {
          var t, r;
          if (
            e.coordinateMode !== c.ECoordinateMode.DataValue &&
            !e.coordinateMode.includes(c.ECoordinateMode.DataValue)
          )
            return {};
          const i =
            null !== (t = e.parentSurface.getXAxisById(e.parentXAxisId)) &&
            void 0 !== t
              ? t
              : e.parentSurface.getDefaultXAxis();
          if (!i)
            throw new Error(
              `No x axis with id ${e.parentXAxisId} found on parent surface`
            );
          const o = i.getCurrentCoordinateCalculator(),
            a =
              null !== (r = e.parentSurface.getYAxisById(e.parentYAxisId)) &&
              void 0 !== r
                ? r
                : e.parentSurface.getDefaultYAxis();
          if (!a)
            throw new Error(
              `No y axis with id ${e.parentYAxisId} found on parent surface`
            );
          const s = a.getCurrentCoordinateCalculator();
          return {
            horizontalCalc: i.isVerticalChart ? s : o,
            verticalCalc: i.isVerticalChart ? o : s,
            xFlipped: i.flippedCoordinates,
            yFlipped: a.flippedCoordinates,
          };
        };
        function f(e, t, r, i, o) {
          switch (t) {
            case c.ECoordinateMode.Pixel:
              return (0, h.translateToScaled)(e);
            case c.ECoordinateMode.Relative:
              return r * e;
            case c.ECoordinateMode.DataValue:
              return o + i.getCoordinate(e);
          }
        }
        function v(e, t, r, i, o) {
          switch (t) {
            case c.ECoordinateMode.Pixel:
              return (0, h.translateToNotScaled)(e);
            case c.ECoordinateMode.Relative:
              return e / r;
            case c.ECoordinateMode.DataValue:
              return i.getDataValue(e - o);
          }
        }
      },
      66549: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnimationToken = void 0),
          (t.AnimationToken = class {
            constructor(e, t) {
              (this.token = e), (this.onCompleted = t);
            }
            cancelAnimation() {
              this.token && (clearInterval(this.token), (this.token = void 0));
            }
            completeAnimation() {
              this.token && (clearInterval(this.token), (this.token = void 0)),
                this.onCompleted && this.onCompleted();
            }
          });
      },
      82229: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SeriesAnimationFiniteStateMachine =
            t.AnimationFiniteStateMachine =
            t.EAnimationStateTransition =
            t.EAnimationState =
              void 0);
        const i = r(64645);
        var o, a;
        !(function (e) {
          (e.InitialState = "InitialState"),
            (e.Delayed = "Delayed"),
            (e.Running = "Running"),
            (e.Completed = "Completed");
        })((o = t.EAnimationState || (t.EAnimationState = {}))),
          (function (e) {
            (e.NoChange = "NoChange"),
              (e.InitialState_Delayed = "InitialState_Delayed"),
              (e.InitialState_Running = "InitialState_Running"),
              (e.InitialState_Completed = "InitialState_Completed"),
              (e.Delayed_Running = "Delayed_Running"),
              (e.Running_Completed = "Running_Completed");
          })(
            (a =
              t.EAnimationStateTransition || (t.EAnimationStateTransition = {}))
          );
        class s {
          constructor(e) {
            (this.stateProperty = o.InitialState), (this.animationProperty = e);
          }
          get state() {
            return this.stateProperty;
          }
          get animation() {
            return this.animationProperty;
          }
          is(e) {
            return e.includes(this.stateProperty);
          }
          update(e) {
            return this.stateProperty === o.InitialState
              ? this.animationProperty.delay
                ? (this.toDelayed(), a.InitialState_Delayed)
                : this.animationProperty.duration
                ? (this.toRunning(), a.InitialState_Running)
                : (this.toCompleted(), a.InitialState_Completed)
              : this.stateProperty === o.Delayed
              ? this.updateDelayedState(e)
              : this.stateProperty === o.Running
              ? this.updateRunningState(e)
              : a.NoChange;
          }
          get animationProgress() {
            if (this.stateProperty === o.Running) {
              const e = i.NumberUtil.constrain(
                this.animationElapsed / this.animationProperty.duration,
                0,
                1
              );
              return this.animationProperty.ease(e);
            }
            return this.stateProperty === o.Completed ? 1 : 0;
          }
          toCompleted() {
            this.stateProperty = o.Completed;
          }
          validate(e, t) {
            if (!e.includes(this.stateProperty))
              throw Error(
                `Transition from state ${this.stateProperty} to ${t} if forbidden`
              );
          }
          toDelayed() {
            (this.animationDelayStartTimestamp = Date.now()),
              (this.animationDelayElapsed = 0),
              (this.stateProperty = o.Delayed);
          }
          toRunning() {
            (this.animationStartTimestamp = Date.now()),
              (this.animationElapsed = 0),
              (this.stateProperty = o.Running);
          }
          updateDelayedState(e) {
            return (
              (this.animationDelayElapsed += e),
              this.animationDelayElapsed >= this.animationProperty.delay
                ? (this.toRunning(), a.Delayed_Running)
                : a.NoChange
            );
          }
          updateRunningState(e) {
            return (
              (this.animationElapsed += e),
              this.animationElapsed >= this.animationProperty.duration
                ? (this.toCompleted(), a.Running_Completed)
                : a.NoChange
            );
          }
        }
        (t.AnimationFiniteStateMachine = s),
          (t.SeriesAnimationFiniteStateMachine = class extends s {
            constructor(e, t) {
              super(e), t && (this.initialStylesProperty = e.getSeriesStyle(t));
            }
            get animation() {
              return this.animationProperty;
            }
            get initialStyles() {
              return this.initialStylesProperty;
            }
          });
      },
      90995: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.animateAny = void 0);
        const i = r(66549),
          o = r(23866),
          a = r(64645);
        t.animateAny = function (e, t, r, s, n, l, d) {
          o.Guard.notNull(s, "onAnimate"),
            o.Guard.notNull(t, "from"),
            o.Guard.notNull(r, "to"),
            o.Guard.notNull(n, "interpolate");
          const h = new Date().getTime() + e;
          s(t);
          const u = new i.AnimationToken(
            setInterval(() => {
              const i = new Date().getTime(),
                o = a.NumberUtil.constrain(1 - (h - i) / e, 0, 1),
                l = d(o),
                c = n(t, r, l);
              s(c),
                i > h && (1 !== l && s(n(t, r, d(1))), u.completeAnimation());
            }, 16.67),
            l
          );
          return u;
        };
      },
      33485: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DoubleAnimator = void 0);
        const i = r(90995),
          o = r(10276);
        class a {
          static animate(e, t, r, s, n, l = o.easing.outExpo) {
            return (0, i.animateAny)(r, e, t, s, a.interpolate, n, l);
          }
          static interpolate(e, t, r) {
            return (t - e) * r + e;
          }
        }
        t.DoubleAnimator = a;
      },
      10276: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.autoReverseEasing = t.easing = void 0),
          (t.easing = {
            linear: (e) => e,
            quadratic: (e) => e * (-e * e * e + 4 * e * e - 6 * e + 4),
            cubic: (e) => e * (4 * e * e - 9 * e + 6),
            elastic: (e) =>
              e *
              (33 * e * e * e * e -
                106 * e * e * e +
                126 * e * e -
                67 * e +
                15),
            inQuad: (e) => e * e,
            outQuad: (e) => e * (2 - e),
            inOutQuad: (e) => (e < 0.5 ? 2 * e * e : (4 - 2 * e) * e - 1),
            inCubic: (e) => e * e * e,
            outCubic: (e) => --e * e * e + 1,
            inOutCubic: (e) =>
              e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
            inQuart: (e) => e * e * e * e,
            outQuart: (e) => 1 - --e * e * e * e,
            inOutQuart: (e) =>
              e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e,
            inQuint: (e) => e * e * e * e * e,
            outQuint: (e) => 1 + --e * e * e * e * e,
            inOutQuint: (e) =>
              e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e,
            inSine: (e) => 1 - Math.cos(e * (Math.PI / 2)),
            outSine: (e) => Math.sin(e * (Math.PI / 2)),
            inOutSine: (e) => -(Math.cos(Math.PI * e) - 1) / 2,
            inExpo: (e) => Math.pow(2, 10 * (e - 1)),
            outExpo: (e) => (1 === e ? 1 : 1 - Math.pow(2, -10 * e)),
            inOutExpo: (e) =>
              (e /= 0.5) < 1
                ? Math.pow(2, 10 * (e - 1)) / 2
                : (e--, (2 - Math.pow(2, -10 * e)) / 2),
            inCirc: (e) => 1 - Math.sqrt(1 - e * e),
            outCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
            inOutCirc: (e) =>
              (e /= 0.5) < 1
                ? -(Math.sqrt(1 - e * e) - 1) / 2
                : ((e -= 2), (Math.sqrt(1 - e * e) + 1) / 2),
          }),
          (t.autoReverseEasing = {
            linear: (e) => (e < 0.5 ? 2 * e : 2 - 2 * e),
          });
      },
      70162: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GenericAnimation = void 0);
        const i = r(73538),
          o = r(82229),
          a = r(10276);
        t.GenericAnimation = class {
          constructor(e) {
            var t, r, s, n;
            (this.delay = 0),
              (this.duration = 1e3),
              (this.ease = a.easing.linear),
              (this.id =
                null !== (t = null == e ? void 0 : e.id) && void 0 !== t
                  ? t
                  : (0, i.generateGuid)()),
              (this.delay =
                null !== (r = null == e ? void 0 : e.delay) && void 0 !== r
                  ? r
                  : this.delay),
              (this.duration =
                null !== (s = null == e ? void 0 : e.duration) && void 0 !== s
                  ? s
                  : this.duration),
              (null == e ? void 0 : e.ease) &&
                "string" == typeof e.ease &&
                (e.ease = a.easing[e.ease]),
              (this.ease =
                null !== (n = null == e ? void 0 : e.ease) && void 0 !== n
                  ? n
                  : this.ease),
              (this.from = e.from),
              (this.to = e.to),
              (this.onAnimate = e.onAnimate),
              (this.onCompleted = null == e ? void 0 : e.onCompleted),
              (this.animationFSM = new o.AnimationFiniteStateMachine(this)),
              (null == e ? void 0 : e.setInitialValueImmediately) &&
                this.onAnimate(this.from, this.to, 0);
          }
          get isComplete() {
            return this.animationFSM.is([o.EAnimationState.Completed]);
          }
          reset() {
            this.animationFSM = new o.AnimationFiniteStateMachine(this);
          }
          update(e) {
            const t = this.animationFSM.update(e);
            [
              o.EAnimationStateTransition.InitialState_Running,
              o.EAnimationStateTransition.Delayed_Running,
            ].includes(t) && this.onAnimate(this.from, this.to, 0),
              this.animationFSM.is([
                o.EAnimationState.Running,
                o.EAnimationState.Completed,
              ]) &&
                this.onAnimate(
                  this.from,
                  this.to,
                  this.animationFSM.animationProgress
                ),
              [
                o.EAnimationStateTransition.Running_Completed,
                o.EAnimationStateTransition.InitialState_Completed,
              ].includes(t) &&
                this.onCompleted &&
                this.onCompleted();
          }
          cancel() {
            this.animationFSM.toCompleted();
          }
        };
      },
      31194: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumberRangeAnimator = void 0);
        const i = r(23866),
          o = r(98140),
          a = r(10276),
          s = r(70162);
        class n {
          static animate(e, t, r, i, o, l = a.easing.outExpo, d = !1) {
            return new s.GenericAnimation({
              from: e,
              to: t,
              duration: r,
              onAnimate: (e, t, r) => {
                const o = (d ? n.interpolateLog : n.interpolate)(e, t, r);
                i(o);
              },
              delay: 0,
              ease: l,
              onCompleted: o,
            });
          }
          static interpolate(e, t, r) {
            i.Guard.notNull(e, "from"), i.Guard.notNull(t, "to");
            const a = (t.min - e.min) * r + e.min,
              s = (t.max - e.max) * r + e.max;
            return new o.NumberRange(a, s);
          }
          static interpolateLog(e, t, r) {
            i.Guard.notNull(e, "from"), i.Guard.notNull(t, "to");
            const a = Math.pow(t.min / e.min, r) * e.min,
              s = Math.pow(t.max / e.max, r) * e.max;
            return new o.NumberRange(a, s);
          }
        }
        t.NumberRangeAnimator = n;
      },
      34238: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.checkBuildStamp = t.libraryVersion = void 0);
        const r = "2025-05-07T00:00:00";
        let i;
        (t.libraryVersion = "4.0.0-beta.734"),
          (t.checkBuildStamp = (e) => {
            if (void 0 !== i) return i;
            if (!e) return !1;
            if (e.SCRTCredentials.GetBuildStamp) {
              const t = e.SCRTCredentials.GetBuildStamp();
              if (t === r) return (i = !0), i;
              console.warn(`Build stamp diff: JS - ${r}; WASM - ${t}`);
            }
            return (
              console.warn(
                "The SciChart webassembly module is from a different version than the javascript that is calling it.\n    Ensure that your build process is copying the correct wasm and data files."
              ),
              (i = !1),
              i
            );
          });
      },
      55023: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createWasmContextRevocableProxy =
            t.WasmContextProxyHandler =
            t.WasmObjectConstructorProxyHandler =
            t.DeletableEntityProxyHandler =
            t.DeletableEntity =
            t.createTrackableProxy =
              void 0);
        const i = r(27307);
        (t.createTrackableProxy = (e, t = !1) => {
          const r = (0, i.generateIdentifier)(e),
            a = Proxy.revocable(e, new o(r));
          return (
            i.MemoryUsageHelper.objectRegistry.add(e, r, {
              proxy: a.proxy,
              revocableToken: a,
              isWasmObject: t,
            }),
            a.proxy
          );
        }),
          (t.DeletableEntity = class {
            constructor(e) {}
          });
        class o {
          constructor(e) {
            this.disposableEntityId = e;
          }
          construct(e, t) {
            return (
              console.warn(
                "construct called on Deletable",
                this.disposableEntityId
              ),
              e
            );
          }
          apply(e, t, r) {
            console.warn("apply called on Deletable", this.disposableEntityId);
          }
          get(e, t, r) {
            return "delete" === t
              ? (...r) => (
                  i.MemoryUsageHelper.objectRegistry.remove(
                    this.disposableEntityId
                  ) ||
                    console.warn(
                      `Failed to remove ${this.disposableEntityId} from the Object Registry Probably it has been already deleted!`
                    ),
                  e[t](...r)
                )
              : e[t];
          }
        }
        t.DeletableEntityProxyHandler = o;
        class a {
          construct(e, r, i) {
            const o = new e(...r);
            return (0, t.createTrackableProxy)(o, !0);
          }
        }
        t.WasmObjectConstructorProxyHandler = a;
        const s = { construct: () => s };
        (t.WasmContextProxyHandler = class {
          constructor() {
            this.constructorProxyHandler = new a();
          }
          get(e, t, r) {
            const i = e[t];
            return ((e) => {
              try {
                return !!new new Proxy(e, s)();
              } catch (e) {
                return !1;
              }
            })(i)
              ? new Proxy(i, this.constructorProxyHandler)
              : i;
          }
        }),
          (t.createWasmContextRevocableProxy = (e, t) => (
            i.MemoryUsageHelper.register(e, `wasmContext_${t}`),
            Proxy.revocable(e, {})
          ));
      },
      56744: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.deleteSafe = void 0),
          (t.deleteSafe = function (e) {
            null == e || e.delete();
          });
      },
      21079: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Dictionary = void 0),
          (t.Dictionary = class {
            constructor() {
              (this.items = {}), (this.countProperty = 0);
            }
            containsKey(e) {
              return this.items.hasOwnProperty(e);
            }
            get count() {
              return this.countProperty;
            }
            add(e, t) {
              this.items.hasOwnProperty(e) || this.countProperty++,
                (this.items[e] = t);
            }
            remove(e) {
              const t = this.items[e];
              return delete this.items[e], this.countProperty--, t;
            }
            item(e) {
              return this.items[e];
            }
            get keys() {
              return Object.keys(this.items);
            }
            get values() {
              return this.keys.map((e) => this.items[e]);
            }
            clear() {
              (this.items = {}), (this.countProperty = 0);
            }
          });
      },
      3214: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EventHandler = void 0),
          (t.EventHandler = class {
            constructor() {
              this.handlers = [];
            }
            subscribe(e) {
              this.handlers.includes(e) || this.handlers.push(e);
            }
            unsubscribe(e) {
              this.handlers = this.handlers.filter((t) => t !== e);
            }
            unsubscribeAll() {
              this.handlers = [];
            }
            raiseEvent(e) {
              this.handlers.slice(0).forEach((t) => t(e));
            }
          });
      },
      99263: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sciChartPieDestinations =
            t.sciChart3DSingleDestinations =
            t.sciChartSingleDestinations =
            t.sciChart3DDestinations =
            t.sciChartDestinations =
              void 0),
          (t.sciChartDestinations = []),
          (t.sciChart3DDestinations = []),
          (t.sciChartSingleDestinations = []),
          (t.sciChart3DSingleDestinations = []),
          (t.sciChartPieDestinations = []);
      },
      58599: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GradientParams = void 0),
          (t.GradientParams = class {
            constructor(e, t, r) {
              if (((this.gradientStops = []), r.length < 2))
                throw Error("At least two gradient point should be provided");
              if (e.x < 0 || e.y < 0 || e.x > 1 || e.y > 1)
                throw Error("startPoint values should be within [0,1]");
              if (t.x < 0 || t.y < 0 || t.x > 1 || t.y > 1)
                throw Error("endPoint values should be within [0,1]");
              r.forEach((e) => {
                if (e.offset < 0 || e.offset > 1)
                  throw Error("gradientStops offset should be within [0,1]");
              }),
                (this.startPoint = e),
                (this.endPoint = t),
                (this.gradientStops = r);
            }
          });
      },
      23866: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Guard = void 0);
        const i = r(72934);
        t.Guard = class {
          static notNull(e, t) {
            if (null == e)
              throw new Error("Argument " + t + " must not be undefined");
          }
          static isTrue(e, t) {
            if (!e) throw new Error(t);
          }
          static arraysSameLength(e, t, r, i) {
            if ((this.notNull(e, t), this.notNull(r, i), e.length !== r.length))
              throw new Error(`Arrays ${t} and ${i} must have the same length`);
          }
          static arraysSameLengthArr(e = []) {
            if (
              (e.forEach((e) => {
                this.notNull(e.arg, e.name);
              }),
              e.length >= 0)
            ) {
              const t = e[0].arg.length,
                r = e[0].name;
              e.forEach((e) => {
                if (e.arg.length !== t)
                  throw new Error(
                    `Arrays ${r} and ${e.name} must have the same length`
                  );
              });
            }
          }
          static argumentIsRealNumber(e, t) {
            if (!(0, i.isRealNumber)(e))
              throw new Error(
                `Argument ${t} must be a real number (not infinite, not NAN)`
              );
          }
          static argumentIsRealInteger(e, t) {
            if (!Number.isInteger(e) || !(0, i.isRealNumber)(e))
              throw new Error(
                `Argument ${t} must be a real integer number (not infinite, not NAN)`
              );
          }
        };
      },
      16819: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.updateAxisIds = void 0),
          (t.updateAxisIds = function (e) {
            var t, r;
            e.parentSurface &&
              (e.xAxisId ||
                (e.xAxisId =
                  null === (t = e.parentSurface.getDefaultXAxis()) ||
                  void 0 === t
                    ? void 0
                    : t.id),
              e.yAxisId ||
                (e.yAxisId =
                  null === (r = e.parentSurface.getDefaultYAxis()) ||
                  void 0 === r
                    ? void 0
                    : r.id));
          });
      },
      77354: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.IncludedItems = void 0),
          (t.IncludedItems = class {
            constructor() {
              (this.itemIdsSet = new Set()), (this.isInclusionSet = !1);
            }
            include(e) {
              return (
                0 === this.itemIdsSet.size && (this.isInclusionSet = !0),
                this.isInclusionSet
                  ? !this.itemIdsSet.has(e) && (this.itemIdsSet.add(e), !0)
                  : !!this.itemIdsSet.has(e) && (this.itemIdsSet.delete(e), !0)
              );
            }
            includeList(e) {
              let t = !1;
              return (
                e.forEach((e) => {
                  !0 === this.include(e) && (t = !0);
                }),
                t
              );
            }
            exclude(e) {
              return (
                0 === this.itemIdsSet.size && (this.isInclusionSet = !1),
                this.isInclusionSet
                  ? !!this.itemIdsSet.has(e) && (this.itemIdsSet.delete(e), !0)
                  : !this.itemIdsSet.has(e) && (this.itemIdsSet.add(e), !0)
              );
            }
            excludeList(e) {
              let t = !1;
              return (
                e.forEach((e) => {
                  !0 === this.exclude(e) && (t = !0);
                }),
                t
              );
            }
            testIsIncluded(e) {
              return this.isInclusionSet
                ? this.itemIdsSet.has(e)
                : !this.itemIdsSet.has(e);
            }
            getIncludedItems(e) {
              return this.isInclusionSet
                ? e.filter((e) => this.itemIdsSet.has(e.id))
                : e.filter((e) => !this.itemIdsSet.has(e.id));
            }
            getIncludedItemIds() {
              return this.isInclusionSet ? Array.from(this.itemIdsSet) : [];
            }
            getExcludedItemIds() {
              return this.isInclusionSet ? [] : Array.from(this.itemIdsSet);
            }
            includeAll() {
              this.itemIdsSet.clear(), (this.isInclusionSet = !1);
            }
            excludeAll() {
              this.itemIdsSet.clear(), (this.isInclusionSet = !0);
            }
            reconcile(e) {
              const t = new Set();
              e.forEach((e) => t.add(e.id));
              const r = [];
              this.itemIdsSet.forEach((e) => {
                t.has(e) || r.push(e);
              }),
                r.forEach((e) => this.itemIdsSet.delete(e));
            }
            getItemIdsSetSize() {
              return this.itemIdsSet.size;
            }
          });
      },
      98869: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.List = void 0),
          (t.List = class {
            constructor() {
              this.items = [];
            }
            size() {
              return this.items.length;
            }
            add(e) {
              this.items.push(e);
            }
            get(e) {
              return this.items[e];
            }
          });
      },
      85258: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MouseManager = void 0);
        const i = r(39299),
          o = r(19145),
          a = r(45215),
          s = r(16602),
          n = r(23866);
        var l;
        !(function (e) {
          (e[(e.Move = 0)] = "Move"),
            (e[(e.Down = 1)] = "Down"),
            (e[(e.Up = 2)] = "Up"),
            (e[(e.Wheel = 3)] = "Wheel"),
            (e[(e.Click = 4)] = "Click"),
            (e[(e.Leave = 5)] = "Leave"),
            (e[(e.Enter = 6)] = "Enter"),
            (e[(e.Cancel = 7)] = "Cancel"),
            (e[(e.Drop = 8)] = "Drop");
        })(l || (l = {}));
        const d = [
          o.ESurfaceType.SciChartSurfaceType,
          o.ESurfaceType.SciChartPolarSurfaceType,
        ];
        t.MouseManager = class {
          constructor(e) {
            (this.isOver = !1),
              (this.maxTapDuration = 500),
              (this.enableDoubleTapPolyfill = !0),
              (this.forceDoubleTapPolyfill = !1),
              (this.sciChartSurface = e),
              (this.onPointerMove = this.onPointerMove.bind(this)),
              (this.onPointerDown = this.onPointerDown.bind(this)),
              (this.onPointerUp = this.onPointerUp.bind(this)),
              (this.onMouseWheel = this.onMouseWheel.bind(this)),
              (this.onDoubleClick = this.onDoubleClick.bind(this)),
              (this.onMouseLeave = this.onMouseLeave.bind(this)),
              (this.onMouseEnter = this.onMouseEnter.bind(this)),
              (this.onContextMenu = this.onContextMenu.bind(this)),
              (this.onPointerCancel = this.onPointerCancel.bind(this)),
              (this.onDrop = this.onDrop.bind(this));
          }
          subscribe(e) {
            n.Guard.notNull(e, "source"),
              this.unsubscribe(),
              (this.canvas = e),
              e.addEventListener("pointermove", this.onPointerMove),
              e.addEventListener("pointerdown", this.onPointerDown),
              e.addEventListener("pointerup", this.onPointerUp),
              e.addEventListener("pointercancel", this.onPointerCancel),
              e.addEventListener("wheel", this.onMouseWheel),
              e.addEventListener("dblclick", this.onDoubleClick),
              e.addEventListener("mouseleave", this.onMouseLeave),
              e.addEventListener("mouseenter", this.onMouseEnter),
              e.addEventListener("contextmenu", this.onContextMenu),
              e.addEventListener("drop", this.onDrop);
          }
          unsubscribe() {
            this.canvas &&
              (this.canvas.removeEventListener(
                "pointermove",
                this.onPointerMove
              ),
              this.canvas.removeEventListener(
                "pointerdown",
                this.onPointerDown
              ),
              this.canvas.removeEventListener("pointerup", this.onPointerUp),
              this.canvas.removeEventListener(
                "pointercancel",
                this.onPointerCancel
              ),
              this.canvas.removeEventListener("wheel", this.onMouseWheel),
              this.canvas.removeEventListener("dblclick", this.onDoubleClick),
              this.canvas.removeEventListener("mouseleave", this.onMouseLeave),
              this.canvas.removeEventListener("mouseenter", this.onMouseEnter),
              this.canvas.removeEventListener(
                "contextmenu",
                this.onContextMenu
              ),
              this.canvas.removeEventListener("drop", this.onDrop)),
              (this.canvas = null);
          }
          onPointerCancel(e) {
            const t = i.ModifierMouseArgs.fromPointerEvent(e);
            this.modifierPointerCancel(t);
          }
          onPointerMove(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.PointerMoveStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromPointerEvent(e);
            this.modifierMouseMove(o),
              s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.PointerMoveEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          onPointerDown(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.PointerDownStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromPointerEvent(e);
            this.modifierMouseDown(o);
            const a =
                this.forceDoubleTapPolyfill ||
                (this.enableDoubleTapPolyfill && !this.supportsDoubleTap),
              n = "touch" === e.pointerType || "pen" === e.pointerType;
            if (a && n) {
              const t = new Date().getTime(),
                r = !!this.lastTapTime,
                o = t - this.lastTapTime < this.maxTapDuration,
                a = e.isPrimary;
              if (r && a && o) {
                (this.lastTapTime = void 0), (this.doubleTapHandled = !0);
                const t = i.ModifierMouseArgs.fromPointerEvent(e);
                this.modifierDoubleClick(t);
              } else (this.lastTapTime = t), (this.doubleTapHandled = !1);
            } else this.doubleTapHandled = !1;
            s.PerformanceDebugHelper.mark(
              s.EPerformanceMarkType.PointerDownEnd,
              {
                contextId: this.sciChartSurface.id,
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                level: s.EPerformanceDebugLevel.Verbose,
              }
            );
          }
          onPointerUp(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.PointerUpStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromPointerEvent(e);
            this.modifierMouseUp(o),
              s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.PointerUpEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          onDoubleClick(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
              s.EPerformanceMarkType.DoubleClickStart,
              {
                contextId: this.sciChartSurface.id,
                level: s.EPerformanceDebugLevel.Verbose,
              }
            );
            if (this.doubleTapHandled)
              return void (this.supportsDoubleTap = !0);
            const o = i.ModifierMouseArgs.fromMouseEvent(e);
            this.modifierDoubleClick(o),
              s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.DoubleClickEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          onMouseWheel(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.ScrollStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromWheelEvent(e);
            this.modifierMouseWheel(o),
              o.handled && e.preventDefault(),
              s.PerformanceDebugHelper.mark(s.EPerformanceMarkType.ScrollEnd, {
                contextId: this.sciChartSurface.id,
                relatedId:
                  null === (t = null == r ? void 0 : r.detail) || void 0 === t
                    ? void 0
                    : t.relatedId,
                level: s.EPerformanceDebugLevel.Verbose,
              });
          }
          onMouseLeave(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.MouseLeaveStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromMouseEvent(e);
            this.modifierMouseLeave(o),
              s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.MouseLeaveEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          onMouseEnter(e) {
            var t;
            const r = s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.MouseEnterStart,
                {
                  contextId: this.sciChartSurface.id,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              ),
              o = i.ModifierMouseArgs.fromMouseEvent(e);
            this.modifierMouseEnter(o),
              s.PerformanceDebugHelper.mark(
                s.EPerformanceMarkType.MouseEnterEnd,
                {
                  contextId: this.sciChartSurface.id,
                  relatedId:
                    null === (t = null == r ? void 0 : r.detail) || void 0 === t
                      ? void 0
                      : t.relatedId,
                  level: s.EPerformanceDebugLevel.Verbose,
                }
              );
          }
          onContextMenu(e) {
            e.preventDefault();
          }
          onDrop(e) {
            const t = i.ModifierMouseArgs.fromMouseEvent(e);
            this.modifierDrop(t);
          }
          modifierPointerCancel(e) {
            if (
              (e.isMaster && e.target.releasePointerCapture(e.pointerId),
              this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierPointerCancel(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierPointerCancel(a);
                });
              }),
                this.updateSubCharts(e, l.Cancel);
            }
          }
          modifierMouseMove(e) {
            if (d.includes(this.sciChartSurface.surfaceType)) {
              const t = this.sciChartSurface;
              if (t.adornerLayer.isAnnotationSelected) {
                const r = t.adornerLayer.selectedAnnotation;
                r.isDraggingStarted && r.onDragAdorner(e);
              }
            }
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierMouseMove(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierMouseMove(a);
                });
              }),
                this.updateSubCharts(e, l.Move);
            }
          }
          modifierMouseDown(e) {
            var t;
            e.isMaster &&
              (null === (t = e.target) ||
                void 0 === t ||
                t.setPointerCapture(e.pointerId));
            const r = () => {
              if (
                (this.chartModifiers.forEach((t) => {
                  !t.canReceiveMouseEvents ||
                    (e.handled && !t.receiveHandledEvents) ||
                    ((e.isMaster ||
                      (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                      t.modifierMouseDown(e, this.sciChartSurface));
                }),
                e.isMaster)
              ) {
                const t = this.getMasterData(this.sciChartSurface, e);
                this.chartModifierGroups.forEach((r) => {
                  this.sciChartSurface.otherSurfaces.forEach((o) => {
                    const a = i.ModifierMouseArgs.copy(
                      e,
                      r,
                      this.sciChartSurface.seriesViewRect,
                      o.seriesViewRect,
                      t
                    );
                    o.mouseManager.modifierMouseDown(a);
                  });
                }),
                  this.updateSubCharts(e, l.Down);
              }
            };
            if (e.isMaster) {
              const t = (t) => {
                t.adornerLayer.selectAnnotation(e);
                const i = t.adornerLayer.selectedAnnotation;
                i ? i.onDragStarted(e) && this.modifierMouseMove(e) : r();
              };
              if (d.includes(this.sciChartSurface.surfaceType)) {
                const r = this.sciChartSurface,
                  i = r.adornerLayer.selectedAnnotation;
                (i &&
                  i.checkIsPointWithinClipArea(e.mousePoint) &&
                  i.onDragStarted(e)) ||
                  t(r);
              } else r();
            } else r();
          }
          modifierMouseUp(e) {
            var t;
            if (
              (e.isMaster &&
                (null === (t = e.target) ||
                  void 0 === t ||
                  t.releasePointerCapture(e.pointerId)),
              d.includes(this.sciChartSurface.surfaceType))
            ) {
              const e = this.sciChartSurface;
              if (e.adornerLayer.isAnnotationSelected) {
                const t = e.adornerLayer.selectedAnnotation;
                t.isDraggingStarted && t.onDragEnded();
              }
            }
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierMouseUp(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierMouseUp(a);
                });
              }),
                this.updateSubCharts(e, l.Up);
            }
          }
          modifierMouseWheel(e) {
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierMouseWheel(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierMouseWheel(a);
                });
              }),
                this.updateSubCharts(e, l.Wheel);
            }
          }
          modifierDoubleClick(e) {
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierDoubleClick(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierDoubleClick(a);
                });
              }),
                this.updateSubCharts(e, l.Click);
            }
          }
          modifierMouseLeave(e) {
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierMouseLeave(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierMouseLeave(a);
                });
              }),
                this.updateSubCharts(e, l.Leave);
            }
          }
          modifierMouseEnter(e) {
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierMouseEnter(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierMouseEnter(a);
                });
              }),
                this.updateSubCharts(e, l.Enter);
            }
          }
          modifierDrop(e) {
            if (
              (this.chartModifiers.forEach((t) => {
                !t.canReceiveMouseEvents ||
                  (e.handled && !t.receiveHandledEvents) ||
                  ((e.isMaster ||
                    (!e.isMaster && t.modifierGroup === e.modifierGroup)) &&
                    t.modifierDrop(e, this.sciChartSurface));
              }),
              e.isMaster)
            ) {
              const t = this.getMasterData(this.sciChartSurface, e);
              this.chartModifierGroups.forEach((r) => {
                this.sciChartSurface.otherSurfaces.forEach((o) => {
                  const a = i.ModifierMouseArgs.copy(
                    e,
                    r,
                    this.sciChartSurface.seriesViewRect,
                    o.seriesViewRect,
                    t
                  );
                  o.mouseManager.modifierDrop(a);
                });
              }),
                this.updateSubCharts(e, l.Drop);
            }
          }
          getMasterData(e, t) {
            return {};
          }
          get chartModifiers() {
            return this.sciChartSurface.chartModifiers.asArray();
          }
          get chartModifierGroups() {
            const e = this.chartModifiers
              .filter((e) => void 0 !== e.modifierGroup)
              .map((e) => e.modifierGroup);
            return (0, a.getUniqueValues)(e);
          }
          updateSubCharts(e, t) {
            const r = this.sciChartSurface.subCharts;
            if (!r || 0 === r.length) return;
            const o =
              null == r
                ? void 0
                : r.find((t) => {
                    if (!t.offset) return !1;
                    const { top: r, left: i, bottom: o, right: a } = t.offset,
                      { x: s, y: n } = e.mousePoint,
                      { width: l, height: d } =
                        this.sciChartSurface.renderSurface.viewportSize;
                    return i <= s && s <= l - a && r <= n && n <= d - o;
                  });
            let a = !1;
            null == r ||
              r.forEach((s) => {
                if (!s.offset) return;
                let n = t,
                  d = !0;
                if (s.mouseManager.isOver) {
                  if (s !== o) {
                    if (((s.mouseManager.isOver = !1), n === l.Move)) {
                      const t = new i.ModifierMouseArgs(e.mousePoint, e);
                      a =
                        a ||
                        this.processSubChartEvent(l.Leave, s, t, r, void 0);
                    }
                    n !== l.Cancel && n !== l.Up && (n = void 0);
                  }
                } else if (s === o) {
                  if (((s.mouseManager.isOver = !0), n === l.Move)) {
                    const t = new i.ModifierMouseArgs(e.mousePoint, e);
                    a =
                      a || this.processSubChartEvent(l.Enter, s, t, r, void 0);
                  }
                } else
                  [l.Cancel, l.Up, l.Move].includes(n) || (n = void 0),
                    (d = !1);
                if (void 0 !== n) {
                  const t = this.getMasterData(o, e);
                  a =
                    a ||
                    this.processSubChartEvent(
                      n,
                      s,
                      Object.assign(Object.assign({}, e), {
                        isActiveSubChartEvent: d,
                      }),
                      r,
                      t
                    );
                }
              }),
              (e.handled = e.handled || a);
          }
          processSubChartEvent(e, t, r, o, a) {
            (r.handled = !1), this.callEvent(e, t, r);
            let s = r.handled;
            return (
              r.isActiveSubChartEvent &&
                t.chartModifierGroups.forEach((n) => {
                  o.filter((e) => e.id !== t.id).forEach((o) => {
                    const l = i.ModifierMouseArgs.copyForSubChart(
                      r,
                      n,
                      t.seriesViewRect,
                      o.seriesViewRect,
                      a
                    );
                    this.callEvent(e, o, l), (s = s || l.handled);
                  });
                }),
              s
            );
          }
          callEvent(e, t, r) {
            switch (e) {
              case l.Cancel:
                t.mouseManager.modifierPointerCancel(r);
                break;
              case l.Click:
                t.mouseManager.modifierDoubleClick(r);
                break;
              case l.Down:
                t.mouseManager.modifierMouseDown(r);
                break;
              case l.Enter:
                t.mouseManager.modifierMouseEnter(r);
                break;
              case l.Leave:
                t.mouseManager.modifierMouseLeave(r);
                break;
              case l.Move:
                t.mouseManager.modifierMouseMove(r);
                break;
              case l.Up:
                t.mouseManager.modifierMouseUp(r);
                break;
              case l.Wheel:
                t.mouseManager.modifierMouseWheel(r);
                break;
              case l.Drop:
                t.mouseManager.modifierDrop(r);
            }
          }
        };
      },
      98140: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumberRange = void 0);
        const i = r(72934),
          o = r(67492);
        class a {
          constructor(e = 0, t = 10) {
            (this.min = e), (this.max = t);
          }
          union(e) {
            const t = Math.min(this.min, e.min),
              r = Math.max(this.max, e.max);
            return new a(t, r);
          }
          clip(e) {
            const t = Math.max(this.min, e.min),
              r = Math.min(this.max, e.max);
            return new a(t, r);
          }
          growBy(e) {
            const t = this.max - this.min;
            let r = this.min - e.min * (this.isZero() ? this.min : t),
              i = this.max + e.max * (this.isZero() ? this.max : t);
            if (r > i) {
              const e = r;
              (r = i), (i = e);
            }
            return new a(r, i);
          }
          growByLog(e, t) {
            const r = this.min < 0 ? -1 : 1,
              i = 0 !== this.min ? (0, o.logToBase)(Math.abs(this.min), t) : 0,
              s = 0 !== this.max ? (0, o.logToBase)(Math.abs(this.max), t) : 0,
              n = s - i,
              l = n * e.min,
              d = n * e.max;
            let h = r * (0 !== this.min ? Math.pow(t, i - l) : 0),
              u = r * (0 !== this.max ? Math.pow(t, s + d) : 0);
            if (h > u) {
              const e = u;
              (u = h), (h = e);
            }
            return new a(h, u);
          }
          isDefined() {
            return (
              (0, i.isRealNumber)(this.max) && (0, i.isRealNumber)(this.min)
            );
          }
          equals(e) {
            return !!e && e.min === this.min && e.max === this.max;
          }
          toString() {
            return `NumberRange (${this.min}, ${this.max})`;
          }
          get diff() {
            return this.max - this.min;
          }
          isZero() {
            return this.min === this.max;
          }
          static areEqual(e, t) {
            return (
              e === t ||
              (!((e && !t) || (!e && t)) && t.min === e.min && t.max === e.max)
            );
          }
          static hydrate(e) {
            return e && !("growBy" in e) ? new a(e.min, e.max) : e;
          }
        }
        t.NumberRange = a;
      },
      64645: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumberUtil = void 0),
          (t.NumberUtil = class {
            static constrain(e, t, r) {
              return Math.max(Math.min(e, r), t);
            }
          });
      },
      37796: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ObservableArray = t.ObservableArrayBase = void 0);
        const i = r(3214),
          o = r(71664);
        class a {
          constructor() {
            (this.items = []), (this.collectionChanged = new i.EventHandler());
          }
          size() {
            return this.items.length;
          }
          add(...e) {
            e.forEach((e) => this.items.push(e)),
              this.collectionChanged.raiseEvent(
                new o.ObservableArrayChangedArgs(
                  o.EObservableArrayChangedAction.Add,
                  e,
                  void 0
                )
              );
          }
          asArray() {
            return this.items;
          }
          insert(e, t) {
            e < 0 && (e = 0),
              e >= this.items.length
                ? this.add(t)
                : (this.items.splice(e, 0, t),
                  this.collectionChanged.raiseEvent(
                    new o.ObservableArrayChangedArgs(
                      o.EObservableArrayChangedAction.Add,
                      [t],
                      void 0
                    )
                  ));
          }
          contains(e) {
            return this.items.includes(e);
          }
          removeAt(e, t = !1) {
            if (e < 0 || e >= this.items.length) return;
            const r = this.items[e];
            this.items.splice(e, 1),
              this.collectionChanged.raiseEvent(
                new o.ObservableArrayChangedArgs(
                  o.EObservableArrayChangedAction.Remove,
                  void 0,
                  [r]
                )
              ),
              t && (null == r ? void 0 : r.delete) && r.delete();
          }
          remove(e, t = !1) {
            for (let r = 0; r < this.size(); r++)
              if (this.items[r] === e) {
                this.removeAt(r, t);
                break;
              }
          }
          clear(e = !1) {
            const t = this.items;
            (this.items = []),
              this.collectionChanged.raiseEvent(
                new o.ObservableArrayChangedArgs(
                  o.EObservableArrayChangedAction.Reset,
                  void 0,
                  t
                )
              ),
              e &&
                (null == t ||
                  t.forEach((e) => {
                    (null == e ? void 0 : e.delete) && e.delete();
                  }));
          }
          get(e) {
            return this.items[e];
          }
          set(e, t) {
            (this.items[e] = t),
              this.collectionChanged.raiseEvent(
                new o.ObservableArrayChangedArgs(
                  o.EObservableArrayChangedAction.Replace,
                  [t],
                  void 0
                )
              );
          }
        }
        (t.ObservableArrayBase = a),
          (t.ObservableArray = class extends a {
            getById(e) {
              return this.items.find((t) => t.id === e);
            }
            checkIdUniqueness(e) {
              return this.items.filter((t) => t.id === e).length <= 1;
            }
          });
      },
      71664: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ObservableArrayChangedArgs = t.EObservableArrayChangedAction =
            void 0),
          ((r =
            t.EObservableArrayChangedAction ||
            (t.EObservableArrayChangedAction = {}))[(r.Add = 0)] = "Add"),
          (r[(r.Remove = 1)] = "Remove"),
          (r[(r.Replace = 2)] = "Replace"),
          (r[(r.Reset = 3)] = "Reset"),
          (t.ObservableArrayChangedArgs = class {
            constructor(e, t, r) {
              (this.action = e), (this.oldItems = r), (this.newItems = t);
            }
            getAction() {
              return this.action;
            }
            getNewItems() {
              return this.newItems;
            }
            getOldItems() {
              return this.oldItems;
            }
          });
      },
      40593: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VisibilityObserver = void 0);
        class r {
          constructor(e, t) {
            (this.callback = t), (this.element = e);
          }
          static observe(e, t) {
            const i = new r(e, t);
            return i.init(), i;
          }
          disconnect() {
            this.observer.disconnect();
          }
          init() {
            (this.observer = new IntersectionObserver(
              (e) => {
                for (const t of e) this.callback(t.isIntersecting);
              },
              { root: null, threshold: 0.01 }
            )),
              this.observer.observe(this.element);
          }
        }
        t.VisibilityObserver = r;
      },
      63508: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OneTimePerformanceWarning = void 0);
        const i = r(2056),
          o = r(85479);
        t.OneTimePerformanceWarning = class {
          constructor(e) {
            (this.warnedProperty = !1), (this.messageProperty = e);
          }
          warn() {
            return !(
              !o.SciChartDefaults.performanceWarnings ||
              this.warnedProperty ||
              !i.licenseManager2dState.getIsDev() ||
              (console.warn(this.messageProperty),
              (this.warnedProperty = !0),
              0)
            );
          }
        };
      },
      75772: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Point = void 0),
          (t.Point = class {
            constructor(e, t) {
              (this.x = e), (this.y = t);
            }
          });
      },
      50605: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PropertyChangedEventArgs = void 0),
          (t.PropertyChangedEventArgs = class {
            constructor(e) {
              this.propertyName = e;
            }
          });
      },
      87459: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Rect = void 0);
        const i = r(75772);
        class o {
          constructor(e, t, r, i) {
            if (r < 0 || i < 0)
              throw new Error("Can not create Rect with negative width/height");
            (this.x = e), (this.y = t), (this.width = r), (this.height = i);
          }
          static create(e, t, r, i) {
            if (r < 0 || i < 0)
              throw new Error(
                "Rect.create width and height cannot be less than zero"
              );
            return new o(e, t, r, i);
          }
          static createWithCoords(e, t, r, i) {
            return new o(e, t, r - e, i - t);
          }
          static createWithPoints(e, t) {
            const r = Math.min(e.x, t.x),
              i = Math.min(e.y, t.y),
              a = Math.max(Math.max(e.x, t.x) - r, 0),
              s = Math.max(Math.max(e.y, t.y) - i, 0);
            return o.create(r, i, a, s);
          }
          static createCopy(e) {
            return new o(e.x, e.y, e.width, e.height);
          }
          static createZero() {
            return new o(0, 0, 0, 0);
          }
          static isEqual(e, t) {
            return (
              e.x === t.x &&
              e.y === t.y &&
              e.width === t.width &&
              e.height === t.height
            );
          }
          static clipPointToRect(e, t) {
            const r =
                e.x < t.x ? t.x : e.x > t.x + t.width ? t.x + t.width : e.x,
              o = e.y < t.y ? t.y : e.y > t.y + t.height ? t.y + t.height : e.y;
            return new i.Point(r, o);
          }
          static intersect(e, t) {
            const r = Math.max(e.left, t.left),
              i = Math.max(e.top, t.top),
              a = Math.min(e.right, t.right),
              s = Math.min(e.bottom, t.bottom);
            return r > a || i > s
              ? o.createZero()
              : o.createWithCoords(r, i, a, s);
          }
          get left() {
            return this.x;
          }
          get top() {
            return this.y;
          }
          get right() {
            return this.x + this.width;
          }
          get bottom() {
            return this.y + this.height;
          }
          static hydrate(e) {
            if (e) {
              const { x: t, y: r, width: i, height: a } = e;
              return new o(t, r, i, a);
            }
          }
        }
        t.Rect = o;
      },
      33519: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sendTelemetry = t.shouldSendTelemetry = t.getUserCookie = void 0);
        const i = r(2056),
          o = r(41670),
          a = r(34238),
          s = r(84745),
          n = r(73538),
          l = r(48125);
        let d = !1;
        (t.getUserCookie = () => {
          const e = (0, o.getCookie)("scUser");
          if (e) {
            const t = e.split(",");
            if (3 === t.length)
              return {
                userId: t[0],
                sessionId: t[1],
                sessionStart: Number.parseInt(t[2], 10),
              };
          }
          return {
            userId: (0, n.base64Id)(),
            sessionId: (0, n.base64Id)(),
            sessionStart: 0,
          };
        }),
          (t.shouldSendTelemetry = () =>
            !(
              s.IS_TEST_ENV ||
              d ||
              (i.licenseManager2dState.getLicenseType() !==
                l.LicenseType.Community &&
                !i.licenseManager2dState.getIsDev()) ||
              !i.licenseManager2dState.getTelemetry() ||
              (window && !window.navigator.onLine)
            )),
          (t.sendTelemetry = () => {
            if (!(0, t.shouldSendTelemetry)()) return;
            const e = (0, t.getUserCookie)(),
              r = new Date().toISOString();
            if (Date.now() - e.sessionStart < 36e5) return;
            (e.sessionId = (0, n.base64Id)()),
              (e.sessionStart = Date.now()),
              ((e, t, r) => {
                const i = `${e},${t},${r}`;
                (0, o.setCookie)("scUser", i, 365);
              })(e.userId, e.sessionId, e.sessionStart);
            const s = {
              time: r,
              iKey: "210b4d64-8147-471e-b6cb-244a2c939455",
              name: "Microsoft.ApplicationInsights.210b4d648147471eb6cb244a2c939455.Event",
              tags: {
                "ai.user.id": e.userId,
                "ai.session.id": e.sessionId,
                "ai.device.id": "browser",
                "ai.device.type": "Browser",
              },
              data: {
                baseType: "EventData",
                baseData: {
                  ver: 2,
                  name: "LicenseSet",
                  properties: {
                    platform: "JS",
                    licenseType: i.licenseManager2dState.getLicenseType(),
                    orderId: i.licenseManager2dState.getOrderId(),
                    productCode: i.licenseManager2dState.getProductCode(),
                    isDev: i.licenseManager2dState.getIsDev(),
                    devCount: i.licenseManager2dState.getDevCount(),
                    sciChartVersion: a.libraryVersion,
                  },
                  measurements: {},
                },
              },
            };
            i.licenseManager2dState.getLicenseType() ===
              l.LicenseType.Community &&
              (s.data.baseData.properties.url = window.location.href);
            const h = JSON.stringify([s]);
            fetch("https://dc.services.visualstudio.com/v2/track", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: h,
            }).catch((e) => {}),
              (d = !0);
          });
      },
      87108: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Thickness = void 0);
        const i = r(23866);
        class o {
          constructor(e, t, r, i) {
            (this.top = e),
              (this.right = t),
              (this.bottom = r),
              (this.left = i);
          }
          static fromString(e) {
            i.Guard.notNull(e, "str");
            const t = e.split(" ").map((e) => parseFloat(e));
            if (4 !== t.length)
              throw new Error(
                "Expected string in the format '1 2 3 4' where values are top, right bottom and left"
              );
            return new o(t[0], t[1], t[2], t[3]);
          }
          static fromNumber(e) {
            return new o(e, e, e, e);
          }
          static areEqual(e, t) {
            return (
              !(!e || !t) &&
              e.top === t.top &&
              e.right === t.right &&
              e.bottom === t.bottom &&
              e.left === t.left
            );
          }
          static mergeMax(e, t) {
            const r = new o(0, 0, 0, 0);
            return (
              (r.top = Math.max(e.top, t.top)),
              (r.left = Math.max(e.left, t.left)),
              (r.bottom = Math.max(e.bottom, t.bottom)),
              (r.right = Math.max(e.right, t.right)),
              r
            );
          }
          static mergeAdd(e, t) {
            return new o(
              e.top + t.top,
              e.right + t.right,
              e.bottom + t.bottom,
              e.left + t.left
            );
          }
          static mergeSubtract(e, t) {
            return new o(
              e.top - t.top,
              e.right - t.right,
              e.bottom - t.bottom,
              e.left - t.left
            );
          }
        }
        t.Thickness = o;
      },
      62049: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebGlHelper = t.EWebGLSupport = void 0);
        const i = r(84745);
        var o;
        !(function (e) {
          (e.WebGL2 = "WebGL 2"),
            (e.WebGL1 = "WebGL 1"),
            (e.NoWebGL = "No WebGL support");
        })((o = t.EWebGLSupport || (t.EWebGLSupport = {})));
        class a {
          static initialize() {
            if (!a.initialized) {
              if (!a.webGlSupport && !i.IS_TEST_ENV) {
                const e = document.createElement("canvas");
                e.getContext("webgl2", { powerPreference: "high-performance" })
                  ? (a.webGlSupport = o.WebGL2)
                  : e.getContext("webgl")
                  ? (a.webGlSupport = o.WebGL1)
                  : (a.webGlSupport = o.NoWebGL);
              }
              a.initialized = !0;
            }
          }
          static getWebGlSupport() {
            return a.webGlSupport;
          }
          static getContext(e, t) {
            if (e && !i.IS_TEST_ENV) {
              if (a.webGlSupport === o.WebGL1)
                return e.getContext("webgl", Object.assign({}, t));
              if (a.webGlSupport === o.WebGL2)
                return e.getContext(
                  "webgl2",
                  Object.assign(Object.assign({}, t), {
                    powerPreference: "high-performance",
                  })
                );
              throw new Error("SciChart: WebGL not supported!");
            }
          }
        }
        (t.WebGlHelper = a), (a.webGlSupport = void 0), (a.initialized = !1);
      },
      31601: (e, t) => {
        "use strict";
        let r;
        function i() {
          if (void 0 !== r) return r;
          try {
            var e = window.localStorage,
              t = "__storage_test__";
            return e.setItem(t, t), e.removeItem(t), (r = !0), !0;
          } catch (e) {
            return (r = !1), !1;
          }
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.localStorageApi = void 0),
          (t.localStorageApi = {
            storageAvailable: i,
            getIsLicenseDebug: function () {
              if (i()) return "1" === localStorage.getItem("LICENSE_DEBUG");
            },
            setIsLicenseDebug: function (e) {
              i() && localStorage.setItem("LICENSE_DEBUG", e ? "1" : "0");
            },
            clearLicensingDebug: function () {
              i() && localStorage.removeItem("LICENSE_DEBUG");
            },
            getLicenseWizardMaxPort: function () {
              if (!i()) return;
              const e = localStorage.getItem("LICENSE_WIZARD_MAXPORT"),
                t = Number(e);
              return isNaN(t) ? void 0 : t;
            },
            getLicenseWizardPort: function () {
              if (!i()) return;
              const e = localStorage.getItem("LICENSE_WIZARD_PORT"),
                t = Number(e);
              return isNaN(t) ? void 0 : t;
            },
          });
      },
      84745: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPSILON =
            t.DEFAULT_HEIGHT =
            t.DEFAULT_WIDTH =
            t.IS_TEST_ENV =
              void 0);
        let i = !1;
        (t.IS_TEST_ENV = i),
          "undefined" != typeof process &&
            (t.IS_TEST_ENV = i =
              "1" ===
              (null === (r = process.env) || void 0 === r
                ? void 0
                : r.TEST_ENV)),
          (t.DEFAULT_WIDTH = 900),
          (t.DEFAULT_HEIGHT = 600),
          (t.EPSILON = 1e-4);
      },
      41493: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.performanceWarnings = void 0);
        const i = r(63508);
        t.performanceWarnings = {
          dataDistributionFlagNaN: new i.OneTimePerformanceWarning(
            "Data Distribution flag (BaseDataSeries.containsNaN = false) can be applied to improve performance. Read this website article https://www.scichart.com/documentation/js/current/DataSeries_Resampling.html for more info. To disable this warning set SciChartDefaults.performanceWarnings = false"
          ),
          dataDistributionFlagSortedAscending: new i.OneTimePerformanceWarning(
            "Data Distribution flag (BaseDataSeries.isSorted = true) can be applied to improve performance. Read this website article https://www.scichart.com/documentation/js/current/DataSeries_Resampling.html for more info. To disable this warning set SciChartDefaults.performanceWarnings = false"
          ),
          subchartBackgroundNotSimpleColor: new i.OneTimePerformanceWarning(
            "When using isTransparent: false on a SubChart, the background needs to be a simple color, not an html gradient (which the default theme uses). To disable this warning set SciChartDefaults.performanceWarnings = false"
          ),
          dataLabelsSkippingMany: new i.OneTimePerformanceWarning(
            "DataLabelProvider generated many more labels than it could display.  To improve performance consider increasing the pointGapThreshold, increasing the skipNumber, or decreasing the pointCountThreshold. To disable this warning set SciChartDefaults.performanceWarnings = false"
          ),
          dateTimeDeltaCalculatorBadDelta: new i.OneTimePerformanceWarning(
            "The DateTimeDeltaCalculator could not find a suitable delta given the current settings. \n        Either increase axis.maxAutoTicks, set axis.deltaCalculator.minTicks less than maxAutoTicks / 3, or set possibleDeltas to an array containing more closely spaced values.\n        To disable this warning set SciChartDefaults.performanceWarnings = false"
          ),
        };
      },
      49742: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RolloverModifier =
            t.PointerEventsMediatorModifier =
            t.PinchZoomModifier =
            t.OverviewRangeSelectionModifier =
            t.MouseWheelZoomModifier =
            t.EActionType =
            t.ModifierMouseArgs =
            t.ModifierArgsBase =
            t.LegendModifier =
            t.DataPointSelectionModifier =
            t.ESelectionMode =
            t.DataPointSelectionChangedArgs =
            t.DataPointInfo =
            t.CustomChartModifier2D =
            t.adjustTooltipPosition =
            t.calcTooltipSize =
            t.defaultCursorTooltipSvgTemplate =
            t.CursorModifier =
            t.getActiveAxes =
            t.testIsOverAxes =
            t.ChartModifierBase2D =
            t.ChartModifierBase =
            t.AnnotationHoverModifier =
            t.getSubTypes =
            t.createType =
            t.getFunction =
            t.registerFunction =
            t.registerWasmType =
            t.registerType =
            t.chartBuilder =
            t.ensureRegistrations =
            t.configureChart =
            t.buildChart =
            t.chartReviver =
            t.configure3DSurface =
            t.configure2DSurface =
            t.buildSubCharts =
            t.build3DChart =
            t.buildPieChart =
            t.build2DPolarChart =
            t.build2DChart =
            t.buildSeries3D =
            t.buildSeries =
            t.buildModifiers3D =
            t.buildModifiers =
            t.buildDataSeries3D =
            t.buildDataSeries =
            t.buildAxis3D =
            t.buildAxes =
            t.buildAnnotations =
              void 0),
          (t.ChartLayoutState =
            t.CentralAxesLayoutManager =
            t.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy =
            t.BottomAlignedOuterAxisLayoutStrategy =
            t.BottomAlignedInnerAxisLayoutStrategy =
            t.BaseCenteredAxisLayoutStrategy =
            t.BaseAxisLayoutStrategy =
            t.testLayoutManager =
            t.getCoordinateWithCoordinateMode =
            t.getValueWithCoordinateMode =
            t.updateTopAndBottomChartLayoutState =
            t.updateLeftAndRightChartLayoutState =
            t.getVerticalAxisRequiredSize =
            t.getHorizontalAxisRequiredSize =
            t.layoutAxisPartsBottomStrategy =
            t.layoutAxisPartsTopStrategy =
            t.layoutAxisPartsRightStrategy =
            t.layoutAxisPartsLeftStrategy =
            t.layoutAxisParts =
            t.updateAxisLayoutState =
            t.WebGlRenderContext2D =
            t.ELineDrawMode =
            t.calculateAbsoluteRenderLayer =
            t.WebGlPen =
            t.WebGlBrush =
            t.RenderContext2D =
            t.createPenInCache =
            t.getScrtPenFromCache =
            t.getWebGlPenFromCache =
            t.createBrushInCache =
            t.getScrtBrushFromCache =
            t.getWebGlBrushFromCache =
            t.BatchRenderContext =
            t.PolarZoomExtentsModifier =
            t.PolarPanModifier =
            t.EPolarPanModifierPanMode =
            t.PolarMouseWheelZoomModifier =
            t.PolarLegendModifier =
            t.PolarDataPointSelectionModifier =
            t.PolarCursorModifier =
            t.PolarArcZoomModifier =
            t.ZoomPanModifier =
            t.ZoomExtentsModifier =
            t.YAxisDragModifier =
            t.XAxisDragModifier =
            t.VerticalSliceModifier =
            t.SeriesSelectionModifier =
            t.getRubberBandRect =
            t.RubberBandXyZoomModifier =
            t.splitIntoClusters =
              void 0),
          (t.BoxPlotSeriesInfo =
            t.XyzDataSeries =
            t.getYyYRange =
            t.XyyDataSeries =
            t.XyxyDataSeries =
            t.XyxDataSeries =
            t.XyTextDataSeries =
            t.XyNDataSeries =
            t.XyDataSeries =
            t.XDataSeries =
            t.UniformHeatmapDataSeries =
            t.PaletteFactory =
            t.getOHLCYRange =
            t.OhlcDataSeries =
            t.NonUniformHeatmapDataSeries =
            t.MetadataPaletteProvider =
            t.TemplateMetadataGenerator =
            t.DefaultPaletteProvider =
            t.EFillPaletteMode =
            t.EStrokePaletteMode =
            t.EDataSeriesValueType =
            t.EDataChangeType =
            t.EDataSeriesType =
            t.HlcDataSeries =
            t.FIFOVectorProvider =
            t.DoubleVectorProvider =
            t.DataPointSelectionPaletteProvider =
            t.BoxPlotDataSeries =
            t.BasePaletteProvider =
            t.BaseHeatmapDataSeries =
            t.getWindowedYRange =
            t.BaseDataSeries =
            t.RadialAxisLayoutStrategy =
            t.PolarLayoutManager =
            t.BasePolarAxisLayoutStrategy =
            t.AngularAxisLayoutStrategy =
            t.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy =
            t.TopAlignedOuterAxisLayoutStrategy =
            t.TopAlignedInnerAxisLayoutStrategy =
            t.SynchronizedLayoutManager =
            t.SciChartVerticalGroup =
            t.SciChartHorizontalGroup =
            t.RightAlignedOuterVerticallyStackedAxisLayoutStrategy =
            t.RightAlignedOuterAxisLayoutStrategy =
            t.RightAlignedInnerAxisLayoutStrategy =
            t.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy =
            t.LeftAlignedOuterAxisLayoutStrategy =
            t.LeftAlignedInnerAxisLayoutStrategy =
            t.LayoutManager =
            t.EInnerAxisPlacementCoordinateMode =
              void 0),
          (t.ExtremeResamplerHelper =
            t.NumericCoordinateCalculator =
            t.LogarithmicCoordinateCalculator =
            t.FlippedNumericCoordinateCalculator =
            t.FlippedCategoryCoordinateCalculator =
            t.CoordinateCalculatorBase =
            t.CategoryCoordinateCalculator =
            t.XyzPointSeriesWrapped =
            t.XyzPointSeriesResampled =
            t.XyyPointSeriesWrapped =
            t.XyyPointSeriesResampled =
            t.XyPointSeriesWrapped =
            t.XyPointSeriesResampled =
            t.XyNPointSeriesResampled =
            t.OhlcPointSeriesWrapped =
            t.OhlcPointSeriesResampled =
            t.HlcPointSeriesWrapped =
            t.BoxPlotPointSeriesWrapped =
            t.BasePointSeriesWrapped =
            t.BasePointSeriesResampled =
            t.XyzScaleOffsetFilter =
            t.XyzFilterBase =
            t.XyzCustomFilter =
            t.XyyScaleOffsetFilter =
            t.XyyFilterBase =
            t.XyyCustomFilter =
            t.XyScaleOffsetFilter =
            t.XyRatioFilter =
            t.XyMovingAverageFilter =
            t.XyLinearTrendFilter =
            t.switchData =
            t.XyFilterBase =
            t.EDataSeriesField =
            t.XyCustomFilter =
            t.OhlcScaleOffsetFilter =
            t.OhlcFilterBase =
            t.OhlcCustomFilter =
            t.HlcScaleOffsetFilter =
            t.HlcFilterBase =
            t.HlcCustomFilter =
            t.DataDistributionCalculator =
            t.XyzSeriesInfo =
            t.XyySeriesInfo =
            t.XySeriesInfo =
            t.TriangleSeriesInfo =
            t.StackedXySeriesInfo =
            t.SeriesInfo =
            t.OhlcSeriesInfo =
            t.HlcSeriesInfo =
            t.HeatmapSeriesInfo =
              void 0),
          (t.AnnotationHoverEventArgs =
            t.annotationHelpers =
            t.AnnotationDragDeltaEventArgs =
            t.AnnotationClickEventArgs =
            t.AnnotationBase =
            t.ECoordinateMode =
            t.EDraggingGripPoint =
            t.AdornerLayer =
            t.UpdateSuspender =
            t.createChartDestination =
            t.SciChartSurfaceBase =
            t.DebugForDpi =
            t.SciChartSurface =
            t.sciChartConfig =
            t.sciChartSubSurfaceCommon =
            t.SciChartSubSurface =
            t.SciChartPolarSurface =
            t.SciChartPolarSubSurface =
            t.SciChartOverview =
            t.SciChartDefaults =
            t.DefaultSciChartLoader =
            t.licenseManager2dState =
            t.HeatmapLegend =
            t.initializeChartEngine2D =
            t.getSharedWasmContext =
            t.SciChartJsNavyTheme =
            t.SciChartJSLightTheme =
            t.SciChartJSDarkv2Theme =
            t.SciChartJSDarkTheme =
            t.stripAutoColor =
            t.ThemeProvider =
            t.AUTO_COLOR =
            t.getAdjustedRotation =
            t.TitleRendererBase =
            t.SciChartRenderer =
            t.RenderPassInfo =
            t.RenderPassDataCollection =
            t.RenderPassData =
            t.ChartTitleRenderer =
            t.TickProvider =
            t.NumericTickProvider =
            t.LogarithmicTickProvider =
            t.ELogarithmicMajorTickMode =
            t.ELogarithmicMinorTickMode =
            t.TickCoordinatesProvider =
            t.StaticTickCoordinatesProvider =
            t.PolarTickCoordinatesProvider =
            t.DefaultTickCoordinatesProvider =
            t.ResamplingParams =
            t.EResamplingMode =
              void 0),
          (t.labelCache =
            t.DateLabelProvider =
            t.NumericDeltaCalculator =
            t.LogarithmicDeltaCalculator =
            t.DeltaCalculator =
            t.DateTimeDeltaCalculator =
            t.CategoryDeltaCalculator =
            t.VisibleRangeChangedArgs =
            t.NumericAxis =
            t.LogarithmicAxis =
            t.MIN_LOG_AXIS_VALUE =
            t.getAxis3dById =
            t.getAxisById =
            t.DateTimeNumericAxis =
            t.CategoryAxisBase =
            t.CategoryAxis =
            t.AxisTitleRenderer =
            t.AxisRenderer =
            t.PolarAxisLayoutState =
            t.AxisLayoutState =
            t.AxisCore =
            t.AxisBase2D =
            t.EClipMode =
            t.VerticalLineAnnotation =
            t.TextAnnotation =
            t.SvgAnnotationBase =
            t.RolloverTooltipSvgAnnotation =
            t.RolloverMarkerSvgAnnotation =
            t.RolloverLegendSvgAnnotation =
            t.RenderContextAnnotationBase =
            t.PolarPointerAnnotation =
            t.PolarArcAnnotation =
            t.OverviewCustomResizableAnnotation =
            t.NativeTextAnnotation =
            t.EWrapTo =
            t.LineArrowAnnotation =
            t.EArrowHeadPosition =
            t.LineAnnotation =
            t.EAnnotationType =
            t.EAnnotationLayer =
            t.HtmlTextAnnotation =
            t.HorizontalLineAnnotation =
            t.DomAnnotationBase =
            t.CustomHtmlAnnotation =
            t.CustomAnnotation =
            t.CursorTooltipSvgAnnotation =
            t.BoxAnnotation =
            t.AxisMarkerAnnotation =
            t.ArcAnnotationBase =
            t.ArcAnnotation =
              void 0),
          (t.ELegendType =
            t.ELegendPlacement =
            t.ELegendOrientation =
            t.SciChartLegend =
            t.ManualLegend =
            t.polarChartHelper =
            t.getAllFontKeys =
            t.getFontKey =
            t.getVector3 =
            t.getVector2 =
            t.getVector4 =
            t.getNativeRect =
            t.getTextBounds =
            t.getTextureVertex =
            t.getArcVertex =
            t.getVertex =
            t.getVectorArcVertex =
            t.getVectorColorTextureVertex =
            t.getVectorColorVertex =
            t.getVectorRectVertex =
            t.freeCache =
            t.deleteCache =
            t.FontKey =
            t.labelHelper =
            t.getLabelCoordinates =
            t.drawAxisMarkerAnnotation =
            t.drawLineAnnotation =
            t.drawModifiersAxisLabel =
            t.drawBorder =
            t.createSolidBrush =
            t.createSCRTPen =
            t.createNativeRect =
            t.EPolarLabelMode =
            t.EPolarGridlineMode =
            t.EPolarAxisMode =
            t.PolarNumericAxis =
            t.PolarCategoryAxis =
            t.PolarAxisRenderer =
            t.PolarAxisBase =
            t.wrapText =
            t.TextLabelProvider =
            t.SmartDateLabelProvider =
            t.ETradeChartLabelFormat =
            t.RadianLabelProvider =
            t.PieLabelProvider =
            t.NumericLabelProvider =
            t.LogarithmicLabelProvider =
            t.LabelProviderBase2D =
            t.LabelInfo =
            t.LabelProvider =
              void 0),
          (t.StackedColumnCollection =
            t.SplineMountainRenderableSeries =
            t.SplineLineRenderableSeries =
            t.SplineBandRenderableSeries =
            t.SmoothStackedMountainRenderableSeries =
            t.ShadowEffect =
            t.ShaderEffect =
            t.SeriesVisibleChangedArgs =
            t.SeriesSelectedArgs =
            t.SeriesHoveredArgs =
            t.SelectionChangedArgs =
            t.NonUniformHeatmapRenderableSeries =
            t.LineSegmentRenderableSeries =
            t.HoveredChangedArgs =
            t.HeatmapColorMap =
            t.GlowEffect =
            t.FastTextRenderableSeries =
            t.FastRectangleRenderableSeries =
            t.FastOhlcRenderableSeries =
            t.FastMountainRenderableSeries =
            t.FastLineRenderableSeries =
            t.FastImpulseRenderableSeries =
            t.FastErrorBarsRenderableSeries =
            t.getXRange =
            t.FastColumnRenderableSeries =
            t.FastCandlestickRenderableSeries =
            t.FastBubbleRenderableSeries =
            t.FastBoxPlotRenderableSeries =
            t.FastBandRenderableSeries =
            t.BaseStackedRenderableSeries =
            t.BaseStackedMountainRenderableSeries =
            t.BaseStackedCollection =
            t.BaseRenderableSeries =
            t.BaseOhlcRenderableSeries =
            t.BaseMountainRenderableSeries =
            t.BaseLineRenderableSeries =
            t.ELineType =
            t.BaseHeatmapRenderableSeries =
            t.BaseBandRenderableSeries =
            t.XPointMarker =
            t.TrianglePointMarker =
            t.SquarePointMarker =
            t.SpritePointMarker =
            t.EllipsePointMarker =
            t.CrossPointMarker =
            t.BasePointMarker =
            t.SciChartPieLegend =
            t.getLegendContainerHtml =
            t.getLegendItemHtml =
            t.SciChartLegendBase =
              void 0),
          (t.BandSeriesDrawingProvider =
            t.TextDataLabelProvider =
            t.StackedColumnSeriesDataLabelProvider =
            t.StackedCollectionDataLabelProvider =
            t.RectangleSeriesDataLabelProvider =
            t.RectangleDataLabelState =
            t.NonUniformHeatMapDataLabelProvider =
            t.LineSeriesDataLabelProvider =
            t.HeatMapDataLabelProvider =
            t.DataLabelState =
            t.DataLabelProvider =
            t.dataLabelHelpers =
            t.ContoursDataLabelProvider =
            t.ColumnSeriesDataLabelProvider =
            t.EColumnDataLabelPosition =
            t.BubbleSeriesDataLabelProvider =
            t.BaseDataLabelProvider =
            t.BandSeriesDataLabelProvider =
            t.WaveAnimation =
            t.SweepAnimation =
            t.SeriesAnimation =
            t.ScatterAnimation =
            t.ScaleAnimation =
            t.PointMarkerStyle =
            t.OhlcAnimationStyle =
            t.OhlcAnimation =
            t.MountainAnimationStyle =
            t.MountainAnimation =
            t.LineAnimation =
            t.FadeAnimation =
            t.CustomPointMarkerStyle =
            t.ColumnAnimationStyle =
            t.ColumnAnimation =
            t.CandlestickAnimationStyle =
            t.CandlestickAnimation =
            t.BubbleAnimation =
            t.BasePointMarkerStyle =
            t.BaseAnimationStyle =
            t.BandAnimationStyle =
            t.BandAnimation =
            t.animationHelpers =
            t.XyScatterRenderableSeries =
            t.UniformHeatmapRenderableSeries =
            t.UniformContoursRenderableSeries =
            t.EContourColorMapMode =
            t.TriangleRenderableSeries =
            t.StackedXyCollection =
            t.StackedMountainRenderableSeries =
            t.StackedMountainCollection =
            t.StackedColumnRenderableSeries =
              void 0),
          (t.PolarMountainRenderableSeries =
            t.PolarLineRenderableSeries =
            t.PolarColumnRenderableSeries =
            t.PolarBandRenderableSeries =
            t.UniformHeatmapHitTestProvider =
            t.TriangleSeriesHitTestProvider =
            t.TextSeriesHitTestProvider =
            t.StackedMountainSeriesHitTestProvider =
            t.StackedColumnSeriesHitTestProvider =
            t.ScatterSeriesHitTestProvider =
            t.RectangleSeriesHitTestProvider =
            t.OhlcSeriesHitTestProvider =
            t.NonUniformHeatmapHitTestProvider =
            t.MountainSeriesHitTestProvider =
            t.LineSeriesHitTestProvider =
            t.LineSegmentSeriesHitTestProvider =
            t.ImpulseSeriesHitTestProvider =
            t.HitTestInfo =
            t.hitTestHelpersRectangleSeries =
            t.hitTestHelpers =
            t.ErrorSeriesHitTestProvider =
            t.ColumnSeriesHitTestProvider =
            t.BubbleSeriesHitTestProvider =
            t.BoxPlotSeriesHitTestProvider =
            t.BaseHitTestProvider =
            t.BandSeriesHitTestProvider =
            t.UniformHeatmapDrawingProvider =
            t.UniformContoursDrawingProvider =
            t.TriangleSeriesDrawingProvider =
            t.SmearSeriesDrawingProvider =
            t.RectangleSeriesDrawingProvider =
            t.PointMarkerDrawingProvider =
            t.OhlcSeriesDrawingProvider =
            t.EOhlcDrawingMode =
            t.NonUniformHeatmapDrawingProvider =
            t.MountainSeriesDrawingProvider =
            t.LineSeriesDrawingProvider =
            t.LineSegmentSeriesDrawingProvider =
            t.HeightSeriesDrawingProvider =
            t.calculateHeatmapTexture =
            t.calculateCellCoordinates =
            t.calculateOffsets =
            t.createColorMap =
            t.getColor =
            t.getColorDataForTexture =
            t.ErrorSeriesDrawingProvider =
            t.ColumnSeriesDrawingProvider =
            t.BubbleSeriesDrawingProvider =
            t.BoxPlotSeriesDrawingProvider =
            t.BaseSeriesDrawingProvider =
              void 0),
          (t.OrbitModifier3D =
            t.MouseWheelZoomModifier3D =
            t.CustomChartModifier3D =
            t.ChartModifierBase3D =
            t.Vector3 =
            t.CameraController =
            t.ECameraProjectionMode =
            t.measureTextWidth =
            t.measureTextHeight =
            t.TextureManager =
            t.DpiHelper =
            t.CanvasTexture =
            t.PieSegment =
            t.SciChartPieSurface =
            t.EPieValueMode =
            t.EPieType =
            t.ESizingMode =
            t.RubberBandSvgRect =
            t.RolloverModifierRenderableSeriesProps =
            t.XyySplineRenderDataTransform =
            t.SplineRenderDataTransform =
            t.PolarInterpolateLineRenderDataTransform =
            t.PolarInterpolateBandRenderDataTransform =
            t.SmoothStackedRenderDataTransform =
            t.XyyBezierRenderDataTransform =
            t.BezierRenderDataTransform =
            t.bezierTransform =
            t.OhlcBaseRenderDataTransform =
            t.XyyBaseRenderDataTransform =
            t.XyBaseRenderDataTransform =
            t.BaseRenderDataTransform =
            t.PolarLineSeriesHitTestProvider =
            t.polarHitTestHelpers =
            t.PolarDataPointHitTestProvider =
            t.PolarPointMarkerDrawingProvider =
            t.PolarLineSeriesDrawingProvider =
            t.PolarHeatmapDrawingProvider =
            t.PolarColumnSeriesDrawingProvider =
            t.PolarBandSeriesDrawingProvider =
            t.PolarHeatMapDataLabelProvider =
            t.PolarDataLabelState =
            t.PolarDataLabelProvider =
            t.PolarColumnSeriesDataLabelProvider =
            t.PolarColumnDataLabelState =
            t.PolarXyScatterRenderableSeries =
            t.PolarUniformHeatmapRenderableSeries =
            t.PolarStackedMountainRenderableSeries =
            t.PolarStackedMountainCollection =
            t.PolarStackedColumnRenderableSeries =
            t.PolarStackedColumnCollection =
              void 0),
          (t.RenderPassInfo3D =
            t.RenderableSeriesSceneEntityState =
            t.RenderableSeriesSceneEntity =
            t.PointLine3DSceneEntity =
            t.DefaultEntityIdProvider =
            t.CrosshairLinesSceneEntity =
            t.ColumnSceneEntity =
            t.BaseSceneEntity3D =
            t.AxisCubeDescriptor =
            t.TrianglePointMarker3D =
            t.EllipsePointMarker3D =
            t.QuadPointMarker =
            t.PixelPointMarker3D =
            t.CylinderPointMarker3D =
            t.PyramidPointMarker3D =
            t.CubePointMarker3D =
            t.SpherePointMarker3D =
            t.BaseTexturePointMarker3D =
            t.BasePointMarker3D =
            t.EMarkerType =
            t.BaseMeshPointMarker3D =
            t.NumericAxis3D =
            t.getArraysEqual =
            t.getTextStylesEqual =
            t.getTArgbEqual =
            t.getLineStylesEqual =
            t.getDescriptorsEqual =
            t.ETextAlignment3D =
            t.EAxisSideClipping =
            t.AxisCubeEntity =
            t.AxisBase3D =
            t.EWhichAxis =
            t.TooltipSvgAnnotation3D =
            t.ViewportManager3DBase =
            t.SciChart3DSurface =
            t.sciChartConfig3D =
            t.SciChart3DRenderer =
            t.RootSceneEntity =
            t.GizmoEntity =
            t.DefaultViewportManager3D =
            t.createSingle3dInternal =
            t.XyzDataSeries3D =
            t.UniformGridDataSeries3D =
            t.BaseGridDataSeries3D =
            t.BaseDataSeries3D =
            t.EDataSeriesType3D =
            t.adjustTooltipPosition3D =
            t.TooltipModifier3D =
            t.ResetCamera3DModifier =
            t.PinchZoomModifier3D =
              void 0),
          (t.AnimationFiniteStateMachine =
            t.EAnimationStateTransition =
            t.EAnimationState =
            t.WebGlHelper =
            t.EWebGLSupport =
            t.Thickness =
            t.sendTelemetry =
            t.shouldSendTelemetry =
            t.getUserCookie =
            t.Rect =
            t.PropertyChangedEventArgs =
            t.Point =
            t.OneTimePerformanceWarning =
            t.ObservableArrayChangedArgs =
            t.EObservableArrayChangedAction =
            t.ObservableArray =
            t.ObservableArrayBase =
            t.NumberUtil =
            t.NumberRange =
            t.List =
            t.IncludedItems =
            t.Guard =
            t.GradientParams =
            t.EventHandler =
            t.Dictionary =
            t.deleteSafe =
            t.DeletableEntity =
            t.checkBuildStamp =
            t.libraryVersion =
            t.AnimationToken =
            t.SurfaceMeshRenderableSeries3D =
            t.EMeshResolution =
            t.EMeshPaletteMode =
            t.EDrawMeshAs =
            t.SolidColorBrushPalette =
            t.MeshColorPalette =
            t.GradientColorPalette =
            t.XyzSeriesInfo3D =
            t.SurfaceMeshSeriesInfo3D =
            t.SeriesInfo3D =
            t.ScatterRenderableSeries3D =
            t.PointLineRenderableSeries3D =
            t.HitTestInfo3D =
            t.ESeriesType3D =
            t.ColumnRenderableSeries3D =
            t.BaseRenderableSeries3D =
            t.SurfaceMeshSceneEntity =
            t.SurfaceMeshSceneEntityState =
            t.SceneDescriptor =
            t.ScatterPointsSceneEntity =
              void 0),
          (t.EModifierType =
            t.ELayoutStrategyType =
            t.ELayoutManagerType =
            t.ELabelProviderType =
            t.ERadialAxisLabelPlacement =
            t.EAngularAxisLabelPlacement =
            t.EVerticalAlignment =
            t.EHorizontalAlignment =
            t.ELabelPlacement =
            t.ELabelAlignment =
            t.EHoverMode =
            t.EHeightSeriesMode =
            t.EColorPickMode =
            t.EErrorMode =
            t.EErrorDirection =
            t.EDragMode =
            t.EDefaultRenderLayer =
            t.EDataPointWidthMode =
            t.EDataLabelSkipMode =
            t.EDataLabelProviderType =
            t.EDataFilterType =
            t.ECursorStyle =
            t.convertYColumnMode =
            t.EColumnYMode =
            t.convertColumnMode =
            t.EColumnMode =
            t.EColor =
            t.EChart3DModifierType =
            t.EChart2DModifierType =
            t.EBaseType =
            t.EAxisType =
            t.handleInvalidAxisAlignment =
            t.getIsVertical =
            t.getIsHorizontal =
            t.EAxisAlignment =
            t.EAutoRange =
            t.EAutoColorMode =
            t.EAnnotationClippingMode =
            t.EAnimationType =
            t.EVerticalAnchorPoint =
            t.EHorizontalAnchorPoint =
            t.localStorageApi =
            t.MouseManager =
            t.NumberRangeAnimator =
            t.GenericAnimation =
            t.autoReverseEasing =
            t.easing =
            t.DoubleAnimator =
            t.animateAny =
            t.SeriesAnimationFiniteStateMachine =
              void 0),
          (t.uintArgbColorMultiplyOpacity =
            t.uintArgbColorToAbgr =
            t.linearColorMapLerp =
            t.uintArgbColorLerp =
            t.uintArgbColorLerp24bit =
            t.calcAverageForArray =
            t.calcAverageForDoubleVector =
            t.appendRangeFifo =
            t.makeIncArray =
            t.isArraySorted =
            t.arrayRemove =
            t.areArraysEqual =
            t.countUnique =
            t.getUniqueValues =
            t.EStrokeLineJoin =
            t.EModifierMouseArgKey =
            t.EExecuteOn =
            t.EZoomState =
            t.EYRangeMode =
            t.EXyDirection =
            t.EWatermarkPosition =
            t.generateValueNamesForDataSeries =
            t.EValueName =
            t.ETriangleSeriesDrawMode =
            t.EColorMapMode =
            t.EThemeProviderType =
            t.ETitlePosition =
            t.ETextAlignment =
            t.convertMultiLineAlignment =
            t.EMultiLineAlignment =
            t.EVerticalTextPosition =
            t.EHorizontalTextPosition =
            t.ESurfaceType =
            t.Size =
            t.EShaderEffectType =
            t.ESeriesType =
            t.convertSearchMode =
            t.ESearchMode =
            t.ESciChartSurfaceType =
            t.ESceneEntityType =
            t.ERenderLayer =
            t.EPointMarkerType =
            t.EPointMarker3DType =
            t.EPaletteProviderType =
            t.OrderedRenderable =
            t.ENumericFormat =
            t.subArray =
            t.isNumberArray =
            t.isTypedArray =
            t.EMousePosition =
              void 0),
          (t.parseColorToHexStringAbgr =
            t.parseColorToHexStringArgb =
            t.checkIsNaN =
            t.toEngineering =
            t.toScientific =
            t.toSuperScript =
            t.formatNumber =
            t.numericHashCode =
            t.formatNumber2Digits =
            t.MemoryUsageHelper =
            t.ObjectRegistry =
            t.memoize =
            t.logToBase =
            t.fillNoisySinewave =
            t.getNoisySinewave =
            t.Logger =
            t.isRealNumber =
            t.createImagesArrayAsync =
            t.createImageAsync =
            t.stringOccurrences =
            t.htmlToElement =
            t.validateColorStops =
            t.HEIGHT_SERIES_MAX_TEXTURE_SIZE =
            t.hashUtils =
            t.hasAllProperties =
            t.base64Id =
            t.generateGuid =
            t.geometryHelpers =
            t.getFontFamily =
            t.DEFAULT_FONT_FAMILY =
            t.getFontString =
            t.logDoubleVector =
            t.formatUnixDateToHumanStringYYYY =
            t.formatUnixDateToHumanStringDD =
            t.formatUnixDateToHumanStringMMM =
            t.formatUnixDateToHumanStringMMMDD =
            t.formatUnixDateToHumanStringHHMM =
            t.formatUnixDateToHumanStringSSms =
            t.formatUnixDateToHumanStringHHMMSS =
            t.formatUnixDateToHumanStringDDMM =
            t.formatUnixDateToHumanStringDDMMHHMM =
            t.formatUnixDateToHumanStringDDMMYY =
            t.formatUnixDateToHumanString =
            t.copyDoubleVector =
            t.convertToPixel =
            t.convertRgbToHexColor =
            t.convertColor =
            t.applyOpacityToHtmlColor =
            t.uintArgbColorIsTransparent =
            t.uintArgbColorOverrideOpacity =
              void 0),
          (t.zeroArray2D =
            t.watermarkHelpers =
            t.fromTsrVector4 =
            t.updateTsrVector4 =
            t.translateDataValueRectToAbsolute =
            t.translateToNotScaledRect =
            t.translateToScaledRect =
            t.translateToNotScaled =
            t.translateToScaled =
            t.translateFromSeriesViewRectToCanvasY =
            t.translateFromSeriesViewRectToCanvasX =
            t.translateFromCanvasToSeriesViewRectY =
            t.translateFromCanvasToSeriesViewRectX =
            t.translateFromSeriesViewRectToCanvas =
            t.translateFromCanvasToSeriesViewRect =
            t.EShift =
            t.ECoord =
            t.ESize =
            t.getNativeTextSize =
            t.wrapNativeText =
            t.getAttributeFromString =
            t.getNextRandomPriceBarFactory =
            t.getStocksDataFactory =
            t.getRandomInRange =
            t.testPointInTriangle =
            t.calcDistanceFromLineSegment =
            t.calcDotProduct =
            t.testIsInInterval =
            t.testIsInXBounds =
            t.calcAnnotationBordersForAxisMarker =
            t.testIsInBounds =
            t.calcDistance =
            t.calcCrossProduct =
            t.calcDistanceFromLine =
            t.runAfterFramePaint =
            t.PerformanceDebugHelper =
            t.EPerformanceDebugLevel =
            t.EPerformanceMarkType =
            t.parseTArgbToHtmlColor =
            t.parseArgbToHtmlColor =
            t.parseColorToTArgb =
            t.toHex =
            t.parseColorToUIntAbgr =
            t.parseColorToUIntArgb =
              void 0);
        var i = r(71993);
        Object.defineProperty(t, "buildAnnotations", {
          enumerable: !0,
          get: function () {
            return i.buildAnnotations;
          },
        });
        var o = r(25924);
        Object.defineProperty(t, "buildAxes", {
          enumerable: !0,
          get: function () {
            return o.buildAxes;
          },
        });
        var a = r(25924);
        Object.defineProperty(t, "buildAxis3D", {
          enumerable: !0,
          get: function () {
            return a.buildAxis3D;
          },
        });
        var s = r(44544);
        Object.defineProperty(t, "buildDataSeries", {
          enumerable: !0,
          get: function () {
            return s.buildDataSeries;
          },
        });
        var n = r(44544);
        Object.defineProperty(t, "buildDataSeries3D", {
          enumerable: !0,
          get: function () {
            return n.buildDataSeries3D;
          },
        });
        var l = r(96841);
        Object.defineProperty(t, "buildModifiers", {
          enumerable: !0,
          get: function () {
            return l.buildModifiers;
          },
        });
        var d = r(96841);
        Object.defineProperty(t, "buildModifiers3D", {
          enumerable: !0,
          get: function () {
            return d.buildModifiers3D;
          },
        });
        var h = r(12193);
        Object.defineProperty(t, "buildSeries", {
          enumerable: !0,
          get: function () {
            return h.buildSeries;
          },
        });
        var u = r(12193);
        Object.defineProperty(t, "buildSeries3D", {
          enumerable: !0,
          get: function () {
            return u.buildSeries3D;
          },
        });
        var c = r(64931);
        Object.defineProperty(t, "build2DChart", {
          enumerable: !0,
          get: function () {
            return c.build2DChart;
          },
        });
        var p = r(64931);
        Object.defineProperty(t, "build2DPolarChart", {
          enumerable: !0,
          get: function () {
            return p.build2DPolarChart;
          },
        });
        var g = r(64931);
        Object.defineProperty(t, "buildPieChart", {
          enumerable: !0,
          get: function () {
            return g.buildPieChart;
          },
        });
        var y = r(64931);
        Object.defineProperty(t, "build3DChart", {
          enumerable: !0,
          get: function () {
            return y.build3DChart;
          },
        });
        var f = r(64931);
        Object.defineProperty(t, "buildSubCharts", {
          enumerable: !0,
          get: function () {
            return f.buildSubCharts;
          },
        });
        var v = r(64931);
        Object.defineProperty(t, "configure2DSurface", {
          enumerable: !0,
          get: function () {
            return v.configure2DSurface;
          },
        });
        var m = r(64931);
        Object.defineProperty(t, "configure3DSurface", {
          enumerable: !0,
          get: function () {
            return m.configure3DSurface;
          },
        });
        var S = r(58996);
        Object.defineProperty(t, "chartReviver", {
          enumerable: !0,
          get: function () {
            return S.chartReviver;
          },
        });
        var P = r(58996);
        Object.defineProperty(t, "buildChart", {
          enumerable: !0,
          get: function () {
            return P.buildChart;
          },
        });
        var C = r(58996);
        Object.defineProperty(t, "configureChart", {
          enumerable: !0,
          get: function () {
            return C.configureChart;
          },
        });
        var b = r(58996);
        Object.defineProperty(t, "ensureRegistrations", {
          enumerable: !0,
          get: function () {
            return b.ensureRegistrations;
          },
        });
        var x = r(58996);
        Object.defineProperty(t, "chartBuilder", {
          enumerable: !0,
          get: function () {
            return x.chartBuilder;
          },
        });
        var A = r(45921);
        Object.defineProperty(t, "registerType", {
          enumerable: !0,
          get: function () {
            return A.registerType;
          },
        });
        var T = r(45921);
        Object.defineProperty(t, "registerWasmType", {
          enumerable: !0,
          get: function () {
            return T.registerWasmType;
          },
        });
        var E = r(45921);
        Object.defineProperty(t, "registerFunction", {
          enumerable: !0,
          get: function () {
            return E.registerFunction;
          },
        });
        var R = r(45921);
        Object.defineProperty(t, "getFunction", {
          enumerable: !0,
          get: function () {
            return R.getFunction;
          },
        });
        var D = r(45921);
        Object.defineProperty(t, "createType", {
          enumerable: !0,
          get: function () {
            return D.createType;
          },
        });
        var w = r(45921);
        Object.defineProperty(t, "getSubTypes", {
          enumerable: !0,
          get: function () {
            return w.getSubTypes;
          },
        });
        var M = r(49975);
        Object.defineProperty(t, "AnnotationHoverModifier", {
          enumerable: !0,
          get: function () {
            return M.AnnotationHoverModifier;
          },
        });
        var L = r(13063);
        Object.defineProperty(t, "ChartModifierBase", {
          enumerable: !0,
          get: function () {
            return L.ChartModifierBase;
          },
        });
        var O = r(89046);
        Object.defineProperty(t, "ChartModifierBase2D", {
          enumerable: !0,
          get: function () {
            return O.ChartModifierBase2D;
          },
        });
        var I = r(89046);
        Object.defineProperty(t, "testIsOverAxes", {
          enumerable: !0,
          get: function () {
            return I.testIsOverAxes;
          },
        });
        var k = r(89046);
        Object.defineProperty(t, "getActiveAxes", {
          enumerable: !0,
          get: function () {
            return k.getActiveAxes;
          },
        });
        var _ = r(62773);
        Object.defineProperty(t, "CursorModifier", {
          enumerable: !0,
          get: function () {
            return _.CursorModifier;
          },
        });
        var V = r(62773);
        Object.defineProperty(t, "defaultCursorTooltipSvgTemplate", {
          enumerable: !0,
          get: function () {
            return V.defaultCursorTooltipSvgTemplate;
          },
        });
        var N = r(62773);
        Object.defineProperty(t, "calcTooltipSize", {
          enumerable: !0,
          get: function () {
            return N.calcTooltipSize;
          },
        });
        var B = r(62773);
        Object.defineProperty(t, "adjustTooltipPosition", {
          enumerable: !0,
          get: function () {
            return B.adjustTooltipPosition;
          },
        });
        var F = r(42639);
        Object.defineProperty(t, "CustomChartModifier2D", {
          enumerable: !0,
          get: function () {
            return F.CustomChartModifier2D;
          },
        });
        var H = r(36534);
        Object.defineProperty(t, "DataPointInfo", {
          enumerable: !0,
          get: function () {
            return H.DataPointInfo;
          },
        });
        var Y = r(897);
        Object.defineProperty(t, "DataPointSelectionChangedArgs", {
          enumerable: !0,
          get: function () {
            return Y.DataPointSelectionChangedArgs;
          },
        });
        var z = r(71575);
        Object.defineProperty(t, "ESelectionMode", {
          enumerable: !0,
          get: function () {
            return z.ESelectionMode;
          },
        });
        var j = r(71575);
        Object.defineProperty(t, "DataPointSelectionModifier", {
          enumerable: !0,
          get: function () {
            return j.DataPointSelectionModifier;
          },
        });
        var X = r(9656);
        Object.defineProperty(t, "LegendModifier", {
          enumerable: !0,
          get: function () {
            return X.LegendModifier;
          },
        });
        var G = r(14290);
        Object.defineProperty(t, "ModifierArgsBase", {
          enumerable: !0,
          get: function () {
            return G.ModifierArgsBase;
          },
        });
        var W = r(39299);
        Object.defineProperty(t, "ModifierMouseArgs", {
          enumerable: !0,
          get: function () {
            return W.ModifierMouseArgs;
          },
        });
        var U = r(56985);
        Object.defineProperty(t, "EActionType", {
          enumerable: !0,
          get: function () {
            return U.EActionType;
          },
        });
        var $ = r(56985);
        Object.defineProperty(t, "MouseWheelZoomModifier", {
          enumerable: !0,
          get: function () {
            return $.MouseWheelZoomModifier;
          },
        });
        var Z = r(55526);
        Object.defineProperty(t, "OverviewRangeSelectionModifier", {
          enumerable: !0,
          get: function () {
            return Z.OverviewRangeSelectionModifier;
          },
        });
        var q = r(21562);
        Object.defineProperty(t, "PinchZoomModifier", {
          enumerable: !0,
          get: function () {
            return q.PinchZoomModifier;
          },
        });
        var K = r(78615);
        Object.defineProperty(t, "PointerEventsMediatorModifier", {
          enumerable: !0,
          get: function () {
            return K.PointerEventsMediatorModifier;
          },
        });
        var J = r(63903);
        Object.defineProperty(t, "RolloverModifier", {
          enumerable: !0,
          get: function () {
            return J.RolloverModifier;
          },
        });
        var Q = r(63903);
        Object.defineProperty(t, "splitIntoClusters", {
          enumerable: !0,
          get: function () {
            return Q.splitIntoClusters;
          },
        });
        var ee = r(18809);
        Object.defineProperty(t, "RubberBandXyZoomModifier", {
          enumerable: !0,
          get: function () {
            return ee.RubberBandXyZoomModifier;
          },
        });
        var te = r(18809);
        Object.defineProperty(t, "getRubberBandRect", {
          enumerable: !0,
          get: function () {
            return te.getRubberBandRect;
          },
        });
        var re = r(32545);
        Object.defineProperty(t, "SeriesSelectionModifier", {
          enumerable: !0,
          get: function () {
            return re.SeriesSelectionModifier;
          },
        });
        var ie = r(96408);
        Object.defineProperty(t, "VerticalSliceModifier", {
          enumerable: !0,
          get: function () {
            return ie.VerticalSliceModifier;
          },
        });
        var oe = r(9809);
        Object.defineProperty(t, "XAxisDragModifier", {
          enumerable: !0,
          get: function () {
            return oe.XAxisDragModifier;
          },
        });
        var ae = r(3397);
        Object.defineProperty(t, "YAxisDragModifier", {
          enumerable: !0,
          get: function () {
            return ae.YAxisDragModifier;
          },
        });
        var se = r(63407);
        Object.defineProperty(t, "ZoomExtentsModifier", {
          enumerable: !0,
          get: function () {
            return se.ZoomExtentsModifier;
          },
        });
        var ne = r(64171);
        Object.defineProperty(t, "ZoomPanModifier", {
          enumerable: !0,
          get: function () {
            return ne.ZoomPanModifier;
          },
        });
        var le = r(95648);
        Object.defineProperty(t, "PolarArcZoomModifier", {
          enumerable: !0,
          get: function () {
            return le.PolarArcZoomModifier;
          },
        });
        var de = r(94118);
        Object.defineProperty(t, "PolarCursorModifier", {
          enumerable: !0,
          get: function () {
            return de.PolarCursorModifier;
          },
        });
        var he = r(37221);
        Object.defineProperty(t, "PolarDataPointSelectionModifier", {
          enumerable: !0,
          get: function () {
            return he.PolarDataPointSelectionModifier;
          },
        });
        var ue = r(99389);
        Object.defineProperty(t, "PolarLegendModifier", {
          enumerable: !0,
          get: function () {
            return ue.PolarLegendModifier;
          },
        });
        var ce = r(30580);
        Object.defineProperty(t, "PolarMouseWheelZoomModifier", {
          enumerable: !0,
          get: function () {
            return ce.PolarMouseWheelZoomModifier;
          },
        });
        var pe = r(27524);
        Object.defineProperty(t, "EPolarPanModifierPanMode", {
          enumerable: !0,
          get: function () {
            return pe.EPolarPanModifierPanMode;
          },
        });
        var ge = r(27524);
        Object.defineProperty(t, "PolarPanModifier", {
          enumerable: !0,
          get: function () {
            return ge.PolarPanModifier;
          },
        });
        var ye = r(36463);
        Object.defineProperty(t, "PolarZoomExtentsModifier", {
          enumerable: !0,
          get: function () {
            return ye.PolarZoomExtentsModifier;
          },
        });
        var fe = r(93113);
        Object.defineProperty(t, "BatchRenderContext", {
          enumerable: !0,
          get: function () {
            return fe.BatchRenderContext;
          },
        });
        var ve = r(51269);
        Object.defineProperty(t, "getWebGlBrushFromCache", {
          enumerable: !0,
          get: function () {
            return ve.getWebGlBrushFromCache;
          },
        });
        var me = r(51269);
        Object.defineProperty(t, "getScrtBrushFromCache", {
          enumerable: !0,
          get: function () {
            return me.getScrtBrushFromCache;
          },
        });
        var Se = r(51269);
        Object.defineProperty(t, "createBrushInCache", {
          enumerable: !0,
          get: function () {
            return Se.createBrushInCache;
          },
        });
        var Pe = r(21915);
        Object.defineProperty(t, "getWebGlPenFromCache", {
          enumerable: !0,
          get: function () {
            return Pe.getWebGlPenFromCache;
          },
        });
        var Ce = r(21915);
        Object.defineProperty(t, "getScrtPenFromCache", {
          enumerable: !0,
          get: function () {
            return Ce.getScrtPenFromCache;
          },
        });
        var be = r(21915);
        Object.defineProperty(t, "createPenInCache", {
          enumerable: !0,
          get: function () {
            return be.createPenInCache;
          },
        });
        var xe = r(53831);
        Object.defineProperty(t, "RenderContext2D", {
          enumerable: !0,
          get: function () {
            return xe.RenderContext2D;
          },
        });
        var Ae = r(33512);
        Object.defineProperty(t, "WebGlBrush", {
          enumerable: !0,
          get: function () {
            return Ae.WebGlBrush;
          },
        });
        var Te = r(55444);
        Object.defineProperty(t, "WebGlPen", {
          enumerable: !0,
          get: function () {
            return Te.WebGlPen;
          },
        });
        var Ee = r(16185);
        Object.defineProperty(t, "calculateAbsoluteRenderLayer", {
          enumerable: !0,
          get: function () {
            return Ee.calculateAbsoluteRenderLayer;
          },
        });
        var Re = r(16185);
        Object.defineProperty(t, "ELineDrawMode", {
          enumerable: !0,
          get: function () {
            return Re.ELineDrawMode;
          },
        });
        var De = r(16185);
        Object.defineProperty(t, "WebGlRenderContext2D", {
          enumerable: !0,
          get: function () {
            return De.WebGlRenderContext2D;
          },
        });
        var we = r(5100);
        Object.defineProperty(t, "updateAxisLayoutState", {
          enumerable: !0,
          get: function () {
            return we.updateAxisLayoutState;
          },
        });
        var Me = r(5100);
        Object.defineProperty(t, "layoutAxisParts", {
          enumerable: !0,
          get: function () {
            return Me.layoutAxisParts;
          },
        });
        var Le = r(5100);
        Object.defineProperty(t, "layoutAxisPartsLeftStrategy", {
          enumerable: !0,
          get: function () {
            return Le.layoutAxisPartsLeftStrategy;
          },
        });
        var Oe = r(5100);
        Object.defineProperty(t, "layoutAxisPartsRightStrategy", {
          enumerable: !0,
          get: function () {
            return Oe.layoutAxisPartsRightStrategy;
          },
        });
        var Ie = r(5100);
        Object.defineProperty(t, "layoutAxisPartsTopStrategy", {
          enumerable: !0,
          get: function () {
            return Ie.layoutAxisPartsTopStrategy;
          },
        });
        var ke = r(5100);
        Object.defineProperty(t, "layoutAxisPartsBottomStrategy", {
          enumerable: !0,
          get: function () {
            return ke.layoutAxisPartsBottomStrategy;
          },
        });
        var _e = r(5100);
        Object.defineProperty(t, "getHorizontalAxisRequiredSize", {
          enumerable: !0,
          get: function () {
            return _e.getHorizontalAxisRequiredSize;
          },
        });
        var Ve = r(5100);
        Object.defineProperty(t, "getVerticalAxisRequiredSize", {
          enumerable: !0,
          get: function () {
            return Ve.getVerticalAxisRequiredSize;
          },
        });
        var Ne = r(5100);
        Object.defineProperty(t, "updateLeftAndRightChartLayoutState", {
          enumerable: !0,
          get: function () {
            return Ne.updateLeftAndRightChartLayoutState;
          },
        });
        var Be = r(5100);
        Object.defineProperty(t, "updateTopAndBottomChartLayoutState", {
          enumerable: !0,
          get: function () {
            return Be.updateTopAndBottomChartLayoutState;
          },
        });
        var Fe = r(5100);
        Object.defineProperty(t, "getValueWithCoordinateMode", {
          enumerable: !0,
          get: function () {
            return Fe.getValueWithCoordinateMode;
          },
        });
        var He = r(5100);
        Object.defineProperty(t, "getCoordinateWithCoordinateMode", {
          enumerable: !0,
          get: function () {
            return He.getCoordinateWithCoordinateMode;
          },
        });
        var Ye = r(5100);
        Object.defineProperty(t, "testLayoutManager", {
          enumerable: !0,
          get: function () {
            return Ye.testLayoutManager;
          },
        });
        var ze = r(21843);
        Object.defineProperty(t, "BaseAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return ze.BaseAxisLayoutStrategy;
          },
        });
        var je = r(93326);
        Object.defineProperty(t, "BaseCenteredAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return je.BaseCenteredAxisLayoutStrategy;
          },
        });
        var Xe = r(60872);
        Object.defineProperty(t, "BottomAlignedInnerAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return Xe.BottomAlignedInnerAxisLayoutStrategy;
          },
        });
        var Ge = r(53521);
        Object.defineProperty(t, "BottomAlignedOuterAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return Ge.BottomAlignedOuterAxisLayoutStrategy;
          },
        });
        var We = r(57384);
        Object.defineProperty(
          t,
          "BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy",
          {
            enumerable: !0,
            get: function () {
              return We.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy;
            },
          }
        );
        var Ue = r(70397);
        Object.defineProperty(t, "CentralAxesLayoutManager", {
          enumerable: !0,
          get: function () {
            return Ue.CentralAxesLayoutManager;
          },
        });
        var $e = r(2310);
        Object.defineProperty(t, "ChartLayoutState", {
          enumerable: !0,
          get: function () {
            return $e.ChartLayoutState;
          },
        });
        var Ze = r(41344);
        Object.defineProperty(t, "EInnerAxisPlacementCoordinateMode", {
          enumerable: !0,
          get: function () {
            return Ze.EInnerAxisPlacementCoordinateMode;
          },
        });
        var qe = r(45481);
        Object.defineProperty(t, "LayoutManager", {
          enumerable: !0,
          get: function () {
            return qe.LayoutManager;
          },
        });
        var Ke = r(83638);
        Object.defineProperty(t, "LeftAlignedInnerAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return Ke.LeftAlignedInnerAxisLayoutStrategy;
          },
        });
        var Je = r(6153);
        Object.defineProperty(t, "LeftAlignedOuterAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return Je.LeftAlignedOuterAxisLayoutStrategy;
          },
        });
        var Qe = r(55173);
        Object.defineProperty(
          t,
          "LeftAlignedOuterVerticallyStackedAxisLayoutStrategy",
          {
            enumerable: !0,
            get: function () {
              return Qe.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy;
            },
          }
        );
        var et = r(24478);
        Object.defineProperty(t, "RightAlignedInnerAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return et.RightAlignedInnerAxisLayoutStrategy;
          },
        });
        var tt = r(27282);
        Object.defineProperty(t, "RightAlignedOuterAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return tt.RightAlignedOuterAxisLayoutStrategy;
          },
        });
        var rt = r(12119);
        Object.defineProperty(
          t,
          "RightAlignedOuterVerticallyStackedAxisLayoutStrategy",
          {
            enumerable: !0,
            get: function () {
              return rt.RightAlignedOuterVerticallyStackedAxisLayoutStrategy;
            },
          }
        );
        var it = r(66086);
        Object.defineProperty(t, "SciChartHorizontalGroup", {
          enumerable: !0,
          get: function () {
            return it.SciChartHorizontalGroup;
          },
        });
        var ot = r(78499);
        Object.defineProperty(t, "SciChartVerticalGroup", {
          enumerable: !0,
          get: function () {
            return ot.SciChartVerticalGroup;
          },
        });
        var at = r(8959);
        Object.defineProperty(t, "SynchronizedLayoutManager", {
          enumerable: !0,
          get: function () {
            return at.SynchronizedLayoutManager;
          },
        });
        var st = r(27194);
        Object.defineProperty(t, "TopAlignedInnerAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return st.TopAlignedInnerAxisLayoutStrategy;
          },
        });
        var nt = r(73145);
        Object.defineProperty(t, "TopAlignedOuterAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return nt.TopAlignedOuterAxisLayoutStrategy;
          },
        });
        var lt = r(55696);
        Object.defineProperty(
          t,
          "TopAlignedOuterHorizontallyStackedAxisLayoutStrategy",
          {
            enumerable: !0,
            get: function () {
              return lt.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy;
            },
          }
        );
        var dt = r(1908);
        Object.defineProperty(t, "AngularAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return dt.AngularAxisLayoutStrategy;
          },
        });
        var ht = r(19238);
        Object.defineProperty(t, "BasePolarAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return ht.BasePolarAxisLayoutStrategy;
          },
        });
        var ut = r(24696);
        Object.defineProperty(t, "PolarLayoutManager", {
          enumerable: !0,
          get: function () {
            return ut.PolarLayoutManager;
          },
        });
        var ct = r(57230);
        Object.defineProperty(t, "RadialAxisLayoutStrategy", {
          enumerable: !0,
          get: function () {
            return ct.RadialAxisLayoutStrategy;
          },
        });
        var pt = r(24933);
        Object.defineProperty(t, "BaseDataSeries", {
          enumerable: !0,
          get: function () {
            return pt.BaseDataSeries;
          },
        });
        var gt = r(24933);
        Object.defineProperty(t, "getWindowedYRange", {
          enumerable: !0,
          get: function () {
            return gt.getWindowedYRange;
          },
        });
        var yt = r(16179);
        Object.defineProperty(t, "BaseHeatmapDataSeries", {
          enumerable: !0,
          get: function () {
            return yt.BaseHeatmapDataSeries;
          },
        });
        var ft = r(27781);
        Object.defineProperty(t, "BasePaletteProvider", {
          enumerable: !0,
          get: function () {
            return ft.BasePaletteProvider;
          },
        });
        var vt = r(57835);
        Object.defineProperty(t, "BoxPlotDataSeries", {
          enumerable: !0,
          get: function () {
            return vt.BoxPlotDataSeries;
          },
        });
        var mt = r(75619);
        Object.defineProperty(t, "DataPointSelectionPaletteProvider", {
          enumerable: !0,
          get: function () {
            return mt.DataPointSelectionPaletteProvider;
          },
        });
        var St = r(84366);
        Object.defineProperty(t, "DoubleVectorProvider", {
          enumerable: !0,
          get: function () {
            return St.DoubleVectorProvider;
          },
        });
        var Pt = r(84366);
        Object.defineProperty(t, "FIFOVectorProvider", {
          enumerable: !0,
          get: function () {
            return Pt.FIFOVectorProvider;
          },
        });
        var Ct = r(22382);
        Object.defineProperty(t, "HlcDataSeries", {
          enumerable: !0,
          get: function () {
            return Ct.HlcDataSeries;
          },
        });
        var bt = r(51885);
        Object.defineProperty(t, "EDataSeriesType", {
          enumerable: !0,
          get: function () {
            return bt.EDataSeriesType;
          },
        });
        var xt = r(51885);
        Object.defineProperty(t, "EDataChangeType", {
          enumerable: !0,
          get: function () {
            return xt.EDataChangeType;
          },
        });
        var At = r(51885);
        Object.defineProperty(t, "EDataSeriesValueType", {
          enumerable: !0,
          get: function () {
            return At.EDataSeriesValueType;
          },
        });
        var Tt = r(32747);
        Object.defineProperty(t, "EStrokePaletteMode", {
          enumerable: !0,
          get: function () {
            return Tt.EStrokePaletteMode;
          },
        });
        var Et = r(32747);
        Object.defineProperty(t, "EFillPaletteMode", {
          enumerable: !0,
          get: function () {
            return Et.EFillPaletteMode;
          },
        });
        var Rt = r(32747);
        Object.defineProperty(t, "DefaultPaletteProvider", {
          enumerable: !0,
          get: function () {
            return Rt.DefaultPaletteProvider;
          },
        });
        var Dt = r(33906);
        Object.defineProperty(t, "TemplateMetadataGenerator", {
          enumerable: !0,
          get: function () {
            return Dt.TemplateMetadataGenerator;
          },
        });
        var wt = r(25907);
        Object.defineProperty(t, "MetadataPaletteProvider", {
          enumerable: !0,
          get: function () {
            return wt.MetadataPaletteProvider;
          },
        });
        var Mt = r(43427);
        Object.defineProperty(t, "NonUniformHeatmapDataSeries", {
          enumerable: !0,
          get: function () {
            return Mt.NonUniformHeatmapDataSeries;
          },
        });
        var Lt = r(35471);
        Object.defineProperty(t, "OhlcDataSeries", {
          enumerable: !0,
          get: function () {
            return Lt.OhlcDataSeries;
          },
        });
        var Ot = r(35471);
        Object.defineProperty(t, "getOHLCYRange", {
          enumerable: !0,
          get: function () {
            return Ot.getOHLCYRange;
          },
        });
        var It = r(52881);
        Object.defineProperty(t, "PaletteFactory", {
          enumerable: !0,
          get: function () {
            return It.PaletteFactory;
          },
        });
        var kt = r(15799);
        Object.defineProperty(t, "UniformHeatmapDataSeries", {
          enumerable: !0,
          get: function () {
            return kt.UniformHeatmapDataSeries;
          },
        });
        var _t = r(52452);
        Object.defineProperty(t, "XDataSeries", {
          enumerable: !0,
          get: function () {
            return _t.XDataSeries;
          },
        });
        var Vt = r(9682);
        Object.defineProperty(t, "XyDataSeries", {
          enumerable: !0,
          get: function () {
            return Vt.XyDataSeries;
          },
        });
        var Nt = r(38446);
        Object.defineProperty(t, "XyNDataSeries", {
          enumerable: !0,
          get: function () {
            return Nt.XyNDataSeries;
          },
        });
        var Bt = r(29803);
        Object.defineProperty(t, "XyTextDataSeries", {
          enumerable: !0,
          get: function () {
            return Bt.XyTextDataSeries;
          },
        });
        var Ft = r(73016);
        Object.defineProperty(t, "XyxDataSeries", {
          enumerable: !0,
          get: function () {
            return Ft.XyxDataSeries;
          },
        });
        var Ht = r(19663);
        Object.defineProperty(t, "XyxyDataSeries", {
          enumerable: !0,
          get: function () {
            return Ht.XyxyDataSeries;
          },
        });
        var Yt = r(75650);
        Object.defineProperty(t, "XyyDataSeries", {
          enumerable: !0,
          get: function () {
            return Yt.XyyDataSeries;
          },
        });
        var zt = r(75650);
        Object.defineProperty(t, "getYyYRange", {
          enumerable: !0,
          get: function () {
            return zt.getYyYRange;
          },
        });
        var jt = r(35508);
        Object.defineProperty(t, "XyzDataSeries", {
          enumerable: !0,
          get: function () {
            return jt.XyzDataSeries;
          },
        });
        var Xt = r(51185);
        Object.defineProperty(t, "BoxPlotSeriesInfo", {
          enumerable: !0,
          get: function () {
            return Xt.BoxPlotSeriesInfo;
          },
        });
        var Gt = r(14883);
        Object.defineProperty(t, "HeatmapSeriesInfo", {
          enumerable: !0,
          get: function () {
            return Gt.HeatmapSeriesInfo;
          },
        });
        var Wt = r(84754);
        Object.defineProperty(t, "HlcSeriesInfo", {
          enumerable: !0,
          get: function () {
            return Wt.HlcSeriesInfo;
          },
        });
        var Ut = r(97041);
        Object.defineProperty(t, "OhlcSeriesInfo", {
          enumerable: !0,
          get: function () {
            return Ut.OhlcSeriesInfo;
          },
        });
        var $t = r(32025);
        Object.defineProperty(t, "SeriesInfo", {
          enumerable: !0,
          get: function () {
            return $t.SeriesInfo;
          },
        });
        var Zt = r(75662);
        Object.defineProperty(t, "StackedXySeriesInfo", {
          enumerable: !0,
          get: function () {
            return Zt.StackedXySeriesInfo;
          },
        });
        var qt = r(43808);
        Object.defineProperty(t, "TriangleSeriesInfo", {
          enumerable: !0,
          get: function () {
            return qt.TriangleSeriesInfo;
          },
        });
        var Kt = r(50874);
        Object.defineProperty(t, "XySeriesInfo", {
          enumerable: !0,
          get: function () {
            return Kt.XySeriesInfo;
          },
        });
        var Jt = r(21780);
        Object.defineProperty(t, "XyySeriesInfo", {
          enumerable: !0,
          get: function () {
            return Jt.XyySeriesInfo;
          },
        });
        var Qt = r(19581);
        Object.defineProperty(t, "XyzSeriesInfo", {
          enumerable: !0,
          get: function () {
            return Qt.XyzSeriesInfo;
          },
        });
        var er = r(33435);
        Object.defineProperty(t, "DataDistributionCalculator", {
          enumerable: !0,
          get: function () {
            return er.DataDistributionCalculator;
          },
        });
        var tr = r(37947);
        Object.defineProperty(t, "HlcCustomFilter", {
          enumerable: !0,
          get: function () {
            return tr.HlcCustomFilter;
          },
        });
        var rr = r(22411);
        Object.defineProperty(t, "HlcFilterBase", {
          enumerable: !0,
          get: function () {
            return rr.HlcFilterBase;
          },
        });
        var ir = r(58465);
        Object.defineProperty(t, "HlcScaleOffsetFilter", {
          enumerable: !0,
          get: function () {
            return ir.HlcScaleOffsetFilter;
          },
        });
        var or = r(12954);
        Object.defineProperty(t, "OhlcCustomFilter", {
          enumerable: !0,
          get: function () {
            return or.OhlcCustomFilter;
          },
        });
        var ar = r(21384);
        Object.defineProperty(t, "OhlcFilterBase", {
          enumerable: !0,
          get: function () {
            return ar.OhlcFilterBase;
          },
        });
        var sr = r(73165);
        Object.defineProperty(t, "OhlcScaleOffsetFilter", {
          enumerable: !0,
          get: function () {
            return sr.OhlcScaleOffsetFilter;
          },
        });
        var nr = r(65936);
        Object.defineProperty(t, "XyCustomFilter", {
          enumerable: !0,
          get: function () {
            return nr.XyCustomFilter;
          },
        });
        var lr = r(95079);
        Object.defineProperty(t, "EDataSeriesField", {
          enumerable: !0,
          get: function () {
            return lr.EDataSeriesField;
          },
        });
        var dr = r(95079);
        Object.defineProperty(t, "XyFilterBase", {
          enumerable: !0,
          get: function () {
            return dr.XyFilterBase;
          },
        });
        var hr = r(95079);
        Object.defineProperty(t, "switchData", {
          enumerable: !0,
          get: function () {
            return hr.switchData;
          },
        });
        var ur = r(26974);
        Object.defineProperty(t, "XyLinearTrendFilter", {
          enumerable: !0,
          get: function () {
            return ur.XyLinearTrendFilter;
          },
        });
        var cr = r(95632);
        Object.defineProperty(t, "XyMovingAverageFilter", {
          enumerable: !0,
          get: function () {
            return cr.XyMovingAverageFilter;
          },
        });
        var pr = r(55007);
        Object.defineProperty(t, "XyRatioFilter", {
          enumerable: !0,
          get: function () {
            return pr.XyRatioFilter;
          },
        });
        var gr = r(39892);
        Object.defineProperty(t, "XyScaleOffsetFilter", {
          enumerable: !0,
          get: function () {
            return gr.XyScaleOffsetFilter;
          },
        });
        var yr = r(42790);
        Object.defineProperty(t, "XyyCustomFilter", {
          enumerable: !0,
          get: function () {
            return yr.XyyCustomFilter;
          },
        });
        var fr = r(20278);
        Object.defineProperty(t, "XyyFilterBase", {
          enumerable: !0,
          get: function () {
            return fr.XyyFilterBase;
          },
        });
        var vr = r(91154);
        Object.defineProperty(t, "XyyScaleOffsetFilter", {
          enumerable: !0,
          get: function () {
            return vr.XyyScaleOffsetFilter;
          },
        });
        var mr = r(86241);
        Object.defineProperty(t, "XyzCustomFilter", {
          enumerable: !0,
          get: function () {
            return mr.XyzCustomFilter;
          },
        });
        var Sr = r(84872);
        Object.defineProperty(t, "XyzFilterBase", {
          enumerable: !0,
          get: function () {
            return Sr.XyzFilterBase;
          },
        });
        var Pr = r(92475);
        Object.defineProperty(t, "XyzScaleOffsetFilter", {
          enumerable: !0,
          get: function () {
            return Pr.XyzScaleOffsetFilter;
          },
        });
        var Cr = r(39484);
        Object.defineProperty(t, "BasePointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Cr.BasePointSeriesResampled;
          },
        });
        var br = r(33070);
        Object.defineProperty(t, "BasePointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return br.BasePointSeriesWrapped;
          },
        });
        var xr = r(22769);
        Object.defineProperty(t, "BoxPlotPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return xr.BoxPlotPointSeriesWrapped;
          },
        });
        var Ar = r(89236);
        Object.defineProperty(t, "HlcPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return Ar.HlcPointSeriesWrapped;
          },
        });
        var Tr = r(65052);
        Object.defineProperty(t, "OhlcPointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Tr.OhlcPointSeriesResampled;
          },
        });
        var Er = r(6328);
        Object.defineProperty(t, "OhlcPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return Er.OhlcPointSeriesWrapped;
          },
        });
        var Rr = r(25919);
        Object.defineProperty(t, "XyNPointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Rr.XyNPointSeriesResampled;
          },
        });
        var Dr = r(58564);
        Object.defineProperty(t, "XyPointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Dr.XyPointSeriesResampled;
          },
        });
        var wr = r(88915);
        Object.defineProperty(t, "XyPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return wr.XyPointSeriesWrapped;
          },
        });
        var Mr = r(14023);
        Object.defineProperty(t, "XyyPointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Mr.XyyPointSeriesResampled;
          },
        });
        var Lr = r(2354);
        Object.defineProperty(t, "XyyPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return Lr.XyyPointSeriesWrapped;
          },
        });
        var Or = r(45425);
        Object.defineProperty(t, "XyzPointSeriesResampled", {
          enumerable: !0,
          get: function () {
            return Or.XyzPointSeriesResampled;
          },
        });
        var Ir = r(62507);
        Object.defineProperty(t, "XyzPointSeriesWrapped", {
          enumerable: !0,
          get: function () {
            return Ir.XyzPointSeriesWrapped;
          },
        });
        var kr = r(48804);
        Object.defineProperty(t, "CategoryCoordinateCalculator", {
          enumerable: !0,
          get: function () {
            return kr.CategoryCoordinateCalculator;
          },
        });
        var _r = r(72307);
        Object.defineProperty(t, "CoordinateCalculatorBase", {
          enumerable: !0,
          get: function () {
            return _r.CoordinateCalculatorBase;
          },
        });
        var Vr = r(25762);
        Object.defineProperty(t, "FlippedCategoryCoordinateCalculator", {
          enumerable: !0,
          get: function () {
            return Vr.FlippedCategoryCoordinateCalculator;
          },
        });
        var Nr = r(33166);
        Object.defineProperty(t, "FlippedNumericCoordinateCalculator", {
          enumerable: !0,
          get: function () {
            return Nr.FlippedNumericCoordinateCalculator;
          },
        });
        var Br = r(46650);
        Object.defineProperty(t, "LogarithmicCoordinateCalculator", {
          enumerable: !0,
          get: function () {
            return Br.LogarithmicCoordinateCalculator;
          },
        });
        var Fr = r(40194);
        Object.defineProperty(t, "NumericCoordinateCalculator", {
          enumerable: !0,
          get: function () {
            return Fr.NumericCoordinateCalculator;
          },
        });
        var Hr = r(78644);
        Object.defineProperty(t, "ExtremeResamplerHelper", {
          enumerable: !0,
          get: function () {
            return Hr.ExtremeResamplerHelper;
          },
        });
        var Yr = r(33240);
        Object.defineProperty(t, "EResamplingMode", {
          enumerable: !0,
          get: function () {
            return Yr.EResamplingMode;
          },
        });
        var zr = r(97742);
        Object.defineProperty(t, "ResamplingParams", {
          enumerable: !0,
          get: function () {
            return zr.ResamplingParams;
          },
        });
        var jr = r(65707);
        Object.defineProperty(t, "DefaultTickCoordinatesProvider", {
          enumerable: !0,
          get: function () {
            return jr.DefaultTickCoordinatesProvider;
          },
        });
        var Xr = r(21430);
        Object.defineProperty(t, "PolarTickCoordinatesProvider", {
          enumerable: !0,
          get: function () {
            return Xr.PolarTickCoordinatesProvider;
          },
        });
        var Gr = r(22019);
        Object.defineProperty(t, "StaticTickCoordinatesProvider", {
          enumerable: !0,
          get: function () {
            return Gr.StaticTickCoordinatesProvider;
          },
        });
        var Wr = r(73423);
        Object.defineProperty(t, "TickCoordinatesProvider", {
          enumerable: !0,
          get: function () {
            return Wr.TickCoordinatesProvider;
          },
        });
        var Ur = r(98172);
        Object.defineProperty(t, "ELogarithmicMinorTickMode", {
          enumerable: !0,
          get: function () {
            return Ur.ELogarithmicMinorTickMode;
          },
        });
        var $r = r(98172);
        Object.defineProperty(t, "ELogarithmicMajorTickMode", {
          enumerable: !0,
          get: function () {
            return $r.ELogarithmicMajorTickMode;
          },
        });
        var Zr = r(98172);
        Object.defineProperty(t, "LogarithmicTickProvider", {
          enumerable: !0,
          get: function () {
            return Zr.LogarithmicTickProvider;
          },
        });
        var qr = r(3346);
        Object.defineProperty(t, "NumericTickProvider", {
          enumerable: !0,
          get: function () {
            return qr.NumericTickProvider;
          },
        });
        var Kr = r(63345);
        Object.defineProperty(t, "TickProvider", {
          enumerable: !0,
          get: function () {
            return Kr.TickProvider;
          },
        });
        var Jr = r(3434);
        Object.defineProperty(t, "ChartTitleRenderer", {
          enumerable: !0,
          get: function () {
            return Jr.ChartTitleRenderer;
          },
        });
        var Qr = r(48570);
        Object.defineProperty(t, "RenderPassData", {
          enumerable: !0,
          get: function () {
            return Qr.RenderPassData;
          },
        });
        var ei = r(648);
        Object.defineProperty(t, "RenderPassDataCollection", {
          enumerable: !0,
          get: function () {
            return ei.RenderPassDataCollection;
          },
        });
        var ti = r(17611);
        Object.defineProperty(t, "RenderPassInfo", {
          enumerable: !0,
          get: function () {
            return ti.RenderPassInfo;
          },
        });
        var ri = r(23059);
        Object.defineProperty(t, "SciChartRenderer", {
          enumerable: !0,
          get: function () {
            return ri.SciChartRenderer;
          },
        });
        var ii = r(24156);
        Object.defineProperty(t, "TitleRendererBase", {
          enumerable: !0,
          get: function () {
            return ii.TitleRendererBase;
          },
        });
        var oi = r(24156);
        Object.defineProperty(t, "getAdjustedRotation", {
          enumerable: !0,
          get: function () {
            return oi.getAdjustedRotation;
          },
        });
        var ai = r(84392);
        Object.defineProperty(t, "AUTO_COLOR", {
          enumerable: !0,
          get: function () {
            return ai.AUTO_COLOR;
          },
        });
        var si = r(84392);
        Object.defineProperty(t, "ThemeProvider", {
          enumerable: !0,
          get: function () {
            return si.ThemeProvider;
          },
        });
        var ni = r(84392);
        Object.defineProperty(t, "stripAutoColor", {
          enumerable: !0,
          get: function () {
            return ni.stripAutoColor;
          },
        });
        var li = r(99016);
        Object.defineProperty(t, "SciChartJSDarkTheme", {
          enumerable: !0,
          get: function () {
            return li.SciChartJSDarkTheme;
          },
        });
        var di = r(2705);
        Object.defineProperty(t, "SciChartJSDarkv2Theme", {
          enumerable: !0,
          get: function () {
            return di.SciChartJSDarkv2Theme;
          },
        });
        var hi = r(60819);
        Object.defineProperty(t, "SciChartJSLightTheme", {
          enumerable: !0,
          get: function () {
            return hi.SciChartJSLightTheme;
          },
        });
        var ui = r(66010);
        Object.defineProperty(t, "SciChartJsNavyTheme", {
          enumerable: !0,
          get: function () {
            return ui.SciChartJsNavyTheme;
          },
        });
        var ci = r(23447);
        Object.defineProperty(t, "getSharedWasmContext", {
          enumerable: !0,
          get: function () {
            return ci.getSharedWasmContext;
          },
        });
        var pi = r(23447);
        Object.defineProperty(t, "initializeChartEngine2D", {
          enumerable: !0,
          get: function () {
            return pi.initializeChartEngine2D;
          },
        });
        var gi = r(31858);
        Object.defineProperty(t, "HeatmapLegend", {
          enumerable: !0,
          get: function () {
            return gi.HeatmapLegend;
          },
        });
        var yi = r(2056);
        Object.defineProperty(t, "licenseManager2dState", {
          enumerable: !0,
          get: function () {
            return yi.licenseManager2dState;
          },
        });
        var fi = r(66570);
        Object.defineProperty(t, "DefaultSciChartLoader", {
          enumerable: !0,
          get: function () {
            return fi.DefaultSciChartLoader;
          },
        });
        var vi = r(85479);
        Object.defineProperty(t, "SciChartDefaults", {
          enumerable: !0,
          get: function () {
            return vi.SciChartDefaults;
          },
        });
        var mi = r(36544);
        Object.defineProperty(t, "SciChartOverview", {
          enumerable: !0,
          get: function () {
            return mi.SciChartOverview;
          },
        });
        var Si = r(8320);
        Object.defineProperty(t, "SciChartPolarSubSurface", {
          enumerable: !0,
          get: function () {
            return Si.SciChartPolarSubSurface;
          },
        });
        var Pi = r(94416);
        Object.defineProperty(t, "SciChartPolarSurface", {
          enumerable: !0,
          get: function () {
            return Pi.SciChartPolarSurface;
          },
        });
        var Ci = r(25610);
        Object.defineProperty(t, "SciChartSubSurface", {
          enumerable: !0,
          get: function () {
            return Ci.SciChartSubSurface;
          },
        });
        var bi = r(75112);
        Object.defineProperty(t, "sciChartSubSurfaceCommon", {
          enumerable: !0,
          get: function () {
            return bi.sciChartSubSurfaceCommon;
          },
        });
        var xi = r(84626);
        Object.defineProperty(t, "sciChartConfig", {
          enumerable: !0,
          get: function () {
            return xi.sciChartConfig;
          },
        });
        var Ai = r(84626);
        Object.defineProperty(t, "SciChartSurface", {
          enumerable: !0,
          get: function () {
            return Ai.SciChartSurface;
          },
        });
        var Ti = r(14184);
        Object.defineProperty(t, "DebugForDpi", {
          enumerable: !0,
          get: function () {
            return Ti.DebugForDpi;
          },
        });
        var Ei = r(14184);
        Object.defineProperty(t, "SciChartSurfaceBase", {
          enumerable: !0,
          get: function () {
            return Ei.SciChartSurfaceBase;
          },
        });
        var Ri = r(14184);
        Object.defineProperty(t, "createChartDestination", {
          enumerable: !0,
          get: function () {
            return Ri.createChartDestination;
          },
        });
        var Di = r(83823);
        Object.defineProperty(t, "UpdateSuspender", {
          enumerable: !0,
          get: function () {
            return Di.UpdateSuspender;
          },
        });
        var wi = r(5102);
        Object.defineProperty(t, "AdornerLayer", {
          enumerable: !0,
          get: function () {
            return wi.AdornerLayer;
          },
        });
        var Mi = r(31306);
        Object.defineProperty(t, "EDraggingGripPoint", {
          enumerable: !0,
          get: function () {
            return Mi.EDraggingGripPoint;
          },
        });
        var Li = r(31306);
        Object.defineProperty(t, "ECoordinateMode", {
          enumerable: !0,
          get: function () {
            return Li.ECoordinateMode;
          },
        });
        var Oi = r(31306);
        Object.defineProperty(t, "AnnotationBase", {
          enumerable: !0,
          get: function () {
            return Oi.AnnotationBase;
          },
        });
        var Ii = r(28792);
        Object.defineProperty(t, "AnnotationClickEventArgs", {
          enumerable: !0,
          get: function () {
            return Ii.AnnotationClickEventArgs;
          },
        });
        var ki = r(78895);
        Object.defineProperty(t, "AnnotationDragDeltaEventArgs", {
          enumerable: !0,
          get: function () {
            return ki.AnnotationDragDeltaEventArgs;
          },
        });
        var _i = r(92415);
        Object.defineProperty(t, "annotationHelpers", {
          enumerable: !0,
          get: function () {
            return _i.annotationHelpers;
          },
        });
        var Vi = r(49641);
        Object.defineProperty(t, "AnnotationHoverEventArgs", {
          enumerable: !0,
          get: function () {
            return Vi.AnnotationHoverEventArgs;
          },
        });
        var Ni = r(40301);
        Object.defineProperty(t, "ArcAnnotation", {
          enumerable: !0,
          get: function () {
            return Ni.ArcAnnotation;
          },
        });
        var Bi = r(68955);
        Object.defineProperty(t, "ArcAnnotationBase", {
          enumerable: !0,
          get: function () {
            return Bi.ArcAnnotationBase;
          },
        });
        var Fi = r(29371);
        Object.defineProperty(t, "AxisMarkerAnnotation", {
          enumerable: !0,
          get: function () {
            return Fi.AxisMarkerAnnotation;
          },
        });
        var Hi = r(89171);
        Object.defineProperty(t, "BoxAnnotation", {
          enumerable: !0,
          get: function () {
            return Hi.BoxAnnotation;
          },
        });
        var Yi = r(64584);
        Object.defineProperty(t, "CursorTooltipSvgAnnotation", {
          enumerable: !0,
          get: function () {
            return Yi.CursorTooltipSvgAnnotation;
          },
        });
        var zi = r(48882);
        Object.defineProperty(t, "CustomAnnotation", {
          enumerable: !0,
          get: function () {
            return zi.CustomAnnotation;
          },
        });
        var ji = r(25107);
        Object.defineProperty(t, "CustomHtmlAnnotation", {
          enumerable: !0,
          get: function () {
            return ji.CustomHtmlAnnotation;
          },
        });
        var Xi = r(75704);
        Object.defineProperty(t, "DomAnnotationBase", {
          enumerable: !0,
          get: function () {
            return Xi.DomAnnotationBase;
          },
        });
        var Gi = r(96696);
        Object.defineProperty(t, "HorizontalLineAnnotation", {
          enumerable: !0,
          get: function () {
            return Gi.HorizontalLineAnnotation;
          },
        });
        var Wi = r(23272);
        Object.defineProperty(t, "HtmlTextAnnotation", {
          enumerable: !0,
          get: function () {
            return Wi.HtmlTextAnnotation;
          },
        });
        var Ui = r(84736);
        Object.defineProperty(t, "EAnnotationLayer", {
          enumerable: !0,
          get: function () {
            return Ui.EAnnotationLayer;
          },
        });
        var $i = r(84736);
        Object.defineProperty(t, "EAnnotationType", {
          enumerable: !0,
          get: function () {
            return $i.EAnnotationType;
          },
        });
        var Zi = r(28677);
        Object.defineProperty(t, "LineAnnotation", {
          enumerable: !0,
          get: function () {
            return Zi.LineAnnotation;
          },
        });
        var qi = r(40734);
        Object.defineProperty(t, "EArrowHeadPosition", {
          enumerable: !0,
          get: function () {
            return qi.EArrowHeadPosition;
          },
        });
        var Ki = r(40734);
        Object.defineProperty(t, "LineArrowAnnotation", {
          enumerable: !0,
          get: function () {
            return Ki.LineArrowAnnotation;
          },
        });
        var Ji = r(74370);
        Object.defineProperty(t, "EWrapTo", {
          enumerable: !0,
          get: function () {
            return Ji.EWrapTo;
          },
        });
        var Qi = r(74370);
        Object.defineProperty(t, "NativeTextAnnotation", {
          enumerable: !0,
          get: function () {
            return Qi.NativeTextAnnotation;
          },
        });
        var eo = r(12021);
        Object.defineProperty(t, "OverviewCustomResizableAnnotation", {
          enumerable: !0,
          get: function () {
            return eo.OverviewCustomResizableAnnotation;
          },
        });
        var to = r(11396);
        Object.defineProperty(t, "PolarArcAnnotation", {
          enumerable: !0,
          get: function () {
            return to.PolarArcAnnotation;
          },
        });
        var ro = r(26977);
        Object.defineProperty(t, "PolarPointerAnnotation", {
          enumerable: !0,
          get: function () {
            return ro.PolarPointerAnnotation;
          },
        });
        var io = r(29530);
        Object.defineProperty(t, "RenderContextAnnotationBase", {
          enumerable: !0,
          get: function () {
            return io.RenderContextAnnotationBase;
          },
        });
        var oo = r(69302);
        Object.defineProperty(t, "RolloverLegendSvgAnnotation", {
          enumerable: !0,
          get: function () {
            return oo.RolloverLegendSvgAnnotation;
          },
        });
        var ao = r(66443);
        Object.defineProperty(t, "RolloverMarkerSvgAnnotation", {
          enumerable: !0,
          get: function () {
            return ao.RolloverMarkerSvgAnnotation;
          },
        });
        var so = r(60915);
        Object.defineProperty(t, "RolloverTooltipSvgAnnotation", {
          enumerable: !0,
          get: function () {
            return so.RolloverTooltipSvgAnnotation;
          },
        });
        var no = r(84690);
        Object.defineProperty(t, "SvgAnnotationBase", {
          enumerable: !0,
          get: function () {
            return no.SvgAnnotationBase;
          },
        });
        var lo = r(49617);
        Object.defineProperty(t, "TextAnnotation", {
          enumerable: !0,
          get: function () {
            return lo.TextAnnotation;
          },
        });
        var ho = r(98409);
        Object.defineProperty(t, "VerticalLineAnnotation", {
          enumerable: !0,
          get: function () {
            return ho.VerticalLineAnnotation;
          },
        });
        var uo = r(57397);
        Object.defineProperty(t, "EClipMode", {
          enumerable: !0,
          get: function () {
            return uo.EClipMode;
          },
        });
        var co = r(57397);
        Object.defineProperty(t, "AxisBase2D", {
          enumerable: !0,
          get: function () {
            return co.AxisBase2D;
          },
        });
        var po = r(42241);
        Object.defineProperty(t, "AxisCore", {
          enumerable: !0,
          get: function () {
            return po.AxisCore;
          },
        });
        var go = r(87673);
        Object.defineProperty(t, "AxisLayoutState", {
          enumerable: !0,
          get: function () {
            return go.AxisLayoutState;
          },
        });
        var yo = r(87673);
        Object.defineProperty(t, "PolarAxisLayoutState", {
          enumerable: !0,
          get: function () {
            return yo.PolarAxisLayoutState;
          },
        });
        var fo = r(74736);
        Object.defineProperty(t, "AxisRenderer", {
          enumerable: !0,
          get: function () {
            return fo.AxisRenderer;
          },
        });
        var vo = r(14790);
        Object.defineProperty(t, "AxisTitleRenderer", {
          enumerable: !0,
          get: function () {
            return vo.AxisTitleRenderer;
          },
        });
        var mo = r(59516);
        Object.defineProperty(t, "CategoryAxis", {
          enumerable: !0,
          get: function () {
            return mo.CategoryAxis;
          },
        });
        var So = r(99269);
        Object.defineProperty(t, "CategoryAxisBase", {
          enumerable: !0,
          get: function () {
            return So.CategoryAxisBase;
          },
        });
        var Po = r(2296);
        Object.defineProperty(t, "DateTimeNumericAxis", {
          enumerable: !0,
          get: function () {
            return Po.DateTimeNumericAxis;
          },
        });
        var Co = r(74734);
        Object.defineProperty(t, "getAxisById", {
          enumerable: !0,
          get: function () {
            return Co.getAxisById;
          },
        });
        var bo = r(74734);
        Object.defineProperty(t, "getAxis3dById", {
          enumerable: !0,
          get: function () {
            return bo.getAxis3dById;
          },
        });
        var xo = r(51392);
        Object.defineProperty(t, "MIN_LOG_AXIS_VALUE", {
          enumerable: !0,
          get: function () {
            return xo.MIN_LOG_AXIS_VALUE;
          },
        });
        var Ao = r(51392);
        Object.defineProperty(t, "LogarithmicAxis", {
          enumerable: !0,
          get: function () {
            return Ao.LogarithmicAxis;
          },
        });
        var To = r(54948);
        Object.defineProperty(t, "NumericAxis", {
          enumerable: !0,
          get: function () {
            return To.NumericAxis;
          },
        });
        var Eo = r(83989);
        Object.defineProperty(t, "VisibleRangeChangedArgs", {
          enumerable: !0,
          get: function () {
            return Eo.VisibleRangeChangedArgs;
          },
        });
        var Ro = r(4220);
        Object.defineProperty(t, "CategoryDeltaCalculator", {
          enumerable: !0,
          get: function () {
            return Ro.CategoryDeltaCalculator;
          },
        });
        var Do = r(7899);
        Object.defineProperty(t, "DateTimeDeltaCalculator", {
          enumerable: !0,
          get: function () {
            return Do.DateTimeDeltaCalculator;
          },
        });
        var wo = r(69738);
        Object.defineProperty(t, "DeltaCalculator", {
          enumerable: !0,
          get: function () {
            return wo.DeltaCalculator;
          },
        });
        var Mo = r(19643);
        Object.defineProperty(t, "LogarithmicDeltaCalculator", {
          enumerable: !0,
          get: function () {
            return Mo.LogarithmicDeltaCalculator;
          },
        });
        var Lo = r(40059);
        Object.defineProperty(t, "NumericDeltaCalculator", {
          enumerable: !0,
          get: function () {
            return Lo.NumericDeltaCalculator;
          },
        });
        var Oo = r(78471);
        Object.defineProperty(t, "DateLabelProvider", {
          enumerable: !0,
          get: function () {
            return Oo.DateLabelProvider;
          },
        });
        var Io = r(16155);
        Object.defineProperty(t, "labelCache", {
          enumerable: !0,
          get: function () {
            return Io.labelCache;
          },
        });
        var ko = r(50687);
        Object.defineProperty(t, "LabelProvider", {
          enumerable: !0,
          get: function () {
            return ko.LabelProvider;
          },
        });
        var _o = r(19833);
        Object.defineProperty(t, "LabelInfo", {
          enumerable: !0,
          get: function () {
            return _o.LabelInfo;
          },
        });
        var Vo = r(19833);
        Object.defineProperty(t, "LabelProviderBase2D", {
          enumerable: !0,
          get: function () {
            return Vo.LabelProviderBase2D;
          },
        });
        var No = r(48767);
        Object.defineProperty(t, "LogarithmicLabelProvider", {
          enumerable: !0,
          get: function () {
            return No.LogarithmicLabelProvider;
          },
        });
        var Bo = r(39920);
        Object.defineProperty(t, "NumericLabelProvider", {
          enumerable: !0,
          get: function () {
            return Bo.NumericLabelProvider;
          },
        });
        var Fo = r(92596);
        Object.defineProperty(t, "PieLabelProvider", {
          enumerable: !0,
          get: function () {
            return Fo.PieLabelProvider;
          },
        });
        var Ho = r(20268);
        Object.defineProperty(t, "RadianLabelProvider", {
          enumerable: !0,
          get: function () {
            return Ho.RadianLabelProvider;
          },
        });
        var Yo = r(68695);
        Object.defineProperty(t, "ETradeChartLabelFormat", {
          enumerable: !0,
          get: function () {
            return Yo.ETradeChartLabelFormat;
          },
        });
        var zo = r(68695);
        Object.defineProperty(t, "SmartDateLabelProvider", {
          enumerable: !0,
          get: function () {
            return zo.SmartDateLabelProvider;
          },
        });
        var jo = r(18184);
        Object.defineProperty(t, "TextLabelProvider", {
          enumerable: !0,
          get: function () {
            return jo.TextLabelProvider;
          },
        });
        var Xo = r(18184);
        Object.defineProperty(t, "wrapText", {
          enumerable: !0,
          get: function () {
            return Xo.wrapText;
          },
        });
        var Go = r(52320);
        Object.defineProperty(t, "PolarAxisBase", {
          enumerable: !0,
          get: function () {
            return Go.PolarAxisBase;
          },
        });
        var Wo = r(31951);
        Object.defineProperty(t, "PolarAxisRenderer", {
          enumerable: !0,
          get: function () {
            return Wo.PolarAxisRenderer;
          },
        });
        var Uo = r(1370);
        Object.defineProperty(t, "PolarCategoryAxis", {
          enumerable: !0,
          get: function () {
            return Uo.PolarCategoryAxis;
          },
        });
        var $o = r(63922);
        Object.defineProperty(t, "PolarNumericAxis", {
          enumerable: !0,
          get: function () {
            return $o.PolarNumericAxis;
          },
        });
        var Zo = r(16989);
        Object.defineProperty(t, "EPolarAxisMode", {
          enumerable: !0,
          get: function () {
            return Zo.EPolarAxisMode;
          },
        });
        var qo = r(80574);
        Object.defineProperty(t, "EPolarGridlineMode", {
          enumerable: !0,
          get: function () {
            return qo.EPolarGridlineMode;
          },
        });
        var Ko = r(8827);
        Object.defineProperty(t, "EPolarLabelMode", {
          enumerable: !0,
          get: function () {
            return Ko.EPolarLabelMode;
          },
        });
        var Jo = r(63458);
        Object.defineProperty(t, "createNativeRect", {
          enumerable: !0,
          get: function () {
            return Jo.createNativeRect;
          },
        });
        var Qo = r(47376);
        Object.defineProperty(t, "createSCRTPen", {
          enumerable: !0,
          get: function () {
            return Qo.createSCRTPen;
          },
        });
        var ea = r(33841);
        Object.defineProperty(t, "createSolidBrush", {
          enumerable: !0,
          get: function () {
            return ea.createSolidBrush;
          },
        });
        var ta = r(94389);
        Object.defineProperty(t, "drawBorder", {
          enumerable: !0,
          get: function () {
            return ta.drawBorder;
          },
        });
        var ra = r(3441);
        Object.defineProperty(t, "drawModifiersAxisLabel", {
          enumerable: !0,
          get: function () {
            return ra.drawModifiersAxisLabel;
          },
        });
        var ia = r(3441);
        Object.defineProperty(t, "drawLineAnnotation", {
          enumerable: !0,
          get: function () {
            return ia.drawLineAnnotation;
          },
        });
        var oa = r(3441);
        Object.defineProperty(t, "drawAxisMarkerAnnotation", {
          enumerable: !0,
          get: function () {
            return oa.drawAxisMarkerAnnotation;
          },
        });
        var aa = r(3441);
        Object.defineProperty(t, "getLabelCoordinates", {
          enumerable: !0,
          get: function () {
            return aa.getLabelCoordinates;
          },
        });
        var sa = r(10572);
        Object.defineProperty(t, "labelHelper", {
          enumerable: !0,
          get: function () {
            return sa.labelHelper;
          },
        });
        var na = r(98353);
        Object.defineProperty(t, "FontKey", {
          enumerable: !0,
          get: function () {
            return na.FontKey;
          },
        });
        var la = r(98353);
        Object.defineProperty(t, "deleteCache", {
          enumerable: !0,
          get: function () {
            return la.deleteCache;
          },
        });
        var da = r(98353);
        Object.defineProperty(t, "freeCache", {
          enumerable: !0,
          get: function () {
            return da.freeCache;
          },
        });
        var ha = r(98353);
        Object.defineProperty(t, "getVectorRectVertex", {
          enumerable: !0,
          get: function () {
            return ha.getVectorRectVertex;
          },
        });
        var ua = r(98353);
        Object.defineProperty(t, "getVectorColorVertex", {
          enumerable: !0,
          get: function () {
            return ua.getVectorColorVertex;
          },
        });
        var ca = r(98353);
        Object.defineProperty(t, "getVectorColorTextureVertex", {
          enumerable: !0,
          get: function () {
            return ca.getVectorColorTextureVertex;
          },
        });
        var pa = r(98353);
        Object.defineProperty(t, "getVectorArcVertex", {
          enumerable: !0,
          get: function () {
            return pa.getVectorArcVertex;
          },
        });
        var ga = r(98353);
        Object.defineProperty(t, "getVertex", {
          enumerable: !0,
          get: function () {
            return ga.getVertex;
          },
        });
        var ya = r(98353);
        Object.defineProperty(t, "getArcVertex", {
          enumerable: !0,
          get: function () {
            return ya.getArcVertex;
          },
        });
        var fa = r(98353);
        Object.defineProperty(t, "getTextureVertex", {
          enumerable: !0,
          get: function () {
            return fa.getTextureVertex;
          },
        });
        var va = r(98353);
        Object.defineProperty(t, "getTextBounds", {
          enumerable: !0,
          get: function () {
            return va.getTextBounds;
          },
        });
        var ma = r(98353);
        Object.defineProperty(t, "getNativeRect", {
          enumerable: !0,
          get: function () {
            return ma.getNativeRect;
          },
        });
        var Sa = r(98353);
        Object.defineProperty(t, "getVector4", {
          enumerable: !0,
          get: function () {
            return Sa.getVector4;
          },
        });
        var Pa = r(98353);
        Object.defineProperty(t, "getVector2", {
          enumerable: !0,
          get: function () {
            return Pa.getVector2;
          },
        });
        var Ca = r(98353);
        Object.defineProperty(t, "getVector3", {
          enumerable: !0,
          get: function () {
            return Ca.getVector3;
          },
        });
        var ba = r(98353);
        Object.defineProperty(t, "getFontKey", {
          enumerable: !0,
          get: function () {
            return ba.getFontKey;
          },
        });
        var xa = r(98353);
        Object.defineProperty(t, "getAllFontKeys", {
          enumerable: !0,
          get: function () {
            return xa.getAllFontKeys;
          },
        });
        var Aa = r(62288);
        Object.defineProperty(t, "polarChartHelper", {
          enumerable: !0,
          get: function () {
            return Aa.polarChartHelper;
          },
        });
        var Ta = r(97703);
        Object.defineProperty(t, "ManualLegend", {
          enumerable: !0,
          get: function () {
            return Ta.ManualLegend;
          },
        });
        var Ea = r(96260);
        Object.defineProperty(t, "SciChartLegend", {
          enumerable: !0,
          get: function () {
            return Ea.SciChartLegend;
          },
        });
        var Ra = r(88266);
        Object.defineProperty(t, "ELegendOrientation", {
          enumerable: !0,
          get: function () {
            return Ra.ELegendOrientation;
          },
        });
        var Da = r(88266);
        Object.defineProperty(t, "ELegendPlacement", {
          enumerable: !0,
          get: function () {
            return Da.ELegendPlacement;
          },
        });
        var wa = r(88266);
        Object.defineProperty(t, "ELegendType", {
          enumerable: !0,
          get: function () {
            return wa.ELegendType;
          },
        });
        var Ma = r(88266);
        Object.defineProperty(t, "SciChartLegendBase", {
          enumerable: !0,
          get: function () {
            return Ma.SciChartLegendBase;
          },
        });
        var La = r(88266);
        Object.defineProperty(t, "getLegendItemHtml", {
          enumerable: !0,
          get: function () {
            return La.getLegendItemHtml;
          },
        });
        var Oa = r(88266);
        Object.defineProperty(t, "getLegendContainerHtml", {
          enumerable: !0,
          get: function () {
            return Oa.getLegendContainerHtml;
          },
        });
        var Ia = r(28243);
        Object.defineProperty(t, "SciChartPieLegend", {
          enumerable: !0,
          get: function () {
            return Ia.SciChartPieLegend;
          },
        });
        var ka = r(27467);
        Object.defineProperty(t, "BasePointMarker", {
          enumerable: !0,
          get: function () {
            return ka.BasePointMarker;
          },
        });
        var _a = r(22745);
        Object.defineProperty(t, "CrossPointMarker", {
          enumerable: !0,
          get: function () {
            return _a.CrossPointMarker;
          },
        });
        var Va = r(10749);
        Object.defineProperty(t, "EllipsePointMarker", {
          enumerable: !0,
          get: function () {
            return Va.EllipsePointMarker;
          },
        });
        var Na = r(21033);
        Object.defineProperty(t, "SpritePointMarker", {
          enumerable: !0,
          get: function () {
            return Na.SpritePointMarker;
          },
        });
        var Ba = r(77057);
        Object.defineProperty(t, "SquarePointMarker", {
          enumerable: !0,
          get: function () {
            return Ba.SquarePointMarker;
          },
        });
        var Fa = r(58229);
        Object.defineProperty(t, "TrianglePointMarker", {
          enumerable: !0,
          get: function () {
            return Fa.TrianglePointMarker;
          },
        });
        var Ha = r(61704);
        Object.defineProperty(t, "XPointMarker", {
          enumerable: !0,
          get: function () {
            return Ha.XPointMarker;
          },
        });
        var Ya = r(20181);
        Object.defineProperty(t, "BaseBandRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ya.BaseBandRenderableSeries;
          },
        });
        var za = r(53904);
        Object.defineProperty(t, "BaseHeatmapRenderableSeries", {
          enumerable: !0,
          get: function () {
            return za.BaseHeatmapRenderableSeries;
          },
        });
        var ja = r(20782);
        Object.defineProperty(t, "ELineType", {
          enumerable: !0,
          get: function () {
            return ja.ELineType;
          },
        });
        var Xa = r(20782);
        Object.defineProperty(t, "BaseLineRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Xa.BaseLineRenderableSeries;
          },
        });
        var Ga = r(36650);
        Object.defineProperty(t, "BaseMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ga.BaseMountainRenderableSeries;
          },
        });
        var Wa = r(18790);
        Object.defineProperty(t, "BaseOhlcRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Wa.BaseOhlcRenderableSeries;
          },
        });
        var Ua = r(79961);
        Object.defineProperty(t, "BaseRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ua.BaseRenderableSeries;
          },
        });
        var $a = r(35246);
        Object.defineProperty(t, "BaseStackedCollection", {
          enumerable: !0,
          get: function () {
            return $a.BaseStackedCollection;
          },
        });
        var Za = r(73124);
        Object.defineProperty(t, "BaseStackedMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Za.BaseStackedMountainRenderableSeries;
          },
        });
        var qa = r(48335);
        Object.defineProperty(t, "BaseStackedRenderableSeries", {
          enumerable: !0,
          get: function () {
            return qa.BaseStackedRenderableSeries;
          },
        });
        var Ka = r(98550);
        Object.defineProperty(t, "FastBandRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ka.FastBandRenderableSeries;
          },
        });
        var Ja = r(33236);
        Object.defineProperty(t, "FastBoxPlotRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ja.FastBoxPlotRenderableSeries;
          },
        });
        var Qa = r(11555);
        Object.defineProperty(t, "FastBubbleRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Qa.FastBubbleRenderableSeries;
          },
        });
        var es = r(12641);
        Object.defineProperty(t, "FastCandlestickRenderableSeries", {
          enumerable: !0,
          get: function () {
            return es.FastCandlestickRenderableSeries;
          },
        });
        var ts = r(20667);
        Object.defineProperty(t, "FastColumnRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ts.FastColumnRenderableSeries;
          },
        });
        var rs = r(20667);
        Object.defineProperty(t, "getXRange", {
          enumerable: !0,
          get: function () {
            return rs.getXRange;
          },
        });
        var is = r(43852);
        Object.defineProperty(t, "FastErrorBarsRenderableSeries", {
          enumerable: !0,
          get: function () {
            return is.FastErrorBarsRenderableSeries;
          },
        });
        var os = r(93522);
        Object.defineProperty(t, "FastImpulseRenderableSeries", {
          enumerable: !0,
          get: function () {
            return os.FastImpulseRenderableSeries;
          },
        });
        var as = r(65297);
        Object.defineProperty(t, "FastLineRenderableSeries", {
          enumerable: !0,
          get: function () {
            return as.FastLineRenderableSeries;
          },
        });
        var ss = r(72362);
        Object.defineProperty(t, "FastMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ss.FastMountainRenderableSeries;
          },
        });
        var ns = r(95179);
        Object.defineProperty(t, "FastOhlcRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ns.FastOhlcRenderableSeries;
          },
        });
        var ls = r(16098);
        Object.defineProperty(t, "FastRectangleRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ls.FastRectangleRenderableSeries;
          },
        });
        var ds = r(89078);
        Object.defineProperty(t, "FastTextRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ds.FastTextRenderableSeries;
          },
        });
        var hs = r(21037);
        Object.defineProperty(t, "GlowEffect", {
          enumerable: !0,
          get: function () {
            return hs.GlowEffect;
          },
        });
        var us = r(60981);
        Object.defineProperty(t, "HeatmapColorMap", {
          enumerable: !0,
          get: function () {
            return us.HeatmapColorMap;
          },
        });
        var cs = r(69570);
        Object.defineProperty(t, "HoveredChangedArgs", {
          enumerable: !0,
          get: function () {
            return cs.HoveredChangedArgs;
          },
        });
        var ps = r(55303);
        Object.defineProperty(t, "LineSegmentRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ps.LineSegmentRenderableSeries;
          },
        });
        var gs = r(50085);
        Object.defineProperty(t, "NonUniformHeatmapRenderableSeries", {
          enumerable: !0,
          get: function () {
            return gs.NonUniformHeatmapRenderableSeries;
          },
        });
        var ys = r(9150);
        Object.defineProperty(t, "SelectionChangedArgs", {
          enumerable: !0,
          get: function () {
            return ys.SelectionChangedArgs;
          },
        });
        var fs = r(57318);
        Object.defineProperty(t, "SeriesHoveredArgs", {
          enumerable: !0,
          get: function () {
            return fs.SeriesHoveredArgs;
          },
        });
        var vs = r(29593);
        Object.defineProperty(t, "SeriesSelectedArgs", {
          enumerable: !0,
          get: function () {
            return vs.SeriesSelectedArgs;
          },
        });
        var ms = r(72469);
        Object.defineProperty(t, "SeriesVisibleChangedArgs", {
          enumerable: !0,
          get: function () {
            return ms.SeriesVisibleChangedArgs;
          },
        });
        var Ss = r(93545);
        Object.defineProperty(t, "ShaderEffect", {
          enumerable: !0,
          get: function () {
            return Ss.ShaderEffect;
          },
        });
        var Ps = r(68264);
        Object.defineProperty(t, "ShadowEffect", {
          enumerable: !0,
          get: function () {
            return Ps.ShadowEffect;
          },
        });
        var Cs = r(56664);
        Object.defineProperty(t, "SmoothStackedMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Cs.SmoothStackedMountainRenderableSeries;
          },
        });
        var bs = r(78146);
        Object.defineProperty(t, "SplineBandRenderableSeries", {
          enumerable: !0,
          get: function () {
            return bs.SplineBandRenderableSeries;
          },
        });
        var xs = r(32471);
        Object.defineProperty(t, "SplineLineRenderableSeries", {
          enumerable: !0,
          get: function () {
            return xs.SplineLineRenderableSeries;
          },
        });
        var As = r(86109);
        Object.defineProperty(t, "SplineMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return As.SplineMountainRenderableSeries;
          },
        });
        var Ts = r(1406);
        Object.defineProperty(t, "StackedColumnCollection", {
          enumerable: !0,
          get: function () {
            return Ts.StackedColumnCollection;
          },
        });
        var Es = r(83262);
        Object.defineProperty(t, "StackedColumnRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Es.StackedColumnRenderableSeries;
          },
        });
        var Rs = r(71719);
        Object.defineProperty(t, "StackedMountainCollection", {
          enumerable: !0,
          get: function () {
            return Rs.StackedMountainCollection;
          },
        });
        var Ds = r(1391);
        Object.defineProperty(t, "StackedMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ds.StackedMountainRenderableSeries;
          },
        });
        var ws = r(11529);
        Object.defineProperty(t, "StackedXyCollection", {
          enumerable: !0,
          get: function () {
            return ws.StackedXyCollection;
          },
        });
        var Ms = r(51852);
        Object.defineProperty(t, "TriangleRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Ms.TriangleRenderableSeries;
          },
        });
        var Ls = r(88189);
        Object.defineProperty(t, "EContourColorMapMode", {
          enumerable: !0,
          get: function () {
            return Ls.EContourColorMapMode;
          },
        });
        var Os = r(88189);
        Object.defineProperty(t, "UniformContoursRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Os.UniformContoursRenderableSeries;
          },
        });
        var Is = r(70033);
        Object.defineProperty(t, "UniformHeatmapRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Is.UniformHeatmapRenderableSeries;
          },
        });
        var ks = r(52954);
        Object.defineProperty(t, "XyScatterRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ks.XyScatterRenderableSeries;
          },
        });
        var _s = r(54580);
        Object.defineProperty(t, "animationHelpers", {
          enumerable: !0,
          get: function () {
            return _s.animationHelpers;
          },
        });
        var Vs = r(27501);
        Object.defineProperty(t, "BandAnimation", {
          enumerable: !0,
          get: function () {
            return Vs.BandAnimation;
          },
        });
        var Ns = r(25923);
        Object.defineProperty(t, "BandAnimationStyle", {
          enumerable: !0,
          get: function () {
            return Ns.BandAnimationStyle;
          },
        });
        var Bs = r(63642);
        Object.defineProperty(t, "BaseAnimationStyle", {
          enumerable: !0,
          get: function () {
            return Bs.BaseAnimationStyle;
          },
        });
        var Fs = r(88227);
        Object.defineProperty(t, "BasePointMarkerStyle", {
          enumerable: !0,
          get: function () {
            return Fs.BasePointMarkerStyle;
          },
        });
        var Hs = r(61690);
        Object.defineProperty(t, "BubbleAnimation", {
          enumerable: !0,
          get: function () {
            return Hs.BubbleAnimation;
          },
        });
        var Ys = r(86551);
        Object.defineProperty(t, "CandlestickAnimation", {
          enumerable: !0,
          get: function () {
            return Ys.CandlestickAnimation;
          },
        });
        var zs = r(50951);
        Object.defineProperty(t, "CandlestickAnimationStyle", {
          enumerable: !0,
          get: function () {
            return zs.CandlestickAnimationStyle;
          },
        });
        var js = r(9687);
        Object.defineProperty(t, "ColumnAnimation", {
          enumerable: !0,
          get: function () {
            return js.ColumnAnimation;
          },
        });
        var Xs = r(37886);
        Object.defineProperty(t, "ColumnAnimationStyle", {
          enumerable: !0,
          get: function () {
            return Xs.ColumnAnimationStyle;
          },
        });
        var Gs = r(386);
        Object.defineProperty(t, "CustomPointMarkerStyle", {
          enumerable: !0,
          get: function () {
            return Gs.CustomPointMarkerStyle;
          },
        });
        var Ws = r(62314);
        Object.defineProperty(t, "FadeAnimation", {
          enumerable: !0,
          get: function () {
            return Ws.FadeAnimation;
          },
        });
        var Us = r(98499);
        Object.defineProperty(t, "LineAnimation", {
          enumerable: !0,
          get: function () {
            return Us.LineAnimation;
          },
        });
        var $s = r(65122);
        Object.defineProperty(t, "MountainAnimation", {
          enumerable: !0,
          get: function () {
            return $s.MountainAnimation;
          },
        });
        var Zs = r(3911);
        Object.defineProperty(t, "MountainAnimationStyle", {
          enumerable: !0,
          get: function () {
            return Zs.MountainAnimationStyle;
          },
        });
        var qs = r(86717);
        Object.defineProperty(t, "OhlcAnimation", {
          enumerable: !0,
          get: function () {
            return qs.OhlcAnimation;
          },
        });
        var Ks = r(54938);
        Object.defineProperty(t, "OhlcAnimationStyle", {
          enumerable: !0,
          get: function () {
            return Ks.OhlcAnimationStyle;
          },
        });
        var Js = r(49987);
        Object.defineProperty(t, "PointMarkerStyle", {
          enumerable: !0,
          get: function () {
            return Js.PointMarkerStyle;
          },
        });
        var Qs = r(56705);
        Object.defineProperty(t, "ScaleAnimation", {
          enumerable: !0,
          get: function () {
            return Qs.ScaleAnimation;
          },
        });
        var en = r(16911);
        Object.defineProperty(t, "ScatterAnimation", {
          enumerable: !0,
          get: function () {
            return en.ScatterAnimation;
          },
        });
        var tn = r(55371);
        Object.defineProperty(t, "SeriesAnimation", {
          enumerable: !0,
          get: function () {
            return tn.SeriesAnimation;
          },
        });
        var rn = r(592);
        Object.defineProperty(t, "SweepAnimation", {
          enumerable: !0,
          get: function () {
            return rn.SweepAnimation;
          },
        });
        var on = r(56498);
        Object.defineProperty(t, "WaveAnimation", {
          enumerable: !0,
          get: function () {
            return on.WaveAnimation;
          },
        });
        var an = r(81856);
        Object.defineProperty(t, "BandSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return an.BandSeriesDataLabelProvider;
          },
        });
        var sn = r(49613);
        Object.defineProperty(t, "BaseDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return sn.BaseDataLabelProvider;
          },
        });
        var nn = r(15273);
        Object.defineProperty(t, "BubbleSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return nn.BubbleSeriesDataLabelProvider;
          },
        });
        var ln = r(1367);
        Object.defineProperty(t, "EColumnDataLabelPosition", {
          enumerable: !0,
          get: function () {
            return ln.EColumnDataLabelPosition;
          },
        });
        var dn = r(1367);
        Object.defineProperty(t, "ColumnSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return dn.ColumnSeriesDataLabelProvider;
          },
        });
        var hn = r(9488);
        Object.defineProperty(t, "ContoursDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return hn.ContoursDataLabelProvider;
          },
        });
        var un = r(77110);
        Object.defineProperty(t, "dataLabelHelpers", {
          enumerable: !0,
          get: function () {
            return un.dataLabelHelpers;
          },
        });
        var cn = r(96852);
        Object.defineProperty(t, "DataLabelProvider", {
          enumerable: !0,
          get: function () {
            return cn.DataLabelProvider;
          },
        });
        var pn = r(55172);
        Object.defineProperty(t, "DataLabelState", {
          enumerable: !0,
          get: function () {
            return pn.DataLabelState;
          },
        });
        var gn = r(75933);
        Object.defineProperty(t, "HeatMapDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return gn.HeatMapDataLabelProvider;
          },
        });
        var yn = r(33802);
        Object.defineProperty(t, "LineSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return yn.LineSeriesDataLabelProvider;
          },
        });
        var fn = r(31544);
        Object.defineProperty(t, "NonUniformHeatMapDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return fn.NonUniformHeatMapDataLabelProvider;
          },
        });
        var vn = r(98585);
        Object.defineProperty(t, "RectangleDataLabelState", {
          enumerable: !0,
          get: function () {
            return vn.RectangleDataLabelState;
          },
        });
        var mn = r(70027);
        Object.defineProperty(t, "RectangleSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return mn.RectangleSeriesDataLabelProvider;
          },
        });
        var Sn = r(93752);
        Object.defineProperty(t, "StackedCollectionDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return Sn.StackedCollectionDataLabelProvider;
          },
        });
        var Pn = r(74026);
        Object.defineProperty(t, "StackedColumnSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return Pn.StackedColumnSeriesDataLabelProvider;
          },
        });
        var Cn = r(1126);
        Object.defineProperty(t, "TextDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return Cn.TextDataLabelProvider;
          },
        });
        var bn = r(7807);
        Object.defineProperty(t, "BandSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return bn.BandSeriesDrawingProvider;
          },
        });
        var xn = r(65043);
        Object.defineProperty(t, "BaseSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return xn.BaseSeriesDrawingProvider;
          },
        });
        var An = r(79687);
        Object.defineProperty(t, "BoxPlotSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return An.BoxPlotSeriesDrawingProvider;
          },
        });
        var Tn = r(9297);
        Object.defineProperty(t, "BubbleSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Tn.BubbleSeriesDrawingProvider;
          },
        });
        var En = r(50836);
        Object.defineProperty(t, "ColumnSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return En.ColumnSeriesDrawingProvider;
          },
        });
        var Rn = r(71788);
        Object.defineProperty(t, "ErrorSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Rn.ErrorSeriesDrawingProvider;
          },
        });
        var Dn = r(24315);
        Object.defineProperty(t, "getColorDataForTexture", {
          enumerable: !0,
          get: function () {
            return Dn.getColorDataForTexture;
          },
        });
        var wn = r(24315);
        Object.defineProperty(t, "getColor", {
          enumerable: !0,
          get: function () {
            return wn.getColor;
          },
        });
        var Mn = r(24315);
        Object.defineProperty(t, "createColorMap", {
          enumerable: !0,
          get: function () {
            return Mn.createColorMap;
          },
        });
        var Ln = r(24315);
        Object.defineProperty(t, "calculateOffsets", {
          enumerable: !0,
          get: function () {
            return Ln.calculateOffsets;
          },
        });
        var On = r(24315);
        Object.defineProperty(t, "calculateCellCoordinates", {
          enumerable: !0,
          get: function () {
            return On.calculateCellCoordinates;
          },
        });
        var In = r(24315);
        Object.defineProperty(t, "calculateHeatmapTexture", {
          enumerable: !0,
          get: function () {
            return In.calculateHeatmapTexture;
          },
        });
        var kn = r(81284);
        Object.defineProperty(t, "HeightSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return kn.HeightSeriesDrawingProvider;
          },
        });
        var _n = r(66743);
        Object.defineProperty(t, "LineSegmentSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return _n.LineSegmentSeriesDrawingProvider;
          },
        });
        var Vn = r(36898);
        Object.defineProperty(t, "LineSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Vn.LineSeriesDrawingProvider;
          },
        });
        var Nn = r(36877);
        Object.defineProperty(t, "MountainSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Nn.MountainSeriesDrawingProvider;
          },
        });
        var Bn = r(37182);
        Object.defineProperty(t, "NonUniformHeatmapDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Bn.NonUniformHeatmapDrawingProvider;
          },
        });
        var Fn = r(88302);
        Object.defineProperty(t, "EOhlcDrawingMode", {
          enumerable: !0,
          get: function () {
            return Fn.EOhlcDrawingMode;
          },
        });
        var Hn = r(88302);
        Object.defineProperty(t, "OhlcSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Hn.OhlcSeriesDrawingProvider;
          },
        });
        var Yn = r(94707);
        Object.defineProperty(t, "PointMarkerDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Yn.PointMarkerDrawingProvider;
          },
        });
        var zn = r(13473);
        Object.defineProperty(t, "RectangleSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return zn.RectangleSeriesDrawingProvider;
          },
        });
        var jn = r(68015);
        Object.defineProperty(t, "SmearSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return jn.SmearSeriesDrawingProvider;
          },
        });
        var Xn = r(74397);
        Object.defineProperty(t, "TriangleSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Xn.TriangleSeriesDrawingProvider;
          },
        });
        var Gn = r(9184);
        Object.defineProperty(t, "UniformContoursDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Gn.UniformContoursDrawingProvider;
          },
        });
        var Wn = r(76566);
        Object.defineProperty(t, "UniformHeatmapDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Wn.UniformHeatmapDrawingProvider;
          },
        });
        var Un = r(72704);
        Object.defineProperty(t, "BandSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return Un.BandSeriesHitTestProvider;
          },
        });
        var $n = r(7541);
        Object.defineProperty(t, "BaseHitTestProvider", {
          enumerable: !0,
          get: function () {
            return $n.BaseHitTestProvider;
          },
        });
        var Zn = r(82767);
        Object.defineProperty(t, "BoxPlotSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return Zn.BoxPlotSeriesHitTestProvider;
          },
        });
        var qn = r(89748);
        Object.defineProperty(t, "BubbleSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return qn.BubbleSeriesHitTestProvider;
          },
        });
        var Kn = r(18314);
        Object.defineProperty(t, "ColumnSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return Kn.ColumnSeriesHitTestProvider;
          },
        });
        var Jn = r(99828);
        Object.defineProperty(t, "ErrorSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return Jn.ErrorSeriesHitTestProvider;
          },
        });
        var Qn = r(85414);
        Object.defineProperty(t, "hitTestHelpers", {
          enumerable: !0,
          get: function () {
            return Qn.hitTestHelpers;
          },
        });
        var el = r(51462);
        Object.defineProperty(t, "hitTestHelpersRectangleSeries", {
          enumerable: !0,
          get: function () {
            return el.hitTestHelpersRectangleSeries;
          },
        });
        var tl = r(35013);
        Object.defineProperty(t, "HitTestInfo", {
          enumerable: !0,
          get: function () {
            return tl.HitTestInfo;
          },
        });
        var rl = r(30995);
        Object.defineProperty(t, "ImpulseSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return rl.ImpulseSeriesHitTestProvider;
          },
        });
        var il = r(98888);
        Object.defineProperty(t, "LineSegmentSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return il.LineSegmentSeriesHitTestProvider;
          },
        });
        var ol = r(28628);
        Object.defineProperty(t, "LineSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return ol.LineSeriesHitTestProvider;
          },
        });
        var al = r(47453);
        Object.defineProperty(t, "MountainSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return al.MountainSeriesHitTestProvider;
          },
        });
        var sl = r(80456);
        Object.defineProperty(t, "NonUniformHeatmapHitTestProvider", {
          enumerable: !0,
          get: function () {
            return sl.NonUniformHeatmapHitTestProvider;
          },
        });
        var nl = r(8535);
        Object.defineProperty(t, "OhlcSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return nl.OhlcSeriesHitTestProvider;
          },
        });
        var ll = r(92762);
        Object.defineProperty(t, "RectangleSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return ll.RectangleSeriesHitTestProvider;
          },
        });
        var dl = r(64485);
        Object.defineProperty(t, "ScatterSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return dl.ScatterSeriesHitTestProvider;
          },
        });
        var hl = r(51825);
        Object.defineProperty(t, "StackedColumnSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return hl.StackedColumnSeriesHitTestProvider;
          },
        });
        var ul = r(99846);
        Object.defineProperty(t, "StackedMountainSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return ul.StackedMountainSeriesHitTestProvider;
          },
        });
        var cl = r(92231);
        Object.defineProperty(t, "TextSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return cl.TextSeriesHitTestProvider;
          },
        });
        var pl = r(22735);
        Object.defineProperty(t, "TriangleSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return pl.TriangleSeriesHitTestProvider;
          },
        });
        var gl = r(3798);
        Object.defineProperty(t, "UniformHeatmapHitTestProvider", {
          enumerable: !0,
          get: function () {
            return gl.UniformHeatmapHitTestProvider;
          },
        });
        var yl = r(83187);
        Object.defineProperty(t, "PolarBandRenderableSeries", {
          enumerable: !0,
          get: function () {
            return yl.PolarBandRenderableSeries;
          },
        });
        var fl = r(38831);
        Object.defineProperty(t, "PolarColumnRenderableSeries", {
          enumerable: !0,
          get: function () {
            return fl.PolarColumnRenderableSeries;
          },
        });
        var vl = r(4455);
        Object.defineProperty(t, "PolarLineRenderableSeries", {
          enumerable: !0,
          get: function () {
            return vl.PolarLineRenderableSeries;
          },
        });
        var ml = r(88409);
        Object.defineProperty(t, "PolarMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return ml.PolarMountainRenderableSeries;
          },
        });
        var Sl = r(2928);
        Object.defineProperty(t, "PolarStackedColumnCollection", {
          enumerable: !0,
          get: function () {
            return Sl.PolarStackedColumnCollection;
          },
        });
        var Pl = r(2270);
        Object.defineProperty(t, "PolarStackedColumnRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Pl.PolarStackedColumnRenderableSeries;
          },
        });
        var Cl = r(68584);
        Object.defineProperty(t, "PolarStackedMountainCollection", {
          enumerable: !0,
          get: function () {
            return Cl.PolarStackedMountainCollection;
          },
        });
        var bl = r(38595);
        Object.defineProperty(t, "PolarStackedMountainRenderableSeries", {
          enumerable: !0,
          get: function () {
            return bl.PolarStackedMountainRenderableSeries;
          },
        });
        var xl = r(10947);
        Object.defineProperty(t, "PolarUniformHeatmapRenderableSeries", {
          enumerable: !0,
          get: function () {
            return xl.PolarUniformHeatmapRenderableSeries;
          },
        });
        var Al = r(69773);
        Object.defineProperty(t, "PolarXyScatterRenderableSeries", {
          enumerable: !0,
          get: function () {
            return Al.PolarXyScatterRenderableSeries;
          },
        });
        var Tl = r(72979);
        Object.defineProperty(t, "PolarColumnDataLabelState", {
          enumerable: !0,
          get: function () {
            return Tl.PolarColumnDataLabelState;
          },
        });
        var El = r(15518);
        Object.defineProperty(t, "PolarColumnSeriesDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return El.PolarColumnSeriesDataLabelProvider;
          },
        });
        var Rl = r(19963);
        Object.defineProperty(t, "PolarDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return Rl.PolarDataLabelProvider;
          },
        });
        var Dl = r(62652);
        Object.defineProperty(t, "PolarDataLabelState", {
          enumerable: !0,
          get: function () {
            return Dl.PolarDataLabelState;
          },
        });
        var wl = r(192);
        Object.defineProperty(t, "PolarHeatMapDataLabelProvider", {
          enumerable: !0,
          get: function () {
            return wl.PolarHeatMapDataLabelProvider;
          },
        });
        var Ml = r(90262);
        Object.defineProperty(t, "PolarBandSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Ml.PolarBandSeriesDrawingProvider;
          },
        });
        var Ll = r(77339);
        Object.defineProperty(t, "PolarColumnSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Ll.PolarColumnSeriesDrawingProvider;
          },
        });
        var Ol = r(40997);
        Object.defineProperty(t, "PolarHeatmapDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Ol.PolarHeatmapDrawingProvider;
          },
        });
        var Il = r(16556);
        Object.defineProperty(t, "PolarLineSeriesDrawingProvider", {
          enumerable: !0,
          get: function () {
            return Il.PolarLineSeriesDrawingProvider;
          },
        });
        var kl = r(37874);
        Object.defineProperty(t, "PolarPointMarkerDrawingProvider", {
          enumerable: !0,
          get: function () {
            return kl.PolarPointMarkerDrawingProvider;
          },
        });
        var _l = r(14082);
        Object.defineProperty(t, "PolarDataPointHitTestProvider", {
          enumerable: !0,
          get: function () {
            return _l.PolarDataPointHitTestProvider;
          },
        });
        var Vl = r(46495);
        Object.defineProperty(t, "polarHitTestHelpers", {
          enumerable: !0,
          get: function () {
            return Vl.polarHitTestHelpers;
          },
        });
        var Nl = r(16256);
        Object.defineProperty(t, "PolarLineSeriesHitTestProvider", {
          enumerable: !0,
          get: function () {
            return Nl.PolarLineSeriesHitTestProvider;
          },
        });
        var Bl = r(4450);
        Object.defineProperty(t, "BaseRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Bl.BaseRenderDataTransform;
          },
        });
        var Fl = r(4450);
        Object.defineProperty(t, "XyBaseRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Fl.XyBaseRenderDataTransform;
          },
        });
        var Hl = r(4450);
        Object.defineProperty(t, "XyyBaseRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Hl.XyyBaseRenderDataTransform;
          },
        });
        var Yl = r(4450);
        Object.defineProperty(t, "OhlcBaseRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Yl.OhlcBaseRenderDataTransform;
          },
        });
        var zl = r(89136);
        Object.defineProperty(t, "bezierTransform", {
          enumerable: !0,
          get: function () {
            return zl.bezierTransform;
          },
        });
        var jl = r(89136);
        Object.defineProperty(t, "BezierRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return jl.BezierRenderDataTransform;
          },
        });
        var Xl = r(89136);
        Object.defineProperty(t, "XyyBezierRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Xl.XyyBezierRenderDataTransform;
          },
        });
        var Gl = r(89136);
        Object.defineProperty(t, "SmoothStackedRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Gl.SmoothStackedRenderDataTransform;
          },
        });
        var Wl = r(87836);
        Object.defineProperty(t, "PolarInterpolateBandRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Wl.PolarInterpolateBandRenderDataTransform;
          },
        });
        var Ul = r(61566);
        Object.defineProperty(t, "PolarInterpolateLineRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Ul.PolarInterpolateLineRenderDataTransform;
          },
        });
        var $l = r(95103);
        Object.defineProperty(t, "SplineRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return $l.SplineRenderDataTransform;
          },
        });
        var Zl = r(69133);
        Object.defineProperty(t, "XyySplineRenderDataTransform", {
          enumerable: !0,
          get: function () {
            return Zl.XyySplineRenderDataTransform;
          },
        });
        var ql = r(54962);
        Object.defineProperty(t, "RolloverModifierRenderableSeriesProps", {
          enumerable: !0,
          get: function () {
            return ql.RolloverModifierRenderableSeriesProps;
          },
        });
        var Kl = r(90182);
        Object.defineProperty(t, "RubberBandSvgRect", {
          enumerable: !0,
          get: function () {
            return Kl.RubberBandSvgRect;
          },
        });
        var Jl = r(79548);
        Object.defineProperty(t, "ESizingMode", {
          enumerable: !0,
          get: function () {
            return Jl.ESizingMode;
          },
        });
        var Ql = r(79548);
        Object.defineProperty(t, "EPieType", {
          enumerable: !0,
          get: function () {
            return Ql.EPieType;
          },
        });
        var ed = r(79548);
        Object.defineProperty(t, "EPieValueMode", {
          enumerable: !0,
          get: function () {
            return ed.EPieValueMode;
          },
        });
        var td = r(79548);
        Object.defineProperty(t, "SciChartPieSurface", {
          enumerable: !0,
          get: function () {
            return td.SciChartPieSurface;
          },
        });
        var rd = r(57419);
        Object.defineProperty(t, "PieSegment", {
          enumerable: !0,
          get: function () {
            return rd.PieSegment;
          },
        });
        var id = r(35992);
        Object.defineProperty(t, "CanvasTexture", {
          enumerable: !0,
          get: function () {
            return id.CanvasTexture;
          },
        });
        var od = r(86127);
        Object.defineProperty(t, "DpiHelper", {
          enumerable: !0,
          get: function () {
            return od.DpiHelper;
          },
        });
        var ad = r(76829);
        Object.defineProperty(t, "TextureManager", {
          enumerable: !0,
          get: function () {
            return ad.TextureManager;
          },
        });
        var sd = r(76829);
        Object.defineProperty(t, "measureTextHeight", {
          enumerable: !0,
          get: function () {
            return sd.measureTextHeight;
          },
        });
        var nd = r(76829);
        Object.defineProperty(t, "measureTextWidth", {
          enumerable: !0,
          get: function () {
            return nd.measureTextWidth;
          },
        });
        var ld = r(3810);
        Object.defineProperty(t, "ECameraProjectionMode", {
          enumerable: !0,
          get: function () {
            return ld.ECameraProjectionMode;
          },
        });
        var dd = r(3810);
        Object.defineProperty(t, "CameraController", {
          enumerable: !0,
          get: function () {
            return dd.CameraController;
          },
        });
        var hd = r(16110);
        Object.defineProperty(t, "Vector3", {
          enumerable: !0,
          get: function () {
            return hd.Vector3;
          },
        });
        var ud = r(63220);
        Object.defineProperty(t, "ChartModifierBase3D", {
          enumerable: !0,
          get: function () {
            return ud.ChartModifierBase3D;
          },
        });
        var cd = r(89577);
        Object.defineProperty(t, "CustomChartModifier3D", {
          enumerable: !0,
          get: function () {
            return cd.CustomChartModifier3D;
          },
        });
        var pd = r(47737);
        Object.defineProperty(t, "MouseWheelZoomModifier3D", {
          enumerable: !0,
          get: function () {
            return pd.MouseWheelZoomModifier3D;
          },
        });
        var gd = r(17707);
        Object.defineProperty(t, "OrbitModifier3D", {
          enumerable: !0,
          get: function () {
            return gd.OrbitModifier3D;
          },
        });
        var yd = r(73792);
        Object.defineProperty(t, "PinchZoomModifier3D", {
          enumerable: !0,
          get: function () {
            return yd.PinchZoomModifier3D;
          },
        });
        var fd = r(68491);
        Object.defineProperty(t, "ResetCamera3DModifier", {
          enumerable: !0,
          get: function () {
            return fd.ResetCamera3DModifier;
          },
        });
        var vd = r(66477);
        Object.defineProperty(t, "TooltipModifier3D", {
          enumerable: !0,
          get: function () {
            return vd.TooltipModifier3D;
          },
        });
        var md = r(66477);
        Object.defineProperty(t, "adjustTooltipPosition3D", {
          enumerable: !0,
          get: function () {
            return md.adjustTooltipPosition3D;
          },
        });
        var Sd = r(23291);
        Object.defineProperty(t, "EDataSeriesType3D", {
          enumerable: !0,
          get: function () {
            return Sd.EDataSeriesType3D;
          },
        });
        var Pd = r(23291);
        Object.defineProperty(t, "BaseDataSeries3D", {
          enumerable: !0,
          get: function () {
            return Pd.BaseDataSeries3D;
          },
        });
        var Cd = r(13426);
        Object.defineProperty(t, "BaseGridDataSeries3D", {
          enumerable: !0,
          get: function () {
            return Cd.BaseGridDataSeries3D;
          },
        });
        var bd = r(75869);
        Object.defineProperty(t, "UniformGridDataSeries3D", {
          enumerable: !0,
          get: function () {
            return bd.UniformGridDataSeries3D;
          },
        });
        var xd = r(98102);
        Object.defineProperty(t, "XyzDataSeries3D", {
          enumerable: !0,
          get: function () {
            return xd.XyzDataSeries3D;
          },
        });
        var Ad = r(86753);
        Object.defineProperty(t, "createSingle3dInternal", {
          enumerable: !0,
          get: function () {
            return Ad.createSingle3dInternal;
          },
        });
        var Td = r(36561);
        Object.defineProperty(t, "DefaultViewportManager3D", {
          enumerable: !0,
          get: function () {
            return Td.DefaultViewportManager3D;
          },
        });
        var Ed = r(1989);
        Object.defineProperty(t, "GizmoEntity", {
          enumerable: !0,
          get: function () {
            return Ed.GizmoEntity;
          },
        });
        var Rd = r(228);
        Object.defineProperty(t, "RootSceneEntity", {
          enumerable: !0,
          get: function () {
            return Rd.RootSceneEntity;
          },
        });
        var Dd = r(20254);
        Object.defineProperty(t, "SciChart3DRenderer", {
          enumerable: !0,
          get: function () {
            return Dd.SciChart3DRenderer;
          },
        });
        var wd = r(52361);
        Object.defineProperty(t, "sciChartConfig3D", {
          enumerable: !0,
          get: function () {
            return wd.sciChartConfig3D;
          },
        });
        var Md = r(52361);
        Object.defineProperty(t, "SciChart3DSurface", {
          enumerable: !0,
          get: function () {
            return Md.SciChart3DSurface;
          },
        });
        var Ld = r(61981);
        Object.defineProperty(t, "ViewportManager3DBase", {
          enumerable: !0,
          get: function () {
            return Ld.ViewportManager3DBase;
          },
        });
        var Od = r(58042);
        Object.defineProperty(t, "TooltipSvgAnnotation3D", {
          enumerable: !0,
          get: function () {
            return Od.TooltipSvgAnnotation3D;
          },
        });
        var Id = r(79135);
        Object.defineProperty(t, "EWhichAxis", {
          enumerable: !0,
          get: function () {
            return Id.EWhichAxis;
          },
        });
        var kd = r(79135);
        Object.defineProperty(t, "AxisBase3D", {
          enumerable: !0,
          get: function () {
            return kd.AxisBase3D;
          },
        });
        var _d = r(22054);
        Object.defineProperty(t, "AxisCubeEntity", {
          enumerable: !0,
          get: function () {
            return _d.AxisCubeEntity;
          },
        });
        var Vd = r(99441);
        Object.defineProperty(t, "EAxisSideClipping", {
          enumerable: !0,
          get: function () {
            return Vd.EAxisSideClipping;
          },
        });
        var Nd = r(69412);
        Object.defineProperty(t, "ETextAlignment3D", {
          enumerable: !0,
          get: function () {
            return Nd.ETextAlignment3D;
          },
        });
        var Bd = r(77103);
        Object.defineProperty(t, "getDescriptorsEqual", {
          enumerable: !0,
          get: function () {
            return Bd.getDescriptorsEqual;
          },
        });
        var Fd = r(77103);
        Object.defineProperty(t, "getLineStylesEqual", {
          enumerable: !0,
          get: function () {
            return Fd.getLineStylesEqual;
          },
        });
        var Hd = r(77103);
        Object.defineProperty(t, "getTArgbEqual", {
          enumerable: !0,
          get: function () {
            return Hd.getTArgbEqual;
          },
        });
        var Yd = r(77103);
        Object.defineProperty(t, "getTextStylesEqual", {
          enumerable: !0,
          get: function () {
            return Yd.getTextStylesEqual;
          },
        });
        var zd = r(77103);
        Object.defineProperty(t, "getArraysEqual", {
          enumerable: !0,
          get: function () {
            return zd.getArraysEqual;
          },
        });
        var jd = r(48936);
        Object.defineProperty(t, "NumericAxis3D", {
          enumerable: !0,
          get: function () {
            return jd.NumericAxis3D;
          },
        });
        var Xd = r(49706);
        Object.defineProperty(t, "BaseMeshPointMarker3D", {
          enumerable: !0,
          get: function () {
            return Xd.BaseMeshPointMarker3D;
          },
        });
        var Gd = r(71906);
        Object.defineProperty(t, "EMarkerType", {
          enumerable: !0,
          get: function () {
            return Gd.EMarkerType;
          },
        });
        var Wd = r(71906);
        Object.defineProperty(t, "BasePointMarker3D", {
          enumerable: !0,
          get: function () {
            return Wd.BasePointMarker3D;
          },
        });
        var Ud = r(29336);
        Object.defineProperty(t, "BaseTexturePointMarker3D", {
          enumerable: !0,
          get: function () {
            return Ud.BaseTexturePointMarker3D;
          },
        });
        var $d = r(37622);
        Object.defineProperty(t, "SpherePointMarker3D", {
          enumerable: !0,
          get: function () {
            return $d.SpherePointMarker3D;
          },
        });
        var Zd = r(37622);
        Object.defineProperty(t, "CubePointMarker3D", {
          enumerable: !0,
          get: function () {
            return Zd.CubePointMarker3D;
          },
        });
        var qd = r(37622);
        Object.defineProperty(t, "PyramidPointMarker3D", {
          enumerable: !0,
          get: function () {
            return qd.PyramidPointMarker3D;
          },
        });
        var Kd = r(37622);
        Object.defineProperty(t, "CylinderPointMarker3D", {
          enumerable: !0,
          get: function () {
            return Kd.CylinderPointMarker3D;
          },
        });
        var Jd = r(37622);
        Object.defineProperty(t, "PixelPointMarker3D", {
          enumerable: !0,
          get: function () {
            return Jd.PixelPointMarker3D;
          },
        });
        var Qd = r(37622);
        Object.defineProperty(t, "QuadPointMarker", {
          enumerable: !0,
          get: function () {
            return Qd.QuadPointMarker;
          },
        });
        var eh = r(37622);
        Object.defineProperty(t, "EllipsePointMarker3D", {
          enumerable: !0,
          get: function () {
            return eh.EllipsePointMarker3D;
          },
        });
        var th = r(37622);
        Object.defineProperty(t, "TrianglePointMarker3D", {
          enumerable: !0,
          get: function () {
            return th.TrianglePointMarker3D;
          },
        });
        var rh = r(33517);
        Object.defineProperty(t, "AxisCubeDescriptor", {
          enumerable: !0,
          get: function () {
            return rh.AxisCubeDescriptor;
          },
        });
        var ih = r(85418);
        Object.defineProperty(t, "BaseSceneEntity3D", {
          enumerable: !0,
          get: function () {
            return ih.BaseSceneEntity3D;
          },
        });
        var oh = r(84501);
        Object.defineProperty(t, "ColumnSceneEntity", {
          enumerable: !0,
          get: function () {
            return oh.ColumnSceneEntity;
          },
        });
        var ah = r(26079);
        Object.defineProperty(t, "CrosshairLinesSceneEntity", {
          enumerable: !0,
          get: function () {
            return ah.CrosshairLinesSceneEntity;
          },
        });
        var sh = r(21240);
        Object.defineProperty(t, "DefaultEntityIdProvider", {
          enumerable: !0,
          get: function () {
            return sh.DefaultEntityIdProvider;
          },
        });
        var nh = r(54005);
        Object.defineProperty(t, "PointLine3DSceneEntity", {
          enumerable: !0,
          get: function () {
            return nh.PointLine3DSceneEntity;
          },
        });
        var lh = r(61325);
        Object.defineProperty(t, "RenderableSeriesSceneEntity", {
          enumerable: !0,
          get: function () {
            return lh.RenderableSeriesSceneEntity;
          },
        });
        var dh = r(75816);
        Object.defineProperty(t, "RenderableSeriesSceneEntityState", {
          enumerable: !0,
          get: function () {
            return dh.RenderableSeriesSceneEntityState;
          },
        });
        var hh = r(72476);
        Object.defineProperty(t, "RenderPassInfo3D", {
          enumerable: !0,
          get: function () {
            return hh.RenderPassInfo3D;
          },
        });
        var uh = r(77162);
        Object.defineProperty(t, "ScatterPointsSceneEntity", {
          enumerable: !0,
          get: function () {
            return uh.ScatterPointsSceneEntity;
          },
        });
        var ch = r(41859);
        Object.defineProperty(t, "SceneDescriptor", {
          enumerable: !0,
          get: function () {
            return ch.SceneDescriptor;
          },
        });
        var ph = r(98694);
        Object.defineProperty(t, "SurfaceMeshSceneEntityState", {
          enumerable: !0,
          get: function () {
            return ph.SurfaceMeshSceneEntityState;
          },
        });
        var gh = r(98694);
        Object.defineProperty(t, "SurfaceMeshSceneEntity", {
          enumerable: !0,
          get: function () {
            return gh.SurfaceMeshSceneEntity;
          },
        });
        var yh = r(83653);
        Object.defineProperty(t, "BaseRenderableSeries3D", {
          enumerable: !0,
          get: function () {
            return yh.BaseRenderableSeries3D;
          },
        });
        var fh = r(56675);
        Object.defineProperty(t, "ColumnRenderableSeries3D", {
          enumerable: !0,
          get: function () {
            return fh.ColumnRenderableSeries3D;
          },
        });
        var vh = r(45265);
        Object.defineProperty(t, "ESeriesType3D", {
          enumerable: !0,
          get: function () {
            return vh.ESeriesType3D;
          },
        });
        var mh = r(56172);
        Object.defineProperty(t, "HitTestInfo3D", {
          enumerable: !0,
          get: function () {
            return mh.HitTestInfo3D;
          },
        });
        var Sh = r(39927);
        Object.defineProperty(t, "PointLineRenderableSeries3D", {
          enumerable: !0,
          get: function () {
            return Sh.PointLineRenderableSeries3D;
          },
        });
        var Ph = r(72954);
        Object.defineProperty(t, "ScatterRenderableSeries3D", {
          enumerable: !0,
          get: function () {
            return Ph.ScatterRenderableSeries3D;
          },
        });
        var Ch = r(94574);
        Object.defineProperty(t, "SeriesInfo3D", {
          enumerable: !0,
          get: function () {
            return Ch.SeriesInfo3D;
          },
        });
        var bh = r(80995);
        Object.defineProperty(t, "SurfaceMeshSeriesInfo3D", {
          enumerable: !0,
          get: function () {
            return bh.SurfaceMeshSeriesInfo3D;
          },
        });
        var xh = r(19221);
        Object.defineProperty(t, "XyzSeriesInfo3D", {
          enumerable: !0,
          get: function () {
            return xh.XyzSeriesInfo3D;
          },
        });
        var Ah = r(28009);
        Object.defineProperty(t, "GradientColorPalette", {
          enumerable: !0,
          get: function () {
            return Ah.GradientColorPalette;
          },
        });
        var Th = r(46294);
        Object.defineProperty(t, "MeshColorPalette", {
          enumerable: !0,
          get: function () {
            return Th.MeshColorPalette;
          },
        });
        var Eh = r(25889);
        Object.defineProperty(t, "SolidColorBrushPalette", {
          enumerable: !0,
          get: function () {
            return Eh.SolidColorBrushPalette;
          },
        });
        var Rh = r(10435);
        Object.defineProperty(t, "EDrawMeshAs", {
          enumerable: !0,
          get: function () {
            return Rh.EDrawMeshAs;
          },
        });
        var Dh = r(10435);
        Object.defineProperty(t, "EMeshPaletteMode", {
          enumerable: !0,
          get: function () {
            return Dh.EMeshPaletteMode;
          },
        });
        var wh = r(10435);
        Object.defineProperty(t, "EMeshResolution", {
          enumerable: !0,
          get: function () {
            return wh.EMeshResolution;
          },
        });
        var Mh = r(10435);
        Object.defineProperty(t, "SurfaceMeshRenderableSeries3D", {
          enumerable: !0,
          get: function () {
            return Mh.SurfaceMeshRenderableSeries3D;
          },
        });
        var Lh = r(66549);
        Object.defineProperty(t, "AnimationToken", {
          enumerable: !0,
          get: function () {
            return Lh.AnimationToken;
          },
        });
        var Oh = r(34238);
        Object.defineProperty(t, "libraryVersion", {
          enumerable: !0,
          get: function () {
            return Oh.libraryVersion;
          },
        });
        var Ih = r(34238);
        Object.defineProperty(t, "checkBuildStamp", {
          enumerable: !0,
          get: function () {
            return Ih.checkBuildStamp;
          },
        });
        var kh = r(55023);
        Object.defineProperty(t, "DeletableEntity", {
          enumerable: !0,
          get: function () {
            return kh.DeletableEntity;
          },
        });
        var _h = r(56744);
        Object.defineProperty(t, "deleteSafe", {
          enumerable: !0,
          get: function () {
            return _h.deleteSafe;
          },
        });
        var Vh = r(21079);
        Object.defineProperty(t, "Dictionary", {
          enumerable: !0,
          get: function () {
            return Vh.Dictionary;
          },
        });
        var Nh = r(3214);
        Object.defineProperty(t, "EventHandler", {
          enumerable: !0,
          get: function () {
            return Nh.EventHandler;
          },
        });
        var Bh = r(58599);
        Object.defineProperty(t, "GradientParams", {
          enumerable: !0,
          get: function () {
            return Bh.GradientParams;
          },
        });
        var Fh = r(23866);
        Object.defineProperty(t, "Guard", {
          enumerable: !0,
          get: function () {
            return Fh.Guard;
          },
        });
        var Hh = r(77354);
        Object.defineProperty(t, "IncludedItems", {
          enumerable: !0,
          get: function () {
            return Hh.IncludedItems;
          },
        });
        var Yh = r(98869);
        Object.defineProperty(t, "List", {
          enumerable: !0,
          get: function () {
            return Yh.List;
          },
        });
        var zh = r(98140);
        Object.defineProperty(t, "NumberRange", {
          enumerable: !0,
          get: function () {
            return zh.NumberRange;
          },
        });
        var jh = r(64645);
        Object.defineProperty(t, "NumberUtil", {
          enumerable: !0,
          get: function () {
            return jh.NumberUtil;
          },
        });
        var Xh = r(37796);
        Object.defineProperty(t, "ObservableArrayBase", {
          enumerable: !0,
          get: function () {
            return Xh.ObservableArrayBase;
          },
        });
        var Gh = r(37796);
        Object.defineProperty(t, "ObservableArray", {
          enumerable: !0,
          get: function () {
            return Gh.ObservableArray;
          },
        });
        var Wh = r(71664);
        Object.defineProperty(t, "EObservableArrayChangedAction", {
          enumerable: !0,
          get: function () {
            return Wh.EObservableArrayChangedAction;
          },
        });
        var Uh = r(71664);
        Object.defineProperty(t, "ObservableArrayChangedArgs", {
          enumerable: !0,
          get: function () {
            return Uh.ObservableArrayChangedArgs;
          },
        });
        var $h = r(63508);
        Object.defineProperty(t, "OneTimePerformanceWarning", {
          enumerable: !0,
          get: function () {
            return $h.OneTimePerformanceWarning;
          },
        });
        var Zh = r(75772);
        Object.defineProperty(t, "Point", {
          enumerable: !0,
          get: function () {
            return Zh.Point;
          },
        });
        var qh = r(50605);
        Object.defineProperty(t, "PropertyChangedEventArgs", {
          enumerable: !0,
          get: function () {
            return qh.PropertyChangedEventArgs;
          },
        });
        var Kh = r(87459);
        Object.defineProperty(t, "Rect", {
          enumerable: !0,
          get: function () {
            return Kh.Rect;
          },
        });
        var Jh = r(33519);
        Object.defineProperty(t, "getUserCookie", {
          enumerable: !0,
          get: function () {
            return Jh.getUserCookie;
          },
        });
        var Qh = r(33519);
        Object.defineProperty(t, "shouldSendTelemetry", {
          enumerable: !0,
          get: function () {
            return Qh.shouldSendTelemetry;
          },
        });
        var eu = r(33519);
        Object.defineProperty(t, "sendTelemetry", {
          enumerable: !0,
          get: function () {
            return eu.sendTelemetry;
          },
        });
        var tu = r(87108);
        Object.defineProperty(t, "Thickness", {
          enumerable: !0,
          get: function () {
            return tu.Thickness;
          },
        });
        var ru = r(62049);
        Object.defineProperty(t, "EWebGLSupport", {
          enumerable: !0,
          get: function () {
            return ru.EWebGLSupport;
          },
        });
        var iu = r(62049);
        Object.defineProperty(t, "WebGlHelper", {
          enumerable: !0,
          get: function () {
            return iu.WebGlHelper;
          },
        });
        var ou = r(82229);
        Object.defineProperty(t, "EAnimationState", {
          enumerable: !0,
          get: function () {
            return ou.EAnimationState;
          },
        });
        var au = r(82229);
        Object.defineProperty(t, "EAnimationStateTransition", {
          enumerable: !0,
          get: function () {
            return au.EAnimationStateTransition;
          },
        });
        var su = r(82229);
        Object.defineProperty(t, "AnimationFiniteStateMachine", {
          enumerable: !0,
          get: function () {
            return su.AnimationFiniteStateMachine;
          },
        });
        var nu = r(82229);
        Object.defineProperty(t, "SeriesAnimationFiniteStateMachine", {
          enumerable: !0,
          get: function () {
            return nu.SeriesAnimationFiniteStateMachine;
          },
        });
        var lu = r(90995);
        Object.defineProperty(t, "animateAny", {
          enumerable: !0,
          get: function () {
            return lu.animateAny;
          },
        });
        var du = r(33485);
        Object.defineProperty(t, "DoubleAnimator", {
          enumerable: !0,
          get: function () {
            return du.DoubleAnimator;
          },
        });
        var hu = r(10276);
        Object.defineProperty(t, "easing", {
          enumerable: !0,
          get: function () {
            return hu.easing;
          },
        });
        var uu = r(10276);
        Object.defineProperty(t, "autoReverseEasing", {
          enumerable: !0,
          get: function () {
            return uu.autoReverseEasing;
          },
        });
        var cu = r(70162);
        Object.defineProperty(t, "GenericAnimation", {
          enumerable: !0,
          get: function () {
            return cu.GenericAnimation;
          },
        });
        var pu = r(31194);
        Object.defineProperty(t, "NumberRangeAnimator", {
          enumerable: !0,
          get: function () {
            return pu.NumberRangeAnimator;
          },
        });
        var gu = r(85258);
        Object.defineProperty(t, "MouseManager", {
          enumerable: !0,
          get: function () {
            return gu.MouseManager;
          },
        });
        var yu = r(31601);
        Object.defineProperty(t, "localStorageApi", {
          enumerable: !0,
          get: function () {
            return yu.localStorageApi;
          },
        });
        var fu = r(60986);
        Object.defineProperty(t, "EHorizontalAnchorPoint", {
          enumerable: !0,
          get: function () {
            return fu.EHorizontalAnchorPoint;
          },
        });
        var vu = r(60986);
        Object.defineProperty(t, "EVerticalAnchorPoint", {
          enumerable: !0,
          get: function () {
            return vu.EVerticalAnchorPoint;
          },
        });
        var mu = r(10763);
        Object.defineProperty(t, "EAnimationType", {
          enumerable: !0,
          get: function () {
            return mu.EAnimationType;
          },
        });
        var Su = r(26520);
        Object.defineProperty(t, "EAnnotationClippingMode", {
          enumerable: !0,
          get: function () {
            return Su.EAnnotationClippingMode;
          },
        });
        var Pu = r(39922);
        Object.defineProperty(t, "EAutoColorMode", {
          enumerable: !0,
          get: function () {
            return Pu.EAutoColorMode;
          },
        });
        var Cu = r(12785);
        Object.defineProperty(t, "EAutoRange", {
          enumerable: !0,
          get: function () {
            return Cu.EAutoRange;
          },
        });
        var bu = r(38215);
        Object.defineProperty(t, "EAxisAlignment", {
          enumerable: !0,
          get: function () {
            return bu.EAxisAlignment;
          },
        });
        var xu = r(38215);
        Object.defineProperty(t, "getIsHorizontal", {
          enumerable: !0,
          get: function () {
            return xu.getIsHorizontal;
          },
        });
        var Au = r(38215);
        Object.defineProperty(t, "getIsVertical", {
          enumerable: !0,
          get: function () {
            return Au.getIsVertical;
          },
        });
        var Tu = r(38215);
        Object.defineProperty(t, "handleInvalidAxisAlignment", {
          enumerable: !0,
          get: function () {
            return Tu.handleInvalidAxisAlignment;
          },
        });
        var Eu = r(2192);
        Object.defineProperty(t, "EAxisType", {
          enumerable: !0,
          get: function () {
            return Eu.EAxisType;
          },
        });
        var Ru = r(11043);
        Object.defineProperty(t, "EBaseType", {
          enumerable: !0,
          get: function () {
            return Ru.EBaseType;
          },
        });
        var Du = r(89955);
        Object.defineProperty(t, "EChart2DModifierType", {
          enumerable: !0,
          get: function () {
            return Du.EChart2DModifierType;
          },
        });
        var wu = r(89955);
        Object.defineProperty(t, "EChart3DModifierType", {
          enumerable: !0,
          get: function () {
            return wu.EChart3DModifierType;
          },
        });
        var Mu = r(72072);
        Object.defineProperty(t, "EColor", {
          enumerable: !0,
          get: function () {
            return Mu.EColor;
          },
        });
        var Lu = r(60960);
        Object.defineProperty(t, "EColumnMode", {
          enumerable: !0,
          get: function () {
            return Lu.EColumnMode;
          },
        });
        var Ou = r(60960);
        Object.defineProperty(t, "convertColumnMode", {
          enumerable: !0,
          get: function () {
            return Ou.convertColumnMode;
          },
        });
        var Iu = r(60960);
        Object.defineProperty(t, "EColumnYMode", {
          enumerable: !0,
          get: function () {
            return Iu.EColumnYMode;
          },
        });
        var ku = r(60960);
        Object.defineProperty(t, "convertYColumnMode", {
          enumerable: !0,
          get: function () {
            return ku.convertYColumnMode;
          },
        });
        var _u = r(14278);
        Object.defineProperty(t, "ECursorStyle", {
          enumerable: !0,
          get: function () {
            return _u.ECursorStyle;
          },
        });
        var Vu = r(51097);
        Object.defineProperty(t, "EDataFilterType", {
          enumerable: !0,
          get: function () {
            return Vu.EDataFilterType;
          },
        });
        var Nu = r(2963);
        Object.defineProperty(t, "EDataLabelProviderType", {
          enumerable: !0,
          get: function () {
            return Nu.EDataLabelProviderType;
          },
        });
        var Bu = r(62993);
        Object.defineProperty(t, "EDataLabelSkipMode", {
          enumerable: !0,
          get: function () {
            return Bu.EDataLabelSkipMode;
          },
        });
        var Fu = r(27970);
        Object.defineProperty(t, "EDataPointWidthMode", {
          enumerable: !0,
          get: function () {
            return Fu.EDataPointWidthMode;
          },
        });
        var Hu = r(3777);
        Object.defineProperty(t, "EDefaultRenderLayer", {
          enumerable: !0,
          get: function () {
            return Hu.EDefaultRenderLayer;
          },
        });
        var Yu = r(7980);
        Object.defineProperty(t, "EDragMode", {
          enumerable: !0,
          get: function () {
            return Yu.EDragMode;
          },
        });
        var zu = r(79226);
        Object.defineProperty(t, "EErrorDirection", {
          enumerable: !0,
          get: function () {
            return zu.EErrorDirection;
          },
        });
        var ju = r(32287);
        Object.defineProperty(t, "EErrorMode", {
          enumerable: !0,
          get: function () {
            return ju.EErrorMode;
          },
        });
        var Xu = r(28268);
        Object.defineProperty(t, "EColorPickMode", {
          enumerable: !0,
          get: function () {
            return Xu.EColorPickMode;
          },
        });
        var Gu = r(74218);
        Object.defineProperty(t, "EHeightSeriesMode", {
          enumerable: !0,
          get: function () {
            return Gu.EHeightSeriesMode;
          },
        });
        var Wu = r(10581);
        Object.defineProperty(t, "EHoverMode", {
          enumerable: !0,
          get: function () {
            return Wu.EHoverMode;
          },
        });
        var Uu = r(63415);
        Object.defineProperty(t, "ELabelAlignment", {
          enumerable: !0,
          get: function () {
            return Uu.ELabelAlignment;
          },
        });
        var $u = r(11805);
        Object.defineProperty(t, "ELabelPlacement", {
          enumerable: !0,
          get: function () {
            return $u.ELabelPlacement;
          },
        });
        var Zu = r(11805);
        Object.defineProperty(t, "EHorizontalAlignment", {
          enumerable: !0,
          get: function () {
            return Zu.EHorizontalAlignment;
          },
        });
        var qu = r(11805);
        Object.defineProperty(t, "EVerticalAlignment", {
          enumerable: !0,
          get: function () {
            return qu.EVerticalAlignment;
          },
        });
        var Ku = r(11805);
        Object.defineProperty(t, "EAngularAxisLabelPlacement", {
          enumerable: !0,
          get: function () {
            return Ku.EAngularAxisLabelPlacement;
          },
        });
        var Ju = r(11805);
        Object.defineProperty(t, "ERadialAxisLabelPlacement", {
          enumerable: !0,
          get: function () {
            return Ju.ERadialAxisLabelPlacement;
          },
        });
        var Qu = r(40359);
        Object.defineProperty(t, "ELabelProviderType", {
          enumerable: !0,
          get: function () {
            return Qu.ELabelProviderType;
          },
        });
        var ec = r(883);
        Object.defineProperty(t, "ELayoutManagerType", {
          enumerable: !0,
          get: function () {
            return ec.ELayoutManagerType;
          },
        });
        var tc = r(73785);
        Object.defineProperty(t, "ELayoutStrategyType", {
          enumerable: !0,
          get: function () {
            return tc.ELayoutStrategyType;
          },
        });
        var rc = r(66405);
        Object.defineProperty(t, "EModifierType", {
          enumerable: !0,
          get: function () {
            return rc.EModifierType;
          },
        });
        var ic = r(57935);
        Object.defineProperty(t, "EMousePosition", {
          enumerable: !0,
          get: function () {
            return ic.EMousePosition;
          },
        });
        var oc = r(65885);
        Object.defineProperty(t, "isTypedArray", {
          enumerable: !0,
          get: function () {
            return oc.isTypedArray;
          },
        });
        var ac = r(65885);
        Object.defineProperty(t, "isNumberArray", {
          enumerable: !0,
          get: function () {
            return ac.isNumberArray;
          },
        });
        var sc = r(65885);
        Object.defineProperty(t, "subArray", {
          enumerable: !0,
          get: function () {
            return sc.subArray;
          },
        });
        var nc = r(96528);
        Object.defineProperty(t, "ENumericFormat", {
          enumerable: !0,
          get: function () {
            return nc.ENumericFormat;
          },
        });
        var lc = r(34496);
        Object.defineProperty(t, "OrderedRenderable", {
          enumerable: !0,
          get: function () {
            return lc.OrderedRenderable;
          },
        });
        var dc = r(28436);
        Object.defineProperty(t, "EPaletteProviderType", {
          enumerable: !0,
          get: function () {
            return dc.EPaletteProviderType;
          },
        });
        var hc = r(56356);
        Object.defineProperty(t, "EPointMarker3DType", {
          enumerable: !0,
          get: function () {
            return hc.EPointMarker3DType;
          },
        });
        var uc = r(30323);
        Object.defineProperty(t, "EPointMarkerType", {
          enumerable: !0,
          get: function () {
            return uc.EPointMarkerType;
          },
        });
        var cc = r(32406);
        Object.defineProperty(t, "ERenderLayer", {
          enumerable: !0,
          get: function () {
            return cc.ERenderLayer;
          },
        });
        var pc = r(34116);
        Object.defineProperty(t, "ESceneEntityType", {
          enumerable: !0,
          get: function () {
            return pc.ESceneEntityType;
          },
        });
        var gc = r(91465);
        Object.defineProperty(t, "ESciChartSurfaceType", {
          enumerable: !0,
          get: function () {
            return gc.ESciChartSurfaceType;
          },
        });
        var yc = r(26361);
        Object.defineProperty(t, "ESearchMode", {
          enumerable: !0,
          get: function () {
            return yc.ESearchMode;
          },
        });
        var fc = r(26361);
        Object.defineProperty(t, "convertSearchMode", {
          enumerable: !0,
          get: function () {
            return fc.convertSearchMode;
          },
        });
        var vc = r(5337);
        Object.defineProperty(t, "ESeriesType", {
          enumerable: !0,
          get: function () {
            return vc.ESeriesType;
          },
        });
        var mc = r(75323);
        Object.defineProperty(t, "EShaderEffectType", {
          enumerable: !0,
          get: function () {
            return mc.EShaderEffectType;
          },
        });
        var Sc = r(22022);
        Object.defineProperty(t, "Size", {
          enumerable: !0,
          get: function () {
            return Sc.Size;
          },
        });
        var Pc = r(19145);
        Object.defineProperty(t, "ESurfaceType", {
          enumerable: !0,
          get: function () {
            return Pc.ESurfaceType;
          },
        });
        var Cc = r(36420);
        Object.defineProperty(t, "EHorizontalTextPosition", {
          enumerable: !0,
          get: function () {
            return Cc.EHorizontalTextPosition;
          },
        });
        var bc = r(36420);
        Object.defineProperty(t, "EVerticalTextPosition", {
          enumerable: !0,
          get: function () {
            return bc.EVerticalTextPosition;
          },
        });
        var xc = r(36420);
        Object.defineProperty(t, "EMultiLineAlignment", {
          enumerable: !0,
          get: function () {
            return xc.EMultiLineAlignment;
          },
        });
        var Ac = r(36420);
        Object.defineProperty(t, "convertMultiLineAlignment", {
          enumerable: !0,
          get: function () {
            return Ac.convertMultiLineAlignment;
          },
        });
        var Tc = r(71238);
        Object.defineProperty(t, "ETextAlignment", {
          enumerable: !0,
          get: function () {
            return Tc.ETextAlignment;
          },
        });
        var Ec = r(71238);
        Object.defineProperty(t, "ETitlePosition", {
          enumerable: !0,
          get: function () {
            return Ec.ETitlePosition;
          },
        });
        var Rc = r(62916);
        Object.defineProperty(t, "EThemeProviderType", {
          enumerable: !0,
          get: function () {
            return Rc.EThemeProviderType;
          },
        });
        var Dc = r(62186);
        Object.defineProperty(t, "EColorMapMode", {
          enumerable: !0,
          get: function () {
            return Dc.EColorMapMode;
          },
        });
        var wc = r(95808);
        Object.defineProperty(t, "ETriangleSeriesDrawMode", {
          enumerable: !0,
          get: function () {
            return wc.ETriangleSeriesDrawMode;
          },
        });
        var Mc = r(54624);
        Object.defineProperty(t, "EValueName", {
          enumerable: !0,
          get: function () {
            return Mc.EValueName;
          },
        });
        var Lc = r(54624);
        Object.defineProperty(t, "generateValueNamesForDataSeries", {
          enumerable: !0,
          get: function () {
            return Lc.generateValueNamesForDataSeries;
          },
        });
        var Oc = r(24149);
        Object.defineProperty(t, "EWatermarkPosition", {
          enumerable: !0,
          get: function () {
            return Oc.EWatermarkPosition;
          },
        });
        var Ic = r(86699);
        Object.defineProperty(t, "EXyDirection", {
          enumerable: !0,
          get: function () {
            return Ic.EXyDirection;
          },
        });
        var kc = r(9073);
        Object.defineProperty(t, "EYRangeMode", {
          enumerable: !0,
          get: function () {
            return kc.EYRangeMode;
          },
        });
        var _c = r(14379);
        Object.defineProperty(t, "EZoomState", {
          enumerable: !0,
          get: function () {
            return _c.EZoomState;
          },
        });
        var Vc = r(6859);
        Object.defineProperty(t, "EExecuteOn", {
          enumerable: !0,
          get: function () {
            return Vc.EExecuteOn;
          },
        });
        var Nc = r(32616);
        Object.defineProperty(t, "EModifierMouseArgKey", {
          enumerable: !0,
          get: function () {
            return Nc.EModifierMouseArgKey;
          },
        });
        var Bc = r(44431);
        Object.defineProperty(t, "EStrokeLineJoin", {
          enumerable: !0,
          get: function () {
            return Bc.EStrokeLineJoin;
          },
        });
        var Fc = r(45215);
        Object.defineProperty(t, "getUniqueValues", {
          enumerable: !0,
          get: function () {
            return Fc.getUniqueValues;
          },
        });
        var Hc = r(45215);
        Object.defineProperty(t, "countUnique", {
          enumerable: !0,
          get: function () {
            return Hc.countUnique;
          },
        });
        var Yc = r(45215);
        Object.defineProperty(t, "areArraysEqual", {
          enumerable: !0,
          get: function () {
            return Yc.areArraysEqual;
          },
        });
        var zc = r(45215);
        Object.defineProperty(t, "arrayRemove", {
          enumerable: !0,
          get: function () {
            return zc.arrayRemove;
          },
        });
        var jc = r(45215);
        Object.defineProperty(t, "isArraySorted", {
          enumerable: !0,
          get: function () {
            return jc.isArraySorted;
          },
        });
        var Xc = r(45215);
        Object.defineProperty(t, "makeIncArray", {
          enumerable: !0,
          get: function () {
            return Xc.makeIncArray;
          },
        });
        var Gc = r(45215);
        Object.defineProperty(t, "appendRangeFifo", {
          enumerable: !0,
          get: function () {
            return Gc.appendRangeFifo;
          },
        });
        var Wc = r(19387);
        Object.defineProperty(t, "calcAverageForDoubleVector", {
          enumerable: !0,
          get: function () {
            return Wc.calcAverageForDoubleVector;
          },
        });
        var Uc = r(19387);
        Object.defineProperty(t, "calcAverageForArray", {
          enumerable: !0,
          get: function () {
            return Uc.calcAverageForArray;
          },
        });
        var $c = r(22950);
        Object.defineProperty(t, "uintArgbColorLerp24bit", {
          enumerable: !0,
          get: function () {
            return $c.uintArgbColorLerp24bit;
          },
        });
        var Zc = r(22950);
        Object.defineProperty(t, "uintArgbColorLerp", {
          enumerable: !0,
          get: function () {
            return Zc.uintArgbColorLerp;
          },
        });
        var qc = r(22950);
        Object.defineProperty(t, "linearColorMapLerp", {
          enumerable: !0,
          get: function () {
            return qc.linearColorMapLerp;
          },
        });
        var Kc = r(22950);
        Object.defineProperty(t, "uintArgbColorToAbgr", {
          enumerable: !0,
          get: function () {
            return Kc.uintArgbColorToAbgr;
          },
        });
        var Jc = r(22950);
        Object.defineProperty(t, "uintArgbColorMultiplyOpacity", {
          enumerable: !0,
          get: function () {
            return Jc.uintArgbColorMultiplyOpacity;
          },
        });
        var Qc = r(22950);
        Object.defineProperty(t, "uintArgbColorOverrideOpacity", {
          enumerable: !0,
          get: function () {
            return Qc.uintArgbColorOverrideOpacity;
          },
        });
        var ep = r(22950);
        Object.defineProperty(t, "uintArgbColorIsTransparent", {
          enumerable: !0,
          get: function () {
            return ep.uintArgbColorIsTransparent;
          },
        });
        var tp = r(22950);
        Object.defineProperty(t, "applyOpacityToHtmlColor", {
          enumerable: !0,
          get: function () {
            return tp.applyOpacityToHtmlColor;
          },
        });
        var rp = r(85505);
        Object.defineProperty(t, "convertColor", {
          enumerable: !0,
          get: function () {
            return rp.convertColor;
          },
        });
        var ip = r(85505);
        Object.defineProperty(t, "convertRgbToHexColor", {
          enumerable: !0,
          get: function () {
            return ip.convertRgbToHexColor;
          },
        });
        var op = r(76630);
        Object.defineProperty(t, "convertToPixel", {
          enumerable: !0,
          get: function () {
            return op.convertToPixel;
          },
        });
        var ap = r(46544);
        Object.defineProperty(t, "copyDoubleVector", {
          enumerable: !0,
          get: function () {
            return ap.copyDoubleVector;
          },
        });
        var sp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanString", {
          enumerable: !0,
          get: function () {
            return sp.formatUnixDateToHumanString;
          },
        });
        var np = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringDDMMYY", {
          enumerable: !0,
          get: function () {
            return np.formatUnixDateToHumanStringDDMMYY;
          },
        });
        var lp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringDDMMHHMM", {
          enumerable: !0,
          get: function () {
            return lp.formatUnixDateToHumanStringDDMMHHMM;
          },
        });
        var dp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringDDMM", {
          enumerable: !0,
          get: function () {
            return dp.formatUnixDateToHumanStringDDMM;
          },
        });
        var hp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringHHMMSS", {
          enumerable: !0,
          get: function () {
            return hp.formatUnixDateToHumanStringHHMMSS;
          },
        });
        var up = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringSSms", {
          enumerable: !0,
          get: function () {
            return up.formatUnixDateToHumanStringSSms;
          },
        });
        var cp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringHHMM", {
          enumerable: !0,
          get: function () {
            return cp.formatUnixDateToHumanStringHHMM;
          },
        });
        var pp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringMMMDD", {
          enumerable: !0,
          get: function () {
            return pp.formatUnixDateToHumanStringMMMDD;
          },
        });
        var gp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringMMM", {
          enumerable: !0,
          get: function () {
            return gp.formatUnixDateToHumanStringMMM;
          },
        });
        var yp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringDD", {
          enumerable: !0,
          get: function () {
            return yp.formatUnixDateToHumanStringDD;
          },
        });
        var fp = r(72633);
        Object.defineProperty(t, "formatUnixDateToHumanStringYYYY", {
          enumerable: !0,
          get: function () {
            return fp.formatUnixDateToHumanStringYYYY;
          },
        });
        var vp = r(71497);
        Object.defineProperty(t, "logDoubleVector", {
          enumerable: !0,
          get: function () {
            return vp.logDoubleVector;
          },
        });
        var mp = r(52578);
        Object.defineProperty(t, "getFontString", {
          enumerable: !0,
          get: function () {
            return mp.getFontString;
          },
        });
        var Sp = r(52578);
        Object.defineProperty(t, "DEFAULT_FONT_FAMILY", {
          enumerable: !0,
          get: function () {
            return Sp.DEFAULT_FONT_FAMILY;
          },
        });
        var Pp = r(52578);
        Object.defineProperty(t, "getFontFamily", {
          enumerable: !0,
          get: function () {
            return Pp.getFontFamily;
          },
        });
        var Cp = r(11665);
        Object.defineProperty(t, "geometryHelpers", {
          enumerable: !0,
          get: function () {
            return Cp.geometryHelpers;
          },
        });
        var bp = r(73538);
        Object.defineProperty(t, "generateGuid", {
          enumerable: !0,
          get: function () {
            return bp.generateGuid;
          },
        });
        var xp = r(73538);
        Object.defineProperty(t, "base64Id", {
          enumerable: !0,
          get: function () {
            return xp.base64Id;
          },
        });
        var Ap = r(54535);
        Object.defineProperty(t, "hasAllProperties", {
          enumerable: !0,
          get: function () {
            return Ap.hasAllProperties;
          },
        });
        var Tp = r(17575);
        Object.defineProperty(t, "hashUtils", {
          enumerable: !0,
          get: function () {
            return Tp.hashUtils;
          },
        });
        var Ep = r(69854);
        Object.defineProperty(t, "HEIGHT_SERIES_MAX_TEXTURE_SIZE", {
          enumerable: !0,
          get: function () {
            return Ep.HEIGHT_SERIES_MAX_TEXTURE_SIZE;
          },
        });
        var Rp = r(69854);
        Object.defineProperty(t, "validateColorStops", {
          enumerable: !0,
          get: function () {
            return Rp.validateColorStops;
          },
        });
        var Dp = r(99064);
        Object.defineProperty(t, "htmlToElement", {
          enumerable: !0,
          get: function () {
            return Dp.htmlToElement;
          },
        });
        var wp = r(99064);
        Object.defineProperty(t, "stringOccurrences", {
          enumerable: !0,
          get: function () {
            return wp.stringOccurrences;
          },
        });
        var Mp = r(34483);
        Object.defineProperty(t, "createImageAsync", {
          enumerable: !0,
          get: function () {
            return Mp.createImageAsync;
          },
        });
        var Lp = r(34483);
        Object.defineProperty(t, "createImagesArrayAsync", {
          enumerable: !0,
          get: function () {
            return Lp.createImagesArrayAsync;
          },
        });
        var Op = r(72934);
        Object.defineProperty(t, "isRealNumber", {
          enumerable: !0,
          get: function () {
            return Op.isRealNumber;
          },
        });
        var Ip = r(9254);
        Object.defineProperty(t, "Logger", {
          enumerable: !0,
          get: function () {
            return Ip.Logger;
          },
        });
        var kp = r(67492);
        Object.defineProperty(t, "getNoisySinewave", {
          enumerable: !0,
          get: function () {
            return kp.getNoisySinewave;
          },
        });
        var _p = r(67492);
        Object.defineProperty(t, "fillNoisySinewave", {
          enumerable: !0,
          get: function () {
            return _p.fillNoisySinewave;
          },
        });
        var Vp = r(67492);
        Object.defineProperty(t, "logToBase", {
          enumerable: !0,
          get: function () {
            return Vp.logToBase;
          },
        });
        var Np = r(4748);
        Object.defineProperty(t, "memoize", {
          enumerable: !0,
          get: function () {
            return Np.memoize;
          },
        });
        var Bp = r(27307);
        Object.defineProperty(t, "ObjectRegistry", {
          enumerable: !0,
          get: function () {
            return Bp.ObjectRegistry;
          },
        });
        var Fp = r(27307);
        Object.defineProperty(t, "MemoryUsageHelper", {
          enumerable: !0,
          get: function () {
            return Fp.MemoryUsageHelper;
          },
        });
        var Hp = r(8591);
        Object.defineProperty(t, "formatNumber2Digits", {
          enumerable: !0,
          get: function () {
            return Hp.formatNumber2Digits;
          },
        });
        var Yp = r(8591);
        Object.defineProperty(t, "numericHashCode", {
          enumerable: !0,
          get: function () {
            return Yp.numericHashCode;
          },
        });
        var zp = r(8591);
        Object.defineProperty(t, "formatNumber", {
          enumerable: !0,
          get: function () {
            return zp.formatNumber;
          },
        });
        var jp = r(8591);
        Object.defineProperty(t, "toSuperScript", {
          enumerable: !0,
          get: function () {
            return jp.toSuperScript;
          },
        });
        var Xp = r(8591);
        Object.defineProperty(t, "toScientific", {
          enumerable: !0,
          get: function () {
            return Xp.toScientific;
          },
        });
        var Gp = r(8591);
        Object.defineProperty(t, "toEngineering", {
          enumerable: !0,
          get: function () {
            return Gp.toEngineering;
          },
        });
        var Wp = r(8591);
        Object.defineProperty(t, "checkIsNaN", {
          enumerable: !0,
          get: function () {
            return Wp.checkIsNaN;
          },
        });
        var Up = r(48008);
        Object.defineProperty(t, "parseColorToHexStringArgb", {
          enumerable: !0,
          get: function () {
            return Up.parseColorToHexStringArgb;
          },
        });
        var $p = r(48008);
        Object.defineProperty(t, "parseColorToHexStringAbgr", {
          enumerable: !0,
          get: function () {
            return $p.parseColorToHexStringAbgr;
          },
        });
        var Zp = r(48008);
        Object.defineProperty(t, "parseColorToUIntArgb", {
          enumerable: !0,
          get: function () {
            return Zp.parseColorToUIntArgb;
          },
        });
        var qp = r(48008);
        Object.defineProperty(t, "parseColorToUIntAbgr", {
          enumerable: !0,
          get: function () {
            return qp.parseColorToUIntAbgr;
          },
        });
        var Kp = r(48008);
        Object.defineProperty(t, "toHex", {
          enumerable: !0,
          get: function () {
            return Kp.toHex;
          },
        });
        var Jp = r(48008);
        Object.defineProperty(t, "parseColorToTArgb", {
          enumerable: !0,
          get: function () {
            return Jp.parseColorToTArgb;
          },
        });
        var Qp = r(48008);
        Object.defineProperty(t, "parseArgbToHtmlColor", {
          enumerable: !0,
          get: function () {
            return Qp.parseArgbToHtmlColor;
          },
        });
        var eg = r(48008);
        Object.defineProperty(t, "parseTArgbToHtmlColor", {
          enumerable: !0,
          get: function () {
            return eg.parseTArgbToHtmlColor;
          },
        });
        var tg = r(16602);
        Object.defineProperty(t, "EPerformanceMarkType", {
          enumerable: !0,
          get: function () {
            return tg.EPerformanceMarkType;
          },
        });
        var rg = r(16602);
        Object.defineProperty(t, "EPerformanceDebugLevel", {
          enumerable: !0,
          get: function () {
            return rg.EPerformanceDebugLevel;
          },
        });
        var ig = r(16602);
        Object.defineProperty(t, "PerformanceDebugHelper", {
          enumerable: !0,
          get: function () {
            return ig.PerformanceDebugHelper;
          },
        });
        var og = r(16602);
        Object.defineProperty(t, "runAfterFramePaint", {
          enumerable: !0,
          get: function () {
            return og.runAfterFramePaint;
          },
        });
        var ag = r(21670);
        Object.defineProperty(t, "calcDistanceFromLine", {
          enumerable: !0,
          get: function () {
            return ag.calcDistanceFromLine;
          },
        });
        var sg = r(21670);
        Object.defineProperty(t, "calcCrossProduct", {
          enumerable: !0,
          get: function () {
            return sg.calcCrossProduct;
          },
        });
        var ng = r(21670);
        Object.defineProperty(t, "calcDistance", {
          enumerable: !0,
          get: function () {
            return ng.calcDistance;
          },
        });
        var lg = r(21670);
        Object.defineProperty(t, "testIsInBounds", {
          enumerable: !0,
          get: function () {
            return lg.testIsInBounds;
          },
        });
        var dg = r(21670);
        Object.defineProperty(t, "calcAnnotationBordersForAxisMarker", {
          enumerable: !0,
          get: function () {
            return dg.calcAnnotationBordersForAxisMarker;
          },
        });
        var hg = r(21670);
        Object.defineProperty(t, "testIsInXBounds", {
          enumerable: !0,
          get: function () {
            return hg.testIsInXBounds;
          },
        });
        var ug = r(21670);
        Object.defineProperty(t, "testIsInInterval", {
          enumerable: !0,
          get: function () {
            return ug.testIsInInterval;
          },
        });
        var cg = r(21670);
        Object.defineProperty(t, "calcDotProduct", {
          enumerable: !0,
          get: function () {
            return cg.calcDotProduct;
          },
        });
        var pg = r(21670);
        Object.defineProperty(t, "calcDistanceFromLineSegment", {
          enumerable: !0,
          get: function () {
            return pg.calcDistanceFromLineSegment;
          },
        });
        var gg = r(21670);
        Object.defineProperty(t, "testPointInTriangle", {
          enumerable: !0,
          get: function () {
            return gg.testPointInTriangle;
          },
        });
        var yg = r(20346);
        Object.defineProperty(t, "getRandomInRange", {
          enumerable: !0,
          get: function () {
            return yg.getRandomInRange;
          },
        });
        var fg = r(61090);
        Object.defineProperty(t, "getStocksDataFactory", {
          enumerable: !0,
          get: function () {
            return fg.getStocksDataFactory;
          },
        });
        var vg = r(61090);
        Object.defineProperty(t, "getNextRandomPriceBarFactory", {
          enumerable: !0,
          get: function () {
            return vg.getNextRandomPriceBarFactory;
          },
        });
        var mg = r(94532);
        Object.defineProperty(t, "getAttributeFromString", {
          enumerable: !0,
          get: function () {
            return mg.getAttributeFromString;
          },
        });
        var Sg = r(87092);
        Object.defineProperty(t, "wrapNativeText", {
          enumerable: !0,
          get: function () {
            return Sg.wrapNativeText;
          },
        });
        var Pg = r(87092);
        Object.defineProperty(t, "getNativeTextSize", {
          enumerable: !0,
          get: function () {
            return Pg.getNativeTextSize;
          },
        });
        var Cg = r(58345);
        Object.defineProperty(t, "ESize", {
          enumerable: !0,
          get: function () {
            return Cg.ESize;
          },
        });
        var bg = r(58345);
        Object.defineProperty(t, "ECoord", {
          enumerable: !0,
          get: function () {
            return bg.ECoord;
          },
        });
        var xg = r(58345);
        Object.defineProperty(t, "EShift", {
          enumerable: !0,
          get: function () {
            return xg.EShift;
          },
        });
        var Ag = r(32873);
        Object.defineProperty(t, "translateFromCanvasToSeriesViewRect", {
          enumerable: !0,
          get: function () {
            return Ag.translateFromCanvasToSeriesViewRect;
          },
        });
        var Tg = r(32873);
        Object.defineProperty(t, "translateFromSeriesViewRectToCanvas", {
          enumerable: !0,
          get: function () {
            return Tg.translateFromSeriesViewRectToCanvas;
          },
        });
        var Eg = r(32873);
        Object.defineProperty(t, "translateFromCanvasToSeriesViewRectX", {
          enumerable: !0,
          get: function () {
            return Eg.translateFromCanvasToSeriesViewRectX;
          },
        });
        var Rg = r(32873);
        Object.defineProperty(t, "translateFromCanvasToSeriesViewRectY", {
          enumerable: !0,
          get: function () {
            return Rg.translateFromCanvasToSeriesViewRectY;
          },
        });
        var Dg = r(32873);
        Object.defineProperty(t, "translateFromSeriesViewRectToCanvasX", {
          enumerable: !0,
          get: function () {
            return Dg.translateFromSeriesViewRectToCanvasX;
          },
        });
        var wg = r(32873);
        Object.defineProperty(t, "translateFromSeriesViewRectToCanvasY", {
          enumerable: !0,
          get: function () {
            return wg.translateFromSeriesViewRectToCanvasY;
          },
        });
        var Mg = r(32873);
        Object.defineProperty(t, "translateToScaled", {
          enumerable: !0,
          get: function () {
            return Mg.translateToScaled;
          },
        });
        var Lg = r(32873);
        Object.defineProperty(t, "translateToNotScaled", {
          enumerable: !0,
          get: function () {
            return Lg.translateToNotScaled;
          },
        });
        var Og = r(32873);
        Object.defineProperty(t, "translateToScaledRect", {
          enumerable: !0,
          get: function () {
            return Og.translateToScaledRect;
          },
        });
        var Ig = r(32873);
        Object.defineProperty(t, "translateToNotScaledRect", {
          enumerable: !0,
          get: function () {
            return Ig.translateToNotScaledRect;
          },
        });
        var kg = r(32873);
        Object.defineProperty(t, "translateDataValueRectToAbsolute", {
          enumerable: !0,
          get: function () {
            return kg.translateDataValueRectToAbsolute;
          },
        });
        var _g = r(11727);
        Object.defineProperty(t, "updateTsrVector4", {
          enumerable: !0,
          get: function () {
            return _g.updateTsrVector4;
          },
        });
        var Vg = r(11727);
        Object.defineProperty(t, "fromTsrVector4", {
          enumerable: !0,
          get: function () {
            return Vg.fromTsrVector4;
          },
        });
        var Ng = r(77376);
        Object.defineProperty(t, "watermarkHelpers", {
          enumerable: !0,
          get: function () {
            return Ng.watermarkHelpers;
          },
        });
        var Bg = r(14936);
        Object.defineProperty(t, "zeroArray2D", {
          enumerable: !0,
          get: function () {
            return Bg.zeroArray2D;
          },
        });
      },
      60986: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EVerticalAnchorPoint = t.EHorizontalAnchorPoint = void 0),
          ((i =
            t.EHorizontalAnchorPoint || (t.EHorizontalAnchorPoint = {})).Left =
            "Left"),
          (i.Center = "Center"),
          (i.Right = "Right"),
          ((r = t.EVerticalAnchorPoint || (t.EVerticalAnchorPoint = {})).Top =
            "Top"),
          (r.Center = "Center"),
          (r.Bottom = "Bottom");
      },
      10763: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAnimationType = void 0),
          ((r = t.EAnimationType || (t.EAnimationType = {})).Fade = "Fade"),
          (r.Scale = "Scale"),
          (r.Sweep = "Sweep"),
          (r.Wave = "Wave"),
          (r.Style = "Style"),
          (r.Custom = "Custom");
      },
      26520: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAnnotationClippingMode = void 0),
          ((r =
            t.EAnnotationClippingMode ||
            (t.EAnnotationClippingMode = {})).SeriesViewRect =
            "SeriesViewRect"),
          (r.SubChart = "SubChart"),
          (r.Chart = "Chart");
      },
      39922: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAutoColorMode = void 0),
          ((r = t.EAutoColorMode || (t.EAutoColorMode = {})).Never = "Never"),
          (r.Once = "Once"),
          (r.OnAddRemoveSeries = "OnAddRemoveSeries"),
          (r.Always = "Always");
      },
      12785: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAutoRange = void 0),
          ((r = t.EAutoRange || (t.EAutoRange = {})).Once = "Once"),
          (r.Always = "Always"),
          (r.Never = "Never");
      },
      38215: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.handleInvalidAxisAlignment =
            t.getIsVertical =
            t.getIsHorizontal =
            t.EAxisAlignment =
              void 0),
          (function (e) {
            (e.Right = "Right"),
              (e.Left = "Left"),
              (e.Top = "Top"),
              (e.Bottom = "Bottom");
          })((r = t.EAxisAlignment || (t.EAxisAlignment = {}))),
          (t.getIsHorizontal = (e) =>
            !![r.Bottom, r.Top].includes(e) ||
            (![r.Right, r.Left].includes(e) && void 0)),
          (t.getIsVertical = (e) =>
            !1 === (0, t.getIsHorizontal)(e) ||
            (!0 !== (0, t.getIsHorizontal)(e) && void 0)),
          (t.handleInvalidAxisAlignment = (e) => {
            throw new Error(`Invalid Axis Alignment value: "${e}"!`);
          });
      },
      2192: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EAxisType = void 0),
          ((r = t.EAxisType || (t.EAxisType = {})).CategoryAxis =
            "CategoryAxis"),
          (r.NumericAxis = "NumericAxis"),
          (r.LogarithmicAxis = "LogarithmicAxis"),
          (r.NumericAxis3D = "NumericAxis3D"),
          (r.DateTimeNumericAxis = "DateTimeNumericAxis"),
          (r.PolarNumericAxis = "PolarNumericAxis"),
          (r.PolarCategoryAxis = "PolarCategoryAxis");
      },
      11043: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EBaseType = void 0),
          (function (e) {
            (e.Axis = "Axis"),
              (e.Annotation = "Annotation"),
              (e.RenderableSeries = "RenderableSeries"),
              (e.LayoutManager = "LayoutManager"),
              (e.ThemeProvider = "ThemeProvider"),
              (e.Chart2DModifier = "Chart2DModifier"),
              (e.Chart3DModifier = "Chart3DModifier"),
              (e.LabelProvider = "LabelProvider"),
              (e.PointMarker = "PointMarker"),
              (e.PointMarker3D = "PointMarker3D"),
              (e.ShaderEffect = "ShaderEffect"),
              (e.PaletteProvider = "PaletteProvider"),
              (e.Animation = "Animation"),
              (e.Loader = "Loader"),
              (e.MetadataGenerator = "MetadataGenerator"),
              (e.OptionFunction = "OptionFunction"),
              (e.OnCreateFunction = "OnCreateFunction"),
              (e.DataFilter = "DataFilter"),
              (e.LayoutStrategy = "LayoutStrategy"),
              (e.DataLabelProvider = "DataLabelProvider");
          })(t.EBaseType || (t.EBaseType = {}));
      },
      89955: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EChart3DModifierType = t.EChart2DModifierType = void 0),
          ((i =
            t.EChart2DModifierType || (t.EChart2DModifierType = {})).Cursor =
            "Cursor"),
          (i.PolarCursor = "PolarCursor"),
          (i.DataPointSelection = "DataPointSelection"),
          (i.PolarDataPointSelection = "PolarDataPointSelection"),
          (i.Legend = "Legend"),
          (i.PolarLegend = "PolarLegend"),
          (i.MouseWheelZoom = "MouseWheelZoom"),
          (i.PolarMouseWheelZoom = "PolarMouseWheelZoom"),
          (i.PinchZoom = "PinchZoom"),
          (i.Rollover = "Rollover"),
          (i.VerticalSlice = "VerticalSlice"),
          (i.RubberBandXYZoom = "RubberBandXYZoom"),
          (i.PolarArcZoom = "PolarArcZoom"),
          (i.SeriesSelection = "SeriesSelection"),
          (i.XAxisDrag = "XAxisDrag"),
          (i.YAxisDrag = "YAxisDrag"),
          (i.ZoomExtents = "ZoomExtents"),
          (i.PolarZoomExtents = "PolarZoomExtents"),
          (i.ZoomPan = "ZoomPan"),
          (i.PolarPan = "PolarPan"),
          (i.OverviewRangeSelection = "OverviewRangeSelection"),
          (i.AnnotationHover = "AnnotationHover"),
          (i.Custom = "Custom"),
          ((r =
            t.EChart3DModifierType ||
            (t.EChart3DModifierType = {})).MouseWheelZoom = "MouseWheelZoom"),
          (r.Orbit = "Orbit"),
          (r.ZoomExtents = "ZoomExtents"),
          (r.Tooltip = "Tooltip"),
          (r.PinchZoom = "PinchZoom"),
          (r.Custom = "Custom");
      },
      6859: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EExecuteOn = void 0),
          ((r = t.EExecuteOn || (t.EExecuteOn = {}))[(r.MouseLeftButton = 0)] =
            "MouseLeftButton"),
          (r[(r.MouseMiddleButton = 1)] = "MouseMiddleButton"),
          (r[(r.MouseRightButton = 2)] = "MouseRightButton"),
          (r[(r.BrowserBackButton = 3)] = "BrowserBackButton"),
          (r[(r.BrowserForwardButton = 4)] = "BrowserForwardButton");
      },
      32616: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EModifierMouseArgKey = void 0),
          ((r = t.EModifierMouseArgKey || (t.EModifierMouseArgKey = {})).Shift =
            "Shift"),
          (r.Ctrl = "Ctrl"),
          (r.Alt = "Alt"),
          (r.None = "None");
      },
      72072: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EColor = void 0),
          ((r = t.EColor || (t.EColor = {})).Aqua = "#00ffff"),
          (r.BackgroundColor = "#1c1c1e"),
          (r.Blue = "#368BC1"),
          (r.DarkGreen = "#03925e"),
          (r.DarkRed = "#be0000"),
          (r.DarkGrey = "#7e8486"),
          (r.DefaultGridBandsColor = "#202123"),
          (r.DefaultTextColor = "#c8c7c3"),
          (r.DodgerBlue = "#1E90FF"),
          (r.Green = "#228B22"),
          (r.LightGrey = "#eeeeee"),
          (r.LightSteelBlue = "#b0c4de"),
          (r.LimeGreen = "#32CD32"),
          (r.Orange = "#ff6600"),
          (r.OrangeRed = "#FF4500"),
          (r.Purple = "#B200FF"),
          (r.Red = "#ff0000"),
          (r.White = "#ffffff"),
          (r.Yellow = "#FFFF00");
      },
      60960: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertYColumnMode =
            t.EColumnYMode =
            t.convertColumnMode =
            t.EColumnMode =
              void 0),
          (function (e) {
            (e.Mid = "Mid"),
              (e.MidWidth = "MidWidth"),
              (e.Start = "Start"),
              (e.StartWidth = "StartWidth"),
              (e.StartEnd = "StartEnd");
          })((r = t.EColumnMode || (t.EColumnMode = {}))),
          (t.convertColumnMode = function (e, t) {
            switch (e) {
              case r.Mid:
                return t.SCRTColumnXMode.ColumnXMode_Mid;
              case r.MidWidth:
                return t.SCRTColumnXMode.ColumnXMode_MidX2Width;
              case r.Start:
                return t.SCRTColumnXMode.ColumnXMode_Start;
              case r.StartEnd:
                return t.SCRTColumnXMode.ColumnXMode_StartX2End;
              case r.StartWidth:
                return t.SCRTColumnXMode.ColumnXMode_StartX2Width;
              default:
                return t.SCRTColumnXMode.ColumnXMode_Mid;
            }
          }),
          (function (e) {
            (e.TopBottom = "TopBottom"),
              (e.TopHeight = "TopHeight"),
              (e.CenterHeight = "CenterHeight");
          })((i = t.EColumnYMode || (t.EColumnYMode = {}))),
          (t.convertYColumnMode = function (e, t) {
            switch (e) {
              case i.TopBottom:
                return t.SCRTColumnYMode.ColumnYMode_TopBottom;
              case i.TopHeight:
                return t.SCRTColumnYMode.ColumnYMode_TopHeight;
              case i.CenterHeight:
                return t.SCRTColumnYMode.ColumnYMode_CenterHeight;
              default:
                return t.SCRTColumnYMode.ColumnYMode_TopBottom;
            }
          });
      },
      14278: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ECursorStyle = void 0),
          ((r = t.ECursorStyle || (t.ECursorStyle = {})).NS = "ns-resize"),
          (r.EW = "ew-resize"),
          (r.Defalut = "auto");
      },
      51097: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDataFilterType = void 0),
          ((r = t.EDataFilterType || (t.EDataFilterType = {})).XyLinearTrend =
            "XyLinearTrend"),
          (r.XyMovingAverage = "XyMovingAverage"),
          (r.XyRatio = "XyRatio"),
          (r.XyScaleOffset = "XyScaleOffset"),
          (r.XyyScaleOffset = "XyyScaleOffset"),
          (r.XyzScaleOffset = "XyzScaleOffset"),
          (r.HlcScaleOffset = "HlcScaleOffset"),
          (r.OhlcScaleOffset = "OhlcScaleOffset");
      },
      2963: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDataLabelProviderType = void 0),
          ((r =
            t.EDataLabelProviderType ||
            (t.EDataLabelProviderType = {})).Default = "Default"),
          (r.Line = "Line"),
          (r.Column = "Column"),
          (r.Rectangle = "Rectangle"),
          (r.Text = "Text"),
          (r.Heatmap = "Heatmap"),
          (r.Band = "Band"),
          (r.Bubble = "Bubble"),
          (r.NonUniformHeatmap = "NonUniformHeatmap"),
          (r.Contours = "Contours"),
          (r.StackedCollection = "StackedCollection"),
          (r.Custom = "Custom"),
          (r.PolarDefault = "PolarDefault"),
          (r.PolarColumn = "PolarColumn");
      },
      62993: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDataLabelSkipMode = void 0),
          ((r = t.EDataLabelSkipMode || (t.EDataLabelSkipMode = {})).ShowAll =
            "ShowAll"),
          (r.SkipIfOverlapPrevious = "SkipIfOverlapPrevious"),
          (r.SkipIfOverlapNext = "SkipIfOverlapNext"),
          (r.SkipIfSame = "SkipIfSame");
      },
      27970: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDataPointWidthMode = void 0),
          ((r =
            t.EDataPointWidthMode || (t.EDataPointWidthMode = {})).Absolute =
            "Absolute"),
          (r.Relative = "Relative"),
          (r.Range = "Range");
      },
      3777: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDefaultRenderLayer = void 0),
          ((r = t.EDefaultRenderLayer || (t.EDefaultRenderLayer = {}))[
            (r.Background = 0)
          ] = "Background"),
          (r[(r.AxisBandsLayer = 1)] = "AxisBandsLayer"),
          (r[(r.MinorGridLinesLayer = 2)] = "MinorGridLinesLayer"),
          (r[(r.MajorGridLinesLayer = 3)] = "MajorGridLinesLayer"),
          (r[(r.AnnotationsBelowSeriesLayer = 4)] =
            "AnnotationsBelowSeriesLayer"),
          (r[(r.SeriesLayer = 5)] = "SeriesLayer"),
          (r[(r.HoveredSeriesLayer = 6)] = "HoveredSeriesLayer"),
          (r[(r.SelectedSeriesLayer = 7)] = "SelectedSeriesLayer"),
          (r[(r.AxisBordersLayer = 8)] = "AxisBordersLayer"),
          (r[(r.AxesLayer = 9)] = "AxesLayer"),
          (r[(r.AnnotationsAboveSeriesLayer = 10)] =
            "AnnotationsAboveSeriesLayer"),
          (r[(r.Foreground = 11)] = "Foreground");
      },
      7980: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EDragMode = void 0),
          ((r = t.EDragMode || (t.EDragMode = {})).Scaling = "Scaling"),
          (r.Panning = "Panning");
      },
      79226: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EErrorDirection = void 0),
          ((r = t.EErrorDirection || (t.EErrorDirection = {})).Horizontal =
            "Horizontal"),
          (r.Vertical = "Vertical");
      },
      32287: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EErrorMode = void 0),
          ((r = t.EErrorMode || (t.EErrorMode = {})).Both = "Both"),
          (r.High = "High"),
          (r.Low = "Low");
      },
      28268: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EColorPickMode = void 0),
          ((r = t.EColorPickMode || (t.EColorPickMode = {})).Discrete =
            "Discrete"),
          (r.Interpolated = "Interpolated");
      },
      74218: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EHeightSeriesMode = void 0),
          ((r =
            t.EHeightSeriesMode || (t.EHeightSeriesMode = {})).Perpendicular =
            "Perpendicular"),
          (r.Vertical = "Vertical"),
          (r.Horizontal = "Horizontal");
      },
      10581: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EHoverMode = void 0),
          ((r = t.EHoverMode || (t.EHoverMode = {})).Multi = "Multi"),
          (r.TopmostIncluded = "TopmostIncluded"),
          (r.AbsoluteTopmost = "AbsoluteTopmost");
      },
      63415: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ELabelAlignment = void 0),
          ((r = t.ELabelAlignment || (t.ELabelAlignment = {})).Auto = "Auto"),
          (r.Left = "Left"),
          (r.Right = "Right"),
          (r.Center = "Center");
      },
      11805: (e, t) => {
        "use strict";
        var r, i, o, a, s;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ERadialAxisLabelPlacement =
            t.EAngularAxisLabelPlacement =
            t.EVerticalAlignment =
            t.EHorizontalAlignment =
            t.ELabelPlacement =
              void 0),
          ((s = t.ELabelPlacement || (t.ELabelPlacement = {})).Right = "Right"),
          (s.TopRight = "TopRight"),
          (s.BottomRight = "BottomRight"),
          (s.Bottom = "Bottom"),
          (s.Left = "Left"),
          (s.TopLeft = "TopLeft"),
          (s.BottomLeft = "BottomLeft"),
          (s.Top = "Top"),
          (s.Axis = "Axis"),
          (s.Auto = "Auto"),
          ((a = t.EHorizontalAlignment || (t.EHorizontalAlignment = {})).Right =
            "Right"),
          (a.Left = "Left"),
          ((o = t.EVerticalAlignment || (t.EVerticalAlignment = {})).Top =
            "Top"),
          (o.Bottom = "Bottom"),
          ((i =
            t.EAngularAxisLabelPlacement ||
            (t.EAngularAxisLabelPlacement = {})).Inner = "Inner"),
          (i.Outer = "Outer"),
          (i.Center = "Center"),
          ((r =
            t.ERadialAxisLabelPlacement ||
            (t.ERadialAxisLabelPlacement = {})).Top = "Top"),
          (r.Bottom = "Bottom"),
          (r.Center = "Center");
      },
      40359: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ELabelProviderType = void 0),
          ((r = t.ELabelProviderType || (t.ELabelProviderType = {})).Numeric =
            "Numeric"),
          (r.Logarithmic = "Logarithmic"),
          (r.Date = "Date"),
          (r.SmartDate = "SmartDate"),
          (r.Text = "Text"),
          (r.Pie = "Pie");
      },
      883: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ELayoutManagerType = void 0),
          ((r = t.ELayoutManagerType || (t.ELayoutManagerType = {})).Default =
            "Default"),
          (r.CentralAxes = "CentralAxes"),
          (r.Synchronised = "Synchronised"),
          (r.Polar = "Polar");
      },
      73785: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ELayoutStrategyType = void 0),
          ((r =
            t.ELayoutStrategyType || (t.ELayoutStrategyType = {})).LeftOuter =
            "LeftOuter"),
          (r.RightOuter = "RightOuter"),
          (r.TopOuter = "TopOuter"),
          (r.BottomOuter = "BottomOuter"),
          (r.LeftInner = "LeftInner"),
          (r.RightInner = "RightInner"),
          (r.TopInner = "TopInner"),
          (r.BottomInner = "BottomInner"),
          (r.LeftStacked = "LeftStacked"),
          (r.RightStacked = "RightStacked"),
          (r.TopStacked = "TopStacked"),
          (r.BottomStacked = "BottomStacked"),
          (r.AngularOuter = "AngularOuter"),
          (r.AngularInner = "AngularInner"),
          (r.RadialOuter = "RadialOuter"),
          (r.RadialInner = "RadialInner"),
          (r.Custom = "Custom");
      },
      66405: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EModifierType = void 0),
          ((r = t.EModifierType || (t.EModifierType = {})).Chart2DModifier =
            "2D Chart Modifier"),
          (r.Chart2DPolarModifier = "2D Polar Chart Modifier"),
          (r.Chart3DModifier = "3D Chart Modifier"),
          (r.MultiChart2DModifier = "Multiple 2D Chart Modifier");
      },
      57935: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EMousePosition = void 0),
          ((r = t.EMousePosition || (t.EMousePosition = {})).OutOfCanvas =
            "OutOfCanvas"),
          (r.AxisArea = "AxisArea"),
          (r.SeriesArea = "SeriesArea");
      },
      65885: (e, t) => {
        "use strict";
        function r(e) {
          return e instanceof Float64Array;
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.subArray = t.isNumberArray = t.isTypedArray = void 0),
          (t.isTypedArray = r),
          (t.isNumberArray = function (e) {
            return (
              Array.isArray(e) && (!(e.length > 0) || "number" == typeof e[0])
            );
          }),
          (t.subArray = function (e, t, i) {
            return r(e) ? e.subarray(t, i) : e.slice(t, i);
          });
      },
      96528: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ENumericFormat = void 0),
          ((r = t.ENumericFormat || (t.ENumericFormat = {})).NoFormat =
            "NoFormat"),
          (r.Decimal = "Decimal"),
          (r.SignificantFigures = "SignificantFigures"),
          (r.Date_DDMMYYYY = "Date_DDMMYYYY"),
          (r.Date_DDMMYY = "Date_DDMMYY"),
          (r.Date_DDMMHHMM = "Date_DDMMHHMM"),
          (r.Date_DDMM = "Date_DDMM"),
          (r.Date_HHMM = "Date_HHMM"),
          (r.Date_HHMMSS = "Date_HHMMSS"),
          (r.Date_SSms = "Date_SSms"),
          (r.Exponential = "Exponential"),
          (r.Scientific = "Scientific"),
          (r.Engineering = "Engineering");
      },
      34496: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.OrderedRenderable = void 0);
        const i = r(73538);
        t.OrderedRenderable = class {
          constructor(e, t, r) {
            (this.isVisible = !0),
              (this.setRenderNextTo = (e, t) => {}),
              (this.getRenderNextTo = () => {}),
              (this.id = (0, i.generateGuid)()),
              (this.surfaceRenderOrder = e),
              (this.renderLayer = t),
              (this.renderOrder = r);
          }
          getSurfaceRenderOrder() {
            return this.surfaceRenderOrder;
          }
          getRenderLayer() {
            return this.renderLayer;
          }
          getRenderOrder() {
            return this.renderOrder;
          }
          setRenderOrder(e) {
            this.renderOrder = e;
          }
        };
      },
      28436: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPaletteProviderType = void 0),
          ((r =
            t.EPaletteProviderType || (t.EPaletteProviderType = {})).Gradient =
            "Gradient"),
          (r.DataPointSelection = "DataPointSelection"),
          (r.Custom = "Custom"),
          (r.Gradient3D = "Gradient3D"),
          (r.Solid3D = "Solid3D");
      },
      56356: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPointMarker3DType = void 0),
          ((r = t.EPointMarker3DType || (t.EPointMarker3DType = {})).Sphere =
            "Sphere"),
          (r.Cube = "Cube"),
          (r.Pyramid = "Pyramid"),
          (r.Cylinder = "Cylinder"),
          (r.Quad = "Quad"),
          (r.Pixel = "Pixel"),
          (r.Ellipse = "Ellipse"),
          (r.Triangle = "Triangle"),
          (r.Custom = "Custom");
      },
      30323: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EPointMarkerType = void 0),
          ((r = t.EPointMarkerType || (t.EPointMarkerType = {})).Ellipse =
            "Ellipse"),
          (r.Cross = "Cross"),
          (r.Sprite = "Sprite"),
          (r.Square = "Square"),
          (r.Triangle = "Triangle"),
          (r.X = "X"),
          (r.Custom = "Custom");
      },
      44431: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EStrokeLineJoin = void 0),
          ((r = t.EStrokeLineJoin || (t.EStrokeLineJoin = {})).Arcs = "arcs"),
          (r.Bevel = "bevel"),
          (r.Miter = "miter"),
          (r.MiterClip = "miter-clip"),
          (r.Round = "round");
      },
      32406: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ERenderLayer = void 0),
          ((r = t.ERenderLayer || (t.ERenderLayer = {}))[(r.First = 0)] =
            "First"),
          (r[(r.Second = 1)] = "Second"),
          (r[(r.Third = 2)] = "Third");
      },
      34116: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ESceneEntityType = void 0),
          ((r =
            t.ESceneEntityType || (t.ESceneEntityType = {})).AxisCubeEntity =
            "AxisCubeEntity"),
          (r.Custom = "Custom"),
          (r.GizmoEntity = "GizmoEntity"),
          (r.RootSceneEntity = "RootSceneEntity"),
          (r.ScatterPointsSceneEntity = "ScatterPointsSceneEntity"),
          (r.SCRTSceneEntity = "SCRTSceneEntity"),
          (r.SurfaceMeshSceneEntity = "SurfaceMeshSceneEntity"),
          (r.PointLine3DSceneEntity = "PointLine3DSceneEntity"),
          (r.ColumnSceneEntity = "ColumnSceneEntity");
      },
      91465: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ESciChartSurfaceType = void 0),
          ((r =
            t.ESciChartSurfaceType || (t.ESciChartSurfaceType = {})).Default2D =
            "Default2D"),
          (r.Pie2D = "Pie2D"),
          (r.Polar2D = "Polar2D"),
          (r.Default3D = "Default3D");
      },
      26361: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertSearchMode = t.ESearchMode = void 0),
          (function (e) {
            (e.Exact = "Exact"),
              (e.Nearest = "Nearest"),
              (e.RoundDown = "RoundDown"),
              (e.RoundUp = "RoundUp");
          })((r = t.ESearchMode || (t.ESearchMode = {}))),
          (t.convertSearchMode = (e, t) => {
            switch (t) {
              case r.Exact:
                return e.SCRTFindIndexSearchMode.Exact;
              case r.Nearest:
                return e.SCRTFindIndexSearchMode.Nearest;
              case r.RoundDown:
                return e.SCRTFindIndexSearchMode.RoundDown;
              case r.RoundUp:
                return e.SCRTFindIndexSearchMode.RoundUp;
            }
          });
      },
      5337: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ESeriesType = void 0),
          ((r = t.ESeriesType || (t.ESeriesType = {})).BandSeries =
            "BandSeries"),
          (r.PolarBandSeries = "PolarBandSeries"),
          (r.SplineBandSeries = "SplineBandSeries"),
          (r.BubbleSeries = "BubbleSeries"),
          (r.CandlestickSeries = "CandlestickSeries"),
          (r.ColumnSeries = "ColumnSeries"),
          (r.PolarColumnSeries = "PolarColumnSeries"),
          (r.ImpulseSeries = "ImpulseSeries"),
          (r.LineSeries = "LineSeries"),
          (r.PolarLineSeries = "PolarLineSeries"),
          (r.LineSegmentSeries = "LineSegmentSeries"),
          (r.SplineLineSeries = "SplineLineSeries"),
          (r.MountainSeries = "MountainSeries"),
          (r.PolarMountainSeries = "PolarMountainSeries"),
          (r.SplineMountainSeries = "SplineMountainSeries"),
          (r.OhlcSeries = "OhlcSeries"),
          (r.StackedColumnSeries = "StackedColumnSeries"),
          (r.PolarStackedColumnSeries = "PolarStackedColumnSeries"),
          (r.StackedMountainSeries = "StackedMountainSeries"),
          (r.PolarStackedMountainSeries = "PolarStackedMountainSeries"),
          (r.SmoothStackedMountainSeries = "SmoothStackedMountainSeries"),
          (r.UniformContoursSeries = "UniformContoursSeries"),
          (r.UniformHeatmapSeries = "UniformHeatmapSeries"),
          (r.PolarUniformHeatmapSeries = "PolarUniformHeatmapSeries"),
          (r.NonUniformHeatmapSeries = "NonUniformHeatmapSeries"),
          (r.StackedMountainCollection = "StackedMountainCollection"),
          (r.PolarStackedMountainCollection = "PolarStackedMountainCollection"),
          (r.StackedColumnCollection = "StackedColumnCollection"),
          (r.PolarStackedColumnCollection = "PolarStackedColumnCollection"),
          (r.ScatterSeries = "ScatterSeries"),
          (r.PolarScatterSeries = "PolarScatterSeries"),
          (r.ErrorBarsSeries = "ErrorBarsSeries"),
          (r.TextSeries = "TextSeries"),
          (r.RectangleSeries = "RectangleSeries"),
          (r.BoxPlotSeries = "BoxPlotSeries"),
          (r.TriangleSeries = "TriangleSeries"),
          (r.Custom = "Custom");
      },
      75323: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EShaderEffectType = void 0),
          ((r = t.EShaderEffectType || (t.EShaderEffectType = {})).Glow =
            "Glow"),
          (r.Shadow = "Shadow");
      },
      22022: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Size = void 0);
        class r {
          constructor(e, t) {
            (this.width = e), (this.height = t);
          }
          static isEqual(e, t) {
            return (
              (null == e ? void 0 : e.width) ===
                (null == t ? void 0 : t.width) &&
              (null == e ? void 0 : e.height) ===
                (null == t ? void 0 : t.height)
            );
          }
        }
        (t.Size = r), (r.EMPTY = new r(0, 0));
      },
      64669: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.polygonFormatRequiredFieldNames =
            t.ltrbFormatRequiredFieldNames =
            t.xywhFormatRequiredFieldNames =
              void 0),
          (t.xywhFormatRequiredFieldNames = ["x", "y", "width", "height"]),
          (t.ltrbFormatRequiredFieldNames = ["left", "top", "right", "bottom"]),
          (t.polygonFormatRequiredFieldNames = ["x1", "x2", "y1", "y2"]);
      },
      19145: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ESurfaceType = void 0),
          ((r = t.ESurfaceType || (t.ESurfaceType = {})).SciChartSurfaceType =
            "SciChartSurfaceType"),
          (r.SciChartPolarSurfaceType = "SciChartPolarSurfaceType"),
          (r.SciChart3DSurfaceType = "SciChart3DSurfaceType");
      },
      62186: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EColorMapMode = void 0),
          ((r = t.EColorMapMode || (t.EColorMapMode = {})).Interpolated =
            "Interpolated"),
          (r.Stepped = "Stepped");
      },
      99176: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      36420: (e, t) => {
        "use strict";
        var r, i, o;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertMultiLineAlignment =
            t.EMultiLineAlignment =
            t.EVerticalTextPosition =
            t.EHorizontalTextPosition =
              void 0),
          ((o =
            t.EHorizontalTextPosition ||
            (t.EHorizontalTextPosition = {})).Left = "Left"),
          (o.Center = "Center"),
          (o.Right = "Right"),
          ((i =
            t.EVerticalTextPosition || (t.EVerticalTextPosition = {})).Above =
            "Above"),
          (i.Center = "Center"),
          (i.Below = "Below"),
          (function (e) {
            (e.Left = "Left"), (e.Right = "Right"), (e.Center = "Center");
          })((r = t.EMultiLineAlignment || (t.EMultiLineAlignment = {}))),
          (t.convertMultiLineAlignment = (e, t) => {
            let i = t.eTSRTextAlignMode.Left;
            switch (e) {
              case r.Left:
                i = t.eTSRTextAlignMode.Left;
                break;
              case r.Right:
                i = t.eTSRTextAlignMode.Right;
                break;
              case r.Center:
                i = t.eTSRTextAlignMode.Center;
            }
            return i;
          });
      },
      71238: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.adjustTextStyle =
            t.areEqualTextStyles =
            t.areEqualSimpleTextStyles =
            t.areEqualNativeTextStyles =
            t.areEqualTextureTextStyles =
            t.handleInvalidTextAlignment =
            t.handleInvalidChartTitlePosition =
            t.getIsHorizontalPlacement =
            t.ETitlePosition =
            t.ETextAlignment =
              void 0);
        const i = r(86127),
          o = r(87108);
        var a, s;
        ((s = t.ETextAlignment || (t.ETextAlignment = {})).Center = "Center"),
          (s.Left = "Left"),
          (s.Right = "Right"),
          (function (e) {
            (e.Top = "Top"),
              (e.Bottom = "Bottom"),
              (e.Right = "Right"),
              (e.Left = "Left");
          })((a = t.ETitlePosition || (t.ETitlePosition = {}))),
          (t.getIsHorizontalPlacement = (e) => e === a.Top || e === a.Bottom),
          (t.handleInvalidChartTitlePosition = (e) => {
            throw new Error(`Invalid chart title position: ${e}!`);
          }),
          (t.handleInvalidTextAlignment = (e) => {
            throw new Error(`Invalid text alignment "${e}"!`);
          }),
          (t.areEqualTextureTextStyles = (e, t) =>
            e.color === t.color &&
            e.fontFamily === t.fontFamily &&
            e.fontSize === t.fontSize &&
            e.fontStyle === t.fontStyle &&
            e.fontWeight === t.fontWeight &&
            e.lineSpacing === t.lineSpacing &&
            ((void 0 === e.padding && void 0 === t.padding) ||
              o.Thickness.areEqual(e.padding, t.padding))),
          (t.areEqualNativeTextStyles = (e, t) =>
            e.color === t.color &&
            e.fontFamily === t.fontFamily &&
            e.fontSize === t.fontSize &&
            e.lineSpacing === t.lineSpacing &&
            ((void 0 === e.padding && void 0 === t.padding) ||
              o.Thickness.areEqual(e.padding, t.padding))),
          (t.areEqualSimpleTextStyles = (e, r) =>
            !(!e || !r || !e.useNativeText != !r.useNativeText) &&
            (e.useNativeText && r.useNativeText
              ? (0, t.areEqualNativeTextStyles)(e, r)
              : (0, t.areEqualTextureTextStyles)(e, r))),
          (t.areEqualTextStyles = (e, r) =>
            (0, t.areEqualSimpleTextStyles)(e, r) &&
            e.rotation === r.rotation &&
            e.multilineAlignment === r.multilineAlignment),
          (t.adjustTextStyle = (e) => i.DpiHelper.adjustTextStyle(e));
      },
      62916: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EThemeProviderType = void 0),
          ((r = t.EThemeProviderType || (t.EThemeProviderType = {})).Light =
            "Light"),
          (r.Dark = "Dark"),
          (r.DarkV2 = "DarkV2"),
          (r.Navy = "Navy"),
          (r.Custom = "Custom");
      },
      95808: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ETriangleSeriesDrawMode = void 0),
          ((r =
            t.ETriangleSeriesDrawMode ||
            (t.ETriangleSeriesDrawMode = {})).List = "List"),
          (r.Polygon = "Polygon"),
          (r.Strip = "Strip");
      },
      54624: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.generateValueNamesForDataSeries = t.EValueName = void 0),
          ((r = t.EValueName || (t.EValueName = {})).Y = "y"),
          (r.Y1 = "y1"),
          (r.X1 = "x1"),
          (r.Z = "z"),
          (r.BoxPlotMedian = "median"),
          (r.BoxPlotMax = "max"),
          (r.BoxPlotUpper = "upper"),
          (r.BoxPlotLower = "lower"),
          (r.BoxPlotMinimum = "minimum"),
          (r.Close = "close"),
          (r.High = "high"),
          (r.Low = "low"),
          (r.Open = "open"),
          (t.generateValueNamesForDataSeries = function (e) {
            const t = [];
            for (let r = 0; r < e; r++)
              t.push("y" + (r > 0 ? r.toString() : ""));
            return t;
          });
      },
      24149: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EWatermarkPosition = void 0),
          ((r =
            t.EWatermarkPosition || (t.EWatermarkPosition = {})).BottomLeft =
            "BottomLeft"),
          (r.BottomRight = "BottomRight"),
          (r.TopLeft = "TopLeft"),
          (r.TopRight = "TopRight");
      },
      86699: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EXyDirection = void 0),
          ((r = t.EXyDirection || (t.EXyDirection = {})).XDirection =
            "XDirection"),
          (r.YDirection = "YDirection"),
          (r.XyDirection = "XyDirection");
      },
      9073: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EYRangeMode = void 0),
          ((r = t.EYRangeMode || (t.EYRangeMode = {})).Visible = "Visible"),
          (r.Drawn = "Drawn");
      },
      14379: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EZoomState = void 0),
          ((r = t.EZoomState || (t.EZoomState = {})).AtExtents = "AtExtents"),
          (r.UserZooming = "UserZooming");
      },
      48125: (e, t) => {
        "use strict";
        var r, i;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LicenseCheckStatus = t.LicenseType = void 0),
          ((i = t.LicenseType || (t.LicenseType = {}))[(i.NoLicense = 0)] =
            "NoLicense"),
          (i[(i.Trial = 1)] = "Trial"),
          (i[(i.Full = 2)] = "Full"),
          (i[(i.Full_Expired = 3)] = "Full_Expired"),
          (i[(i.Trial_Expired = 4)] = "Trial_Expired"),
          (i[(i.Subscription_Expired = 5)] = "Subscription_Expired"),
          (i[(i.Invalid_Developer = 6)] = "Invalid_Developer"),
          (i[(i.Requres_Validation = 7)] = "Requres_Validation"),
          (i[(i.Invalid = 8)] = "Invalid"),
          (i[(i.Community = 9)] = "Community"),
          ((r = t.LicenseCheckStatus || (t.LicenseCheckStatus = {}))[
            (r.NoLicense = 0)
          ] = "NoLicense"),
          (r[(r.FetchingFromServer = 1)] = "FetchingFromServer"),
          (r[(r.StartLookingForLicenseWizard = 2)] =
            "StartLookingForLicenseWizard"),
          (r[(r.LookingForLicenseWizard = 3)] = "LookingForLicenseWizard"),
          (r[(r.ValidatingDeveloperLicense = 4)] =
            "ValidatingDeveloperLicense"),
          (r[(r.NoLicenseInWizard = 5)] = "NoLicenseInWizard"),
          (r[(r.FailedToFindLicenseWizard = 6)] = "FailedToFindLicenseWizard"),
          (r[(r.FailedToValidateDeveloperLicense = 7)] =
            "FailedToValidateDeveloperLicense"),
          (r[(r.DevKeyInRuntimeKey = 8)] = "DevKeyInRuntimeKey"),
          (r[(r.LicenseOK = 9)] = "LicenseOK");
      },
      69854: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateColorStops = t.HEIGHT_SERIES_MAX_TEXTURE_SIZE = void 0),
          (t.HEIGHT_SERIES_MAX_TEXTURE_SIZE = 1024),
          (t.validateColorStops = function (e) {
            if (!e) return !0;
            if (e.colorStops.length < 2)
              throw new Error("Must define at least 2 colorStops");
            let r = Number.MAX_VALUE;
            const i = e.colorStops,
              o = i[0].dataValue,
              a = i[i.length - 1].dataValue;
            for (let e = 0; e < i.length - 1; e++) {
              if (i[e].dataValue >= i[e + 1].dataValue)
                throw new Error(
                  "colorStops must be unique and in ascending order"
                );
              r = Math.min(r, i[e + 1].dataValue - i[e].dataValue);
            }
            if ((a - o) / r > t.HEIGHT_SERIES_MAX_TEXTURE_SIZE)
              throw new Error(
                `Unsupported stop configuration. The range can be at most ${t.HEIGHT_SERIES_MAX_TEXTURE_SIZE} times the smallest difference between stops.\n        If you need more resolution than this, use a Fill PaletteProvider`
              );
            return !0;
          });
      },
      27307: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MemoryUsageHelper =
            t.generateIdentifier =
            t.ObjectRegistry =
              void 0);
        const i = r(16155),
          o = r(99263),
          a = r(73538);
        (t.ObjectRegistry = class {
          constructor() {
            (this.weakMapRegistry = new WeakMap()),
              (this.undeletedObjectsMap = new Map()),
              (this.uncollectedObjectsMap = new Map()),
              (this.finalizationRegistry = new FinalizationRegistry((e) => {
                this.uncollectedObjectsMap.delete(e), this.onCollect(e);
              }));
          }
          add(e, t, r = { isWasmObject: !1 }) {
            var i, o;
            const { isWasmObject: a } = r;
            this.weakMapRegistry.has(e) &&
              console.warn("Adding existing entry to the registry!", t),
              this.undeletedObjectsMap.has(t) &&
                console.warn("Adding existing entry id to the registry!", t),
              this.finalizationRegistry.register(e, t),
              this.weakMapRegistry.set(e, t);
            const s =
                null !==
                  (o =
                    null === (i = null == r ? void 0 : r.revocableToken) ||
                    void 0 === i
                      ? void 0
                      : i.proxy) && void 0 !== o
                  ? o
                  : null == r
                  ? void 0
                  : r.proxy,
              n = null == r ? void 0 : r.revocableToken;
            s && this.weakMapRegistry.set(s, t);
            const l = {
              isWasmObject: a,
              objectRef: new WeakRef(e),
              proxyRef: s && new WeakRef(s),
              revocableTokenRef: n && new WeakRef(n),
            };
            e.delete && this.undeletedObjectsMap.set(t, l),
              this.uncollectedObjectsMap.set(t, l);
          }
          remove(e) {
            return (
              this.undeletedObjectsMap.has(e) ||
                this.uncollectedObjectsMap.has(e) ||
                console.warn(`${e} was not found in the ObjectRegistry!`),
              this.undeletedObjectsMap.delete(e)
            );
          }
          getObjectId(e) {
            return this.weakMapRegistry.get(e);
          }
          deleteIDeletableObjects() {
            this.undeletedObjectsMap.forEach((e, t) => {
              e.isWasmObject || this.deleteEntry(e, t);
            });
          }
          deleteWasmObjects() {
            this.undeletedObjectsMap.forEach((e, t) => {
              e.isWasmObject && this.deleteEntry(e, t);
            });
          }
          log() {
            const e = Array.from(this.undeletedObjectsMap.keys()),
              t = Array.from(this.uncollectedObjectsMap.keys()),
              r = e.filter((e) => !this.uncollectedObjectsMap.has(e)),
              o = t.filter((e) => !this.undeletedObjectsMap.has(e)),
              a = i.labelCache.getSize();
            console.log("Object Registry Log Start:"),
              console.log("undeletedObjectsMap", this.undeletedObjectsMap),
              console.log("uncollectedObjectsMap", this.uncollectedObjectsMap),
              console.log("collectedNotDeleted", r),
              console.log("deletedNotCollected", o),
              console.log("weakMap", this.weakMapRegistry),
              console.log("axisLabelCacheSize", a),
              console.log("Object Registry Log End");
          }
          getState() {
            const e = Array.from(this.undeletedObjectsMap.keys()),
              t = Array.from(this.uncollectedObjectsMap.keys()),
              r = {};
            return (
              e.length && (r.undeletedObjectsIds = e),
              t.length && (r.uncollectedObjectsIds = t),
              r
            );
          }
          deleteEntry(e, t) {
            const r = e.objectRef.deref();
            r
              ? (r.delete(), this.remove(t))
              : console.warn(
                  `Looks like the ${t} has already been garbage collected, thus the proper cleanup could not be executed!`
                );
          }
          onCollect(e) {}
        }),
          (t.generateIdentifier = (e) =>
            `${null == e ? void 0 : e.constructor.name}_${(0,
            a.generateGuid)()}`);
        class s {
          static get isMemoryUsageDebugEnabled() {
            return this.isMemoryUsageDebugEnabledProperty;
          }
          static set isMemoryUsageDebugEnabled(e) {
            e &&
              console.warn(
                "Memory usage debug enabled! Make sure to disable it for production build!"
              );
          }
          static register(e, r) {
            var i;
            e
              ? null === (i = s.objectRegistry) ||
                void 0 === i ||
                i.add(e, null != r ? r : (0, t.generateIdentifier)(e))
              : console.warn(`Registering invalid object "${e}"!`);
          }
          static unregister(e) {
            var t;
            null === (t = s.objectRegistry) || void 0 === t || t.remove(e);
          }
          static destroyMultiChart() {
            o.sciChartDestinations.forEach((e) => e.sciChartSurface.delete(!0)),
              o.sciChart3DDestinations.forEach((e) =>
                e.sciChartSurface.delete(!0)
              );
          }
          static destroySingleCharts() {
            o.sciChartSingleDestinations.forEach((e) =>
              e.sciChartSurface.delete(!0)
            ),
              o.sciChart3DSingleDestinations.forEach((e) =>
                e.sciChartSurface.delete(!0)
              );
          }
          static destroyPieCharts() {
            o.sciChartPieDestinations.forEach((e) =>
              e.sciChartSurface.delete(!0)
            );
          }
          static destroyAllCharts() {
            s.destroyMultiChart(),
              s.destroySingleCharts(),
              s.destroyPieCharts();
          }
        }
        (t.MemoryUsageHelper = s), (s.isMemoryUsageDebugEnabledProperty = !1);
      },
      45215: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.appendRangeFifo =
            t.makeIncArray =
            t.isArraySorted =
            t.arrayRemove =
            t.areArraysEqual =
            t.countUnique =
            t.getUniqueValues =
              void 0),
          (t.getUniqueValues = function (e) {
            return e.filter((e, t, r) => null != e && r.indexOf(e) === t);
          }),
          (t.countUnique = function (e) {
            return new Set(e).size;
          }),
          (t.areArraysEqual = (e, t) => {
            if (e === t) return !0;
            if (
              (null == e ? void 0 : e.length) !==
              (null == t ? void 0 : t.length)
            )
              return !1;
            if (e && t)
              for (let r = 0; r < e.length; ++r) if (e[r] !== t[r]) return !1;
            return !0;
          }),
          (t.arrayRemove = function (e, t) {
            for (let r = 0; r < e.length; r++)
              if (e[r] === t) {
                e.splice(r, 1);
                break;
              }
            return e;
          }),
          (t.isArraySorted = function (e, t = !0) {
            let r = !0;
            const i = t ? (t) => e[t] > e[t + 1] : (t) => e[t] < e[t + 1];
            for (let t = 0; t < e.length - 1; t++)
              if (i(t)) {
                r = !1;
                break;
              }
            return r;
          }),
          (t.makeIncArray = function (e, t, r) {
            const i = Array.from(Array(e)).map(
              (e, r) => (null != t ? t : 1) * r
            );
            return r ? i.map(r) : i;
          }),
          (t.appendRangeFifo = function (e, t, r, i) {
            const o = t.length,
              a = e.length;
            if (r >= o + a) {
              t.length += a;
              for (let r = 0; r < a; ++r) t[o + r] = e[r];
            } else if (a > r) {
              const i = a - r;
              t = e.slice(i);
            } else if (r > o) {
              const i = r - o;
              t.length = r;
              for (let r = 0; r < a; ++r)
                r < i ? (t[o + r] = e[r]) : (t[i - r] = e[r]);
            } else {
              let o = a;
              i + a > r && (o = r - i);
              for (let r = 0; r < a; ++r)
                r < o ? (t[i + r] = e[r]) : (t[o - r] = e[r]);
            }
          });
      },
      19387: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.calcAverageForArray = t.calcAverageForDoubleVector = void 0),
          (t.calcAverageForDoubleVector = (e, t, r) => {
            const i = e.size(),
              o = null != r ? r : i - 1;
            if (o >= i || o < 0)
              throw Error("index should be in range [0, length-1]");
            if (o + 1 < t) return NaN;
            let a = 0;
            for (let r = o + 1 - t; r < o + 1; r++) a += e.get(r);
            return (a /= t), a;
          }),
          (t.calcAverageForArray = (e, t, r) => {
            const i = e.length,
              o = null != r ? r : i - 1;
            if (o >= i || o < 0)
              throw Error("index should be in range [0, length-1]");
            if (o + 1 < t) return NaN;
            let a = 0;
            for (let r = o + 1 - t; r < o + 1; r++) a += e[r];
            return (a /= t), a;
          });
      },
      27699: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.appendDoubleVectorFromJsArray =
            t.memCopyFloat32 =
            t.insertDoubleVectorFromJsArray =
            t.SIZEOF_FLOAT32 =
            t.SIZEOF_NUMBER =
              void 0);
        const i = r(23866);
        (t.SIZEOF_NUMBER = 8),
          (t.SIZEOF_FLOAT32 = 4),
          (t.insertDoubleVectorFromJsArray = function (e, r, o, a) {
            i.Guard.notNull(e, "wasmContext"),
              i.Guard.notNull(r, "source"),
              i.Guard.notNull(o, "dest"),
              i.Guard.isTrue(
                a >= 0,
                "destIndex must be greater than or equal to zero"
              ),
              i.Guard.isTrue(
                a <= o.size(),
                "destIndex must be less than or equal to dest.size()"
              );
            const s = r.length;
            if (0 === s) return;
            const n = o.size();
            o.resizeFast(n + s),
              a < n &&
                e.SCRTMemMove(
                  o.dataPtr(a + s),
                  o.dataPtr(a),
                  (n - a) * t.SIZEOF_NUMBER
                ),
              e.HEAPF64.set(r, o.dataPtr(a) / t.SIZEOF_NUMBER);
          }),
          (t.memCopyFloat32 = function (e, r, o, a) {
            i.Guard.notNull(e, "wasmContext"),
              i.Guard.notNull(r, "source"),
              i.Guard.notNull(o, "dest"),
              i.Guard.isTrue(
                a >= 0,
                "destIndex must be greater than or equal to zero"
              ),
              i.Guard.isTrue(
                a <= o.size() + r.length,
                "destIndex must be less than or equal to dest.size() + source.Length"
              ),
              0 !== r.length &&
                e.HEAPF32.set(r, o.dataPtr(a) / t.SIZEOF_FLOAT32);
          }),
          (t.appendDoubleVectorFromJsArray = function (e, r, i, o = !0) {
            let a;
            try {
              if (o) {
                const o = r.size(),
                  a = i.length,
                  s = o,
                  n = s + a;
                r.resizeFast(n);
                const l = r.dataPtr(s);
                e.HEAPF64.set(i, l / t.SIZEOF_NUMBER);
              } else {
                const o = r.size(),
                  s = i.length,
                  n = o,
                  l = n + s;
                e.SCRTSetActiveDoubleVector(r, o),
                  (a = e._malloc(8 * s)),
                  e.HEAPF64.set(i, a / t.SIZEOF_NUMBER),
                  e.ccall(
                    "SCRTFillActiveDoubleVector",
                    null,
                    ["number", "number", "number"],
                    [a, n, l]
                  );
              }
            } catch (e) {
              console.log(e);
            } finally {
              a && e._free(a);
            }
          });
      },
      22950: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.applyOpacityToHtmlColor =
            t.uintArgbColorIsTransparent =
            t.uintArgbColorOverrideOpacity =
            t.uintArgbColorMultiplyOpacity =
            t.uintArgbColorToAbgr =
            t.linearColorMapLerp =
            t.uintArgbColorLerp =
            t.uintArgbColorLerp24bit =
              void 0);
        const i = r(62186),
          o = r(48008);
        function a(e, t, r) {
          const i = 16711935,
            o = 4278255360,
            a = 256 * r,
            s = 256 - a;
          return (
            ((((e & i) * s + (t & i) * a) >> 8) & i) |
            ((((e & o) * s + (t & o) * a) >> 8) & o)
          );
        }
        function s(e, t, r) {
          const i = (65535 & e) >>> 0,
            o = (65535 & t) >>> 0;
          return ((a(e >>> 16, t >>> 16, r) << 16) >>> 0) + a(i, o, r);
        }
        (t.uintArgbColorLerp24bit = a),
          (t.uintArgbColorLerp = s),
          (t.linearColorMapLerp = function (e, t) {
            if (t < e.Minimum)
              return (0, o.parseColorToUIntArgb)(e.GradientStops[0].color);
            const r = 1 / (e.Maximum - e.Minimum),
              a = (t - e.Minimum) * r,
              n = e.GradientStops,
              l = [];
            let d;
            for (d = 1; d < n.length; d++)
              l.push(1 / (n[d].offset - n[d - 1].offset));
            for (d = 0; d < n.length - 1; d++) {
              const t = n[d],
                r = n[d + 1];
              if (a >= t.offset && a < r.offset) {
                if (e.Mode === i.EColorMapMode.Stepped)
                  return (0, o.parseColorToUIntArgb)(t.color);
                const n = (a - t.offset) * l[d];
                return s(
                  (0, o.parseColorToUIntArgb)(t.color),
                  (0, o.parseColorToUIntArgb)(r.color),
                  n
                );
              }
            }
            return (0, o.parseColorToUIntArgb)(e.GradientStops[d].color);
          }),
          (t.uintArgbColorToAbgr = function (e) {
            let t = e - (16777215 & e);
            return (
              (t += (255 & e) << 16),
              (t += ((65280 & e) >> 8) << 8),
              (t += (16711680 & e) >> 16),
              t
            );
          }),
          (t.uintArgbColorMultiplyOpacity = function (e, t) {
            let r = e - (16777215 & e);
            return (
              (r >>>= 24),
              (r *= t),
              (r = Math.floor(r)),
              (r *= 16777216),
              r + (16777215 & e)
            );
          }),
          (t.uintArgbColorOverrideOpacity = function (e, t) {
            let r = 255 * t;
            return (r = Math.floor(r)), (r *= 16777216), r + (16777215 & e);
          }),
          (t.uintArgbColorIsTransparent = function (e) {
            return 4278190080 != e - (16777215 & e);
          }),
          (t.applyOpacityToHtmlColor = function (e, t) {
            const r = (0, o.parseColorToTArgb)(e);
            return (
              (r.opacity = Math.floor(256 * t)), (0, o.parseTArgbToHtmlColor)(r)
            );
          });
      },
      85505: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertRgbToHexColor = t.convertColor = void 0),
          (t.convertColor = (e, t = 1) => {
            const i = r(t),
              o = e.toLowerCase();
            return 0 === o.length
              ? ""
              : "#" === o[0]
              ? `0x${i}${o.substr(1)}`
              : `0x${i}${o}`;
          }),
          (t.convertRgbToHexColor = (e, t, i) => "#" + r(e) + r(t) + r(i));
        const r = (e) => {
          if (e >= 1) return "ff";
          if (e <= 0) return "00";
          const t = Math.floor(256 * e).toString(16);
          return 1 === t.length ? "0" + t : t;
        };
      },
      76630: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertToPixel = void 0),
          (t.convertToPixel = (e, t, i, o) => {
            const a = "0x" + r(o) + r(e) + r(t) + r(i);
            return parseInt(a, 16);
          });
        const r = (e) => (e >= 255 ? "ff" : e <= 0 ? "00" : e.toString(16));
      },
      41670: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.deleteCookie = t.getCookie = t.setCookie = void 0),
          (t.setCookie = function (e, t, r) {
            const i = new Date(),
              o = t;
            i.setTime(i.getTime() + 24 * r * 60 * 60 * 1e3),
              "undefined" != typeof document &&
                (document.cookie =
                  e + "=" + o + "; expires=" + i.toUTCString() + "; path=/");
          }),
          (t.getCookie = function (e) {
            if ("undefined" == typeof document) return null;
            const t = ("; " + document.cookie).split("; " + e + "=");
            return 2 === t.length ? t.pop().split(";").shift() : "";
          }),
          (t.deleteCookie = function (e) {
            if ("undefined" == typeof document) return;
            const t = new Date();
            t.setTime(t.getTime() + -864e5),
              (document.cookie =
                e + "=; expires=" + t.toUTCString() + "; path=/");
          });
      },
      46544: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.copyDoubleVector = void 0);
        const i = r(27699);
        t.copyDoubleVector = (e, t, r) => {
          const o = e.size();
          t.resizeFast(o),
            r.SCRTMemCopy(t.dataPtr(0), e.dataPtr(0), o * i.SIZEOF_NUMBER);
        };
      },
      72633: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.formatUnixDateToHumanStringYYYY =
            t.formatUnixDateToHumanStringDD =
            t.formatUnixDateToHumanStringMMM =
            t.formatUnixDateToHumanStringMMMDD =
            t.formatUnixDateToHumanStringHHMM =
            t.formatUnixDateToHumanStringSSms =
            t.formatUnixDateToHumanStringHHMMSS =
            t.formatUnixDateToHumanStringDDMM =
            t.formatUnixDateToHumanStringDDMMHHMM =
            t.formatUnixDateToHumanStringDDMMYY =
            t.formatUnixDateToHumanString =
              void 0),
          (t.formatUnixDateToHumanString = (e, t = "en-US") => {
            const r = new Date(1e3 * e).toLocaleDateString(t, {
              month: "numeric",
              year: "numeric",
              day: "numeric",
            });
            return "Invalid Date" === r ? "" : r;
          }),
          (t.formatUnixDateToHumanStringDDMMYY = (e) => {
            const t = new Date(1e3 * e).toLocaleDateString("en-GB", {
              timeZone: "utc",
              year: "2-digit",
              month: "2-digit",
              day: "2-digit",
            });
            return "Invalid Date" === t ? "" : t;
          }),
          (t.formatUnixDateToHumanStringDDMMHHMM = (e) =>
            `${(0, t.formatUnixDateToHumanStringDDMM)(e)} ${(0,
            t.formatUnixDateToHumanStringHHMM)(e)}`),
          (t.formatUnixDateToHumanStringDDMM = (e) => {
            const t = new Date(1e3 * e).toLocaleDateString("en-GB", {
              timeZone: "utc",
              day: "numeric",
              month: "numeric",
            });
            return "Invalid Date" === t ? "" : t;
          }),
          (t.formatUnixDateToHumanStringHHMMSS = (e) => {
            const t = new Date(1e3 * e),
              r = t.getUTCHours(),
              i = t.getUTCMinutes(),
              o = t.getUTCSeconds();
            return isNaN(r) || isNaN(i) || isNaN(o)
              ? ""
              : `${r <= 9 ? `0${r}` : r.toString(10)}:${
                  i <= 9 ? `0${i}` : i.toString(10)
                }:${o <= 9 ? `0${o}` : o.toString(10)}`;
          }),
          (t.formatUnixDateToHumanStringSSms = (e) => {
            const t = new Date(1e3 * e),
              r = t.getUTCSeconds(),
              i = t.getUTCMilliseconds();
            return isNaN(r) || isNaN(i)
              ? ""
              : `${r <= 9 ? `0${r}` : r.toString(10)}.${
                  i <= 9 ? `0${i}` : i.toString(10)
                }`;
          }),
          (t.formatUnixDateToHumanStringHHMM = (e) => {
            const t = new Date(1e3 * e),
              r = t.getUTCHours(),
              i = t.getUTCMinutes();
            return isNaN(r) || isNaN(i)
              ? ""
              : `${r <= 9 ? `0${r}` : r.toString(10)}:${
                  i <= 9 ? `0${i}` : i.toString(10)
                }`;
          }),
          (t.formatUnixDateToHumanStringMMMDD = (e) => {
            const t = new Date(1e3 * e),
              i = t.getUTCMonth(),
              o = t.getUTCDate();
            return isNaN(i) || isNaN(o) ? "" : `${r(i)} ${o}`;
          }),
          (t.formatUnixDateToHumanStringMMM = (e) => {
            const t = new Date(1e3 * e).getUTCMonth();
            return isNaN(t) ? "" : r(t);
          }),
          (t.formatUnixDateToHumanStringDD = (e) => {
            const t = new Date(1e3 * e).getUTCDate();
            if (isNaN(t)) return "";
            const r = t.toString();
            return 2 === r.length ? r : 1 === r.length ? `0${r}` : "";
          }),
          (t.formatUnixDateToHumanStringYYYY = (e) => {
            const t = new Date(1e3 * e).getUTCFullYear();
            return isNaN(t) ? "" : t.toString(10);
          });
        const r = (e) => {
          switch (e) {
            case 0:
              return "Jan";
            case 1:
              return "Feb";
            case 2:
              return "Mar";
            case 3:
              return "Apr";
            case 4:
              return "May";
            case 5:
              return "Jun";
            case 6:
              return "Jul";
            case 7:
              return "Aug";
            case 8:
              return "Sep";
            case 9:
              return "Oct";
            case 10:
              return "Nov";
            case 11:
              return "Dec";
            default:
              throw Error("Not correct month");
          }
        };
      },
      71497: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.logDoubleVector = void 0),
          (t.logDoubleVector = (e, t, r = 2, i) => {
            var o;
            let a = "";
            for (
              let t = 0;
              null !== (o = t < i) && void 0 !== o ? o : e.size();
              t++
            )
              a += e.get(t).toFixed(r) + ",";
            t ? console.log(t, a) : console.log(a);
          });
      },
      52578: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getFontFamily = t.DEFAULT_FONT_FAMILY = t.getFontString = void 0),
          (t.getFontString = (e, r, i, o) => {
            const a = (0, t.getFontFamily)(o, !1);
            return r ? `${e} ${r} ${i}px ${a}` : `${e} ${i}px ${a}`;
          }),
          (t.DEFAULT_FONT_FAMILY = "DEFAULT_FONT_FAMILY"),
          (t.getFontFamily = (e, r) =>
            e === t.DEFAULT_FONT_FAMILY ? (r ? "Default" : "Arial") : e);
      },
      11665: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.geometryHelpers = void 0),
          (t.geometryHelpers = {
            calcArrowHeadParameters: function (e, t, r, i, o, a) {
              const s = o / 2,
                n = Math.cos(r),
                l = Math.sin(r),
                d = e - i * n,
                h = t - i * l;
              return {
                baseMidX: e - a * n,
                baseMidY: t - a * l,
                leftX: d + s * l,
                leftY: h - s * n,
                rightX: d - s * l,
                rightY: h + s * n,
              };
            },
          });
      },
      73538: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.base64Id = t.generateGuid = void 0),
          (t.generateGuid = () =>
            "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
              const t = (16 * Math.random()) | 0;
              return ("x" === e ? t : (3 & t) | 8).toString(16);
            })),
          (t.base64Id = (e = 22) => {
            let t = "";
            for (; t.length < e; ) {
              const e = Math.floor(64 * Math.random());
              t +=
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(
                  e
                );
            }
            return t;
          });
      },
      54535: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hasAllProperties = void 0),
          (t.hasAllProperties = (e, t) => {
            for (let r = 0; r < t.length; r++)
              if (!e.hasOwnProperty(t[r])) return !1;
            return !0;
          });
      },
      17575: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hashUtils = void 0);
        const r = (e) =>
          e
            .split("")
            .reduce((e, t) => (e = (e << 5) - e + t.charCodeAt(0)) & e, 0);
        t.hashUtils = {
          generateHash: r,
          generateObjectHash: (e) => {
            const t = JSON.stringify(e);
            return r(t);
          },
          generateBooleanHash: (e) => r(!1 === e ? "0" : !0 === e ? "1" : "-1"),
          generateNumberHash: (e) => {
            const t = e.toString(10);
            return r(t);
          },
          generateCombinedHash: (e) => e.reduce((e, t) => (397 * e) ^ t, 0),
        };
      },
      99064: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.stringOccurrences = t.htmlToElement = void 0),
          (t.htmlToElement = function (e) {
            const t = document.createElement("template");
            return (e = e.trim()), (t.innerHTML = e), t.content.firstChild;
          }),
          (t.stringOccurrences = function (e, t, r = !1) {
            if (((e += ""), (t += "").length <= 0)) return e.length + 1;
            let i = 0,
              o = 0;
            const a = r ? 1 : t.length;
            for (; (o = e.indexOf(t, o)), o >= 0; ) ++i, (o += a);
            return i;
          });
      },
      34483: (e, t) => {
        "use strict";
        function r(e) {
          return new Promise((t, r) => {
            const i = new Image();
            (i.crossOrigin = "Anonymous"),
              (i.onload = () => t(i)),
              (i.onerror = r),
              (i.src = e);
          });
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createImagesArrayAsync = t.createImageAsync = void 0),
          (t.createImageAsync = r),
          (t.createImagesArrayAsync = function (e) {
            const t = e.map((e) => r(e));
            return Promise.all(t);
          });
      },
      72934: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isRealNumber = void 0),
          (t.isRealNumber = function (e) {
            return (
              !isNaN(e) &&
              isFinite(e) &&
              e !== Number.MAX_VALUE &&
              e !== Number.MIN_VALUE &&
              e !== Number.NEGATIVE_INFINITY
            );
          });
      },
      9254: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Logger = void 0);
        class r {
          static log(e, ...t) {
            console.log(e, t);
          }
          static debug(e, ...t) {
            r.enableDebug && console.debug(e, ...t);
          }
        }
        (t.Logger = r), (r.enableDebug = !1);
      },
      67492: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.logToBase = t.fillNoisySinewave = t.getNoisySinewave = void 0),
          (t.getNoisySinewave = (e, t, r, i, o) => {
            const a = [],
              s = [],
              n = r / t,
              l = 2 * Math.PI * n;
            for (let r = 0; r < e; r++) {
              const n = (r * t) / (e - 1);
              a.push(n);
              const d = i * Math.sin(n * l),
                h = (Math.random() - 0.5) * o;
              s.push(d + h);
            }
            return [a, s];
          }),
          (t.fillNoisySinewave = (e, t, r, i, o, a) => {
            const s = r / t,
              n = 2 * Math.PI * s,
              l = a.getNativeXValues(),
              d = a.getNativeYValues();
            l.reserve(e), d.reserve(e);
            for (let r = 0; r < e; r++) {
              const a = (r * t) / (e - 1),
                s = i * Math.sin(a * n),
                h = (Math.random() - 0.5) * o;
              l.push_back(a), d.push_back(s + h);
            }
          }),
          (t.logToBase = (e, t) =>
            10 === t ? Math.log10(e) : Math.log(e) / (t ? Math.log(t) : 1));
      },
      4748: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.memoize = void 0),
          (t.memoize = function (e, t) {
            let r, i;
            const o = null != t ? t : (e, t) => !e.some((e, r) => e !== t[r]);
            return (...t) => {
              const a = i && o(t, i);
              return (i && a) || ((i = t), (r = e(...t))), r;
            };
          });
      },
      8591: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.checkIsNaN =
            t.toEngineering =
            t.toScientific =
            t.toSuperScript =
            t.formatNumber =
            t.numericHashCode =
            t.formatNumber2Digits =
              void 0);
        const i = r(96528),
          o = r(72633),
          a = r(67492);
        (t.formatNumber2Digits = (e) =>
          (Math.round(100 * (e + Number.EPSILON)) / 100).toFixed(2)),
          (t.numericHashCode = (e, t) => 0 | (e = 31 * e - e + t)),
          (t.formatNumber = (e, r, a, s) => {
            if (void 0 === e) return "";
            switch (r) {
              case i.ENumericFormat.NoFormat:
                return e.toString();
              case i.ENumericFormat.Decimal:
                return e.toFixed(a);
              case i.ENumericFormat.SignificantFigures:
                return Number(e.toPrecision(a)).toString();
              case i.ENumericFormat.Exponential:
                return e.toExponential(a);
              case i.ENumericFormat.Scientific:
                return (0, t.toScientific)(e, a, 10);
              case i.ENumericFormat.Date_DDMMYYYY:
                return (0, o.formatUnixDateToHumanString)(e);
              case i.ENumericFormat.Date_DDMMYY:
                return (0, o.formatUnixDateToHumanStringDDMMYY)(e);
              case i.ENumericFormat.Date_DDMMHHMM:
                return (0, o.formatUnixDateToHumanStringDDMMHHMM)(e);
              case i.ENumericFormat.Date_DDMM:
                return (0, o.formatUnixDateToHumanStringDDMM)(e);
              case i.ENumericFormat.Date_HHMM:
                return (0, o.formatUnixDateToHumanStringHHMM)(e);
              case i.ENumericFormat.Date_HHMMSS:
                return (0, o.formatUnixDateToHumanStringHHMMSS)(e);
              case i.ENumericFormat.Date_SSms:
                return (0, o.formatUnixDateToHumanStringSSms)(e);
              case i.ENumericFormat.Engineering:
                return (0, t.toEngineering)(
                  e,
                  null == s ? void 0 : s.large,
                  null == s ? void 0 : s.small,
                  a
                );
            }
          });
        const s = ["⁰", "¹", "²", "³", "⁴", "⁵", "⁶", "⁷", "⁸", "⁹"];
        (t.toSuperScript = (e) => {
          let t = "",
            r = e < 0,
            i = Math.abs(e).toString();
          for (const e of i) {
            const r = Number.parseInt(e);
            isNaN(r) || (t += s[r]);
          }
          return (r ? "⁻" : "") + t;
        }),
          (t.toScientific = (e, r, i) => {
            if (0 === e) return "0";
            let o = (0, a.logToBase)(Math.abs(e), i);
            return (
              (o = Math.floor(o)),
              (e / Math.pow(i, o)).toPrecision(r).toString() +
                "x" +
                i.toString() +
                (0, t.toSuperScript)(o)
            );
          }),
          (t.toEngineering = (e, t, r, i = 1) => {
            if (0 === e) return "0";
            const o = Math.abs(e);
            if (
              (null != t || (t = ["K", "M", "B", "T"]),
              null != r || (r = ["m", "µ", "n", "p"]),
              0 === t.length && 0 === r.length)
            )
              return e.toString();
            const a = (e) => {
              const t = Math.pow(10, i);
              return (Math.trunc(e * t) / t).toFixed(i).replace(/\.?0+$/, "");
            };
            if (o >= 1 && o < 1e3) return a(e);
            if (o >= 1e3 && t.length > 0)
              for (let r = 1; r <= t.length; r++)
                if (o < Math.pow(10, 3 * (r + 1)) || r === t.length)
                  return a(e / Math.pow(10, 3 * r)) + t[r - 1];
            if (o < 1 && o > 0 && r.length > 0)
              for (let t = 0; t < r.length; t++)
                if (o >= Math.pow(10, -3 * (t + 1)) || t === r.length - 1)
                  return a(e * Math.pow(10, 3 * (t + 1))) + r[t];
            return e.toString();
          }),
          (t.checkIsNaN = (e) => e != e);
      },
      7171: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hasProperties = t.areEqual = void 0),
          (t.areEqual = function (e, t) {
            if (e === t) return !0;
            const r = Object.keys(e),
              i = Object.keys(e);
            return (
              r.length === i.length &&
              r.every(
                (r) =>
                  Object.prototype.hasOwnProperty.call(t, r) && e[r] === t[r]
              )
            );
          }),
          (t.hasProperties = (e, t) =>
            t.every((t) => Object.prototype.hasOwnProperty.call(e, t)));
      },
      48008: (e, t) => {
        "use strict";
        function r(e, t) {
          const r = a(e);
          return (
            "0x" +
            o(null != t ? t : r.opacity) +
            o(r.red) +
            o(r.green) +
            o(r.blue)
          );
        }
        function i(e, t) {
          const r = a(e);
          return "0x" + o(t || r.opacity) + o(r.blue) + o(r.green) + o(r.red);
        }
        function o(e) {
          const t = e.toString(16);
          return 1 === t.length ? "0" + t : t;
        }
        function a(e) {
          if (!e || !e.length || e.length > 50)
            throw Error("'" + e + "' is not a valid color...");
          const r = e.match(/^#?([0-9a-f]{3})$/i);
          if (r) {
            const e = r[1],
              t = 255,
              i = 17 * parseInt(e.charAt(0), 16),
              o = 17 * parseInt(e.charAt(1), 16),
              a = 17 * parseInt(e.charAt(2), 16);
            return (
              s([i, o, a], ["red", "green", "blue"]),
              { opacity: t, red: i, green: o, blue: a }
            );
          }
          const i = e.match(/^#?([0-9a-f]{6})$/i);
          if (i) {
            const e = i[1],
              t = 255,
              r = parseInt(e.substr(0, 2), 16),
              o = parseInt(e.substr(2, 2), 16),
              a = parseInt(e.substr(4, 2), 16);
            return (
              s([r, o, a], ["red", "green", "blue"]),
              { opacity: t, red: r, green: o, blue: a }
            );
          }
          const o = e.match(/^#?([0-9a-f]{8})$/i);
          if (o) {
            const e = o[1],
              t = parseInt(e.substr(0, 2), 16),
              r = parseInt(e.substr(2, 2), 16),
              i = parseInt(e.substr(4, 2), 16),
              a = parseInt(e.substr(6, 2), 16);
            return (
              s([a, t, r, i], ["opacity", "red", "green", "blue"]),
              { opacity: a, red: t, green: r, blue: i }
            );
          }
          const l = e.match(
            /^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*\.?\d*)\s*\)$/i
          );
          if (l) {
            const e = parseFloat(l[4]);
            !(function (e) {
              if (void 0 === e)
                throw Error("parseColor error opacity should not be null");
              if (Number.isNaN(e))
                throw Error("parseColor error opacity should not be NaN");
              if (e < 0 || e > 1)
                throw Error(
                  "parseColor error opacity should be within [0, 1] range"
                );
            })(e);
            const t = n(e),
              r = parseInt(l[1], 10),
              i = parseInt(l[2], 10),
              o = parseInt(l[3], 10);
            return (
              s([r, i, o], ["red", "green", "blue"]),
              { opacity: t, red: r, green: i, blue: o }
            );
          }
          const d = t.webColors[e.toLowerCase()];
          if (d) return a(d);
          throw Error("'" + e + "' is not a valid color...");
        }
        function s(e, t) {
          e.forEach((e, r) => {
            const i = t[r];
            if (void 0 === e)
              throw Error(`parseColor error ${i} color should not be null`);
            if (Number.isNaN(e))
              throw Error(`parseColor error ${i} color should not be NaN`);
            if (e < 0 || e > 255)
              throw Error(
                `parseColor error ${i} color should be within [0, 255] range`
              );
          });
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.webColors =
            t.parseTArgbToHtmlColor =
            t.parseArgbToHtmlColor =
            t.parseColorToTArgb =
            t.toHex =
            t.parseColorToUIntAbgr =
            t.parseColorToUIntArgb =
            t.parseColorToHexStringAbgr =
            t.parseColorToHexStringArgb =
              void 0),
          (t.parseColorToHexStringArgb = r),
          (t.parseColorToHexStringAbgr = i),
          (t.parseColorToUIntArgb = function (e, t) {
            return parseInt(r(e, t), 16);
          }),
          (t.parseColorToUIntAbgr = function (e, t) {
            return parseInt(i(e, t), 16);
          }),
          (t.toHex = o),
          (t.parseColorToTArgb = a),
          (t.parseArgbToHtmlColor = (e) => {
            const t = e.toString(16);
            if (t.length > 8)
              throw new Error("HTML color length cannot be greater than 8");
            const r = (e, t) => {
              const r = t - e.length;
              return new Array(r + 1).join("0") + e;
            };
            return (
              "#" + r(t.substr(-6), 6) + r(t.substring(0, t.length - 6), 2)
            );
          }),
          (t.parseTArgbToHtmlColor = (e) =>
            (
              "#" +
              l(e.red) +
              l(e.green) +
              l(e.blue) +
              l(e.opacity)
            ).toUpperCase());
        const n = (e) => (e >= 1 ? 255 : e <= 0 ? 0 : Math.floor(256 * e)),
          l = (e) => {
            if (e >= 256) return "ff";
            if (e <= 0) return "00";
            const t = e.toString(16);
            return 1 === t.length ? "0" + t : t;
          };
        t.webColors = {
          transparent: "#00000000",
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyan: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgrey: "#a9a9a9",
          darkgreen: "#006400",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          grey: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgrey: "#d3d3d3",
          lightgreen: "#90ee90",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370db",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#db7093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          rebeccapurple: "#663399",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          steelblue: "#4682b4",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          tomato: "#ff6347",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32",
        };
      },
      16602: function (e, t, r) {
        "use strict";
        var i =
          (this && this.__rest) ||
          function (e, t) {
            var r = {};
            for (var i in e)
              Object.prototype.hasOwnProperty.call(e, i) &&
                t.indexOf(i) < 0 &&
                (r[i] = e[i]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (i = Object.getOwnPropertySymbols(e); o < i.length; o++)
                t.indexOf(i[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, i[o]) &&
                  (r[i[o]] = e[i[o]]);
            }
            return r;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.runAfterFramePaint =
            t.PerformanceDebugHelper =
            t.EPerformanceDebugLevel =
            t.EPerformanceMarkType =
              void 0);
        const o = r(73538);
        var a, s;
        ((s =
          t.EPerformanceMarkType ||
          (t.EPerformanceMarkType = {})).InitializationStart =
          "InitializationStart"),
          (s.InitializationEnd = "InitializationEnd"),
          (s.EngineInitStart = "EngineInitStart"),
          (s.EngineInitEnd = "EngineInitEnd"),
          (s.LeadingInvalidate = "LeadingInvalidate"),
          (s.Invalidate = "Invalidate"),
          (s.DataUpdateStart = "DataUpdateStart"),
          (s.DataUpdateEnd = "DataUpdateEnd"),
          (s.RenderStart = "RenderStart"),
          (s.RenderEnd = "RenderEnd"),
          (s.Rendered = "Rendered"),
          (s.FullStateRendered = "FullStateRendered"),
          (s.Painted = "Painted"),
          (s.Resize = "Resize"),
          (s.DpiChange = "DpiChange"),
          (s.SetupStart = "SetupStart"),
          (s.SetupEnd = "SetupEnd"),
          (s.CanvasInitializationStart = "CanvasInitializationStart"),
          (s.CanvasInitializationEnd = "CanvasInitializationEnd"),
          (s.AddSubSurfaceStart = "AddSubSurfaceStart"),
          (s.AddSubSurfaceEnd = "AddSubSurfaceEnd"),
          (s.RenderSurfaceDrawStart = "RenderSurfaceDrawStart"),
          (s.RenderSurfaceDrawEnd = "RenderSurfaceDrawEnd"),
          (s.DrawingLoopStart = "DrawingLoopStart"),
          (s.DrawingLoopEnd = "DrawingLoopEnd"),
          (s.CopyToCanvasStart = "CopyToCanvasStart"),
          (s.CopyToCanvasEnd = "CopyToCanvasEnd"),
          (s.GenericAnimationStart = "GenericAnimationStart"),
          (s.GenericAnimationEnd = "GenericAnimationEnd"),
          (s.AutoRangeStart = "AutoRangeStart"),
          (s.AutoRangeEnd = "AutoRangeEnd"),
          (s.LayoutStart = "LayoutStart"),
          (s.LayoutEnd = "LayoutEnd"),
          (s.GetTicksStart = "GetTicksStart"),
          (s.GetTicksEnd = "GetTicksEnd"),
          (s.DrawAxisBorderStart = "DrawAxisBorderStart"),
          (s.DrawAxisBorderEnd = "DrawAxisBorderEnd"),
          (s.DrawAxisBandsStart = "DrawAxisBandsStart"),
          (s.DrawAxisBandsEnd = "DrawAxisBandsEnd"),
          (s.DrawMinorGridLinesStart = "DrawMinorGridLinesStart"),
          (s.DrawMinorGridLinesEnd = "DrawMinorGridLinesEnd"),
          (s.DrawMajorGridLinesStart = "DrawMajorGridLinesStart"),
          (s.DrawMajorGridLinesEnd = "DrawMajorGridLinesEnd"),
          (s.DrawAxisBackgroundStart = "DrawAxisBackgroundStart"),
          (s.DrawAxisBackgroundEnd = "DrawAxisBackgroundEnd"),
          (s.DrawAxisLabelsStart = "DrawAxisLabelsStart"),
          (s.DrawAxisLabelsEnd = "DrawAxisLabelsEnd"),
          (s.DrawMinorTicksStart = "DrawMinorTicksStart"),
          (s.DrawMinorTicksEnd = "DrawMinorTicksEnd"),
          (s.DrawMajorTicksStart = "DrawMajorTicksStart"),
          (s.DrawMajorTicksEnd = "DrawMajorTicksEnd"),
          (s.DrawNativeTextStart = "DrawNativeTextStart"),
          (s.DrawNativeTextEnd = "DrawNativeTextEnd"),
          (s.DrawAnnotationStart = "DrawAnnotationStart"),
          (s.DrawAnnotationEnd = "DrawAnnotationEnd"),
          (s.ResampleSingleSeriesStart = "ResampleSingleSeriesStart"),
          (s.ResampleSingleSeriesEnd = "ResampleSingleSeriesEnd"),
          (s.DrawSingleSeriesStart = "DrawSingleSeriesStart"),
          (s.DrawSingleSeriesEnd = "DrawSingleSeriesEnd"),
          (s.DrawCollectionSeriesStart = "DrawCollectionSeriesStart"),
          (s.DrawCollectionSeriesEnd = "DrawCollectionSeriesEnd"),
          (s.PerformTextLayoutStart = "PerformTextLayoutStart"),
          (s.PerformTextLayoutEnd = "PerformTextLayoutEnd"),
          (s.DrawDataLabelsStart = "DrawDataLabelsStart"),
          (s.DrawDataLabelsEnd = "DrawDataLabelsEnd"),
          (s.PostDrawActionsStart = "PostDrawActionsStart"),
          (s.PostDrawActionsEnd = "PostDrawActionsEnd"),
          (s.PointerMoveStart = "PointerMoveStart"),
          (s.PointerMoveEnd = "PointerMoveEnd"),
          (s.PointerDownStart = "PointerDownStart"),
          (s.PointerDownEnd = "PointerDownEnd"),
          (s.PointerUpStart = "PointerUpStart"),
          (s.PointerUpEnd = "PointerUpEnd"),
          (s.ScrollStart = "ScrollStart"),
          (s.ScrollEnd = "ScrollEnd"),
          (s.DoubleClickStart = "DoubleClickStart"),
          (s.DoubleClickEnd = "DoubleClickEnd"),
          (s.MouseLeaveStart = "MouseLeaveStart"),
          (s.MouseLeaveEnd = "MouseLeaveEnd"),
          (s.MouseEnterStart = "MouseEnterStart"),
          (s.MouseEnterEnd = "MouseEnterEnd"),
          (function (e) {
            (e[(e.Info = 0)] = "Info"), (e[(e.Verbose = 1)] = "Verbose");
          })((a = t.EPerformanceDebugLevel || (t.EPerformanceDebugLevel = {})));
        class n {
          constructor() {
            this.separator = "_";
          }
          static mark(e, t) {
            if (n.enableDebug) return n.instance.addMark(e, t);
          }
          static getMarks() {
            return n.instance.getMarks();
          }
          static clearMarks(e) {
            return n.instance.clearMarks(e);
          }
          static outputLogs() {
            n.instance.getMarks().forEach((e) => {
              console.log(e.name, e.startTime);
            });
          }
          static toJSON() {
            const e = n.instance
              .getMarks()
              .map(({ name: e, startTime: t, detail: r }) => ({
                name: e,
                startTime: t,
                detail: r,
              }));
            return {
              name: self.name,
              timeOrigin: performance.timeOrigin,
              marks: e,
            };
          }
          getMarks() {
            return performance.getEntriesByType("mark");
          }
          clearMarks(e) {
            performance.clearMarks(e);
          }
          addMark(e, t) {
            var r;
            const s = null != t ? t : { level: a.Info },
              { level: l } = s,
              d = i(s, ["level"]);
            if ((null != l ? l : a.Info) <= n.debugLevel) {
              const i =
                null !== (r = null == t ? void 0 : t.relatedId) && void 0 !== r
                  ? r
                  : (0, o.generateGuid)();
              return (d.relatedId = i), this.createMark(e, i, d);
            }
            return null;
          }
          createMark(e, t, r) {
            return performance.mark(`${e}${this.separator}${t}`, { detail: r });
          }
        }
        (t.PerformanceDebugHelper = n),
          (n.enableDebug = !1),
          (n.debugLevel = a.Info),
          (n.instance = new n()),
          (t.runAfterFramePaint = function (e) {
            const t = new MessageChannel();
            (t.port1.onmessage = e), t.port2.postMessage(void 0);
          });
      },
      21670: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.testPointInTriangle =
            t.calcDistanceFromLineSegment =
            t.calcDotProduct =
            t.testIsInInterval =
            t.testIsInXBounds =
            t.calcAnnotationBordersForAxisMarker =
            t.testIsInBounds =
            t.calcDistance =
            t.calcCrossProduct =
            t.calcDistanceFromLine =
              void 0);
        const i = r(38215);
        (t.calcDistanceFromLine = (e, r, i, o, a, s) =>
          Math.abs(
            (0, t.calcCrossProduct)(i, o, a, s, e, r) /
              (0, t.calcDistance)(i, o, a, s)
          )),
          (t.calcCrossProduct = (e, t, r, i, o, a) =>
            (r - e) * (a - t) - (i - t) * (o - e)),
          (t.calcDistance = (e, t, r, i) => {
            const o = e - r,
              a = t - i;
            return Math.sqrt(o * o + a * a);
          }),
          (t.testIsInBounds = (e, t, r, i, a, s, n = 0) =>
            o(e, r - n, a + n) && o(t, s + n, i - n));
        const o = (e, t, r) => (e >= t && e <= r) || (e >= r && e <= t);
        (t.calcAnnotationBordersForAxisMarker = (
          e,
          t,
          r,
          o,
          a,
          s,
          n,
          l,
          d,
          h,
          u,
          c,
          p,
          g
        ) => {
          const y = { x1: 0, x2: 0, y1: 0, y2: 0 };
          return (
            e
              ? t
                ? o.axisAlignment === i.EAxisAlignment.Top
                  ? a.axisAlignment === i.EAxisAlignment.Left
                    ? ((y.x1 = s - n.y),
                      (y.y1 = d - n.y),
                      (y.x2 = 0),
                      (y.y2 = d + h - n.y))
                    : a.axisAlignment === i.EAxisAlignment.Right &&
                      ((y.x1 = n.width - s + n.y),
                      (y.y1 = d - n.y),
                      (y.x2 = n.width),
                      (y.y2 = d + h - n.y))
                  : a.axisAlignment === i.EAxisAlignment.Left
                  ? ((y.x1 = s - n.x + u),
                    (y.y1 = d - n.y),
                    (y.x2 = 0),
                    (y.y2 = d + h - n.y))
                  : a.axisAlignment === i.EAxisAlignment.Right &&
                    ((y.x1 = l - u),
                    (y.y1 = d - n.y),
                    (y.x2 = n.width),
                    (y.y2 = d + h - n.y))
                : r &&
                  (o.axisAlignment === i.EAxisAlignment.Top
                    ? ((y.x1 = l + s / 2 - n.x + c),
                      (y.y1 = h - n.y + c),
                      (y.x2 = l - s / 2 - n.x + c),
                      (y.y2 = 0))
                    : ((y.x1 = l - s / 2 - n.x + c),
                      (y.y1 = d - c),
                      (y.x2 = l + s / 2 - n.x + c),
                      (y.y2 = n.height)))
              : t
              ? p
                ? ((y.x1 = l - s / 2 + c),
                  (y.y1 = d + h - n.y),
                  (y.x2 = l + s / 2),
                  (y.y2 = d))
                : g
                ? ((y.x1 = l - s / 2 + u - n.x),
                  (y.y1 = d - u),
                  (y.x2 = l + s / 2 + u - n.x),
                  (y.y2 = n.height))
                : ((y.x1 = l - s / 2 - c),
                  (y.y1 = d - u),
                  (y.x2 = l + s / 2 - c),
                  (y.y2 = d + h - n.y))
              : r &&
                (g
                  ? ((y.x1 = s - n.x + c),
                    (y.y1 = d - h / 2),
                    (y.x2 = 0),
                    (y.y2 = d + h / 2))
                  : ((y.x1 = l - c),
                    (y.y1 = d - h / 2 - u),
                    (y.x2 = l + s),
                    (y.y2 = d + h / 2 - u))),
            y
          );
        }),
          (t.testIsInXBounds = (e, t, r) => Math.abs(e - t) < r),
          (t.testIsInInterval = (e, t, r, i = 0) =>
            t <= r ? t - i <= e && e <= r + i : r - i <= e && e <= t + i),
          (t.calcDotProduct = (e, t, r, i, o, a) =>
            (r - e) * (o - r) + (i - t) * (a - i)),
          (t.calcDistanceFromLineSegment = (e, r, i, o, a, s) =>
            (0, t.calcDotProduct)(i, o, a, s, e, r) > 0
              ? (0, t.calcDistance)(a, s, e, r)
              : (0, t.calcDotProduct)(a, s, i, o, e, r) > 0
              ? (0, t.calcDistance)(i, o, e, r)
              : (0, t.calcDistanceFromLine)(e, r, i, o, a, s));
        const a = (e, t, r, i, o, a) =>
          Math.abs((e * (i - a) + r * (a - t) + o * (t - i)) / 2);
        t.testPointInTriangle = (e, t, r, i, o, s, n, l) => {
          const d = a(r, i, o, s, n, l),
            h = a(e, t, o, s, n, l),
            u = a(r, i, e, t, n, l),
            c = a(r, i, o, s, e, t);
          return Math.abs(h + u + c - d) < 1e-6;
        };
      },
      20346: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getRandomInRange = void 0),
          (t.getRandomInRange = (e, t, r) => {
            const i = Math.random();
            return (
              parseInt(((e + i * (t - e)) * Math.pow(10, r)).toFixed(r), 10) /
              Math.pow(10, r)
            );
          });
      },
      61090: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getNextRandomPriceBarFactory = t.getStocksDataFactory = void 0);
        const i = r(20346);
        t.getStocksDataFactory = (e, t, r) => (o, a) => {
          const s = o + e,
            n = a,
            l = (0, i.getRandomInRange)(t, r, 3),
            d = Math.abs(n - l),
            h = Math.max(n, l),
            u = (0, i.getRandomInRange)(h, Math.min(r, h + 0.7 * d), 3),
            c = Math.min(n, l);
          return {
            xValue: s,
            openValue: n,
            highValue: u,
            lowValue: (0, i.getRandomInRange)(Math.max(t, c - 0.7 * d), c, 3),
            closeValue: l,
          };
        };
        class o {
          constructor(e, t, r, i, o, a) {
            (this.xValue = e),
              (this.openValue = t),
              (this.highValue = r),
              (this.lowValue = i),
              (this.closeValue = o),
              (this.volume = a);
          }
        }
        t.getNextRandomPriceBarFactory = (e, t, r, i) => {
          let s = e,
            n = new o(e, i, i, i, i, 0);
          return (e = !1) =>
            e
              ? (() => {
                  const e =
                      n.closeValue +
                      (Math.random() - 0.48) * (n.closeValue / 100),
                    t = e > n.highValue ? e : n.highValue,
                    r = e < n.lowValue ? e : n.lowValue,
                    i = 0.05 * (3e4 * Math.random() + 2e4);
                  return (
                    (n = new o(n.xValue, n.openValue, t, r, e, n.volume + i)), n
                  );
                })()
              : (() => {
                  const e = n.closeValue,
                    l = ((Math.random() - 0.9) * i) / 30,
                    d = Math.random(),
                    h =
                      0.5 * i +
                      (i / 2) * Math.sin(727220521664304e-20 * s) +
                      (i / 16) * Math.cos(727220521664304e-19 * s) +
                      (i / 32) * Math.sin(727220521664304e-19 * (10 + d) * s) +
                      (i / 64) * Math.cos(727220521664304e-19 * (20 + d) * s) +
                      l,
                    u = Math.max(e, h) + (Math.random() * i) / 100,
                    c = Math.min(e, h) - (Math.random() * i) / 100,
                    p = 3e4 * Math.random() + 2e4,
                    g = r ? a(n.xValue) : n.xValue;
                  return (
                    (n = new o(g + 60 * t, e, u, c, h, p)), (s += 60 * t), n
                  );
                })();
        };
        const a = (e) => e;
      },
      94532: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAttributeFromString = void 0),
          (t.getAttributeFromString = (e, t) => {
            const r = e.indexOf(t);
            if (r >= 0) {
              const t = e.indexOf('"', r),
                i = t >= 0 ? e.indexOf('"', t + 1) : -1;
              if (i >= 0) {
                const r = e.substr(t + 1, i - t - 1),
                  o = parseInt(r, 10);
                if (!isNaN(o)) return o;
              }
            }
          });
      },
      87092: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getNativeTextSize = t.wrapNativeText = void 0);
        const i = r(98353);
        (t.wrapNativeText = (e, t, r, i) => {
          if (0 === t) return e;
          if (!e) return "";
          const o = [],
            a = e.split(" "),
            s = a[0].trim(),
            n = s + " " + s + "\n" + a.map((e) => e.trim()).join("\n");
          r.CalculateStringBounds(null != n ? n : "", i, 2);
          let l = "",
            d = 0,
            h = i.GetLineBounds(0).m_fWidth - 2 * i.GetLineBounds(1).m_fWidth;
          for (let e = 0; e < a.length; e++) {
            const r = a[e],
              s = i.GetLineBounds(e + 1).m_fWidth,
              n = l + ("" !== l ? " " : "") + r;
            (d += ("" !== l ? h : 0) + s),
              d > t
                ? "" === l
                  ? (o.push(r), (d = 0))
                  : (o.push(l), (l = r), (d = s))
                : (l = n),
              l.endsWith("\n") && (d = 0);
          }
          return o.push(l), o.join("\n");
        }),
          (t.getNativeTextSize = (e, t, r, o, a = 0) => {
            const s = (0, i.getTextBounds)(o);
            t.CalculateStringBounds(e, s, 0);
            let n = 0;
            for (let e = 0; e < s.GetLinesCount(); e++) {
              const t = s.GetLineBounds(e),
                r = t.m_fHeight - t.m_fOffsetY;
              n < r && (n = r);
            }
            const l = Math.round(n * (r.lineSpacing - 1)),
              d = Math.round(
                s.m_fHeight +
                  (s.GetLinesCount() - 1) * l +
                  r.padding.top +
                  r.padding.bottom
              ),
              h = Math.round(s.m_fWidth + r.padding.left + r.padding.right),
              u = s.GetLineBounds(0).m_fHeight,
              c = ((a % 360) * Math.PI) / 180;
            let p = Math.sin(c),
              g = Math.cos(c);
            const y = Math.round(h * Math.abs(g) + d * Math.abs(p)),
              f = Math.round(h * Math.abs(p) + d * Math.abs(g));
            let v = 0,
              m = 0;
            return (
              a >= 0 && a < 90
                ? ((v = (d - r.padding.top - u) * p + r.padding.left * g),
                  (m = r.padding.left * p + (r.padding.top + u) * g))
                : a >= 90 && a <= 180
                ? ((v = y - (r.padding.top + u) * p + r.padding.left * g),
                  (m = -(d - r.padding.top - u) * g + r.padding.left * p))
                : a > 180 && a <= 270
                ? ((v = y - (r.padding.top + u - d) * p + r.padding.left * g),
                  (m = f + (r.padding.top + u) * g + r.padding.left * p))
                : a > 270 &&
                  a < 360 &&
                  ((v = -(r.padding.top + u) * p + r.padding.left * g),
                  (m = f - (d - u - r.padding.top) * g + r.padding.left * p)),
              {
                textHeight: f,
                textWidth: y,
                nativeLineSpacing: l,
                deltaX: v,
                deltaY: m,
              }
            );
          });
      },
      58345: (e, t) => {
        "use strict";
        var r, i, o;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getTooltipPositionProperties =
            t.getUpdatedPoints =
            t.getEndPoint =
            t.getStartPoint =
            t.getTotalSpacing =
            t.getTotalSize =
            t.checkHasOverlap =
            t.spreadTooltips =
            t.EShift =
            t.ECoord =
            t.ESize =
              void 0),
          (function (e) {
            (e.width = "width"), (e.height = "height");
          })((r = t.ESize || (t.ESize = {}))),
          (function (e) {
            (e.xCoord = "xCoord"), (e.yCoord = "yCoord");
          })((i = t.ECoord || (t.ECoord = {}))),
          (function (e) {
            (e.xCoordShift = "xCoordShift"), (e.yCoordShift = "yCoordShift");
          })((o = t.EShift || (t.EShift = {}))),
          (t.spreadTooltips = (e, r, i, o, a) => {
            const s = new Map(),
              n = e.length,
              l = (0, t.getTotalSize)(e, i.sizePropertyName),
              d = l + (0, t.getTotalSpacing)(e, o),
              h = e[0],
              u = e[n - 1];
            let c = (0, t.getStartPoint)(
                h[i.coordPropertyName],
                h[i.shiftPropertyName],
                r
              ),
              p = (0, t.getEndPoint)(
                u[i.coordPropertyName],
                u[i.shiftPropertyName],
                r,
                u[i.sizePropertyName]
              );
            const g = (0, t.getUpdatedPoints)(c, p, d, a[i.sizePropertyName]);
            (c = g.start), (p = g.end);
            const y = (p - c - l) / (e.length - 1);
            return (
              e.reduce(
                (e, t) => (
                  s.set(t.index, (e - t[i.coordPropertyName]) / r),
                  e + t[i.sizePropertyName] + y
                ),
                c
              ),
              s
            );
          }),
          (t.checkHasOverlap = (e, t, r, i) => {
            const o = e.length;
            for (let a = 0; a < o - 1; a++) {
              const o = e[a],
                s =
                  o[i.coordPropertyName] +
                  o[i.sizePropertyName] +
                  o[i.shiftPropertyName] * r,
                n = e[a + 1];
              if (n[i.coordPropertyName] + n[i.shiftPropertyName] * r - s < t)
                return !0;
            }
            return !1;
          }),
          (t.getTotalSize = (e, t) =>
            e.reduce((e, r) => {
              const i = r[t];
              return "number" == typeof i ? e + i : e;
            }, 0)),
          (t.getTotalSpacing = (e, t) => (e.length - 1) * t),
          (t.getStartPoint = (e, t, r) => e + t * r),
          (t.getEndPoint = (e, t, r, i) => e + t * r + i),
          (t.getUpdatedPoints = (e, t, r, i) => {
            const o = r - (t - e),
              a = o / 2,
              s = i - t;
            let n = e - a,
              l = t + a;
            return (
              e < a && ((n = 0), (l = t + (o - e))),
              s < a && ((n = e - (o - s)), (l = i)),
              { start: n, end: l }
            );
          }),
          (t.getTooltipPositionProperties = (e) =>
            e
              ? {
                  sizePropertyName: r.width,
                  coordPropertyName: i.xCoord,
                  shiftPropertyName: o.xCoordShift,
                }
              : {
                  sizePropertyName: r.height,
                  coordPropertyName: i.yCoord,
                  shiftPropertyName: o.yCoordShift,
                });
      },
      32873: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fitSvgToViewRect =
            t.fitElementToViewRect =
            t.convertToHtmlPx =
            t.translateDataValueRectToAbsolute =
            t.translateToNotScaledRect =
            t.translateToScaledRect =
            t.translateToNotScaled =
            t.translateToScaled =
            t.translateFromSeriesViewRectToCanvasY =
            t.translateFromSeriesViewRectToCanvasX =
            t.translateFromCanvasToSeriesViewRectY =
            t.translateFromCanvasToSeriesViewRectX =
            t.translateFromSeriesViewRectToCanvas =
            t.translateFromCanvasToSeriesViewRect =
              void 0);
        const i = r(86127),
          o = r(75772),
          a = r(87459);
        (t.translateFromCanvasToSeriesViewRect = (e, t, r = !1) => {
          if (!t) return;
          const i = e.x - t.x,
            a = e.y - t.y;
          return r || !(i < 0 || i > t.width || a < 0 || a > t.height)
            ? new o.Point(i, a)
            : void 0;
        }),
          (t.translateFromSeriesViewRectToCanvas = (e, t, r = !1) => {
            if (!t) return;
            const i = e.x + t.x,
              a = e.y + t.y;
            return r || !(i < 0 || i > t.width || a < 0 || a > t.height)
              ? new o.Point(i, a)
              : void 0;
          }),
          (t.translateFromCanvasToSeriesViewRectX = (e, t, r = !1) => {
            if (!t) return;
            const i = e - t.x;
            return r || !(i < 0 || i > t.width) ? i : void 0;
          }),
          (t.translateFromCanvasToSeriesViewRectY = (e, t, r = !1) => {
            if (!t) return;
            const i = e - t.y;
            return r || !(i < 0 || i > t.height) ? i : void 0;
          }),
          (t.translateFromSeriesViewRectToCanvasX = (e, t, r = !1) => {
            if (!t) return;
            const i = e + t.x;
            return r || !(i < 0 || i > t.width) ? i : void 0;
          }),
          (t.translateFromSeriesViewRectToCanvasY = (e, t, r = !1) => {
            if (!t) return;
            const i = e + t.y;
            return r || !(i < 0 || i > t.height) ? i : void 0;
          }),
          (t.translateToScaled = (e) => e * i.DpiHelper.PIXEL_RATIO),
          (t.translateToNotScaled = (e) => e / i.DpiHelper.PIXEL_RATIO),
          (t.translateToScaledRect = (e) =>
            new a.Rect(
              e.x * i.DpiHelper.PIXEL_RATIO,
              e.y * i.DpiHelper.PIXEL_RATIO,
              e.width * i.DpiHelper.PIXEL_RATIO,
              e.height * i.DpiHelper.PIXEL_RATIO
            )),
          (t.translateToNotScaledRect = (e) =>
            new a.Rect(
              e.x / i.DpiHelper.PIXEL_RATIO,
              e.y / i.DpiHelper.PIXEL_RATIO,
              e.width / i.DpiHelper.PIXEL_RATIO,
              e.height / i.DpiHelper.PIXEL_RATIO
            )),
          (t.translateDataValueRectToAbsolute = (e, r, i, o) => {
            const { x: s, y: n, width: l, height: d } = e,
              h = (0, t.translateToNotScaled)(o.left),
              u = (0, t.translateToNotScaled)(o.top),
              c = r.getCurrentCoordinateCalculator(),
              p = i.getCurrentCoordinateCalculator();
            let g = r.isVerticalChart ? p.getCoordinate(s) : c.getCoordinate(s),
              y = r.isVerticalChart ? c.getCoordinate(n) : p.getCoordinate(n);
            (g = Math.max((0, t.translateToNotScaled)(g), 0)),
              (y = Math.max((0, t.translateToNotScaled)(y), 0));
            const f = r.flippedCoordinates ? s - l : s + l,
              v = i.flippedCoordinates ? n + d : n - d;
            let m = (0, t.translateToNotScaled)(
                r.isVerticalChart ? c.getCoordinate(v) : p.getCoordinate(v)
              ),
              S = (0, t.translateToNotScaled)(
                r.isVerticalChart ? p.getCoordinate(f) : c.getCoordinate(f)
              );
            return (
              (g += h),
              (y += u),
              (S += h),
              (m += u),
              new a.Rect(g, y, Math.abs(S - g), Math.abs(y - m))
            );
          }),
          (t.convertToHtmlPx = (e) => `${e}px`),
          (t.fitElementToViewRect = (e, t) => {
            (e.style.marginLeft = `${t.x}px`),
              (e.style.marginTop = `${t.y}px`),
              e.setAttribute("width", t.width.toString()),
              e.setAttribute("height", t.height.toString()),
              (e.style.width = t.width + "px"),
              (e.style.height = t.height + "px");
          }),
          (t.fitSvgToViewRect = (e, r) => {
            (0, t.fitElementToViewRect)(e, r), (e.currentScale = 1);
          });
      },
      11727: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fromTsrVector4 = t.updateTsrVector4 = void 0);
        const i = r(23866);
        (t.updateTsrVector4 = (e, t) => {
          i.Guard.notNull(e, "color");
          const r = 1 / 255;
          (t.x = e.red * r),
            (t.y = e.green * r),
            (t.z = e.blue * r),
            (t.w = e.opacity * r);
        }),
          (t.fromTsrVector4 = (e) => (
            i.Guard.notNull(e, "tsrColor"),
            {
              red: Math.round(255 * e.x),
              green: Math.round(255 * e.y),
              blue: Math.round(255 * e.z),
              opacity: Math.round(255 * e.w),
            }
          ));
      },
      77376: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.watermarkHelpers = void 0);
        const i = r(87459),
          o = r(22022),
          a = r(24149);
        t.watermarkHelpers = {
          calcPosition: function (e, t, r, s, n, l) {
            const d = null != n ? n : i.Rect.create(0, 0, e, t),
              h = null != l ? l : new o.Size(e, t);
            let u = 0,
              c = 0,
              p = 0,
              g = 0;
            e > 500
              ? ((u = 156), (c = 42), (p = 5), (g = 10))
              : ((u = 79), (c = 21), (p = 3), (g = 6));
            let y = d.x + p,
              f = t - (d.top + d.height) + g;
            if (s)
              switch (r) {
                case a.EWatermarkPosition.BottomRight:
                  (y = e - u - p), (f = t - h.height + g);
                  break;
                case a.EWatermarkPosition.TopLeft:
                  (y = p), (f = t - (g + c));
                  break;
                case a.EWatermarkPosition.TopRight:
                  (y = e - u - p), (f = t - (g + c));
                  break;
                case a.EWatermarkPosition.BottomLeft:
                  (y = p), (f = t - h.height + g);
              }
            else
              switch (r) {
                case a.EWatermarkPosition.BottomRight:
                  y = d.left + d.width - u - p;
                  break;
                case a.EWatermarkPosition.TopLeft:
                  f = t - (d.top + g + c);
                  break;
                case a.EWatermarkPosition.TopRight:
                  (y = d.left + d.width - u - p), (f = t - (d.top + g + c));
                case a.EWatermarkPosition.BottomLeft:
              }
            return { left: y, bottom: f };
          },
        };
      },
      14936: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.zeroArray2D = void 0),
          (t.zeroArray2D = (e) => {
            if (!e) return;
            const r = [];
            for (let i = 0; i < e[0]; ++i)
              r.push(1 === e.length ? 0 : (0, t.zeroArray2D)(e.slice(1)));
            return r;
          });
      },
      84215: (e) => {
        var t,
          r =
            ((t =
              "undefined" != typeof document
                ? document.currentScript?.src
                : void 0),
            function (e = {}) {
              var r,
                i,
                o,
                a,
                s = e,
                n = new Promise((e, t) => {
                  (r = e), (i = t);
                }),
                l = Object.assign({}, s),
                d = [],
                h = "./this.program",
                u = (e, t) => {
                  throw t;
                },
                c = "";
              "undefined" != typeof document &&
                document.currentScript &&
                (c = document.currentScript.src),
                t && (c = t),
                (c = c.startsWith("blob:")
                  ? ""
                  : c.substr(0, c.replace(/[?#].*/, "").lastIndexOf("/") + 1)),
                (o = async (e) => {
                  var t = await fetch(e, { credentials: "same-origin" });
                  if (t.ok) return t.arrayBuffer();
                  throw new Error(t.status + " : " + t.url);
                });
              var p = s.print || console.log.bind(console),
                g = s.printErr || console.error.bind(console);
              Object.assign(s, l),
                (l = null),
                s.arguments && (d = s.arguments),
                s.thisProgram && (h = s.thisProgram);
              var y,
                f,
                v,
                m,
                S,
                P,
                C,
                b,
                x,
                A,
                T = s.wasmBinary,
                E = !1;
              function R() {
                var e = y.buffer;
                (s.HEAP8 = v = new Int8Array(e)),
                  (s.HEAP16 = S = new Int16Array(e)),
                  (s.HEAPU8 = m = new Uint8Array(e)),
                  (s.HEAPU16 = P = new Uint16Array(e)),
                  (s.HEAP32 = C = new Int32Array(e)),
                  (s.HEAPU32 = b = new Uint32Array(e)),
                  (s.HEAPF32 = x = new Float32Array(e)),
                  (s.HEAPF64 = A = new Float64Array(e));
              }
              var D = [],
                w = [],
                M = [],
                L = [],
                O = 0,
                I = null;
              function k(e) {
                O++, s.monitorRunDependencies?.(O);
              }
              function _(e) {
                if ((O--, s.monitorRunDependencies?.(O), 0 == O && I)) {
                  var t = I;
                  (I = null), t();
                }
              }
              function V(e) {
                s.onAbort?.(e),
                  g((e = "Aborted(" + e + ")")),
                  (E = !0),
                  (e += ". Build with -sASSERTIONS for more info.");
                var t = new WebAssembly.RuntimeError(e);
                throw (i(t), t);
              }
              var N,
                B,
                F,
                H = (e) =>
                  e.startsWith("data:application/octet-stream;base64,");
              async function Y(e, t, r) {
                if (
                  !e &&
                  "function" == typeof WebAssembly.instantiateStreaming &&
                  !H(t) &&
                  "function" == typeof fetch
                )
                  try {
                    var i = fetch(t, { credentials: "same-origin" });
                    return await WebAssembly.instantiateStreaming(i, r);
                  } catch (e) {
                    g(`wasm streaming compile failed: ${e}`),
                      g("falling back to ArrayBuffer instantiation");
                  }
                return (async function (e, t) {
                  try {
                    var r = await (async function (e) {
                      if (!T)
                        try {
                          var t = await o(e);
                          return new Uint8Array(t);
                        } catch {}
                      return (function (e) {
                        if (e == N && T) return new Uint8Array(T);
                        if (a) return a(e);
                        throw "both async and sync fetching of the wasm failed";
                      })(e);
                    })(e);
                    return await WebAssembly.instantiate(r, t);
                  } catch (e) {
                    g(`failed to asynchronously prepare wasm: ${e}`), V(e);
                  }
                })(t, r);
              }
              var z = {
                874004: () => {
                  var e =
                    navigator.userAgent || navigator.vendor || window.opera;
                  return /windows phone/i.test(e)
                    ? 0
                    : /Android/i.test(e)
                    ? 1
                    : /iPad|iPhone|iPod/.test(e) && !window.MSStream
                    ? 2
                    : 0;
                },
                874274: () => {
                  ar["#canvas"] = s.canvas;
                },
                874325: () => s.getRandomValue(),
                874361: () => {
                  if (void 0 === s.getRandomValue)
                    try {
                      var e = "object" == typeof window ? window : self,
                        t = void 0 !== e.crypto ? e.crypto : e.msCrypto,
                        r = function () {
                          var e = new Uint32Array(1);
                          return t.getRandomValues(e), e[0] >>> 0;
                        };
                      r(), (s.getRandomValue = r);
                    } catch (e) {
                      try {
                        var i = Math.pow(2, 32),
                          o = function () {
                            return (
                              Math.floor(Math.random() * Math.floor(i)) >>> 0
                            );
                          };
                        o(), (s.getRandomValue = o);
                      } catch (e) {
                        throw "No secure random number generator found";
                      }
                    }
                },
                875043: (e) => {
                  var t =
                      Se(e) + "\n\nAbort/Retry/Ignore/AlwaysIgnore? [ariA] :",
                    r = window.prompt(t, "i");
                  return (
                    null === r && (r = "i"), allocate(se(r), "i8", ALLOC_NORMAL)
                  );
                },
                875268: () =>
                  "undefined" != typeof AudioContext ||
                  "undefined" != typeof webkitAudioContext,
                875415: () =>
                  (void 0 !== navigator.mediaDevices &&
                    void 0 !== navigator.mediaDevices.getUserMedia) ||
                  void 0 !== navigator.webkitGetUserMedia,
                875649: (e) => {
                  void 0 === s.SDL2 && (s.SDL2 = {});
                  var t = s.SDL2;
                  return (
                    e ? (t.capture = {}) : (t.audio = {}),
                    t.audioContext ||
                      ("undefined" != typeof AudioContext
                        ? (t.audioContext = new AudioContext())
                        : "undefined" != typeof webkitAudioContext &&
                          (t.audioContext = new webkitAudioContext()),
                      t.audioContext &&
                        void 0 === navigator.userActivation &&
                        bs(t.audioContext)),
                    void 0 === t.audioContext ? -1 : 0
                  );
                },
                876201: () => s.SDL2.audioContext.sampleRate,
                876269: (e, t, r, i) => {
                  var o = s.SDL2,
                    a = function (a) {
                      void 0 !== o.capture.silenceTimer &&
                        (clearInterval(o.capture.silenceTimer),
                        (o.capture.silenceTimer = void 0),
                        (o.capture.silenceBuffer = void 0)),
                        (o.capture.mediaStreamNode =
                          o.audioContext.createMediaStreamSource(a)),
                        (o.capture.scriptProcessorNode =
                          o.audioContext.createScriptProcessor(t, e, 1)),
                        (o.capture.scriptProcessorNode.onaudioprocess =
                          function (e) {
                            void 0 !== o &&
                              void 0 !== o.capture &&
                              (e.outputBuffer.getChannelData(0).fill(0),
                              (o.capture.currentCaptureBuffer = e.inputBuffer),
                              lt("vi", r, [i]));
                          }),
                        o.capture.mediaStreamNode.connect(
                          o.capture.scriptProcessorNode
                        ),
                        o.capture.scriptProcessorNode.connect(
                          o.audioContext.destination
                        ),
                        (o.capture.stream = a);
                    },
                    n = function (e) {};
                  (o.capture.silenceBuffer = o.audioContext.createBuffer(
                    e,
                    t,
                    o.audioContext.sampleRate
                  )),
                    o.capture.silenceBuffer.getChannelData(0).fill(0),
                    (o.capture.silenceTimer = setInterval(function () {
                      (o.capture.currentCaptureBuffer =
                        o.capture.silenceBuffer),
                        lt("vi", r, [i]);
                    }, (t / o.audioContext.sampleRate) * 1e3)),
                    void 0 !== navigator.mediaDevices &&
                    void 0 !== navigator.mediaDevices.getUserMedia
                      ? navigator.mediaDevices
                          .getUserMedia({ audio: !0, video: !1 })
                          .then(a)
                          .catch(n)
                      : void 0 !== navigator.webkitGetUserMedia &&
                        navigator.webkitGetUserMedia(
                          { audio: !0, video: !1 },
                          a,
                          n
                        );
                },
                877962: (e, t, r, i) => {
                  var o = s.SDL2;
                  (o.audio.scriptProcessorNode =
                    o.audioContext.createScriptProcessor(t, 0, e)),
                    (o.audio.scriptProcessorNode.onaudioprocess = function (e) {
                      void 0 !== o &&
                        void 0 !== o.audio &&
                        (void 0 !== o.audio.silenceTimer &&
                          (clearInterval(o.audio.silenceTimer),
                          (o.audio.silenceTimer = void 0),
                          (o.audio.silenceBuffer = void 0)),
                        (o.audio.currentOutputBuffer = e.outputBuffer),
                        lt("vi", r, [i]));
                    }),
                    o.audio.scriptProcessorNode.connect(
                      o.audioContext.destination
                    ),
                    "suspended" === o.audioContext.state &&
                      ((o.audio.silenceBuffer = o.audioContext.createBuffer(
                        e,
                        t,
                        o.audioContext.sampleRate
                      )),
                      o.audio.silenceBuffer.getChannelData(0).fill(0),
                      (o.audio.silenceTimer = setInterval(function () {
                        void 0 !== navigator.userActivation &&
                          navigator.userActivation.hasBeenActive &&
                          o.audioContext.resume(),
                          (o.audio.currentOutputBuffer = o.audio.silenceBuffer),
                          lt("vi", r, [i]),
                          (o.audio.currentOutputBuffer = void 0);
                      }, (t / o.audioContext.sampleRate) * 1e3)));
                },
                879137: (e, t) => {
                  for (
                    var r = s.SDL2,
                      i = r.capture.currentCaptureBuffer.numberOfChannels,
                      o = 0;
                    o < i;
                    ++o
                  ) {
                    var a = r.capture.currentCaptureBuffer.getChannelData(o);
                    if (a.length != t)
                      throw (
                        "Web Audio capture buffer length mismatch! Destination size: " +
                        a.length +
                        " samples vs expected " +
                        t +
                        " samples!"
                      );
                    if (1 == i)
                      for (var n = 0; n < t; ++n) W(e + 4 * n, a[n], "float");
                    else
                      for (n = 0; n < t; ++n)
                        W(e + 4 * (n * i + o), a[n], "float");
                  }
                },
                879742: (e, t) => {
                  for (
                    var r = s.SDL2,
                      i = e >>> 2,
                      o = r.audio.currentOutputBuffer.numberOfChannels,
                      a = 0;
                    a < o;
                    ++a
                  ) {
                    var n = r.audio.currentOutputBuffer.getChannelData(a);
                    if (n.length != t)
                      throw (
                        "Web Audio output buffer length mismatch! Destination size: " +
                        n.length +
                        " samples vs expected " +
                        t +
                        " samples!"
                      );
                    for (var l = 0; l < t; ++l) n[l] = x[i + (l * o + a)];
                  }
                },
                880231: (e) => {
                  var t = s.SDL2;
                  if (e) {
                    if (
                      (void 0 !== t.capture.silenceTimer &&
                        clearInterval(t.capture.silenceTimer),
                      void 0 !== t.capture.stream)
                    )
                      for (
                        var r = t.capture.stream.getAudioTracks(), i = 0;
                        i < r.length;
                        i++
                      )
                        t.capture.stream.removeTrack(r[i]);
                    void 0 !== t.capture.scriptProcessorNode &&
                      ((t.capture.scriptProcessorNode.onaudioprocess =
                        function (e) {}),
                      t.capture.scriptProcessorNode.disconnect()),
                      void 0 !== t.capture.mediaStreamNode &&
                        t.capture.mediaStreamNode.disconnect(),
                      (t.capture = void 0);
                  } else
                    null != t.audio.scriptProcessorNode &&
                      t.audio.scriptProcessorNode.disconnect(),
                      void 0 !== t.audio.silenceTimer &&
                        clearInterval(t.audio.silenceTimer),
                      (t.audio = void 0);
                  void 0 !== t.audioContext &&
                    void 0 === t.audio &&
                    void 0 === t.capture &&
                    (t.audioContext.close(), (t.audioContext = void 0));
                },
                881237: (e, t, r) => {
                  var i = e,
                    o = t,
                    a = r;
                  s.SDL2 || (s.SDL2 = {});
                  var n = s.SDL2;
                  n.ctxCanvas !== s.canvas &&
                    ((n.ctx = s.createContext(s.canvas, !1, !0)),
                    (n.ctxCanvas = s.canvas)),
                    (n.w === i && n.h === o && n.imageCtx === n.ctx) ||
                      ((n.image = n.ctx.createImageData(i, o)),
                      (n.w = i),
                      (n.h = o),
                      (n.imageCtx = n.ctx));
                  var l,
                    d = n.image.data,
                    h = a / 4,
                    u = 0;
                  if (
                    "undefined" != typeof CanvasPixelArray &&
                    d instanceof CanvasPixelArray
                  )
                    for (l = d.length; u < l; ) {
                      var c = C[h];
                      (d[u] = 255 & c),
                        (d[u + 1] = (c >> 8) & 255),
                        (d[u + 2] = (c >> 16) & 255),
                        (d[u + 3] = 255),
                        h++,
                        (u += 4);
                    }
                  else {
                    n.data32Data !== d &&
                      ((n.data32 = new Int32Array(d.buffer)),
                      (n.data8 = new Uint8Array(d.buffer)),
                      (n.data32Data = d));
                    var p = n.data32;
                    (l = p.length), p.set(C.subarray(h, h + l));
                    var g = n.data8,
                      y = 3,
                      f = y + 4 * l;
                    if (l % 8 == 0)
                      for (; y < f; )
                        (g[y] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (y = (y + 4) | 0);
                    else for (; y < f; ) (g[y] = 255), (y = (y + 4) | 0);
                  }
                  n.ctx.putImageData(n.image, 0, 0);
                },
                882705: (e, t, r, i, o) => {
                  var a = e,
                    s = t,
                    n = r,
                    l = i,
                    d = o,
                    h = document.createElement("canvas");
                  (h.width = a), (h.height = s);
                  var u,
                    c = h.getContext("2d"),
                    p = c.createImageData(a, s),
                    g = p.data,
                    y = d / 4,
                    f = 0;
                  if (
                    "undefined" != typeof CanvasPixelArray &&
                    g instanceof CanvasPixelArray
                  )
                    for (u = g.length; f < u; ) {
                      var v = C[y];
                      (g[f] = 255 & v),
                        (g[f + 1] = (v >> 8) & 255),
                        (g[f + 2] = (v >> 16) & 255),
                        (g[f + 3] = (v >> 24) & 255),
                        y++,
                        (f += 4);
                    }
                  else {
                    var m = new Int32Array(g.buffer);
                    (u = m.length), m.set(C.subarray(y, y + u));
                  }
                  c.putImageData(p, 0, 0);
                  var S =
                      0 === n && 0 === l
                        ? "url(" + h.toDataURL() + "), auto"
                        : "url(" +
                          h.toDataURL() +
                          ") " +
                          n +
                          " " +
                          l +
                          ", auto",
                    P = Os(S.length + 1);
                  return xt(S, P, S.length + 1), P;
                },
                883693: (e) => {
                  s.canvas && (s.canvas.style.cursor = Se(e));
                },
                883776: () => {
                  s.canvas && (s.canvas.style.cursor = "none");
                },
                883845: () => window.innerWidth,
                883875: () => window.innerHeight,
              };
              class j {
                name = "ExitStatus";
                constructor(e) {
                  (this.message = `Program terminated with exit(${e})`),
                    (this.status = e);
                }
              }
              var X = (e) => {
                  for (; e.length > 0; ) e.shift()(s);
                },
                G = s.noExitRuntime || !0;
              function W(e, t, r = "i8") {
                switch ((r.endsWith("*") && (r = "*"), r)) {
                  case "i1":
                  case "i8":
                    v[e] = t;
                    break;
                  case "i16":
                    S[e >> 1] = t;
                    break;
                  case "i32":
                    C[e >> 2] = t;
                    break;
                  case "i64":
                    V("to do setValue(i64) use WASM_BIGINT");
                  case "float":
                    x[e >> 2] = t;
                    break;
                  case "double":
                    A[e >> 3] = t;
                    break;
                  case "*":
                    b[e >> 2] = t;
                    break;
                  default:
                    V(`invalid type for setValue: ${r}`);
                }
              }
              var U = (e) => Vs(e),
                $ = () => Bs();
              class Z {
                constructor(e) {
                  (this.excPtr = e), (this.ptr = e - 24);
                }
                set_type(e) {
                  b[(this.ptr + 4) >> 2] = e;
                }
                get_type() {
                  return b[(this.ptr + 4) >> 2];
                }
                set_destructor(e) {
                  b[(this.ptr + 8) >> 2] = e;
                }
                get_destructor() {
                  return b[(this.ptr + 8) >> 2];
                }
                set_caught(e) {
                  (e = e ? 1 : 0), (v[this.ptr + 12] = e);
                }
                get_caught() {
                  return 0 != v[this.ptr + 12];
                }
                set_rethrown(e) {
                  (e = e ? 1 : 0), (v[this.ptr + 13] = e);
                }
                get_rethrown() {
                  return 0 != v[this.ptr + 13];
                }
                init(e, t) {
                  this.set_adjusted_ptr(0),
                    this.set_type(e),
                    this.set_destructor(t);
                }
                set_adjusted_ptr(e) {
                  b[(this.ptr + 16) >> 2] = e;
                }
                get_adjusted_ptr() {
                  return b[(this.ptr + 16) >> 2];
                }
              }
              var q = () => {
                  var e = C[+Pe.varargs >> 2];
                  return (Pe.varargs += 4), e;
                },
                K = q,
                J = {
                  isAbs: (e) => "/" === e.charAt(0),
                  splitPath: (e) =>
                    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
                      .exec(e)
                      .slice(1),
                  normalizeArray: (e, t) => {
                    for (var r = 0, i = e.length - 1; i >= 0; i--) {
                      var o = e[i];
                      "." === o
                        ? e.splice(i, 1)
                        : ".." === o
                        ? (e.splice(i, 1), r++)
                        : r && (e.splice(i, 1), r--);
                    }
                    if (t) for (; r; r--) e.unshift("..");
                    return e;
                  },
                  normalize: (e) => {
                    var t = J.isAbs(e),
                      r = "/" === e.substr(-1);
                    return (
                      (e = J.normalizeArray(
                        e.split("/").filter((e) => !!e),
                        !t
                      ).join("/")) ||
                        t ||
                        (e = "."),
                      e && r && (e += "/"),
                      (t ? "/" : "") + e
                    );
                  },
                  dirname: (e) => {
                    var t = J.splitPath(e),
                      r = t[0],
                      i = t[1];
                    return r || i
                      ? (i && (i = i.substr(0, i.length - 1)), r + i)
                      : ".";
                  },
                  basename: (e) => {
                    if ("/" === e) return "/";
                    var t = (e = (e = J.normalize(e)).replace(
                      /\/$/,
                      ""
                    )).lastIndexOf("/");
                    return -1 === t ? e : e.substr(t + 1);
                  },
                  join: (...e) => J.normalize(e.join("/")),
                  join2: (e, t) => J.normalize(e + "/" + t),
                },
                Q = (e) =>
                  (Q = (() => {
                    if (
                      "object" == typeof crypto &&
                      "function" == typeof crypto.getRandomValues
                    )
                      return (e) => crypto.getRandomValues(e);
                    V("initRandomDevice");
                  })())(e),
                ee = {
                  resolve: (...e) => {
                    for (
                      var t = "", r = !1, i = e.length - 1;
                      i >= -1 && !r;
                      i--
                    ) {
                      var o = i >= 0 ? e[i] : me.cwd();
                      if ("string" != typeof o)
                        throw new TypeError(
                          "Arguments to path.resolve must be strings"
                        );
                      if (!o) return "";
                      (t = o + "/" + t), (r = J.isAbs(o));
                    }
                    return (
                      (r ? "/" : "") +
                        (t = J.normalizeArray(
                          t.split("/").filter((e) => !!e),
                          !r
                        ).join("/")) || "."
                    );
                  },
                  relative: (e, t) => {
                    function r(e) {
                      for (var t = 0; t < e.length && "" === e[t]; t++);
                      for (var r = e.length - 1; r >= 0 && "" === e[r]; r--);
                      return t > r ? [] : e.slice(t, r - t + 1);
                    }
                    (e = ee.resolve(e).substr(1)),
                      (t = ee.resolve(t).substr(1));
                    for (
                      var i = r(e.split("/")),
                        o = r(t.split("/")),
                        a = Math.min(i.length, o.length),
                        s = a,
                        n = 0;
                      n < a;
                      n++
                    )
                      if (i[n] !== o[n]) {
                        s = n;
                        break;
                      }
                    var l = [];
                    for (n = s; n < i.length; n++) l.push("..");
                    return (l = l.concat(o.slice(s))).join("/");
                  },
                },
                te =
                  "undefined" != typeof TextDecoder
                    ? new TextDecoder()
                    : void 0,
                re = (e, t = 0, r = NaN) => {
                  for (var i = t + r, o = t; e[o] && !(o >= i); ) ++o;
                  if (o - t > 16 && e.buffer && te)
                    return te.decode(e.subarray(t, o));
                  for (var a = ""; t < o; ) {
                    var s = e[t++];
                    if (128 & s) {
                      var n = 63 & e[t++];
                      if (192 != (224 & s)) {
                        var l = 63 & e[t++];
                        if (
                          (s =
                            224 == (240 & s)
                              ? ((15 & s) << 12) | (n << 6) | l
                              : ((7 & s) << 18) |
                                (n << 12) |
                                (l << 6) |
                                (63 & e[t++])) < 65536
                        )
                          a += String.fromCharCode(s);
                        else {
                          var d = s - 65536;
                          a += String.fromCharCode(
                            55296 | (d >> 10),
                            56320 | (1023 & d)
                          );
                        }
                      } else a += String.fromCharCode(((31 & s) << 6) | n);
                    } else a += String.fromCharCode(s);
                  }
                  return a;
                },
                ie = [],
                oe = (e) => {
                  for (var t = 0, r = 0; r < e.length; ++r) {
                    var i = e.charCodeAt(r);
                    i <= 127
                      ? t++
                      : i <= 2047
                      ? (t += 2)
                      : i >= 55296 && i <= 57343
                      ? ((t += 4), ++r)
                      : (t += 3);
                  }
                  return t;
                },
                ae = (e, t, r, i) => {
                  if (!(i > 0)) return 0;
                  for (var o = r, a = r + i - 1, s = 0; s < e.length; ++s) {
                    var n = e.charCodeAt(s);
                    if (
                      (n >= 55296 &&
                        n <= 57343 &&
                        (n =
                          (65536 + ((1023 & n) << 10)) |
                          (1023 & e.charCodeAt(++s))),
                      n <= 127)
                    ) {
                      if (r >= a) break;
                      t[r++] = n;
                    } else if (n <= 2047) {
                      if (r + 1 >= a) break;
                      (t[r++] = 192 | (n >> 6)), (t[r++] = 128 | (63 & n));
                    } else if (n <= 65535) {
                      if (r + 2 >= a) break;
                      (t[r++] = 224 | (n >> 12)),
                        (t[r++] = 128 | ((n >> 6) & 63)),
                        (t[r++] = 128 | (63 & n));
                    } else {
                      if (r + 3 >= a) break;
                      (t[r++] = 240 | (n >> 18)),
                        (t[r++] = 128 | ((n >> 12) & 63)),
                        (t[r++] = 128 | ((n >> 6) & 63)),
                        (t[r++] = 128 | (63 & n));
                    }
                  }
                  return (t[r] = 0), r - o;
                };
              function se(e, t, r) {
                var i = r > 0 ? r : oe(e) + 1,
                  o = new Array(i),
                  a = ae(e, o, 0, o.length);
                return t && (o.length = a), o;
              }
              var ne,
                le,
                de,
                he,
                ue = {
                  ttys: [],
                  init() {},
                  shutdown() {},
                  register(e, t) {
                    (ue.ttys[e] = { input: [], output: [], ops: t }),
                      me.registerDevice(e, ue.stream_ops);
                  },
                  stream_ops: {
                    open(e) {
                      var t = ue.ttys[e.node.rdev];
                      if (!t) throw new me.ErrnoError(43);
                      (e.tty = t), (e.seekable = !1);
                    },
                    close(e) {
                      e.tty.ops.fsync(e.tty);
                    },
                    fsync(e) {
                      e.tty.ops.fsync(e.tty);
                    },
                    read(e, t, r, i, o) {
                      if (!e.tty || !e.tty.ops.get_char)
                        throw new me.ErrnoError(60);
                      for (var a = 0, s = 0; s < i; s++) {
                        var n;
                        try {
                          n = e.tty.ops.get_char(e.tty);
                        } catch (e) {
                          throw new me.ErrnoError(29);
                        }
                        if (void 0 === n && 0 === a) throw new me.ErrnoError(6);
                        if (null == n) break;
                        a++, (t[r + s] = n);
                      }
                      return a && (e.node.atime = Date.now()), a;
                    },
                    write(e, t, r, i, o) {
                      if (!e.tty || !e.tty.ops.put_char)
                        throw new me.ErrnoError(60);
                      try {
                        for (var a = 0; a < i; a++)
                          e.tty.ops.put_char(e.tty, t[r + a]);
                      } catch (e) {
                        throw new me.ErrnoError(29);
                      }
                      return i && (e.node.mtime = e.node.ctime = Date.now()), a;
                    },
                  },
                  default_tty_ops: {
                    get_char: (e) =>
                      (() => {
                        if (!ie.length) {
                          var e = null;
                          if (
                            ("undefined" != typeof window &&
                              "function" == typeof window.prompt &&
                              null !== (e = window.prompt("Input: ")) &&
                              (e += "\n"),
                            !e)
                          )
                            return null;
                          ie = se(e, !0);
                        }
                        return ie.shift();
                      })(),
                    put_char(e, t) {
                      null === t || 10 === t
                        ? (p(re(e.output)), (e.output = []))
                        : 0 != t && e.output.push(t);
                    },
                    fsync(e) {
                      e.output &&
                        e.output.length > 0 &&
                        (p(re(e.output)), (e.output = []));
                    },
                    ioctl_tcgets: (e) => ({
                      c_iflag: 25856,
                      c_oflag: 5,
                      c_cflag: 191,
                      c_lflag: 35387,
                      c_cc: [
                        3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23,
                        22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      ],
                    }),
                    ioctl_tcsets: (e, t, r) => 0,
                    ioctl_tiocgwinsz: (e) => [24, 80],
                  },
                  default_tty1_ops: {
                    put_char(e, t) {
                      null === t || 10 === t
                        ? (g(re(e.output)), (e.output = []))
                        : 0 != t && e.output.push(t);
                    },
                    fsync(e) {
                      e.output &&
                        e.output.length > 0 &&
                        (g(re(e.output)), (e.output = []));
                    },
                  },
                },
                ce = (e) => {
                  V();
                },
                pe = {
                  ops_table: null,
                  mount: (e) => pe.createNode(null, "/", 16895, 0),
                  createNode(e, t, r, i) {
                    if (me.isBlkdev(r) || me.isFIFO(r))
                      throw new me.ErrnoError(63);
                    pe.ops_table ||= {
                      dir: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                          lookup: pe.node_ops.lookup,
                          mknod: pe.node_ops.mknod,
                          rename: pe.node_ops.rename,
                          unlink: pe.node_ops.unlink,
                          rmdir: pe.node_ops.rmdir,
                          readdir: pe.node_ops.readdir,
                          symlink: pe.node_ops.symlink,
                        },
                        stream: { llseek: pe.stream_ops.llseek },
                      },
                      file: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                        },
                        stream: {
                          llseek: pe.stream_ops.llseek,
                          read: pe.stream_ops.read,
                          write: pe.stream_ops.write,
                          allocate: pe.stream_ops.allocate,
                          mmap: pe.stream_ops.mmap,
                          msync: pe.stream_ops.msync,
                        },
                      },
                      link: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                          readlink: pe.node_ops.readlink,
                        },
                        stream: {},
                      },
                      chrdev: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                        },
                        stream: me.chrdev_stream_ops,
                      },
                    };
                    var o = me.createNode(e, t, r, i);
                    return (
                      me.isDir(o.mode)
                        ? ((o.node_ops = pe.ops_table.dir.node),
                          (o.stream_ops = pe.ops_table.dir.stream),
                          (o.contents = {}))
                        : me.isFile(o.mode)
                        ? ((o.node_ops = pe.ops_table.file.node),
                          (o.stream_ops = pe.ops_table.file.stream),
                          (o.usedBytes = 0),
                          (o.contents = null))
                        : me.isLink(o.mode)
                        ? ((o.node_ops = pe.ops_table.link.node),
                          (o.stream_ops = pe.ops_table.link.stream))
                        : me.isChrdev(o.mode) &&
                          ((o.node_ops = pe.ops_table.chrdev.node),
                          (o.stream_ops = pe.ops_table.chrdev.stream)),
                      (o.atime = o.mtime = o.ctime = Date.now()),
                      e &&
                        ((e.contents[t] = o),
                        (e.atime = e.mtime = e.ctime = o.atime)),
                      o
                    );
                  },
                  getFileDataAsTypedArray: (e) =>
                    e.contents
                      ? e.contents.subarray
                        ? e.contents.subarray(0, e.usedBytes)
                        : new Uint8Array(e.contents)
                      : new Uint8Array(0),
                  expandFileStorage(e, t) {
                    var r = e.contents ? e.contents.length : 0;
                    if (!(r >= t)) {
                      (t = Math.max(t, (r * (r < 1048576 ? 2 : 1.125)) >>> 0)),
                        0 != r && (t = Math.max(t, 256));
                      var i = e.contents;
                      (e.contents = new Uint8Array(t)),
                        e.usedBytes > 0 &&
                          e.contents.set(i.subarray(0, e.usedBytes), 0);
                    }
                  },
                  resizeFileStorage(e, t) {
                    if (e.usedBytes != t)
                      if (0 == t) (e.contents = null), (e.usedBytes = 0);
                      else {
                        var r = e.contents;
                        (e.contents = new Uint8Array(t)),
                          r &&
                            e.contents.set(
                              r.subarray(0, Math.min(t, e.usedBytes))
                            ),
                          (e.usedBytes = t);
                      }
                  },
                  node_ops: {
                    getattr(e) {
                      var t = {};
                      return (
                        (t.dev = me.isChrdev(e.mode) ? e.id : 1),
                        (t.ino = e.id),
                        (t.mode = e.mode),
                        (t.nlink = 1),
                        (t.uid = 0),
                        (t.gid = 0),
                        (t.rdev = e.rdev),
                        me.isDir(e.mode)
                          ? (t.size = 4096)
                          : me.isFile(e.mode)
                          ? (t.size = e.usedBytes)
                          : me.isLink(e.mode)
                          ? (t.size = e.link.length)
                          : (t.size = 0),
                        (t.atime = new Date(e.atime)),
                        (t.mtime = new Date(e.mtime)),
                        (t.ctime = new Date(e.ctime)),
                        (t.blksize = 4096),
                        (t.blocks = Math.ceil(t.size / t.blksize)),
                        t
                      );
                    },
                    setattr(e, t) {
                      for (const r of ["mode", "atime", "mtime", "ctime"])
                        t[r] && (e[r] = t[r]);
                      void 0 !== t.size && pe.resizeFileStorage(e, t.size);
                    },
                    lookup(e, t) {
                      throw pe.doesNotExistError;
                    },
                    mknod: (e, t, r, i) => pe.createNode(e, t, r, i),
                    rename(e, t, r) {
                      var i;
                      try {
                        i = me.lookupNode(t, r);
                      } catch (e) {}
                      if (i) {
                        if (me.isDir(e.mode))
                          for (var o in i.contents) throw new me.ErrnoError(55);
                        me.hashRemoveNode(i);
                      }
                      delete e.parent.contents[e.name],
                        (t.contents[r] = e),
                        (e.name = r),
                        (t.ctime =
                          t.mtime =
                          e.parent.ctime =
                          e.parent.mtime =
                            Date.now());
                    },
                    unlink(e, t) {
                      delete e.contents[t], (e.ctime = e.mtime = Date.now());
                    },
                    rmdir(e, t) {
                      var r = me.lookupNode(e, t);
                      for (var i in r.contents) throw new me.ErrnoError(55);
                      delete e.contents[t], (e.ctime = e.mtime = Date.now());
                    },
                    readdir: (e) => [".", "..", ...Object.keys(e.contents)],
                    symlink(e, t, r) {
                      var i = pe.createNode(e, t, 41471, 0);
                      return (i.link = r), i;
                    },
                    readlink(e) {
                      if (!me.isLink(e.mode)) throw new me.ErrnoError(28);
                      return e.link;
                    },
                  },
                  stream_ops: {
                    read(e, t, r, i, o) {
                      var a = e.node.contents;
                      if (o >= e.node.usedBytes) return 0;
                      var s = Math.min(e.node.usedBytes - o, i);
                      if (s > 8 && a.subarray) t.set(a.subarray(o, o + s), r);
                      else for (var n = 0; n < s; n++) t[r + n] = a[o + n];
                      return s;
                    },
                    write(e, t, r, i, o, a) {
                      if ((t.buffer === v.buffer && (a = !1), !i)) return 0;
                      var s = e.node;
                      if (
                        ((s.mtime = s.ctime = Date.now()),
                        t.subarray && (!s.contents || s.contents.subarray))
                      ) {
                        if (a)
                          return (
                            (s.contents = t.subarray(r, r + i)),
                            (s.usedBytes = i),
                            i
                          );
                        if (0 === s.usedBytes && 0 === o)
                          return (
                            (s.contents = t.slice(r, r + i)),
                            (s.usedBytes = i),
                            i
                          );
                        if (o + i <= s.usedBytes)
                          return s.contents.set(t.subarray(r, r + i), o), i;
                      }
                      if (
                        (pe.expandFileStorage(s, o + i),
                        s.contents.subarray && t.subarray)
                      )
                        s.contents.set(t.subarray(r, r + i), o);
                      else
                        for (var n = 0; n < i; n++)
                          s.contents[o + n] = t[r + n];
                      return (s.usedBytes = Math.max(s.usedBytes, o + i)), i;
                    },
                    llseek(e, t, r) {
                      var i = t;
                      if (
                        (1 === r
                          ? (i += e.position)
                          : 2 === r &&
                            me.isFile(e.node.mode) &&
                            (i += e.node.usedBytes),
                        i < 0)
                      )
                        throw new me.ErrnoError(28);
                      return i;
                    },
                    allocate(e, t, r) {
                      pe.expandFileStorage(e.node, t + r),
                        (e.node.usedBytes = Math.max(e.node.usedBytes, t + r));
                    },
                    mmap(e, t, r, i, o) {
                      if (!me.isFile(e.node.mode)) throw new me.ErrnoError(43);
                      var a,
                        s,
                        n = e.node.contents;
                      if (2 & o || !n || n.buffer !== v.buffer) {
                        if (((s = !0), !(a = ce())))
                          throw new me.ErrnoError(48);
                        n &&
                          ((r > 0 || r + t < n.length) &&
                            (n = n.subarray
                              ? n.subarray(r, r + t)
                              : Array.prototype.slice.call(n, r, r + t)),
                          v.set(n, a));
                      } else (s = !1), (a = n.byteOffset);
                      return { ptr: a, allocated: s };
                    },
                    msync: (e, t, r, i, o) => (
                      pe.stream_ops.write(e, t, 0, i, r, !1), 0
                    ),
                  },
                },
                ge = (e, t, r, i, o, a) => {
                  me.createDataFile(e, t, r, i, o, a);
                },
                ye = s.preloadPlugins || [],
                fe = (e, t, r, i) => {
                  void 0 !== Wt && Wt.init();
                  var o = !1;
                  return (
                    ye.forEach((a) => {
                      o || (a.canHandle(t) && (a.handle(e, t, r, i), (o = !0)));
                    }),
                    o
                  );
                },
                ve = (e, t) => {
                  var r = 0;
                  return e && (r |= 365), t && (r |= 146), r;
                },
                me = {
                  root: null,
                  mounts: [],
                  devices: {},
                  streams: [],
                  nextInode: 1,
                  nameTable: null,
                  currentPath: "/",
                  initialized: !1,
                  ignorePermissions: !0,
                  ErrnoError: class {
                    name = "ErrnoError";
                    constructor(e) {
                      this.errno = e;
                    }
                  },
                  filesystems: null,
                  syncFSRequests: 0,
                  readFiles: {},
                  FSStream: class {
                    shared = {};
                    get object() {
                      return this.node;
                    }
                    set object(e) {
                      this.node = e;
                    }
                    get isRead() {
                      return 1 != (2097155 & this.flags);
                    }
                    get isWrite() {
                      return 0 != (2097155 & this.flags);
                    }
                    get isAppend() {
                      return 1024 & this.flags;
                    }
                    get flags() {
                      return this.shared.flags;
                    }
                    set flags(e) {
                      this.shared.flags = e;
                    }
                    get position() {
                      return this.shared.position;
                    }
                    set position(e) {
                      this.shared.position = e;
                    }
                  },
                  FSNode: class {
                    node_ops = {};
                    stream_ops = {};
                    readMode = 365;
                    writeMode = 146;
                    mounted = null;
                    constructor(e, t, r, i) {
                      e || (e = this),
                        (this.parent = e),
                        (this.mount = e.mount),
                        (this.id = me.nextInode++),
                        (this.name = t),
                        (this.mode = r),
                        (this.rdev = i),
                        (this.atime = this.mtime = this.ctime = Date.now());
                    }
                    get read() {
                      return (this.mode & this.readMode) === this.readMode;
                    }
                    set read(e) {
                      e
                        ? (this.mode |= this.readMode)
                        : (this.mode &= ~this.readMode);
                    }
                    get write() {
                      return (this.mode & this.writeMode) === this.writeMode;
                    }
                    set write(e) {
                      e
                        ? (this.mode |= this.writeMode)
                        : (this.mode &= ~this.writeMode);
                    }
                    get isFolder() {
                      return me.isDir(this.mode);
                    }
                    get isDevice() {
                      return me.isChrdev(this.mode);
                    }
                  },
                  lookupPath(e, t = {}) {
                    if (!e) return { path: "", node: null };
                    (t.follow_mount ??= !0),
                      J.isAbs(e) || (e = me.cwd() + "/" + e);
                    e: for (var r = 0; r < 40; r++) {
                      for (
                        var i = e.split("/").filter((e) => !!e && "." !== e),
                          o = me.root,
                          a = "/",
                          s = 0;
                        s < i.length;
                        s++
                      ) {
                        var n = s === i.length - 1;
                        if (n && t.parent) break;
                        if (".." !== i[s]) {
                          a = J.join2(a, i[s]);
                          try {
                            o = me.lookupNode(o, i[s]);
                          } catch (e) {
                            if (44 === e?.errno && n && t.noent_okay)
                              return { path: a };
                            throw e;
                          }
                          if (
                            (!me.isMountpoint(o) ||
                              (n && !t.follow_mount) ||
                              (o = o.mounted.root),
                            me.isLink(o.mode) && (!n || t.follow))
                          ) {
                            if (!o.node_ops.readlink)
                              throw new me.ErrnoError(52);
                            var l = o.node_ops.readlink(o);
                            J.isAbs(l) || (l = J.dirname(a) + "/" + l),
                              (e = l + "/" + i.slice(s + 1).join("/"));
                            continue e;
                          }
                        } else (a = J.dirname(a)), (o = o.parent);
                      }
                      return { path: a, node: o };
                    }
                    throw new me.ErrnoError(32);
                  },
                  getPath(e) {
                    for (var t; ; ) {
                      if (me.isRoot(e)) {
                        var r = e.mount.mountpoint;
                        return t
                          ? "/" !== r[r.length - 1]
                            ? `${r}/${t}`
                            : r + t
                          : r;
                      }
                      (t = t ? `${e.name}/${t}` : e.name), (e = e.parent);
                    }
                  },
                  hashName(e, t) {
                    for (var r = 0, i = 0; i < t.length; i++)
                      r = ((r << 5) - r + t.charCodeAt(i)) | 0;
                    return ((e + r) >>> 0) % me.nameTable.length;
                  },
                  hashAddNode(e) {
                    var t = me.hashName(e.parent.id, e.name);
                    (e.name_next = me.nameTable[t]), (me.nameTable[t] = e);
                  },
                  hashRemoveNode(e) {
                    var t = me.hashName(e.parent.id, e.name);
                    if (me.nameTable[t] === e) me.nameTable[t] = e.name_next;
                    else
                      for (var r = me.nameTable[t]; r; ) {
                        if (r.name_next === e) {
                          r.name_next = e.name_next;
                          break;
                        }
                        r = r.name_next;
                      }
                  },
                  lookupNode(e, t) {
                    var r = me.mayLookup(e);
                    if (r) throw new me.ErrnoError(r);
                    for (
                      var i = me.hashName(e.id, t), o = me.nameTable[i];
                      o;
                      o = o.name_next
                    ) {
                      var a = o.name;
                      if (o.parent.id === e.id && a === t) return o;
                    }
                    return me.lookup(e, t);
                  },
                  createNode(e, t, r, i) {
                    var o = new me.FSNode(e, t, r, i);
                    return me.hashAddNode(o), o;
                  },
                  destroyNode(e) {
                    me.hashRemoveNode(e);
                  },
                  isRoot: (e) => e === e.parent,
                  isMountpoint: (e) => !!e.mounted,
                  isFile: (e) => 32768 == (61440 & e),
                  isDir: (e) => 16384 == (61440 & e),
                  isLink: (e) => 40960 == (61440 & e),
                  isChrdev: (e) => 8192 == (61440 & e),
                  isBlkdev: (e) => 24576 == (61440 & e),
                  isFIFO: (e) => 4096 == (61440 & e),
                  isSocket: (e) => 49152 == (49152 & e),
                  flagsToPermissionString(e) {
                    var t = ["r", "w", "rw"][3 & e];
                    return 512 & e && (t += "w"), t;
                  },
                  nodePermissions: (e, t) =>
                    me.ignorePermissions ||
                    ((!t.includes("r") || 292 & e.mode) &&
                      (!t.includes("w") || 146 & e.mode) &&
                      (!t.includes("x") || 73 & e.mode))
                      ? 0
                      : 2,
                  mayLookup: (e) =>
                    me.isDir(e.mode)
                      ? me.nodePermissions(e, "x") ||
                        (e.node_ops.lookup ? 0 : 2)
                      : 54,
                  mayCreate(e, t) {
                    if (!me.isDir(e.mode)) return 54;
                    try {
                      return me.lookupNode(e, t), 20;
                    } catch (e) {}
                    return me.nodePermissions(e, "wx");
                  },
                  mayDelete(e, t, r) {
                    var i;
                    try {
                      i = me.lookupNode(e, t);
                    } catch (e) {
                      return e.errno;
                    }
                    var o = me.nodePermissions(e, "wx");
                    if (o) return o;
                    if (r) {
                      if (!me.isDir(i.mode)) return 54;
                      if (me.isRoot(i) || me.getPath(i) === me.cwd()) return 10;
                    } else if (me.isDir(i.mode)) return 31;
                    return 0;
                  },
                  mayOpen: (e, t) =>
                    e
                      ? me.isLink(e.mode)
                        ? 32
                        : me.isDir(e.mode) &&
                          ("r" !== me.flagsToPermissionString(t) || 512 & t)
                        ? 31
                        : me.nodePermissions(e, me.flagsToPermissionString(t))
                      : 44,
                  MAX_OPEN_FDS: 4096,
                  nextfd() {
                    for (var e = 0; e <= me.MAX_OPEN_FDS; e++)
                      if (!me.streams[e]) return e;
                    throw new me.ErrnoError(33);
                  },
                  getStreamChecked(e) {
                    var t = me.getStream(e);
                    if (!t) throw new me.ErrnoError(8);
                    return t;
                  },
                  getStream: (e) => me.streams[e],
                  createStream: (e, t = -1) => (
                    (e = Object.assign(new me.FSStream(), e)),
                    -1 == t && (t = me.nextfd()),
                    (e.fd = t),
                    (me.streams[t] = e),
                    e
                  ),
                  closeStream(e) {
                    me.streams[e] = null;
                  },
                  dupStream(e, t = -1) {
                    var r = me.createStream(e, t);
                    return r.stream_ops?.dup?.(r), r;
                  },
                  chrdev_stream_ops: {
                    open(e) {
                      var t = me.getDevice(e.node.rdev);
                      (e.stream_ops = t.stream_ops), e.stream_ops.open?.(e);
                    },
                    llseek() {
                      throw new me.ErrnoError(70);
                    },
                  },
                  major: (e) => e >> 8,
                  minor: (e) => 255 & e,
                  makedev: (e, t) => (e << 8) | t,
                  registerDevice(e, t) {
                    me.devices[e] = { stream_ops: t };
                  },
                  getDevice: (e) => me.devices[e],
                  getMounts(e) {
                    for (var t = [], r = [e]; r.length; ) {
                      var i = r.pop();
                      t.push(i), r.push(...i.mounts);
                    }
                    return t;
                  },
                  syncfs(e, t) {
                    "function" == typeof e && ((t = e), (e = !1)),
                      me.syncFSRequests++,
                      me.syncFSRequests > 1 &&
                        g(
                          `warning: ${me.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
                        );
                    var r = me.getMounts(me.root.mount),
                      i = 0;
                    function o(e) {
                      return me.syncFSRequests--, t(e);
                    }
                    function a(e) {
                      if (e)
                        return a.errored ? void 0 : ((a.errored = !0), o(e));
                      ++i >= r.length && o(null);
                    }
                    r.forEach((t) => {
                      if (!t.type.syncfs) return a(null);
                      t.type.syncfs(t, e, a);
                    });
                  },
                  mount(e, t, r) {
                    var i,
                      o = "/" === r,
                      a = !r;
                    if (o && me.root) throw new me.ErrnoError(10);
                    if (!o && !a) {
                      var s = me.lookupPath(r, { follow_mount: !1 });
                      if (((r = s.path), (i = s.node), me.isMountpoint(i)))
                        throw new me.ErrnoError(10);
                      if (!me.isDir(i.mode)) throw new me.ErrnoError(54);
                    }
                    var n = { type: e, opts: t, mountpoint: r, mounts: [] },
                      l = e.mount(n);
                    return (
                      (l.mount = n),
                      (n.root = l),
                      o
                        ? (me.root = l)
                        : i &&
                          ((i.mounted = n), i.mount && i.mount.mounts.push(n)),
                      l
                    );
                  },
                  unmount(e) {
                    var t = me.lookupPath(e, { follow_mount: !1 });
                    if (!me.isMountpoint(t.node)) throw new me.ErrnoError(28);
                    var r = t.node,
                      i = r.mounted,
                      o = me.getMounts(i);
                    Object.keys(me.nameTable).forEach((e) => {
                      for (var t = me.nameTable[e]; t; ) {
                        var r = t.name_next;
                        o.includes(t.mount) && me.destroyNode(t), (t = r);
                      }
                    }),
                      (r.mounted = null);
                    var a = r.mount.mounts.indexOf(i);
                    r.mount.mounts.splice(a, 1);
                  },
                  lookup: (e, t) => e.node_ops.lookup(e, t),
                  mknod(e, t, r) {
                    var i = me.lookupPath(e, { parent: !0 }).node,
                      o = J.basename(e);
                    if (!o || "." === o || ".." === o)
                      throw new me.ErrnoError(28);
                    var a = me.mayCreate(i, o);
                    if (a) throw new me.ErrnoError(a);
                    if (!i.node_ops.mknod) throw new me.ErrnoError(63);
                    return i.node_ops.mknod(i, o, t, r);
                  },
                  statfs(e) {
                    var t = {
                        bsize: 4096,
                        frsize: 4096,
                        blocks: 1e6,
                        bfree: 5e5,
                        bavail: 5e5,
                        files: me.nextInode,
                        ffree: me.nextInode - 1,
                        fsid: 42,
                        flags: 2,
                        namelen: 255,
                      },
                      r = me.lookupPath(e, { follow: !0 }).node;
                    return (
                      r?.node_ops.statfs &&
                        Object.assign(t, r.node_ops.statfs(r.mount.opts.root)),
                      t
                    );
                  },
                  create: (e, t = 438) => (
                    (t &= 4095), (t |= 32768), me.mknod(e, t, 0)
                  ),
                  mkdir: (e, t = 511) => (
                    (t &= 1023), (t |= 16384), me.mknod(e, t, 0)
                  ),
                  mkdirTree(e, t) {
                    for (var r = e.split("/"), i = "", o = 0; o < r.length; ++o)
                      if (r[o]) {
                        i += "/" + r[o];
                        try {
                          me.mkdir(i, t);
                        } catch (e) {
                          if (20 != e.errno) throw e;
                        }
                      }
                  },
                  mkdev: (e, t, r) => (
                    void 0 === r && ((r = t), (t = 438)),
                    (t |= 8192),
                    me.mknod(e, t, r)
                  ),
                  symlink(e, t) {
                    if (!ee.resolve(e)) throw new me.ErrnoError(44);
                    var r = me.lookupPath(t, { parent: !0 }).node;
                    if (!r) throw new me.ErrnoError(44);
                    var i = J.basename(t),
                      o = me.mayCreate(r, i);
                    if (o) throw new me.ErrnoError(o);
                    if (!r.node_ops.symlink) throw new me.ErrnoError(63);
                    return r.node_ops.symlink(r, i, e);
                  },
                  rename(e, t) {
                    var r,
                      i,
                      o = J.dirname(e),
                      a = J.dirname(t),
                      s = J.basename(e),
                      n = J.basename(t);
                    if (
                      ((r = me.lookupPath(e, { parent: !0 }).node),
                      (i = me.lookupPath(t, { parent: !0 }).node),
                      !r || !i)
                    )
                      throw new me.ErrnoError(44);
                    if (r.mount !== i.mount) throw new me.ErrnoError(75);
                    var l,
                      d = me.lookupNode(r, s),
                      h = ee.relative(e, a);
                    if ("." !== h.charAt(0)) throw new me.ErrnoError(28);
                    if ("." !== (h = ee.relative(t, o)).charAt(0))
                      throw new me.ErrnoError(55);
                    try {
                      l = me.lookupNode(i, n);
                    } catch (e) {}
                    if (d !== l) {
                      var u = me.isDir(d.mode),
                        c = me.mayDelete(r, s, u);
                      if (c) throw new me.ErrnoError(c);
                      if ((c = l ? me.mayDelete(i, n, u) : me.mayCreate(i, n)))
                        throw new me.ErrnoError(c);
                      if (!r.node_ops.rename) throw new me.ErrnoError(63);
                      if (me.isMountpoint(d) || (l && me.isMountpoint(l)))
                        throw new me.ErrnoError(10);
                      if (i !== r && (c = me.nodePermissions(r, "w")))
                        throw new me.ErrnoError(c);
                      me.hashRemoveNode(d);
                      try {
                        r.node_ops.rename(d, i, n), (d.parent = i);
                      } catch (e) {
                        throw e;
                      } finally {
                        me.hashAddNode(d);
                      }
                    }
                  },
                  rmdir(e) {
                    var t = me.lookupPath(e, { parent: !0 }).node,
                      r = J.basename(e),
                      i = me.lookupNode(t, r),
                      o = me.mayDelete(t, r, !0);
                    if (o) throw new me.ErrnoError(o);
                    if (!t.node_ops.rmdir) throw new me.ErrnoError(63);
                    if (me.isMountpoint(i)) throw new me.ErrnoError(10);
                    t.node_ops.rmdir(t, r), me.destroyNode(i);
                  },
                  readdir(e) {
                    var t = me.lookupPath(e, { follow: !0 }).node;
                    if (!t.node_ops.readdir) throw new me.ErrnoError(54);
                    return t.node_ops.readdir(t);
                  },
                  unlink(e) {
                    var t = me.lookupPath(e, { parent: !0 }).node;
                    if (!t) throw new me.ErrnoError(44);
                    var r = J.basename(e),
                      i = me.lookupNode(t, r),
                      o = me.mayDelete(t, r, !1);
                    if (o) throw new me.ErrnoError(o);
                    if (!t.node_ops.unlink) throw new me.ErrnoError(63);
                    if (me.isMountpoint(i)) throw new me.ErrnoError(10);
                    t.node_ops.unlink(t, r), me.destroyNode(i);
                  },
                  readlink(e) {
                    var t = me.lookupPath(e).node;
                    if (!t) throw new me.ErrnoError(44);
                    if (!t.node_ops.readlink) throw new me.ErrnoError(28);
                    return t.node_ops.readlink(t);
                  },
                  stat(e, t) {
                    var r = me.lookupPath(e, { follow: !t }).node;
                    if (!r) throw new me.ErrnoError(44);
                    if (!r.node_ops.getattr) throw new me.ErrnoError(63);
                    return r.node_ops.getattr(r);
                  },
                  lstat: (e) => me.stat(e, !0),
                  chmod(e, t, r) {
                    var i;
                    if (
                      !(i =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !r }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    i.node_ops.setattr(i, {
                      mode: (4095 & t) | (-4096 & i.mode),
                      ctime: Date.now(),
                    });
                  },
                  lchmod(e, t) {
                    me.chmod(e, t, !0);
                  },
                  fchmod(e, t) {
                    var r = me.getStreamChecked(e);
                    me.chmod(r.node, t);
                  },
                  chown(e, t, r, i) {
                    var o;
                    if (
                      !(o =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !i }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    o.node_ops.setattr(o, { timestamp: Date.now() });
                  },
                  lchown(e, t, r) {
                    me.chown(e, t, r, !0);
                  },
                  fchown(e, t, r) {
                    var i = me.getStreamChecked(e);
                    me.chown(i.node, t, r);
                  },
                  truncate(e, t) {
                    if (t < 0) throw new me.ErrnoError(28);
                    var r;
                    if (
                      !(r =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !0 }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    if (me.isDir(r.mode)) throw new me.ErrnoError(31);
                    if (!me.isFile(r.mode)) throw new me.ErrnoError(28);
                    var i = me.nodePermissions(r, "w");
                    if (i) throw new me.ErrnoError(i);
                    r.node_ops.setattr(r, { size: t, timestamp: Date.now() });
                  },
                  ftruncate(e, t) {
                    var r = me.getStreamChecked(e);
                    if (0 == (2097155 & r.flags)) throw new me.ErrnoError(28);
                    me.truncate(r.node, t);
                  },
                  utime(e, t, r) {
                    var i = me.lookupPath(e, { follow: !0 }).node;
                    i.node_ops.setattr(i, { atime: t, mtime: r });
                  },
                  open(e, t, r = 438) {
                    if ("" === e) throw new me.ErrnoError(44);
                    var i;
                    if (
                      ((r =
                        64 &
                        (t =
                          "string" == typeof t
                            ? ((e) => {
                                var t = {
                                  r: 0,
                                  "r+": 2,
                                  w: 577,
                                  "w+": 578,
                                  a: 1089,
                                  "a+": 1090,
                                }[e];
                                if (void 0 === t)
                                  throw new Error(
                                    `Unknown file open mode: ${e}`
                                  );
                                return t;
                              })(t)
                            : t)
                          ? (4095 & r) | 32768
                          : 0),
                      "object" == typeof e)
                    )
                      i = e;
                    else {
                      var o = me.lookupPath(e, {
                        follow: !(131072 & t),
                        noent_okay: !0,
                      });
                      (i = o.node), (e = o.path);
                    }
                    var a = !1;
                    if (64 & t)
                      if (i) {
                        if (128 & t) throw new me.ErrnoError(20);
                      } else (i = me.mknod(e, r, 0)), (a = !0);
                    if (!i) throw new me.ErrnoError(44);
                    if (
                      (me.isChrdev(i.mode) && (t &= -513),
                      65536 & t && !me.isDir(i.mode))
                    )
                      throw new me.ErrnoError(54);
                    if (!a) {
                      var n = me.mayOpen(i, t);
                      if (n) throw new me.ErrnoError(n);
                    }
                    512 & t && !a && me.truncate(i, 0), (t &= -131713);
                    var l = me.createStream({
                      node: i,
                      path: me.getPath(i),
                      flags: t,
                      seekable: !0,
                      position: 0,
                      stream_ops: i.stream_ops,
                      ungotten: [],
                      error: !1,
                    });
                    return (
                      l.stream_ops.open && l.stream_ops.open(l),
                      !s.logReadFiles ||
                        1 & t ||
                        e in me.readFiles ||
                        (me.readFiles[e] = 1),
                      l
                    );
                  },
                  close(e) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    e.getdents && (e.getdents = null);
                    try {
                      e.stream_ops.close && e.stream_ops.close(e);
                    } catch (e) {
                      throw e;
                    } finally {
                      me.closeStream(e.fd);
                    }
                    e.fd = null;
                  },
                  isClosed: (e) => null === e.fd,
                  llseek(e, t, r) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (!e.seekable || !e.stream_ops.llseek)
                      throw new me.ErrnoError(70);
                    if (0 != r && 1 != r && 2 != r) throw new me.ErrnoError(28);
                    return (
                      (e.position = e.stream_ops.llseek(e, t, r)),
                      (e.ungotten = []),
                      e.position
                    );
                  },
                  read(e, t, r, i, o) {
                    if (i < 0 || o < 0) throw new me.ErrnoError(28);
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (1 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (me.isDir(e.node.mode)) throw new me.ErrnoError(31);
                    if (!e.stream_ops.read) throw new me.ErrnoError(28);
                    var a = void 0 !== o;
                    if (a) {
                      if (!e.seekable) throw new me.ErrnoError(70);
                    } else o = e.position;
                    var s = e.stream_ops.read(e, t, r, i, o);
                    return a || (e.position += s), s;
                  },
                  write(e, t, r, i, o, a) {
                    if (i < 0 || o < 0) throw new me.ErrnoError(28);
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (0 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (me.isDir(e.node.mode)) throw new me.ErrnoError(31);
                    if (!e.stream_ops.write) throw new me.ErrnoError(28);
                    e.seekable && 1024 & e.flags && me.llseek(e, 0, 2);
                    var s = void 0 !== o;
                    if (s) {
                      if (!e.seekable) throw new me.ErrnoError(70);
                    } else o = e.position;
                    var n = e.stream_ops.write(e, t, r, i, o, a);
                    return s || (e.position += n), n;
                  },
                  allocate(e, t, r) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (t < 0 || r <= 0) throw new me.ErrnoError(28);
                    if (0 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (!me.isFile(e.node.mode) && !me.isDir(e.node.mode))
                      throw new me.ErrnoError(43);
                    if (!e.stream_ops.allocate) throw new me.ErrnoError(138);
                    e.stream_ops.allocate(e, t, r);
                  },
                  mmap(e, t, r, i, o) {
                    if (
                      0 != (2 & i) &&
                      0 == (2 & o) &&
                      2 != (2097155 & e.flags)
                    )
                      throw new me.ErrnoError(2);
                    if (1 == (2097155 & e.flags)) throw new me.ErrnoError(2);
                    if (!e.stream_ops.mmap) throw new me.ErrnoError(43);
                    if (!t) throw new me.ErrnoError(28);
                    return e.stream_ops.mmap(e, t, r, i, o);
                  },
                  msync: (e, t, r, i, o) =>
                    e.stream_ops.msync ? e.stream_ops.msync(e, t, r, i, o) : 0,
                  ioctl(e, t, r) {
                    if (!e.stream_ops.ioctl) throw new me.ErrnoError(59);
                    return e.stream_ops.ioctl(e, t, r);
                  },
                  readFile(e, t = {}) {
                    if (
                      ((t.flags = t.flags || 0),
                      (t.encoding = t.encoding || "binary"),
                      "utf8" !== t.encoding && "binary" !== t.encoding)
                    )
                      throw new Error(`Invalid encoding type "${t.encoding}"`);
                    var r,
                      i = me.open(e, t.flags),
                      o = me.stat(e).size,
                      a = new Uint8Array(o);
                    return (
                      me.read(i, a, 0, o, 0),
                      "utf8" === t.encoding
                        ? (r = re(a))
                        : "binary" === t.encoding && (r = a),
                      me.close(i),
                      r
                    );
                  },
                  writeFile(e, t, r = {}) {
                    r.flags = r.flags || 577;
                    var i = me.open(e, r.flags, r.mode);
                    if ("string" == typeof t) {
                      var o = new Uint8Array(oe(t) + 1),
                        a = ae(t, o, 0, o.length);
                      me.write(i, o, 0, a, void 0, r.canOwn);
                    } else {
                      if (!ArrayBuffer.isView(t))
                        throw new Error("Unsupported data type");
                      me.write(i, t, 0, t.byteLength, void 0, r.canOwn);
                    }
                    me.close(i);
                  },
                  cwd: () => me.currentPath,
                  chdir(e) {
                    var t = me.lookupPath(e, { follow: !0 });
                    if (null === t.node) throw new me.ErrnoError(44);
                    if (!me.isDir(t.node.mode)) throw new me.ErrnoError(54);
                    var r = me.nodePermissions(t.node, "x");
                    if (r) throw new me.ErrnoError(r);
                    me.currentPath = t.path;
                  },
                  createDefaultDirectories() {
                    me.mkdir("/tmp"),
                      me.mkdir("/home"),
                      me.mkdir("/home/web_user");
                  },
                  createDefaultDevices() {
                    me.mkdir("/dev"),
                      me.registerDevice(me.makedev(1, 3), {
                        read: () => 0,
                        write: (e, t, r, i, o) => i,
                        llseek: () => 0,
                      }),
                      me.mkdev("/dev/null", me.makedev(1, 3)),
                      ue.register(me.makedev(5, 0), ue.default_tty_ops),
                      ue.register(me.makedev(6, 0), ue.default_tty1_ops),
                      me.mkdev("/dev/tty", me.makedev(5, 0)),
                      me.mkdev("/dev/tty1", me.makedev(6, 0));
                    var e = new Uint8Array(1024),
                      t = 0,
                      r = () => (0 === t && (t = Q(e).byteLength), e[--t]);
                    me.createDevice("/dev", "random", r),
                      me.createDevice("/dev", "urandom", r),
                      me.mkdir("/dev/shm"),
                      me.mkdir("/dev/shm/tmp");
                  },
                  createSpecialDirectories() {
                    me.mkdir("/proc");
                    var e = me.mkdir("/proc/self");
                    me.mkdir("/proc/self/fd"),
                      me.mount(
                        {
                          mount() {
                            var t = me.createNode(e, "fd", 16895, 73);
                            return (
                              (t.stream_ops = { llseek: pe.stream_ops.llseek }),
                              (t.node_ops = {
                                lookup(e, t) {
                                  var r = +t,
                                    i = me.getStreamChecked(r),
                                    o = {
                                      parent: null,
                                      mount: { mountpoint: "fake" },
                                      node_ops: { readlink: () => i.path },
                                      id: r + 1,
                                    };
                                  return (o.parent = o), o;
                                },
                                readdir: () =>
                                  Array.from(me.streams.entries())
                                    .filter(([e, t]) => t)
                                    .map(([e, t]) => e.toString()),
                              }),
                              t
                            );
                          },
                        },
                        {},
                        "/proc/self/fd"
                      );
                  },
                  createStandardStreams(e, t, r) {
                    e
                      ? me.createDevice("/dev", "stdin", e)
                      : me.symlink("/dev/tty", "/dev/stdin"),
                      t
                        ? me.createDevice("/dev", "stdout", null, t)
                        : me.symlink("/dev/tty", "/dev/stdout"),
                      r
                        ? me.createDevice("/dev", "stderr", null, r)
                        : me.symlink("/dev/tty1", "/dev/stderr"),
                      me.open("/dev/stdin", 0),
                      me.open("/dev/stdout", 1),
                      me.open("/dev/stderr", 1);
                  },
                  staticInit() {
                    (me.nameTable = new Array(4096)),
                      me.mount(pe, {}, "/"),
                      me.createDefaultDirectories(),
                      me.createDefaultDevices(),
                      me.createSpecialDirectories(),
                      (me.filesystems = { MEMFS: pe });
                  },
                  init(e, t, r) {
                    (me.initialized = !0),
                      (e ??= s.stdin),
                      (t ??= s.stdout),
                      (r ??= s.stderr),
                      me.createStandardStreams(e, t, r);
                  },
                  quit() {
                    me.initialized = !1;
                    for (var e = 0; e < me.streams.length; e++) {
                      var t = me.streams[e];
                      t && me.close(t);
                    }
                  },
                  findObject(e, t) {
                    var r = me.analyzePath(e, t);
                    return r.exists ? r.object : null;
                  },
                  analyzePath(e, t) {
                    try {
                      e = (i = me.lookupPath(e, { follow: !t })).path;
                    } catch (e) {}
                    var r = {
                      isRoot: !1,
                      exists: !1,
                      error: 0,
                      name: null,
                      path: null,
                      object: null,
                      parentExists: !1,
                      parentPath: null,
                      parentObject: null,
                    };
                    try {
                      var i = me.lookupPath(e, { parent: !0 });
                      (r.parentExists = !0),
                        (r.parentPath = i.path),
                        (r.parentObject = i.node),
                        (r.name = J.basename(e)),
                        (i = me.lookupPath(e, { follow: !t })),
                        (r.exists = !0),
                        (r.path = i.path),
                        (r.object = i.node),
                        (r.name = i.node.name),
                        (r.isRoot = "/" === i.path);
                    } catch (e) {
                      r.error = e.errno;
                    }
                    return r;
                  },
                  createPath(e, t, r, i) {
                    e = "string" == typeof e ? e : me.getPath(e);
                    for (var o = t.split("/").reverse(); o.length; ) {
                      var a = o.pop();
                      if (a) {
                        var s = J.join2(e, a);
                        try {
                          me.mkdir(s);
                        } catch (e) {}
                        e = s;
                      }
                    }
                    return s;
                  },
                  createFile(e, t, r, i, o) {
                    var a = J.join2(
                        "string" == typeof e ? e : me.getPath(e),
                        t
                      ),
                      s = ve(i, o);
                    return me.create(a, s);
                  },
                  createDataFile(e, t, r, i, o, a) {
                    var s = t;
                    e &&
                      ((e = "string" == typeof e ? e : me.getPath(e)),
                      (s = t ? J.join2(e, t) : e));
                    var n = ve(i, o),
                      l = me.create(s, n);
                    if (r) {
                      if ("string" == typeof r) {
                        for (
                          var d = new Array(r.length), h = 0, u = r.length;
                          h < u;
                          ++h
                        )
                          d[h] = r.charCodeAt(h);
                        r = d;
                      }
                      me.chmod(l, 146 | n);
                      var c = me.open(l, 577);
                      me.write(c, r, 0, r.length, 0, a),
                        me.close(c),
                        me.chmod(l, n);
                    }
                  },
                  createDevice(e, t, r, i) {
                    var o = J.join2(
                        "string" == typeof e ? e : me.getPath(e),
                        t
                      ),
                      a = ve(!!r, !!i);
                    me.createDevice.major ??= 64;
                    var s = me.makedev(me.createDevice.major++, 0);
                    return (
                      me.registerDevice(s, {
                        open(e) {
                          e.seekable = !1;
                        },
                        close(e) {
                          i?.buffer?.length && i(10);
                        },
                        read(e, t, i, o, a) {
                          for (var s = 0, n = 0; n < o; n++) {
                            var l;
                            try {
                              l = r();
                            } catch (e) {
                              throw new me.ErrnoError(29);
                            }
                            if (void 0 === l && 0 === s)
                              throw new me.ErrnoError(6);
                            if (null == l) break;
                            s++, (t[i + n] = l);
                          }
                          return s && (e.node.atime = Date.now()), s;
                        },
                        write(e, t, r, o, a) {
                          for (var s = 0; s < o; s++)
                            try {
                              i(t[r + s]);
                            } catch (e) {
                              throw new me.ErrnoError(29);
                            }
                          return (
                            o && (e.node.mtime = e.node.ctime = Date.now()), s
                          );
                        },
                      }),
                      me.mkdev(o, a, s)
                    );
                  },
                  forceLoadFile(e) {
                    if (e.isDevice || e.isFolder || e.link || e.contents)
                      return !0;
                    if ("undefined" != typeof XMLHttpRequest)
                      throw new Error(
                        "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
                      );
                    try {
                      (e.contents = a(e.url)),
                        (e.usedBytes = e.contents.length);
                    } catch (e) {
                      throw new me.ErrnoError(29);
                    }
                  },
                  createLazyFile(e, t, r, i, o) {
                    if ("undefined" != typeof XMLHttpRequest)
                      throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                    var a = { isDevice: !1, url: r },
                      s = me.createFile(e, t, a, i, o);
                    a.contents
                      ? (s.contents = a.contents)
                      : a.url && ((s.contents = null), (s.url = a.url)),
                      Object.defineProperties(s, {
                        usedBytes: {
                          get: function () {
                            return this.contents.length;
                          },
                        },
                      });
                    var n = {};
                    function l(e, t, r, i, o) {
                      var a = e.node.contents;
                      if (o >= a.length) return 0;
                      var s = Math.min(a.length - o, i);
                      if (a.slice)
                        for (var n = 0; n < s; n++) t[r + n] = a[o + n];
                      else for (n = 0; n < s; n++) t[r + n] = a.get(o + n);
                      return s;
                    }
                    return (
                      Object.keys(s.stream_ops).forEach((e) => {
                        var t = s.stream_ops[e];
                        n[e] = (...e) => (me.forceLoadFile(s), t(...e));
                      }),
                      (n.read = (e, t, r, i, o) => (
                        me.forceLoadFile(s), l(e, t, r, i, o)
                      )),
                      (n.mmap = (e, t, r, i, o) => {
                        me.forceLoadFile(s);
                        var a = ce();
                        if (!a) throw new me.ErrnoError(48);
                        return l(e, v, a, t, r), { ptr: a, allocated: !0 };
                      }),
                      (s.stream_ops = n),
                      s
                    );
                  },
                },
                Se = (e, t) => (e ? re(m, e, t) : ""),
                Pe = {
                  DEFAULT_POLLMASK: 5,
                  calculateAt(e, t, r) {
                    if (J.isAbs(t)) return t;
                    var i;
                    if (
                      ((i = -100 === e ? me.cwd() : Pe.getStreamFromFD(e).path),
                      0 == t.length)
                    ) {
                      if (!r) throw new me.ErrnoError(44);
                      return i;
                    }
                    return i + "/" + t;
                  },
                  doStat(e, t, r) {
                    var i = e(t);
                    (C[r >> 2] = i.dev),
                      (C[(r + 4) >> 2] = i.mode),
                      (b[(r + 8) >> 2] = i.nlink),
                      (C[(r + 12) >> 2] = i.uid),
                      (C[(r + 16) >> 2] = i.gid),
                      (C[(r + 20) >> 2] = i.rdev),
                      (F = [
                        i.size >>> 0,
                        ((B = i.size),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 24) >> 2] = F[0]),
                      (C[(r + 28) >> 2] = F[1]),
                      (C[(r + 32) >> 2] = 4096),
                      (C[(r + 36) >> 2] = i.blocks);
                    var o = i.atime.getTime(),
                      a = i.mtime.getTime(),
                      s = i.ctime.getTime();
                    return (
                      (F = [
                        Math.floor(o / 1e3) >>> 0,
                        ((B = Math.floor(o / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 40) >> 2] = F[0]),
                      (C[(r + 44) >> 2] = F[1]),
                      (b[(r + 48) >> 2] = (o % 1e3) * 1e3 * 1e3),
                      (F = [
                        Math.floor(a / 1e3) >>> 0,
                        ((B = Math.floor(a / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 56) >> 2] = F[0]),
                      (C[(r + 60) >> 2] = F[1]),
                      (b[(r + 64) >> 2] = (a % 1e3) * 1e3 * 1e3),
                      (F = [
                        Math.floor(s / 1e3) >>> 0,
                        ((B = Math.floor(s / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 72) >> 2] = F[0]),
                      (C[(r + 76) >> 2] = F[1]),
                      (b[(r + 80) >> 2] = (s % 1e3) * 1e3 * 1e3),
                      (F = [
                        i.ino >>> 0,
                        ((B = i.ino),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 88) >> 2] = F[0]),
                      (C[(r + 92) >> 2] = F[1]),
                      0
                    );
                  },
                  doMsync(e, t, r, i, o) {
                    if (!me.isFile(t.node.mode)) throw new me.ErrnoError(43);
                    if (2 & i) return 0;
                    var a = m.slice(e, e + r);
                    me.msync(t, a, o, r, i);
                  },
                  getStreamFromFD: (e) => me.getStreamChecked(e),
                  varargs: void 0,
                  getStr: (e) => Se(e),
                },
                Ce = (e, t) => Object.defineProperty(t, "name", { value: e }),
                be = [],
                xe = [],
                Ae = (e) => {
                  throw new ne(e);
                },
                Te = {
                  toValue: (e) => (
                    e || Ae("Cannot use deleted val. handle = " + e), xe[e]
                  ),
                  toHandle: (e) => {
                    switch (e) {
                      case void 0:
                        return 2;
                      case null:
                        return 4;
                      case !0:
                        return 6;
                      case !1:
                        return 8;
                      default: {
                        const t = be.pop() || xe.length;
                        return (xe[t] = e), (xe[t + 1] = 1), t;
                      }
                    }
                  },
                },
                Ee = (e, t) => {
                  var r = Ce(t, function (e) {
                    (this.name = t), (this.message = e);
                    var r = new Error(e).stack;
                    void 0 !== r &&
                      (this.stack =
                        this.toString() +
                        "\n" +
                        r.replace(/^Error(:[^\n]*)?\n/, ""));
                  });
                  return (
                    (r.prototype = Object.create(e.prototype)),
                    (r.prototype.constructor = r),
                    (r.prototype.toString = function () {
                      return void 0 === this.message
                        ? this.name
                        : `${this.name}: ${this.message}`;
                    }),
                    r
                  );
                },
                Re = (e) => {
                  for (var t = "", r = e; m[r]; ) t += de[m[r++]];
                  return t;
                },
                De = {},
                we = (e, t) => {
                  for (
                    void 0 === t && Ae("ptr should not be undefined");
                    e.baseClass;

                  )
                    (t = e.upcast(t)), (e = e.baseClass);
                  return t;
                },
                Me = {},
                Le = (e) => {
                  var t = Ls(e),
                    r = Re(t);
                  return Is(t), r;
                },
                Oe = (e, t) => {
                  var r = Me[e];
                  return (
                    void 0 === r && Ae(`${t} has unknown type ${Le(e)}`), r
                  );
                },
                Ie = (e) => {},
                ke = !1,
                _e = (e) => {
                  (e.count.value -= 1),
                    0 === e.count.value &&
                      ((e) => {
                        e.smartPtr
                          ? e.smartPtrType.rawDestructor(e.smartPtr)
                          : e.ptrType.registeredClass.rawDestructor(e.ptr);
                      })(e);
                },
                Ve = (e, t, r) => {
                  if (t === r) return e;
                  if (void 0 === r.baseClass) return null;
                  var i = Ve(e, t, r.baseClass);
                  return null === i ? null : r.downcast(i);
                },
                Ne = {},
                Be = (e, t) => ((t = we(e, t)), De[t]),
                Fe = (e) => {
                  throw new he(e);
                },
                He = (e, t) => (
                  (t.ptrType && t.ptr) ||
                    Fe("makeClassHandle requires ptr and ptrType"),
                  !!t.smartPtrType != !!t.smartPtr &&
                    Fe("Both smartPtrType and smartPtr must be specified"),
                  (t.count = { value: 1 }),
                  Ye(Object.create(e, { $$: { value: t, writable: !0 } }))
                );
              var Ye = (e) =>
                  "undefined" == typeof FinalizationRegistry
                    ? ((Ye = (e) => e), e)
                    : ((ke = new FinalizationRegistry((e) => {
                        _e(e.$$);
                      })),
                      (Ye = (e) => {
                        var t = e.$$;
                        if (t.smartPtr) {
                          var r = { $$: t };
                          ke.register(e, r, e);
                        }
                        return e;
                      }),
                      (Ie = (e) => ke.unregister(e)),
                      Ye(e)),
                ze = {},
                je = {},
                Xe = (e, t, r) => {
                  function i(t) {
                    var i = r(t);
                    i.length !== e.length &&
                      Fe("Mismatched type converter count");
                    for (var o = 0; o < e.length; ++o) Ge(e[o], i[o]);
                  }
                  e.forEach((e) => (je[e] = t));
                  var o = new Array(t.length),
                    a = [],
                    s = 0;
                  t.forEach((e, t) => {
                    Me.hasOwnProperty(e)
                      ? (o[t] = Me[e])
                      : (a.push(e),
                        ze.hasOwnProperty(e) || (ze[e] = []),
                        ze[e].push(() => {
                          (o[t] = Me[e]), ++s === a.length && i(o);
                        }));
                  }),
                    0 === a.length && i(o);
                };
              function Ge(e, t, r = {}) {
                return (function (e, t, r = {}) {
                  var i = t.name;
                  if (
                    (e ||
                      Ae(
                        `type "${i}" must have a positive integer typeid pointer`
                      ),
                    Me.hasOwnProperty(e))
                  ) {
                    if (r.ignoreDuplicateRegistrations) return;
                    Ae(`Cannot register type '${i}' twice`);
                  }
                  if (((Me[e] = t), delete je[e], ze.hasOwnProperty(e))) {
                    var o = ze[e];
                    delete ze[e], o.forEach((e) => e());
                  }
                })(e, t, r);
              }
              var We = (e) => {
                  Ae(
                    e.$$.ptrType.registeredClass.name +
                      " instance already deleted"
                  );
                },
                Ue = [];
              function $e() {}
              var Ze = (e, t, r) => {
                  if (void 0 === e[t].overloadTable) {
                    var i = e[t];
                    (e[t] = function (...i) {
                      return (
                        e[t].overloadTable.hasOwnProperty(i.length) ||
                          Ae(
                            `Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`
                          ),
                        e[t].overloadTable[i.length].apply(this, i)
                      );
                    }),
                      (e[t].overloadTable = []),
                      (e[t].overloadTable[i.argCount] = i);
                  }
                },
                qe = (e, t, r) => {
                  s.hasOwnProperty(e)
                    ? ((void 0 === r ||
                        (void 0 !== s[e].overloadTable &&
                          void 0 !== s[e].overloadTable[r])) &&
                        Ae(`Cannot register public name '${e}' twice`),
                      Ze(s, e, e),
                      s[e].overloadTable.hasOwnProperty(r) &&
                        Ae(
                          `Cannot register multiple overloads of a function with the same number of arguments (${r})!`
                        ),
                      (s[e].overloadTable[r] = t))
                    : ((s[e] = t), (s[e].argCount = r));
                };
              function Ke(e, t, r, i, o, a, s, n) {
                (this.name = e),
                  (this.constructor = t),
                  (this.instancePrototype = r),
                  (this.rawDestructor = i),
                  (this.baseClass = o),
                  (this.getActualType = a),
                  (this.upcast = s),
                  (this.downcast = n),
                  (this.pureVirtualFunctions = []);
              }
              var Je = (e, t, r) => {
                for (; t !== r; )
                  t.upcast ||
                    Ae(
                      `Expected null or instance of ${r.name}, got an instance of ${t.name}`
                    ),
                    (e = t.upcast(e)),
                    (t = t.baseClass);
                return e;
              };
              function Qe(e, t) {
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    0
                  );
                t.$$ || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    );
                var r = t.$$.ptrType.registeredClass;
                return Je(t.$$.ptr, r, this.registeredClass);
              }
              function et(e, t) {
                var r;
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    this.isSmartPointer
                      ? ((r = this.rawConstructor()),
                        null !== e && e.push(this.rawDestructor, r),
                        r)
                      : 0
                  );
                (t && t.$$) || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    ),
                  !this.isConst &&
                    t.$$.ptrType.isConst &&
                    Ae(
                      `Cannot convert argument of type ${
                        t.$$.smartPtrType
                          ? t.$$.smartPtrType.name
                          : t.$$.ptrType.name
                      } to parameter type ${this.name}`
                    );
                var i = t.$$.ptrType.registeredClass;
                if (
                  ((r = Je(t.$$.ptr, i, this.registeredClass)),
                  this.isSmartPointer)
                )
                  switch (
                    (void 0 === t.$$.smartPtr &&
                      Ae("Passing raw pointer to smart pointer is illegal"),
                    this.sharingPolicy)
                  ) {
                    case 0:
                      t.$$.smartPtrType === this
                        ? (r = t.$$.smartPtr)
                        : Ae(
                            `Cannot convert argument of type ${
                              t.$$.smartPtrType
                                ? t.$$.smartPtrType.name
                                : t.$$.ptrType.name
                            } to parameter type ${this.name}`
                          );
                      break;
                    case 1:
                      r = t.$$.smartPtr;
                      break;
                    case 2:
                      if (t.$$.smartPtrType === this) r = t.$$.smartPtr;
                      else {
                        var o = t.clone();
                        (r = this.rawShare(
                          r,
                          Te.toHandle(() => o.delete())
                        )),
                          null !== e && e.push(this.rawDestructor, r);
                      }
                      break;
                    default:
                      Ae("Unsupporting sharing policy");
                  }
                return r;
              }
              function tt(e, t) {
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    0
                  );
                t.$$ || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    ),
                  t.$$.ptrType.isConst &&
                    Ae(
                      `Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`
                    );
                var r = t.$$.ptrType.registeredClass;
                return Je(t.$$.ptr, r, this.registeredClass);
              }
              function rt(e) {
                return this.fromWireType(b[e >> 2]);
              }
              function it(e, t, r, i, o, a, s, n, l, d, h) {
                (this.name = e),
                  (this.registeredClass = t),
                  (this.isReference = r),
                  (this.isConst = i),
                  (this.isSmartPointer = o),
                  (this.pointeeType = a),
                  (this.sharingPolicy = s),
                  (this.rawGetPointee = n),
                  (this.rawConstructor = l),
                  (this.rawShare = d),
                  (this.rawDestructor = h),
                  o || void 0 !== t.baseClass
                    ? (this.toWireType = et)
                    : i
                    ? ((this.toWireType = Qe), (this.destructorFunction = null))
                    : ((this.toWireType = tt),
                      (this.destructorFunction = null));
              }
              var ot,
                at,
                st = (e, t, r) => {
                  s.hasOwnProperty(e) ||
                    Fe("Replacing nonexistent public symbol"),
                    void 0 !== s[e].overloadTable && void 0 !== r
                      ? (s[e].overloadTable[r] = t)
                      : ((s[e] = t), (s[e].argCount = r));
                },
                nt = (e) => ot.get(e),
                lt = (e, t, r = []) =>
                  e.includes("j")
                    ? ((e, t, r) => (
                        (e = e.replace(/p/g, "i")),
                        (0, s["dynCall_" + e])(t, ...r)
                      ))(e, t, r)
                    : nt(t)(...r),
                dt = (e, t) => {
                  var r,
                    i,
                    o = (e = Re(e)).includes("j")
                      ? ((r = e), (i = t), (...e) => lt(r, i, e))
                      : nt(t);
                  return (
                    "function" != typeof o &&
                      Ae(`unknown function pointer with signature ${e}: ${t}`),
                    o
                  );
                },
                ht = (e, t) => {
                  var r = [],
                    i = {};
                  throw (
                    (t.forEach(function e(t) {
                      i[t] ||
                        Me[t] ||
                        (je[t] ? je[t].forEach(e) : (r.push(t), (i[t] = !0)));
                    }),
                    new at(`${e}: ` + r.map(Le).join([", "])))
                  );
                },
                ut = (e) => {
                  for (; e.length; ) {
                    var t = e.pop();
                    e.pop()(t);
                  }
                };
              function ct(e, t, r, i, o, a) {
                var s = t.length;
                s < 2 &&
                  Ae(
                    "argTypes array size mismatch! Must at least get return value and 'this' types!"
                  );
                var n = null !== t[1] && null !== r,
                  l = (function (e) {
                    for (var t = 1; t < e.length; ++t)
                      if (null !== e[t] && void 0 === e[t].destructorFunction)
                        return !0;
                    return !1;
                  })(t),
                  d = "void" !== t[0].name,
                  h = s - 2,
                  u = new Array(h),
                  c = [],
                  p = [];
                return Ce(e, function (...e) {
                  var r;
                  (p.length = 0),
                    (c.length = n ? 2 : 1),
                    (c[0] = o),
                    n && ((r = t[1].toWireType(p, this)), (c[1] = r));
                  for (var a = 0; a < h; ++a)
                    (u[a] = t[a + 2].toWireType(p, e[a])), c.push(u[a]);
                  return (function (e) {
                    if (l) ut(p);
                    else
                      for (var i = n ? 1 : 2; i < t.length; i++) {
                        var o = 1 === i ? r : u[i - 2];
                        null !== t[i].destructorFunction &&
                          t[i].destructorFunction(o);
                      }
                    if (d) return t[0].fromWireType(e);
                  })(i(...c));
                });
              }
              var pt,
                gt = (e, t) => {
                  for (var r = [], i = 0; i < e; i++)
                    r.push(b[(t + 4 * i) >> 2]);
                  return r;
                },
                yt = (e) => {
                  const t = (e = e.trim()).indexOf("(");
                  return -1 !== t ? e.substr(0, t) : e;
                },
                ft = (e, t, r) => (
                  e instanceof Object || Ae(`${r} with invalid "this": ${e}`),
                  e instanceof t.registeredClass.constructor ||
                    Ae(
                      `${r} incompatible with "this" of type ${e.constructor.name}`
                    ),
                  e.$$.ptr ||
                    Ae(
                      `cannot call emscripten binding method ${r} on deleted object`
                    ),
                  Je(e.$$.ptr, e.$$.ptrType.registeredClass, t.registeredClass)
                ),
                vt = (e) => {
                  e > 9 && 0 == --xe[e + 1] && ((xe[e] = void 0), be.push(e));
                },
                mt = {
                  name: "emscripten::val",
                  fromWireType: (e) => {
                    var t = Te.toValue(e);
                    return vt(e), t;
                  },
                  toWireType: (e, t) => Te.toHandle(t),
                  argPackAdvance: 8,
                  readValueFromPointer: rt,
                  destructorFunction: null,
                },
                St = (e, t, r) => {
                  switch (t) {
                    case 1:
                      return r
                        ? function (e) {
                            return this.fromWireType(v[e]);
                          }
                        : function (e) {
                            return this.fromWireType(m[e]);
                          };
                    case 2:
                      return r
                        ? function (e) {
                            return this.fromWireType(S[e >> 1]);
                          }
                        : function (e) {
                            return this.fromWireType(P[e >> 1]);
                          };
                    case 4:
                      return r
                        ? function (e) {
                            return this.fromWireType(C[e >> 2]);
                          }
                        : function (e) {
                            return this.fromWireType(b[e >> 2]);
                          };
                    default:
                      throw new TypeError(`invalid integer width (${t}): ${e}`);
                  }
                },
                Pt = (e) => {
                  if (null === e) return "null";
                  var t = typeof e;
                  return "object" === t || "array" === t || "function" === t
                    ? e.toString()
                    : "" + e;
                },
                Ct = (e, t) => {
                  switch (t) {
                    case 4:
                      return function (e) {
                        return this.fromWireType(x[e >> 2]);
                      };
                    case 8:
                      return function (e) {
                        return this.fromWireType(A[e >> 3]);
                      };
                    default:
                      throw new TypeError(`invalid float width (${t}): ${e}`);
                  }
                },
                bt = (e, t, r) => {
                  switch (t) {
                    case 1:
                      return r ? (e) => v[e] : (e) => m[e];
                    case 2:
                      return r ? (e) => S[e >> 1] : (e) => P[e >> 1];
                    case 4:
                      return r ? (e) => C[e >> 2] : (e) => b[e >> 2];
                    default:
                      throw new TypeError(`invalid integer width (${t}): ${e}`);
                  }
                },
                xt = (e, t, r) => ae(e, m, t, r),
                At =
                  "undefined" != typeof TextDecoder
                    ? new TextDecoder("utf-16le")
                    : void 0,
                Tt = (e, t) => {
                  for (
                    var r = e, i = r >> 1, o = i + t / 2;
                    !(i >= o) && P[i];

                  )
                    ++i;
                  if ((r = i << 1) - e > 32 && At)
                    return At.decode(m.subarray(e, r));
                  for (var a = "", s = 0; !(s >= t / 2); ++s) {
                    var n = S[(e + 2 * s) >> 1];
                    if (0 == n) break;
                    a += String.fromCharCode(n);
                  }
                  return a;
                },
                Et = (e, t, r) => {
                  if (((r ??= 2147483647), r < 2)) return 0;
                  for (
                    var i = t,
                      o = (r -= 2) < 2 * e.length ? r / 2 : e.length,
                      a = 0;
                    a < o;
                    ++a
                  ) {
                    var s = e.charCodeAt(a);
                    (S[t >> 1] = s), (t += 2);
                  }
                  return (S[t >> 1] = 0), t - i;
                },
                Rt = (e) => 2 * e.length,
                Dt = (e, t) => {
                  for (var r = 0, i = ""; !(r >= t / 4); ) {
                    var o = C[(e + 4 * r) >> 2];
                    if (0 == o) break;
                    if ((++r, o >= 65536)) {
                      var a = o - 65536;
                      i += String.fromCharCode(
                        55296 | (a >> 10),
                        56320 | (1023 & a)
                      );
                    } else i += String.fromCharCode(o);
                  }
                  return i;
                },
                wt = (e, t, r) => {
                  if (((r ??= 2147483647), r < 4)) return 0;
                  for (var i = t, o = i + r - 4, a = 0; a < e.length; ++a) {
                    var s = e.charCodeAt(a);
                    if (
                      (s >= 55296 &&
                        s <= 57343 &&
                        (s =
                          (65536 + ((1023 & s) << 10)) |
                          (1023 & e.charCodeAt(++a))),
                      (C[t >> 2] = s),
                      (t += 4) + 4 > o)
                    )
                      break;
                  }
                  return (C[t >> 2] = 0), t - i;
                },
                Mt = (e) => {
                  for (var t = 0, r = 0; r < e.length; ++r) {
                    var i = e.charCodeAt(r);
                    i >= 55296 && i <= 57343 && ++r, (t += 4);
                  }
                  return t;
                },
                Lt = {},
                Ot = [],
                It = Reflect.construct,
                kt = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
                _t = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
                Vt = (e, t) =>
                  (t + 2097152) >>> 0 < 4194305 - !!e
                    ? (e >>> 0) + 4294967296 * t
                    : NaN,
                Nt = () => performance.now(),
                Bt = () => Date.now(),
                Ft = (e) => {
                  if (e instanceof j || "unwind" == e) return f;
                  u(0, e);
                },
                Ht = () => G || !1,
                Yt = (e, t) => {
                  var r;
                  (f = e),
                    (f = r = e),
                    Ht() || (s.onExit?.(r), (E = !0)),
                    u(0, new j(r));
                },
                zt = Yt,
                jt = () => {
                  if (!Ht())
                    try {
                      zt(f);
                    } catch (e) {
                      Ft(e);
                    }
                },
                Xt = (e) => {
                  if (!E)
                    try {
                      e(), jt();
                    } catch (e) {
                      Ft(e);
                    }
                },
                Gt = (e, t) =>
                  setTimeout(() => {
                    Xt(e);
                  }, t),
                Wt = {
                  useWebGL: !1,
                  isFullscreen: !1,
                  pointerLock: !1,
                  moduleContextCreatedCallbacks: [],
                  workers: [],
                  preloadedImages: {},
                  preloadedAudios: {},
                  init() {
                    if (!Wt.initted) {
                      Wt.initted = !0;
                      var e = {
                        canHandle: function (e) {
                          return (
                            !s.noImageDecoding &&
                            /\.(jpg|jpeg|png|bmp|webp)$/i.test(e)
                          );
                        },
                        handle: function (e, t, r, i) {
                          var o = new Blob([e], { type: Wt.getMimetype(t) });
                          o.size !== e.length &&
                            (o = new Blob([new Uint8Array(e).buffer], {
                              type: Wt.getMimetype(t),
                            }));
                          var a = URL.createObjectURL(o),
                            s = new Image();
                          (s.onload = () => {
                            var i = document.createElement("canvas");
                            (i.width = s.width),
                              (i.height = s.height),
                              i.getContext("2d").drawImage(s, 0, 0),
                              (Wt.preloadedImages[t] = i),
                              URL.revokeObjectURL(a),
                              r?.(e);
                          }),
                            (s.onerror = (e) => {
                              g(`Image ${a} could not be decoded`), i?.();
                            }),
                            (s.src = a);
                        },
                      };
                      ye.push(e);
                      var t = {
                        canHandle: function (e) {
                          return (
                            !s.noAudioDecoding &&
                            e.substr(-4) in { ".ogg": 1, ".wav": 1, ".mp3": 1 }
                          );
                        },
                        handle: function (e, t, r, i) {
                          var o = !1;
                          function a(i) {
                            o ||
                              ((o = !0), (Wt.preloadedAudios[t] = i), r?.(e));
                          }
                          var s = new Blob([e], { type: Wt.getMimetype(t) }),
                            n = URL.createObjectURL(s),
                            l = new Audio();
                          l.addEventListener("canplaythrough", () => a(l), !1),
                            (l.onerror = function (r) {
                              o ||
                                (g(
                                  `warning: browser could not fully decode audio ${t}, trying slower base64 approach`
                                ),
                                (l.src =
                                  "data:audio/x-" +
                                  t.substr(-3) +
                                  ";base64," +
                                  (function (e) {
                                    for (
                                      var t =
                                          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                                        r = "",
                                        i = 0,
                                        o = 0,
                                        a = 0;
                                      a < e.length;
                                      a++
                                    )
                                      for (
                                        i = (i << 8) | e[a], o += 8;
                                        o >= 6;

                                      ) {
                                        var s = (i >> (o - 6)) & 63;
                                        (o -= 6), (r += t[s]);
                                      }
                                    return (
                                      2 == o
                                        ? ((r += t[(3 & i) << 4]), (r += "=="))
                                        : 4 == o &&
                                          ((r += t[(15 & i) << 2]), (r += "=")),
                                      r
                                    );
                                  })(e)),
                                a(l));
                            }),
                            (l.src = n),
                            Gt(() => {
                              a(l);
                            }, 1e4);
                        },
                      };
                      ye.push(t);
                      var r = s.canvas;
                      r &&
                        ((r.requestPointerLock =
                          r.requestPointerLock ||
                          r.mozRequestPointerLock ||
                          r.webkitRequestPointerLock ||
                          r.msRequestPointerLock ||
                          (() => {})),
                        (r.exitPointerLock =
                          document.exitPointerLock ||
                          document.mozExitPointerLock ||
                          document.webkitExitPointerLock ||
                          document.msExitPointerLock ||
                          (() => {})),
                        (r.exitPointerLock = r.exitPointerLock.bind(document)),
                        document.addEventListener("pointerlockchange", i, !1),
                        document.addEventListener(
                          "mozpointerlockchange",
                          i,
                          !1
                        ),
                        document.addEventListener(
                          "webkitpointerlockchange",
                          i,
                          !1
                        ),
                        document.addEventListener("mspointerlockchange", i, !1),
                        s.elementPointerLock &&
                          r.addEventListener(
                            "click",
                            (e) => {
                              !Wt.pointerLock &&
                                s.canvas.requestPointerLock &&
                                (s.canvas.requestPointerLock(),
                                e.preventDefault());
                            },
                            !1
                          ));
                    }
                    function i() {
                      Wt.pointerLock =
                        document.pointerLockElement === s.canvas ||
                        document.mozPointerLockElement === s.canvas ||
                        document.webkitPointerLockElement === s.canvas ||
                        document.msPointerLockElement === s.canvas;
                    }
                  },
                  createContext(e, t, r, i) {
                    if (t && s.ctx && e == s.canvas) return s.ctx;
                    var o, a;
                    if (t) {
                      var n = {
                        antialias: !1,
                        alpha: !1,
                        majorVersion:
                          "undefined" != typeof WebGL2RenderingContext ? 2 : 1,
                      };
                      if (i) for (var l in i) n[l] = i[l];
                      void 0 !== Zt &&
                        (a = Zt.createContext(e, n)) &&
                        (o = Zt.getContext(a).GLctx);
                    } else o = e.getContext("2d");
                    return o
                      ? (r &&
                          ((s.ctx = o),
                          t && Zt.makeContextCurrent(a),
                          (Wt.useWebGL = t),
                          Wt.moduleContextCreatedCallbacks.forEach((e) => e()),
                          Wt.init()),
                        o)
                      : null;
                  },
                  fullscreenHandlersInstalled: !1,
                  lockPointer: void 0,
                  resizeCanvas: void 0,
                  requestFullscreen(e, t) {
                    (Wt.lockPointer = e),
                      (Wt.resizeCanvas = t),
                      void 0 === Wt.lockPointer && (Wt.lockPointer = !0),
                      void 0 === Wt.resizeCanvas && (Wt.resizeCanvas = !1);
                    var r = s.canvas;
                    function i() {
                      Wt.isFullscreen = !1;
                      var e = r.parentNode;
                      (document.fullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.webkitCurrentFullScreenElement) === e
                        ? ((r.exitFullscreen = Wt.exitFullscreen),
                          Wt.lockPointer && r.requestPointerLock(),
                          (Wt.isFullscreen = !0),
                          Wt.resizeCanvas
                            ? Wt.setFullscreenCanvasSize()
                            : Wt.updateCanvasDimensions(r))
                        : (e.parentNode.insertBefore(r, e),
                          e.parentNode.removeChild(e),
                          Wt.resizeCanvas
                            ? Wt.setWindowedCanvasSize()
                            : Wt.updateCanvasDimensions(r)),
                        s.onFullScreen?.(Wt.isFullscreen),
                        s.onFullscreen?.(Wt.isFullscreen);
                    }
                    Wt.fullscreenHandlersInstalled ||
                      ((Wt.fullscreenHandlersInstalled = !0),
                      document.addEventListener("fullscreenchange", i, !1),
                      document.addEventListener("mozfullscreenchange", i, !1),
                      document.addEventListener(
                        "webkitfullscreenchange",
                        i,
                        !1
                      ),
                      document.addEventListener("MSFullscreenChange", i, !1));
                    var o = document.createElement("div");
                    r.parentNode.insertBefore(o, r),
                      o.appendChild(r),
                      (o.requestFullscreen =
                        o.requestFullscreen ||
                        o.mozRequestFullScreen ||
                        o.msRequestFullscreen ||
                        (o.webkitRequestFullscreen
                          ? () =>
                              o.webkitRequestFullscreen(
                                Element.ALLOW_KEYBOARD_INPUT
                              )
                          : null) ||
                        (o.webkitRequestFullScreen
                          ? () =>
                              o.webkitRequestFullScreen(
                                Element.ALLOW_KEYBOARD_INPUT
                              )
                          : null)),
                      o.requestFullscreen();
                  },
                  exitFullscreen: () =>
                    !!Wt.isFullscreen &&
                    ((
                      document.exitFullscreen ||
                      document.cancelFullScreen ||
                      document.mozCancelFullScreen ||
                      document.msExitFullscreen ||
                      document.webkitCancelFullScreen ||
                      (() => {})
                    ).apply(document, []),
                    !0),
                  safeSetTimeout: (e, t) => Gt(e, t),
                  getMimetype: (e) =>
                    ({
                      jpg: "image/jpeg",
                      jpeg: "image/jpeg",
                      png: "image/png",
                      bmp: "image/bmp",
                      ogg: "audio/ogg",
                      wav: "audio/wav",
                      mp3: "audio/mpeg",
                    }[e.substr(e.lastIndexOf(".") + 1)]),
                  getUserMedia(e) {
                    (window.getUserMedia ||=
                      navigator.getUserMedia || navigator.mozGetUserMedia),
                      window.getUserMedia(e);
                  },
                  getMovementX: (e) =>
                    e.movementX || e.mozMovementX || e.webkitMovementX || 0,
                  getMovementY: (e) =>
                    e.movementY || e.mozMovementY || e.webkitMovementY || 0,
                  getMouseWheelDelta(e) {
                    var t = 0;
                    switch (e.type) {
                      case "DOMMouseScroll":
                        t = e.detail / 3;
                        break;
                      case "mousewheel":
                        t = e.wheelDelta / 120;
                        break;
                      case "wheel":
                        switch (((t = e.deltaY), e.deltaMode)) {
                          case 0:
                            t /= 100;
                            break;
                          case 1:
                            t /= 3;
                            break;
                          case 2:
                            t *= 80;
                            break;
                          default:
                            throw (
                              "unrecognized mouse wheel delta mode: " +
                              e.deltaMode
                            );
                        }
                        break;
                      default:
                        throw "unrecognized mouse wheel event: " + e.type;
                    }
                    return t;
                  },
                  mouseX: 0,
                  mouseY: 0,
                  mouseMovementX: 0,
                  mouseMovementY: 0,
                  touches: {},
                  lastTouches: {},
                  calculateMouseCoords(e, t) {
                    var r = s.canvas.getBoundingClientRect(),
                      i = s.canvas.width,
                      o = s.canvas.height,
                      a =
                        void 0 !== window.scrollX
                          ? window.scrollX
                          : window.pageXOffset,
                      n =
                        void 0 !== window.scrollY
                          ? window.scrollY
                          : window.pageYOffset,
                      l = e - (a + r.left),
                      d = t - (n + r.top);
                    return { x: (l *= i / r.width), y: (d *= o / r.height) };
                  },
                  setMouseCoords(e, t) {
                    const { x: r, y: i } = Wt.calculateMouseCoords(e, t);
                    (Wt.mouseMovementX = r - Wt.mouseX),
                      (Wt.mouseMovementY = i - Wt.mouseY),
                      (Wt.mouseX = r),
                      (Wt.mouseY = i);
                  },
                  calculateMouseEvent(e) {
                    if (Wt.pointerLock)
                      "mousemove" != e.type && "mozMovementX" in e
                        ? (Wt.mouseMovementX = Wt.mouseMovementY = 0)
                        : ((Wt.mouseMovementX = Wt.getMovementX(e)),
                          (Wt.mouseMovementY = Wt.getMovementY(e))),
                        (Wt.mouseX += Wt.mouseMovementX),
                        (Wt.mouseY += Wt.mouseMovementY);
                    else {
                      if (
                        "touchstart" === e.type ||
                        "touchend" === e.type ||
                        "touchmove" === e.type
                      ) {
                        var t = e.touch;
                        if (void 0 === t) return;
                        var r = Wt.calculateMouseCoords(t.pageX, t.pageY);
                        if ("touchstart" === e.type)
                          (Wt.lastTouches[t.identifier] = r),
                            (Wt.touches[t.identifier] = r);
                        else if (
                          "touchend" === e.type ||
                          "touchmove" === e.type
                        ) {
                          var i = Wt.touches[t.identifier];
                          (i ||= r),
                            (Wt.lastTouches[t.identifier] = i),
                            (Wt.touches[t.identifier] = r);
                        }
                        return;
                      }
                      Wt.setMouseCoords(e.pageX, e.pageY);
                    }
                  },
                  resizeListeners: [],
                  updateResizeListeners() {
                    var e = s.canvas;
                    Wt.resizeListeners.forEach((t) => t(e.width, e.height));
                  },
                  setCanvasSize(e, t, r) {
                    var i = s.canvas;
                    Wt.updateCanvasDimensions(i, e, t),
                      r || Wt.updateResizeListeners();
                  },
                  windowedWidth: 0,
                  windowedHeight: 0,
                  setFullscreenCanvasSize() {
                    if ("undefined" != typeof SDL) {
                      var e = b[SDL.screen >> 2];
                      (e |= 8388608), (C[SDL.screen >> 2] = e);
                    }
                    Wt.updateCanvasDimensions(s.canvas),
                      Wt.updateResizeListeners();
                  },
                  setWindowedCanvasSize() {
                    if ("undefined" != typeof SDL) {
                      var e = b[SDL.screen >> 2];
                      (e &= -8388609), (C[SDL.screen >> 2] = e);
                    }
                    Wt.updateCanvasDimensions(s.canvas),
                      Wt.updateResizeListeners();
                  },
                  updateCanvasDimensions(e, t, r) {
                    t && r
                      ? ((e.widthNative = t), (e.heightNative = r))
                      : ((t = e.widthNative), (r = e.heightNative));
                    var i = t,
                      o = r;
                    if (
                      (s.forcedAspectRatio &&
                        s.forcedAspectRatio > 0 &&
                        (i / o < s.forcedAspectRatio
                          ? (i = Math.round(o * s.forcedAspectRatio))
                          : (o = Math.round(i / s.forcedAspectRatio))),
                      (document.fullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.webkitCurrentFullScreenElement) ===
                        e.parentNode && "undefined" != typeof screen)
                    ) {
                      var a = Math.min(screen.width / i, screen.height / o);
                      (i = Math.round(i * a)), (o = Math.round(o * a));
                    }
                    Wt.resizeCanvas
                      ? (e.width != i && (e.width = i),
                        e.height != o && (e.height = o),
                        void 0 !== e.style &&
                          (e.style.removeProperty("width"),
                          e.style.removeProperty("height")))
                      : (e.width != t && (e.width = t),
                        e.height != r && (e.height = r),
                        void 0 !== e.style &&
                          (i != t || o != r
                            ? (e.style.setProperty(
                                "width",
                                i + "px",
                                "important"
                              ),
                              e.style.setProperty(
                                "height",
                                o + "px",
                                "important"
                              ))
                            : (e.style.removeProperty("width"),
                              e.style.removeProperty("height"))));
                  },
                },
                Ut = {
                  errorCode: 12288,
                  defaultDisplayInitialized: !1,
                  currentContext: 0,
                  currentReadSurface: 0,
                  currentDrawSurface: 0,
                  contextAttributes: {
                    alpha: !1,
                    depth: !1,
                    stencil: !1,
                    antialias: !1,
                  },
                  stringCache: {},
                  setErrorCode(e) {
                    Ut.errorCode = e;
                  },
                  chooseConfig(e, t, r, i, o) {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if (t)
                      for (;;) {
                        var a = C[t >> 2];
                        if (12321 == a) {
                          var s = C[(t + 4) >> 2];
                          Ut.contextAttributes.alpha = s > 0;
                        } else if (12325 == a) {
                          var n = C[(t + 4) >> 2];
                          Ut.contextAttributes.depth = n > 0;
                        } else if (12326 == a) {
                          var l = C[(t + 4) >> 2];
                          Ut.contextAttributes.stencil = l > 0;
                        } else if (12337 == a) {
                          var d = C[(t + 4) >> 2];
                          Ut.contextAttributes.antialias = d > 0;
                        } else if (12338 == a)
                          (d = C[(t + 4) >> 2]),
                            (Ut.contextAttributes.antialias = 1 == d);
                        else if (12544 == a) {
                          var h = C[(t + 4) >> 2];
                          Ut.contextAttributes.lowLatency = 12547 != h;
                        } else if (12344 == a) break;
                        t += 8;
                      }
                    return (r && i) || o
                      ? (o && (C[o >> 2] = 1),
                        r && i > 0 && (b[r >> 2] = 62002),
                        Ut.setErrorCode(12288),
                        1)
                      : (Ut.setErrorCode(12300), 0);
                  },
                },
                $t = (e) => {
                  var t = [
                    "ANGLE_instanced_arrays",
                    "EXT_blend_minmax",
                    "EXT_disjoint_timer_query",
                    "EXT_frag_depth",
                    "EXT_shader_texture_lod",
                    "EXT_sRGB",
                    "OES_element_index_uint",
                    "OES_fbo_render_mipmap",
                    "OES_standard_derivatives",
                    "OES_texture_float",
                    "OES_texture_half_float",
                    "OES_texture_half_float_linear",
                    "OES_vertex_array_object",
                    "WEBGL_color_buffer_float",
                    "WEBGL_depth_texture",
                    "WEBGL_draw_buffers",
                    "EXT_color_buffer_float",
                    "EXT_conservative_depth",
                    "EXT_disjoint_timer_query_webgl2",
                    "EXT_texture_norm16",
                    "NV_shader_noperspective_interpolation",
                    "WEBGL_clip_cull_distance",
                    "EXT_clip_control",
                    "EXT_color_buffer_half_float",
                    "EXT_depth_clamp",
                    "EXT_float_blend",
                    "EXT_polygon_offset_clamp",
                    "EXT_texture_compression_bptc",
                    "EXT_texture_compression_rgtc",
                    "EXT_texture_filter_anisotropic",
                    "KHR_parallel_shader_compile",
                    "OES_texture_float_linear",
                    "WEBGL_blend_func_extended",
                    "WEBGL_compressed_texture_astc",
                    "WEBGL_compressed_texture_etc",
                    "WEBGL_compressed_texture_etc1",
                    "WEBGL_compressed_texture_s3tc",
                    "WEBGL_compressed_texture_s3tc_srgb",
                    "WEBGL_debug_renderer_info",
                    "WEBGL_debug_shaders",
                    "WEBGL_lose_context",
                    "WEBGL_multi_draw",
                    "WEBGL_polygon_mode",
                  ];
                  return (e.getSupportedExtensions() || []).filter((e) =>
                    t.includes(e)
                  );
                },
                Zt = {
                  counter: 1,
                  buffers: [],
                  programs: [],
                  framebuffers: [],
                  renderbuffers: [],
                  textures: [],
                  shaders: [],
                  vaos: [],
                  contexts: [],
                  offscreenCanvases: {},
                  queries: [],
                  samplers: [],
                  transformFeedbacks: [],
                  syncs: [],
                  stringCache: {},
                  stringiCache: {},
                  unpackAlignment: 4,
                  unpackRowLength: 0,
                  recordError: (e) => {
                    Zt.lastError || (Zt.lastError = e);
                  },
                  getNewId: (e) => {
                    for (var t = Zt.counter++, r = e.length; r < t; r++)
                      e[r] = null;
                    return t;
                  },
                  genObject: (e, t, r, i) => {
                    for (var o = 0; o < e; o++) {
                      var a = pt[r](),
                        s = a && Zt.getNewId(i);
                      a ? ((a.name = s), (i[s] = a)) : Zt.recordError(1282),
                        (C[(t + 4 * o) >> 2] = s);
                    }
                  },
                  getSource: (e, t, r, i) => {
                    for (var o = "", a = 0; a < t; ++a) {
                      var s = i ? b[(i + 4 * a) >> 2] : void 0;
                      o += Se(b[(r + 4 * a) >> 2], s);
                    }
                    return o;
                  },
                  createContext: (e, t) => {
                    var r =
                      t.majorVersion > 1
                        ? e.getContext("webgl2", t)
                        : e.getContext("webgl", t);
                    return r ? Zt.registerContext(r, t) : 0;
                  },
                  registerContext: (e, t) => {
                    var r = Zt.getNewId(Zt.contexts),
                      i = {
                        handle: r,
                        attributes: t,
                        version: t.majorVersion,
                        GLctx: e,
                      };
                    return (
                      e.canvas && (e.canvas.GLctxObject = i),
                      (Zt.contexts[r] = i),
                      (void 0 === t.enableExtensionsByDefault ||
                        t.enableExtensionsByDefault) &&
                        Zt.initExtensions(i),
                      r
                    );
                  },
                  makeContextCurrent: (e) => (
                    (Zt.currentContext = Zt.contexts[e]),
                    (s.ctx = pt = Zt.currentContext?.GLctx),
                    !(e && !pt)
                  ),
                  getContext: (e) => Zt.contexts[e],
                  deleteContext: (e) => {
                    Zt.currentContext === Zt.contexts[e] &&
                      (Zt.currentContext = null),
                      "object" == typeof ir &&
                        ir.removeAllHandlersOnTarget(
                          Zt.contexts[e].GLctx.canvas
                        ),
                      Zt.contexts[e] &&
                        Zt.contexts[e].GLctx.canvas &&
                        (Zt.contexts[e].GLctx.canvas.GLctxObject = void 0),
                      (Zt.contexts[e] = null);
                  },
                  initExtensions: (e) => {
                    if (((e ||= Zt.currentContext), !e.initExtensionsDone)) {
                      e.initExtensionsDone = !0;
                      var t,
                        r = e.GLctx;
                      ((t = r).multiDrawWebgl =
                        t.getExtension("WEBGL_multi_draw")),
                        ((e) => {
                          e.extPolygonOffsetClamp = e.getExtension(
                            "EXT_polygon_offset_clamp"
                          );
                        })(r),
                        ((e) => {
                          e.extClipControl = e.getExtension("EXT_clip_control");
                        })(r),
                        ((e) => {
                          e.webglPolygonMode =
                            e.getExtension("WEBGL_polygon_mode");
                        })(r),
                        ((e) => {
                          var t = e.getExtension("ANGLE_instanced_arrays");
                          t &&
                            ((e.vertexAttribDivisor = (e, r) =>
                              t.vertexAttribDivisorANGLE(e, r)),
                            (e.drawArraysInstanced = (e, r, i, o) =>
                              t.drawArraysInstancedANGLE(e, r, i, o)),
                            (e.drawElementsInstanced = (e, r, i, o, a) =>
                              t.drawElementsInstancedANGLE(e, r, i, o, a)));
                        })(r),
                        ((e) => {
                          var t = e.getExtension("OES_vertex_array_object");
                          t &&
                            ((e.createVertexArray = () =>
                              t.createVertexArrayOES()),
                            (e.deleteVertexArray = (e) =>
                              t.deleteVertexArrayOES(e)),
                            (e.bindVertexArray = (e) =>
                              t.bindVertexArrayOES(e)),
                            (e.isVertexArray = (e) => t.isVertexArrayOES(e)));
                        })(r),
                        ((e) => {
                          var t = e.getExtension("WEBGL_draw_buffers");
                          t &&
                            (e.drawBuffers = (e, r) =>
                              t.drawBuffersWEBGL(e, r));
                        })(r),
                        ((e) => {
                          e.dibvbi = e.getExtension(
                            "WEBGL_draw_instanced_base_vertex_base_instance"
                          );
                        })(r),
                        ((e) => {
                          e.mdibvbi = e.getExtension(
                            "WEBGL_multi_draw_instanced_base_vertex_base_instance"
                          );
                        })(r),
                        e.version >= 2 &&
                          (r.disjointTimerQueryExt = r.getExtension(
                            "EXT_disjoint_timer_query_webgl2"
                          )),
                        (e.version < 2 || !r.disjointTimerQueryExt) &&
                          (r.disjointTimerQueryExt = r.getExtension(
                            "EXT_disjoint_timer_query"
                          )),
                        $t(r).forEach((e) => {
                          e.includes("lose_context") ||
                            e.includes("debug") ||
                            r.getExtension(e);
                        });
                    }
                  },
                },
                qt = (e) => {
                  var t = oe(e) + 1,
                    r = Os(t);
                  return r && xt(e, r, t), r;
                },
                Kt = (e, t, r, i, o) => {
                  (Jt.func = e), (Jt.arg = i);
                  var a = Jt.currentlyRunningMainloop;
                  function s() {
                    return !(a < Jt.currentlyRunningMainloop && (jt(), 1));
                  }
                  if (
                    ((Jt.running = !1),
                    (Jt.runner = function () {
                      if (!E)
                        if (Jt.queue.length > 0) {
                          Date.now();
                          var t = Jt.queue.shift();
                          if ((t.func(t.arg), Jt.remainingBlockers)) {
                            var r = Jt.remainingBlockers,
                              i = r % 1 == 0 ? r - 1 : Math.floor(r);
                            t.counted
                              ? (Jt.remainingBlockers = i)
                              : ((i += 0.5),
                                (Jt.remainingBlockers = (8 * r + i) / 9));
                          }
                          if ((Jt.updateStatus(), !s())) return;
                          setTimeout(Jt.runner, 0);
                        } else
                          s() &&
                            ((Jt.currentFrameNumber =
                              (Jt.currentFrameNumber + 1) | 0),
                            1 == Jt.timingMode &&
                            Jt.timingValue > 1 &&
                            Jt.currentFrameNumber % Jt.timingValue != 0
                              ? Jt.scheduler()
                              : (0 == Jt.timingMode &&
                                  (Jt.tickStartTime = Nt()),
                                Jt.runIter(e),
                                s() && Jt.scheduler()));
                    }),
                    o ||
                      (t && t > 0 ? Qt(0, 1e3 / t) : Qt(1, 1), Jt.scheduler()),
                    r)
                  )
                    throw "unwind";
                },
                Jt = {
                  running: !1,
                  scheduler: null,
                  method: "",
                  currentlyRunningMainloop: 0,
                  func: null,
                  arg: 0,
                  timingMode: 0,
                  timingValue: 0,
                  currentFrameNumber: 0,
                  queue: [],
                  preMainLoop: [],
                  postMainLoop: [],
                  pause() {
                    (Jt.scheduler = null), Jt.currentlyRunningMainloop++;
                  },
                  resume() {
                    Jt.currentlyRunningMainloop++;
                    var e = Jt.timingMode,
                      t = Jt.timingValue,
                      r = Jt.func;
                    (Jt.func = null),
                      Kt(r, 0, !1, Jt.arg, !0),
                      Qt(e, t),
                      Jt.scheduler();
                  },
                  updateStatus() {
                    if (s.setStatus) {
                      var e = s.statusMessage || "Please wait...",
                        t = Jt.remainingBlockers ?? 0,
                        r = Jt.expectedBlockers ?? 0;
                      t
                        ? t < r
                          ? s.setStatus(
                              "{message} ({expected - remaining}/{expected})"
                            )
                          : s.setStatus(e)
                        : s.setStatus("");
                    }
                  },
                  init() {
                    s.preMainLoop && Jt.preMainLoop.push(s.preMainLoop),
                      s.postMainLoop && Jt.postMainLoop.push(s.postMainLoop);
                  },
                  runIter(e) {
                    if (!E) {
                      for (var t of Jt.preMainLoop) if (!1 === t()) return;
                      for (var r of (Xt(e), Jt.postMainLoop)) r();
                    }
                  },
                  nextRAF: 0,
                  fakeRequestAnimationFrame(e) {
                    var t = Date.now();
                    if (0 === Jt.nextRAF) Jt.nextRAF = t + 1e3 / 60;
                    else for (; t + 2 >= Jt.nextRAF; ) Jt.nextRAF += 1e3 / 60;
                    var r = Math.max(Jt.nextRAF - t, 0);
                    setTimeout(e, r);
                  },
                  requestAnimationFrame(e) {
                    "function" != typeof requestAnimationFrame
                      ? (0, Jt.fakeRequestAnimationFrame)(e)
                      : requestAnimationFrame(e);
                  },
                },
                Qt = (e, t) => {
                  if (((Jt.timingMode = e), (Jt.timingValue = t), !Jt.func))
                    return 1;
                  if ((Jt.running || (Jt.running = !0), 0 == e))
                    (Jt.scheduler = function () {
                      var e = 0 | Math.max(0, Jt.tickStartTime + t - Nt());
                      setTimeout(Jt.runner, e);
                    }),
                      (Jt.method = "timeout");
                  else if (1 == e)
                    (Jt.scheduler = function () {
                      Jt.requestAnimationFrame(Jt.runner);
                    }),
                      (Jt.method = "rAF");
                  else if (2 == e) {
                    if (void 0 === Jt.setImmediate)
                      if ("undefined" == typeof setImmediate) {
                        var r = [],
                          i = "setimmediate";
                        addEventListener(
                          "message",
                          (e) => {
                            (e.data !== i && e.data.target !== i) ||
                              (e.stopPropagation(), r.shift()());
                          },
                          !0
                        ),
                          (Jt.setImmediate = (e) => {
                            r.push(e), postMessage(i, "*");
                          });
                      } else Jt.setImmediate = setImmediate;
                    (Jt.scheduler = function () {
                      Jt.setImmediate(Jt.runner);
                    }),
                      (Jt.method = "immediate");
                  }
                  return 0;
                },
                er = [],
                tr = (e, t) => {
                  var r;
                  for (er.length = 0; (r = m[e++]); ) {
                    var i = 105 != r;
                    (t += (i &= 112 != r) && t % 8 ? 4 : 0),
                      er.push(
                        112 == r ? b[t >> 2] : 105 == r ? C[t >> 2] : A[t >> 3]
                      ),
                      (t += i ? 8 : 4);
                  }
                  return er;
                },
                rr = (e, t, r, i) => {
                  var o = tr(t, r);
                  return z[e](...o);
                },
                ir = {
                  memcpy(e, t, r) {
                    v.set(v.subarray(t, t + r), e);
                  },
                  removeAllEventListeners() {
                    for (; ir.eventHandlers.length; )
                      ir._removeHandler(ir.eventHandlers.length - 1);
                    ir.deferredCalls = [];
                  },
                  inEventHandler: 0,
                  deferredCalls: [],
                  deferCall(e, t, r) {
                    function i(e, t) {
                      if (e.length != t.length) return !1;
                      for (var r in e) if (e[r] != t[r]) return !1;
                      return !0;
                    }
                    for (var o of ir.deferredCalls)
                      if (o.targetFunction == e && i(o.argsList, r)) return;
                    ir.deferredCalls.push({
                      targetFunction: e,
                      precedence: t,
                      argsList: r,
                    }),
                      ir.deferredCalls.sort(
                        (e, t) => e.precedence < t.precedence
                      );
                  },
                  removeDeferredCalls(e) {
                    ir.deferredCalls = ir.deferredCalls.filter(
                      (t) => t.targetFunction != e
                    );
                  },
                  canPerformEventHandlerRequests: () =>
                    navigator.userActivation
                      ? navigator.userActivation.isActive
                      : ir.inEventHandler &&
                        ir.currentEventHandler.allowsDeferredCalls,
                  runDeferredCalls() {
                    if (ir.canPerformEventHandlerRequests()) {
                      var e = ir.deferredCalls;
                      for (var t of ((ir.deferredCalls = []), e))
                        t.targetFunction(...t.argsList);
                    }
                  },
                  eventHandlers: [],
                  removeAllHandlersOnTarget: (e, t) => {
                    for (var r = 0; r < ir.eventHandlers.length; ++r)
                      ir.eventHandlers[r].target != e ||
                        (t && t != ir.eventHandlers[r].eventTypeString) ||
                        ir._removeHandler(r--);
                  },
                  _removeHandler(e) {
                    var t = ir.eventHandlers[e];
                    t.target.removeEventListener(
                      t.eventTypeString,
                      t.eventListenerFunc,
                      t.useCapture
                    ),
                      ir.eventHandlers.splice(e, 1);
                  },
                  registerOrRemoveHandler(e) {
                    if (!e.target) return -4;
                    if (e.callbackfunc)
                      (e.eventListenerFunc = function (t) {
                        ++ir.inEventHandler,
                          (ir.currentEventHandler = e),
                          ir.runDeferredCalls(),
                          e.handlerFunc(t),
                          ir.runDeferredCalls(),
                          --ir.inEventHandler;
                      }),
                        e.target.addEventListener(
                          e.eventTypeString,
                          e.eventListenerFunc,
                          e.useCapture
                        ),
                        ir.eventHandlers.push(e);
                    else
                      for (var t = 0; t < ir.eventHandlers.length; ++t)
                        ir.eventHandlers[t].target == e.target &&
                          ir.eventHandlers[t].eventTypeString ==
                            e.eventTypeString &&
                          ir._removeHandler(t--);
                    return 0;
                  },
                  getNodeNameForTarget: (e) =>
                    e
                      ? e == window
                        ? "#window"
                        : e == screen
                        ? "#screen"
                        : e?.nodeName || ""
                      : "",
                  fullscreenEnabled: () =>
                    document.fullscreenEnabled ||
                    document.webkitFullscreenEnabled,
                },
                or = {},
                ar = [0, document, window],
                sr = (e) => {
                  var t;
                  return (
                    (e = (t = e) > 2 ? Se(t) : t),
                    ar[e] || document.querySelector(e)
                  );
                },
                nr = sr,
                lr = (e) => Ns(e),
                dr = (e) => {
                  var t = oe(e) + 1,
                    r = lr(t);
                  return xt(e, r, t), r;
                },
                hr = (e) => {
                  var t = $(),
                    r = lr(8),
                    i = r + 4,
                    o =
                      (((e, t, r) => {
                        var i = nr(e);
                        if (!i) return -4;
                        (C[t >> 2] = i.width), (C[r >> 2] = i.height);
                      })(dr(e.id), r, i),
                      [C[r >> 2], C[i >> 2]]);
                  return U(t), o;
                },
                ur = (e, t, r) => {
                  var i = nr(e);
                  return i ? ((i.width = t), (i.height = r), 0) : -4;
                },
                cr = (e, t, r) => {
                  if (e.controlTransferredOffscreen) {
                    var i = $(),
                      o = dr(e.id);
                    ur(o, t, r), U(i);
                  } else (e.width = t), (e.height = r);
                },
                pr = (e, t, r) => {
                  (e.style.paddingLeft = e.style.paddingRight = r + "px"),
                    (e.style.paddingTop = e.style.paddingBottom = t + "px");
                },
                gr = (e) =>
                  ar.indexOf(e) < 0
                    ? e.getBoundingClientRect()
                    : { left: 0, top: 0 },
                yr = (e, t) => {
                  if (
                    ((0 == t.scaleMode && 0 == t.canvasResolutionScaleMode) ||
                      ((e, t) => {
                        var r = ((e) => {
                            var t = hr(e),
                              r = t[0],
                              i = t[1],
                              o = e.style.width,
                              a = e.style.height,
                              s = e.style.backgroundColor,
                              n = document.body.style.backgroundColor,
                              l = e.style.paddingLeft,
                              d = e.style.paddingRight,
                              h = e.style.paddingTop,
                              u = e.style.paddingBottom,
                              c = e.style.marginLeft,
                              p = e.style.marginRight,
                              g = e.style.marginTop,
                              y = e.style.marginBottom,
                              f = document.body.style.margin,
                              v = document.documentElement.style.overflow,
                              m = document.body.scroll,
                              S = e.style.imageRendering;
                            function P() {
                              document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                (document.removeEventListener(
                                  "fullscreenchange",
                                  P
                                ),
                                document.removeEventListener(
                                  "webkitfullscreenchange",
                                  P
                                ),
                                cr(e, r, i),
                                (e.style.width = o),
                                (e.style.height = a),
                                (e.style.backgroundColor = s),
                                n ||
                                  (document.body.style.backgroundColor =
                                    "white"),
                                (document.body.style.backgroundColor = n),
                                (e.style.paddingLeft = l),
                                (e.style.paddingRight = d),
                                (e.style.paddingTop = h),
                                (e.style.paddingBottom = u),
                                (e.style.marginLeft = c),
                                (e.style.marginRight = p),
                                (e.style.marginTop = g),
                                (e.style.marginBottom = y),
                                (document.body.style.margin = f),
                                (document.documentElement.style.overflow = v),
                                (document.body.scroll = m),
                                (e.style.imageRendering = S),
                                e.GLctxObject &&
                                  e.GLctxObject.GLctx.viewport(0, 0, r, i),
                                or.canvasResizedCallback &&
                                  nt(or.canvasResizedCallback)(
                                    37,
                                    0,
                                    or.canvasResizedCallbackUserData
                                  ));
                            }
                            return (
                              document.addEventListener("fullscreenchange", P),
                              document.addEventListener(
                                "webkitfullscreenchange",
                                P
                              ),
                              P
                            );
                          })(e),
                          i = t.softFullscreen ? innerWidth : screen.width,
                          o = t.softFullscreen ? innerHeight : screen.height,
                          a = gr(e),
                          s = a.width,
                          n = a.height,
                          l = hr(e),
                          d = l[0],
                          h = l[1];
                        if (3 == t.scaleMode)
                          pr(e, (o - n) / 2, (i - s) / 2), (i = s), (o = n);
                        else if (2 == t.scaleMode)
                          if (i * h < d * o) {
                            var u = (h * i) / d;
                            pr(e, (o - u) / 2, 0), (o = u);
                          } else {
                            var c = (d * o) / h;
                            pr(e, 0, (i - c) / 2), (i = c);
                          }
                        (e.style.backgroundColor ||= "black"),
                          (document.body.style.backgroundColor ||= "black"),
                          (e.style.width = i + "px"),
                          (e.style.height = o + "px"),
                          1 == t.filteringMode &&
                            ((e.style.imageRendering = "optimizeSpeed"),
                            (e.style.imageRendering = "-moz-crisp-edges"),
                            (e.style.imageRendering = "-o-crisp-edges"),
                            (e.style.imageRendering =
                              "-webkit-optimize-contrast"),
                            (e.style.imageRendering = "optimize-contrast"),
                            (e.style.imageRendering = "crisp-edges"),
                            (e.style.imageRendering = "pixelated"));
                        var p =
                          2 == t.canvasResolutionScaleMode
                            ? devicePixelRatio
                            : 1;
                        if (0 != t.canvasResolutionScaleMode) {
                          var g = (i * p) | 0,
                            y = (o * p) | 0;
                          cr(e, g, y),
                            e.GLctxObject &&
                              e.GLctxObject.GLctx.viewport(0, 0, g, y);
                        }
                      })(e, t),
                    e.requestFullscreen)
                  )
                    e.requestFullscreen();
                  else {
                    if (!e.webkitRequestFullscreen)
                      return ir.fullscreenEnabled() ? -3 : -1;
                    e.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                  }
                  return (
                    (or = t),
                    t.canvasResizedCallback &&
                      nt(t.canvasResizedCallback)(
                        37,
                        0,
                        t.canvasResizedCallbackUserData
                      ),
                    0
                  );
                },
                fr = (e) =>
                  e.requestPointerLock
                    ? (e.requestPointerLock(), 0)
                    : document.body.requestPointerLock
                    ? -3
                    : -1,
                vr = (e, t) => {
                  A[e >> 3] = t.timestamp;
                  for (var r = 0; r < t.axes.length; ++r)
                    A[(e + 8 * r + 16) >> 3] = t.axes[r];
                  for (r = 0; r < t.buttons.length; ++r)
                    "object" == typeof t.buttons[r]
                      ? (A[(e + 8 * r + 528) >> 3] = t.buttons[r].value)
                      : (A[(e + 8 * r + 528) >> 3] = t.buttons[r]);
                  for (r = 0; r < t.buttons.length; ++r)
                    "object" == typeof t.buttons[r]
                      ? (v[e + r + 1040] = t.buttons[r].pressed)
                      : (v[e + r + 1040] = 1 == t.buttons[r]);
                  (v[e + 1104] = t.connected),
                    (C[(e + 1108) >> 2] = t.index),
                    (C[(e + 8) >> 2] = t.axes.length),
                    (C[(e + 12) >> 2] = t.buttons.length),
                    xt(t.id, e + 1112, 64),
                    xt(t.mapping, e + 1176, 64);
                },
                mr = (e) => pt.activeTexture(e),
                Sr = mr,
                Pr = (e, t) => {
                  pt.attachShader(Zt.programs[e], Zt.shaders[t]);
                },
                Cr = Pr,
                br = (e, t, r) => {
                  pt.bindAttribLocation(Zt.programs[e], t, Se(r));
                },
                xr = br,
                Ar = (e, t) => {
                  35051 == e
                    ? (pt.currentPixelPackBufferBinding = t)
                    : 35052 == e && (pt.currentPixelUnpackBufferBinding = t),
                    pt.bindBuffer(e, Zt.buffers[t]);
                },
                Tr = Ar,
                Er = (e, t) => {
                  pt.bindFramebuffer(e, Zt.framebuffers[t]);
                },
                Rr = Er,
                Dr = (e, t) => {
                  pt.bindTexture(e, Zt.textures[t]);
                },
                wr = Dr,
                Mr = (e) => {
                  pt.bindVertexArray(Zt.vaos[e]);
                },
                Lr = Mr,
                Or = Mr,
                Ir = Or,
                kr = (e, t, r, i) => pt.blendColor(e, t, r, i),
                _r = kr,
                Vr = (e) => pt.blendEquation(e),
                Nr = Vr,
                Br = (e, t, r, i) => pt.blendFuncSeparate(e, t, r, i),
                Fr = Br,
                Hr = (e, t, r, i) => {
                  Zt.currentContext.version >= 2
                    ? r && t
                      ? pt.bufferData(e, m, i, r, t)
                      : pt.bufferData(e, t, i)
                    : pt.bufferData(e, r ? m.subarray(r, r + t) : t, i);
                },
                Yr = Hr,
                zr = (e) => pt.checkFramebufferStatus(e),
                jr = zr,
                Xr = (e) => pt.clear(e),
                Gr = Xr,
                Wr = (e, t, r, i) => pt.clearColor(e, t, r, i),
                Ur = Wr,
                $r = (e, t) => (e >>> 0) + 4294967296 * t,
                Zr = (e, t, r, i) => {
                  pt.colorMask(!!e, !!t, !!r, !!i);
                },
                qr = Zr,
                Kr = (e) => {
                  pt.compileShader(Zt.shaders[e]);
                },
                Jr = Kr,
                Qr = (e, t, r, i, o, a, s, n) => {
                  if (Zt.currentContext.version >= 2)
                    return pt.currentPixelUnpackBufferBinding || !s
                      ? void pt.compressedTexImage2D(e, t, r, i, o, a, s, n)
                      : void pt.compressedTexImage2D(e, t, r, i, o, a, m, n, s);
                  pt.compressedTexImage2D(
                    e,
                    t,
                    r,
                    i,
                    o,
                    a,
                    m.subarray(n, n + s)
                  );
                },
                ei = Qr,
                ti = () => {
                  var e = Zt.getNewId(Zt.programs),
                    t = pt.createProgram();
                  return (
                    (t.name = e),
                    (t.maxUniformLength =
                      t.maxAttributeLength =
                      t.maxUniformBlockNameLength =
                        0),
                    (t.uniformIdCounter = 1),
                    (Zt.programs[e] = t),
                    e
                  );
                },
                ri = ti,
                ii = (e) => {
                  var t = Zt.getNewId(Zt.shaders);
                  return (Zt.shaders[t] = pt.createShader(e)), t;
                },
                oi = ii,
                ai = (e) => pt.cullFace(e),
                si = ai,
                ni = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.buffers[i];
                    o &&
                      (pt.deleteBuffer(o),
                      (o.name = 0),
                      (Zt.buffers[i] = null),
                      i == pt.currentPixelPackBufferBinding &&
                        (pt.currentPixelPackBufferBinding = 0),
                      i == pt.currentPixelUnpackBufferBinding &&
                        (pt.currentPixelUnpackBufferBinding = 0));
                  }
                },
                li = ni,
                di = (e, t) => {
                  for (var r = 0; r < e; ++r) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.framebuffers[i];
                    o &&
                      (pt.deleteFramebuffer(o),
                      (o.name = 0),
                      (Zt.framebuffers[i] = null));
                  }
                },
                hi = di,
                ui = (e) => {
                  if (e) {
                    var t = Zt.programs[e];
                    t
                      ? (pt.deleteProgram(t),
                        (t.name = 0),
                        (Zt.programs[e] = null))
                      : Zt.recordError(1281);
                  }
                },
                ci = ui,
                pi = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.renderbuffers[i];
                    o &&
                      (pt.deleteRenderbuffer(o),
                      (o.name = 0),
                      (Zt.renderbuffers[i] = null));
                  }
                },
                gi = pi,
                yi = (e) => {
                  if (e) {
                    var t = Zt.shaders[e];
                    t
                      ? (pt.deleteShader(t), (Zt.shaders[e] = null))
                      : Zt.recordError(1281);
                  }
                },
                fi = yi,
                vi = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.textures[i];
                    o &&
                      (pt.deleteTexture(o),
                      (o.name = 0),
                      (Zt.textures[i] = null));
                  }
                },
                mi = vi,
                Si = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2];
                    pt.deleteVertexArray(Zt.vaos[i]), (Zt.vaos[i] = null);
                  }
                },
                Pi = Si,
                Ci = Si,
                bi = Ci,
                xi = (e) => pt.depthFunc(e),
                Ai = xi,
                Ti = (e) => {
                  pt.depthMask(!!e);
                },
                Ei = Ti,
                Ri = (e, t) => {
                  pt.detachShader(Zt.programs[e], Zt.shaders[t]);
                },
                Di = Ri,
                wi = (e) => pt.disable(e),
                Mi = wi,
                Li = (e, t, r) => {
                  pt.drawArrays(e, t, r);
                },
                Oi = Li,
                Ii = (e, t, r, i) => {
                  pt.drawArraysInstanced(e, t, r, i);
                },
                ki = Ii,
                _i = Ii,
                Vi = _i,
                Ni = Ii,
                Bi = Ni,
                Fi = Ii,
                Hi = Fi,
                Yi = Ii,
                zi = Yi,
                ji = [],
                Xi = (e, t) => {
                  for (var r = ji[e], i = 0; i < e; i++)
                    r[i] = C[(t + 4 * i) >> 2];
                  pt.drawBuffers(r);
                },
                Gi = Xi,
                Wi = Xi,
                Ui = Wi,
                $i = Xi,
                Zi = $i,
                qi = (e, t, r, i) => {
                  pt.drawElements(e, t, r, i);
                },
                Ki = qi,
                Ji = (e, t, r, i, o) => {
                  pt.drawElementsInstanced(e, t, r, i, o);
                },
                Qi = Ji,
                eo = Ji,
                to = eo,
                ro = Ji,
                io = ro,
                oo = Ji,
                ao = oo,
                so = Ji,
                no = so,
                lo = (e) => pt.enable(e),
                ho = lo,
                uo = (e) => {
                  pt.enableVertexAttribArray(e);
                },
                co = uo,
                po = (e, t, r, i, o) => {
                  pt.framebufferTexture2D(e, t, r, Zt.textures[i], o);
                },
                go = po,
                yo = (e) => pt.frontFace(e),
                fo = yo,
                vo = (e, t) => {
                  Zt.genObject(e, t, "createBuffer", Zt.buffers);
                },
                mo = vo,
                So = (e, t) => {
                  Zt.genObject(e, t, "createFramebuffer", Zt.framebuffers);
                },
                Po = So,
                Co = (e, t) => {
                  Zt.genObject(e, t, "createTexture", Zt.textures);
                },
                bo = Co,
                xo = (e, t) => {
                  Zt.genObject(e, t, "createVertexArray", Zt.vaos);
                },
                Ao = xo,
                To = xo,
                Eo = To,
                Ro = (e) => pt.generateMipmap(e),
                Do = Ro,
                wo = (e, t, r, i, o, a, s, n) => {
                  t = Zt.programs[t];
                  var l = pt[e](t, r);
                  if (l) {
                    var d = n && xt(l.name, n, i);
                    o && (C[o >> 2] = d),
                      a && (C[a >> 2] = l.size),
                      s && (C[s >> 2] = l.type);
                  }
                },
                Mo = (e, t, r, i, o, a, s) =>
                  wo("getActiveAttrib", e, t, r, i, o, a, s),
                Lo = Mo,
                Oo = (e, t, r, i, o, a, s) =>
                  wo("getActiveUniform", e, t, r, i, o, a, s),
                Io = Oo,
                ko = (e, t) => {
                  b[e >> 2] = t;
                  var r = b[e >> 2];
                  b[(e + 4) >> 2] = (t - r) / 4294967296;
                },
                _o = () => {
                  var e = $t(pt);
                  return e.concat(e.map((e) => "GL_" + e));
                },
                Vo = (e, t, r) => {
                  if (t) {
                    var i = void 0;
                    switch (e) {
                      case 36346:
                        i = 1;
                        break;
                      case 36344:
                        return void (0 != r && 1 != r && Zt.recordError(1280));
                      case 34814:
                      case 36345:
                        i = 0;
                        break;
                      case 34466:
                        var o = pt.getParameter(34467);
                        i = o ? o.length : 0;
                        break;
                      case 33309:
                        if (Zt.currentContext.version < 2)
                          return void Zt.recordError(1282);
                        i = _o().length;
                        break;
                      case 33307:
                      case 33308:
                        if (Zt.currentContext.version < 2)
                          return void Zt.recordError(1280);
                        i = 33307 == e ? 3 : 0;
                    }
                    if (void 0 === i) {
                      var a = pt.getParameter(e);
                      switch (typeof a) {
                        case "number":
                          i = a;
                          break;
                        case "boolean":
                          i = a ? 1 : 0;
                          break;
                        case "string":
                          return void Zt.recordError(1280);
                        case "object":
                          if (null === a)
                            switch (e) {
                              case 34964:
                              case 35725:
                              case 34965:
                              case 36006:
                              case 36007:
                              case 32873:
                              case 34229:
                              case 36662:
                              case 36663:
                              case 35053:
                              case 35055:
                              case 36010:
                              case 35097:
                              case 35869:
                              case 32874:
                              case 36389:
                              case 35983:
                              case 35368:
                              case 34068:
                                i = 0;
                                break;
                              default:
                                return void Zt.recordError(1280);
                            }
                          else {
                            if (
                              a instanceof Float32Array ||
                              a instanceof Uint32Array ||
                              a instanceof Int32Array ||
                              a instanceof Array
                            ) {
                              for (var s = 0; s < a.length; ++s)
                                switch (r) {
                                  case 0:
                                    C[(t + 4 * s) >> 2] = a[s];
                                    break;
                                  case 2:
                                    x[(t + 4 * s) >> 2] = a[s];
                                    break;
                                  case 4:
                                    v[t + s] = a[s] ? 1 : 0;
                                }
                              return;
                            }
                            try {
                              i = 0 | a.name;
                            } catch (t) {
                              return (
                                Zt.recordError(1280),
                                void g(
                                  `GL_INVALID_ENUM in glGet${r}v: Unknown object returned from WebGL getParameter(${e})! (error: ${t})`
                                )
                              );
                            }
                          }
                          break;
                        default:
                          return (
                            Zt.recordError(1280),
                            void g(
                              `GL_INVALID_ENUM in glGet${r}v: Native code calling glGet${r}v(${e}) and it returns ${a} of type ${typeof a}!`
                            )
                          );
                      }
                    }
                    switch (r) {
                      case 1:
                        ko(t, i);
                        break;
                      case 0:
                        C[t >> 2] = i;
                        break;
                      case 2:
                        x[t >> 2] = i;
                        break;
                      case 4:
                        v[t] = i ? 1 : 0;
                    }
                  } else Zt.recordError(1281);
                },
                No = (e, t, r, i) => {
                  if (r) {
                    var o,
                      a = pt.getIndexedParameter(e, t);
                    switch (typeof a) {
                      case "boolean":
                        o = a ? 1 : 0;
                        break;
                      case "number":
                        o = a;
                        break;
                      case "object":
                        if (null === a)
                          switch (e) {
                            case 35983:
                            case 35368:
                              o = 0;
                              break;
                            default:
                              return void Zt.recordError(1280);
                          }
                        else {
                          if (!(a instanceof WebGLBuffer))
                            return void Zt.recordError(1280);
                          o = 0 | a.name;
                        }
                        break;
                      default:
                        return void Zt.recordError(1280);
                    }
                    switch (i) {
                      case 1:
                        ko(r, o);
                        break;
                      case 0:
                        C[r >> 2] = o;
                        break;
                      case 2:
                        x[r >> 2] = o;
                        break;
                      case 4:
                        v[r] = o ? 1 : 0;
                        break;
                      default:
                        throw (
                          "internal emscriptenWebGLGetIndexed() error, bad type: " +
                          i
                        );
                    }
                  } else Zt.recordError(1281);
                },
                Bo = (e, t) => Vo(e, t, 0),
                Fo = Bo,
                Ho = (e, t, r, i) => {
                  var o = pt.getProgramInfoLog(Zt.programs[e]);
                  null === o && (o = "(unknown error)");
                  var a = t > 0 && i ? xt(o, i, t) : 0;
                  r && (C[r >> 2] = a);
                },
                Yo = Ho,
                zo = (e, t, r) => {
                  if (r)
                    if (e >= Zt.counter) Zt.recordError(1281);
                    else if (((e = Zt.programs[e]), 35716 == t)) {
                      var i = pt.getProgramInfoLog(e);
                      null === i && (i = "(unknown error)"),
                        (C[r >> 2] = i.length + 1);
                    } else if (35719 == t) {
                      if (!e.maxUniformLength)
                        for (
                          var o = pt.getProgramParameter(e, 35718), a = 0;
                          a < o;
                          ++a
                        )
                          e.maxUniformLength = Math.max(
                            e.maxUniformLength,
                            pt.getActiveUniform(e, a).name.length + 1
                          );
                      C[r >> 2] = e.maxUniformLength;
                    } else if (35722 == t) {
                      if (!e.maxAttributeLength) {
                        var s = pt.getProgramParameter(e, 35721);
                        for (a = 0; a < s; ++a)
                          e.maxAttributeLength = Math.max(
                            e.maxAttributeLength,
                            pt.getActiveAttrib(e, a).name.length + 1
                          );
                      }
                      C[r >> 2] = e.maxAttributeLength;
                    } else if (35381 == t) {
                      if (!e.maxUniformBlockNameLength) {
                        var n = pt.getProgramParameter(e, 35382);
                        for (a = 0; a < n; ++a)
                          e.maxUniformBlockNameLength = Math.max(
                            e.maxUniformBlockNameLength,
                            pt.getActiveUniformBlockName(e, a).length + 1
                          );
                      }
                      C[r >> 2] = e.maxUniformBlockNameLength;
                    } else C[r >> 2] = pt.getProgramParameter(e, t);
                  else Zt.recordError(1281);
                },
                jo = zo,
                Xo = (e, t, r) => {
                  if (r) {
                    var i,
                      o = Zt.queries[e];
                    (i =
                      Zt.currentContext.version < 2
                        ? pt.disjointTimerQueryExt.getQueryObjectEXT(o, t)
                        : pt.getQueryParameter(o, t)),
                      ko(r, "boolean" == typeof i ? (i ? 1 : 0) : i);
                  } else Zt.recordError(1281);
                },
                Go = Xo,
                Wo = (e, t, r) => {
                  if (r) {
                    var i,
                      o = Zt.queries[e],
                      a = pt.disjointTimerQueryExt.getQueryObjectEXT(o, t);
                    (i = "boolean" == typeof a ? (a ? 1 : 0) : a),
                      (C[r >> 2] = i);
                  } else Zt.recordError(1281);
                },
                Uo = Wo,
                $o = Xo,
                Zo = Wo,
                qo = (e, t, r, i) => {
                  var o = pt.getShaderInfoLog(Zt.shaders[e]);
                  null === o && (o = "(unknown error)");
                  var a = t > 0 && i ? xt(o, i, t) : 0;
                  r && (C[r >> 2] = a);
                },
                Ko = qo,
                Jo = (e, t, r) => {
                  if (r)
                    if (35716 == t) {
                      var i = pt.getShaderInfoLog(Zt.shaders[e]);
                      null === i && (i = "(unknown error)");
                      var o = i ? i.length + 1 : 0;
                      C[r >> 2] = o;
                    } else if (35720 == t) {
                      var a = pt.getShaderSource(Zt.shaders[e]),
                        s = a ? a.length + 1 : 0;
                      C[r >> 2] = s;
                    } else C[r >> 2] = pt.getShaderParameter(Zt.shaders[e], t);
                  else Zt.recordError(1281);
                },
                Qo = Jo,
                ea = (e) => {
                  var t = Zt.stringCache[e];
                  if (!t) {
                    switch (e) {
                      case 7939:
                        t = qt(_o().join(" "));
                        break;
                      case 7936:
                      case 7937:
                      case 37445:
                      case 37446:
                        var r = pt.getParameter(e);
                        r || Zt.recordError(1280), (t = r ? qt(r) : 0);
                        break;
                      case 7938:
                        var i = pt.getParameter(7938),
                          o = `OpenGL ES 2.0 (${i})`;
                        Zt.currentContext.version >= 2 &&
                          (o = `OpenGL ES 3.0 (${i})`),
                          (t = qt(o));
                        break;
                      case 35724:
                        var a = pt.getParameter(35724),
                          s = a.match(
                            /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/
                          );
                        null !== s &&
                          (3 == s[1].length && (s[1] = s[1] + "0"),
                          (a = `OpenGL ES GLSL ES ${s[1]} (${a})`)),
                          (t = qt(a));
                        break;
                      default:
                        Zt.recordError(1280);
                    }
                    Zt.stringCache[e] = t;
                  }
                  return t;
                },
                ta = ea,
                ra = (e) => "]" == e.slice(-1) && e.lastIndexOf("["),
                ia = (e) => {
                  var t,
                    r,
                    i = e.uniformLocsById,
                    o = e.uniformSizeAndIdsByName;
                  if (!i) {
                    (e.uniformLocsById = i = {}),
                      (e.uniformArrayNamesById = {});
                    var a = pt.getProgramParameter(e, 35718);
                    for (t = 0; t < a; ++t) {
                      var s = pt.getActiveUniform(e, t),
                        n = s.name,
                        l = s.size,
                        d = ra(n),
                        h = d > 0 ? n.slice(0, d) : n,
                        u = e.uniformIdCounter;
                      for (
                        e.uniformIdCounter += l, o[h] = [l, u], r = 0;
                        r < l;
                        ++r
                      )
                        (i[u] = r), (e.uniformArrayNamesById[u++] = h);
                    }
                  }
                },
                oa = (e, t) => {
                  if (((t = Se(t)), (e = Zt.programs[e]))) {
                    ia(e);
                    var r = e.uniformLocsById,
                      i = 0,
                      o = t,
                      a = ra(t);
                    a > 0 &&
                      ((n = t.slice(a + 1)),
                      (i = parseInt(n) >>> 0),
                      (o = t.slice(0, a)));
                    var s = e.uniformSizeAndIdsByName[o];
                    if (
                      s &&
                      i < s[0] &&
                      (r[(i += s[1])] = r[i] || pt.getUniformLocation(e, t))
                    )
                      return i;
                  } else Zt.recordError(1281);
                  var n;
                  return -1;
                },
                aa = oa,
                sa = (e) => {
                  var t = pt.currentProgram;
                  if (t) {
                    var r = t.uniformLocsById[e];
                    return (
                      "number" == typeof r &&
                        (t.uniformLocsById[e] = r =
                          pt.getUniformLocation(
                            t,
                            t.uniformArrayNamesById[e] + (r > 0 ? `[${r}]` : "")
                          )),
                      r
                    );
                  }
                  Zt.recordError(1282);
                },
                na = (e, t, r, i) => {
                  if (r) {
                    (e = Zt.programs[e]), ia(e);
                    var o = pt.getUniform(e, sa(t));
                    if ("number" == typeof o || "boolean" == typeof o)
                      switch (i) {
                        case 0:
                          C[r >> 2] = o;
                          break;
                        case 2:
                          x[r >> 2] = o;
                      }
                    else
                      for (var a = 0; a < o.length; a++)
                        switch (i) {
                          case 0:
                            C[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 2:
                            x[(r + 4 * a) >> 2] = o[a];
                        }
                  } else Zt.recordError(1281);
                },
                la = (e, t, r, i) => {
                  if (r) {
                    var o = pt.getVertexAttrib(e, t);
                    if (34975 == t) C[r >> 2] = o && o.name;
                    else if ("number" == typeof o || "boolean" == typeof o)
                      switch (i) {
                        case 0:
                          C[r >> 2] = o;
                          break;
                        case 2:
                          x[r >> 2] = o;
                          break;
                        case 5:
                          C[r >> 2] = Math.fround(o);
                      }
                    else
                      for (var a = 0; a < o.length; a++)
                        switch (i) {
                          case 0:
                            C[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 2:
                            x[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 5:
                            C[(r + 4 * a) >> 2] = Math.fround(o[a]);
                        }
                  } else Zt.recordError(1281);
                },
                da = (e, t, r) => {
                  la(e, t, r, 0);
                },
                ha = da,
                ua = da,
                ca = (e) => {
                  var t = Zt.vaos[e];
                  return t ? pt.isVertexArray(t) : 0;
                },
                pa = ca,
                ga = ca,
                ya = (e) => pt.lineWidth(e),
                fa = ya,
                va = (e) => {
                  (e = Zt.programs[e]),
                    pt.linkProgram(e),
                    (e.uniformLocsById = 0),
                    (e.uniformSizeAndIdsByName = {});
                },
                ma = va,
                Sa = (e, t) => {
                  3317 == e
                    ? (Zt.unpackAlignment = t)
                    : 3314 == e && (Zt.unpackRowLength = t),
                    pt.pixelStorei(e, t);
                },
                Pa = Sa,
                Ca = (e) =>
                  0 == (e -= 5120)
                    ? v
                    : 1 == e
                    ? m
                    : 2 == e
                    ? S
                    : 4 == e
                    ? C
                    : 6 == e
                    ? x
                    : 5 == e ||
                      28922 == e ||
                      28520 == e ||
                      30779 == e ||
                      30782 == e
                    ? b
                    : P,
                ba = (e, t) => e >>> (31 - Math.clz32(t.BYTES_PER_ELEMENT)),
                xa = (e, t, r, i, o, a) => {
                  var s = Ca(e),
                    n =
                      ((e) =>
                        ({
                          5: 3,
                          6: 4,
                          8: 2,
                          29502: 3,
                          29504: 4,
                          26917: 2,
                          26918: 2,
                          29846: 3,
                          29847: 4,
                        }[e - 6402] || 1))(t) * s.BYTES_PER_ELEMENT,
                    l = ((e, t, r) => {
                      var i;
                      return (
                        t *
                        (((Zt.unpackRowLength || e) * r +
                          (i = Zt.unpackAlignment) -
                          1) &
                          -i)
                      );
                    })(r, i, n);
                  return s.subarray(ba(o, s), ba(o + l, s));
                },
                Aa = (e, t, r, i, o, a, s) => {
                  if (Zt.currentContext.version >= 2) {
                    if (pt.currentPixelPackBufferBinding)
                      return void pt.readPixels(e, t, r, i, o, a, s);
                    var n = Ca(a),
                      l = ba(s, n);
                    pt.readPixels(e, t, r, i, o, a, n, l);
                  } else {
                    var d = xa(a, o, r, i, s);
                    d
                      ? pt.readPixels(e, t, r, i, o, a, d)
                      : Zt.recordError(1280);
                  }
                },
                Ta = Aa,
                Ea = (e, t, r, i) => pt.scissor(e, t, r, i),
                Ra = Ea,
                Da = (e, t, r, i) => {
                  var o = Zt.getSource(e, t, r, i);
                  pt.shaderSource(Zt.shaders[e], o);
                },
                wa = Da,
                Ma = (e, t, r, i, o, a, s, n, l) => {
                  if (Zt.currentContext.version >= 2) {
                    if (pt.currentPixelUnpackBufferBinding)
                      return void pt.texImage2D(e, t, r, i, o, a, s, n, l);
                    if (l) {
                      var d = Ca(n),
                        h = ba(l, d);
                      return void pt.texImage2D(e, t, r, i, o, a, s, n, d, h);
                    }
                  }
                  var u = l ? xa(n, s, i, o, l) : null;
                  pt.texImage2D(e, t, r, i, o, a, s, n, u);
                },
                La = Ma,
                Oa = (e, t, r) => pt.texParameteri(e, t, r),
                Ia = Oa,
                ka = [],
                _a = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform1fv(sa(e), x, r >> 2, t);
                  else {
                    if (t <= 288)
                      for (var i = ka[t], o = 0; o < t; ++o)
                        i[o] = x[(r + 4 * o) >> 2];
                    else i = x.subarray(r >> 2, (r + 4 * t) >> 2);
                    pt.uniform1fv(sa(e), i);
                  }
                },
                Va = _a,
                Na = (e, t) => {
                  pt.uniform1i(sa(e), t);
                },
                Ba = Na,
                Fa = [],
                Ha = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform2fv(sa(e), x, r >> 2, 2 * t);
                  else {
                    if (t <= 144)
                      for (var i = ka[(t *= 2)], o = 0; o < t; o += 2)
                        (i[o] = x[(r + 4 * o) >> 2]),
                          (i[o + 1] = x[(r + (4 * o + 4)) >> 2]);
                    else i = x.subarray(r >> 2, (r + 8 * t) >> 2);
                    pt.uniform2fv(sa(e), i);
                  }
                },
                Ya = Ha,
                za = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform3fv(sa(e), x, r >> 2, 3 * t);
                  else {
                    if (t <= 96)
                      for (var i = ka[(t *= 3)], o = 0; o < t; o += 3)
                        (i[o] = x[(r + 4 * o) >> 2]),
                          (i[o + 1] = x[(r + (4 * o + 4)) >> 2]),
                          (i[o + 2] = x[(r + (4 * o + 8)) >> 2]);
                    else i = x.subarray(r >> 2, (r + 12 * t) >> 2);
                    pt.uniform3fv(sa(e), i);
                  }
                },
                ja = za,
                Xa = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform4fv(sa(e), x, r >> 2, 4 * t);
                  else {
                    if (t <= 72) {
                      var i = ka[4 * t],
                        o = x;
                      (r >>= 2), (t *= 4);
                      for (var a = 0; a < t; a += 4) {
                        var s = r + a;
                        (i[a] = o[s]),
                          (i[a + 1] = o[s + 1]),
                          (i[a + 2] = o[s + 2]),
                          (i[a + 3] = o[s + 3]);
                      }
                    } else i = x.subarray(r >> 2, (r + 16 * t) >> 2);
                    pt.uniform4fv(sa(e), i);
                  }
                },
                Ga = Xa,
                Wa = (e, t, r, i) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniformMatrix4fv(sa(e), !!r, x, i >> 2, 16 * t);
                  else {
                    if (t <= 18) {
                      var o = ka[16 * t],
                        a = x;
                      (i >>= 2), (t *= 16);
                      for (var s = 0; s < t; s += 16) {
                        var n = i + s;
                        (o[s] = a[n]),
                          (o[s + 1] = a[n + 1]),
                          (o[s + 2] = a[n + 2]),
                          (o[s + 3] = a[n + 3]),
                          (o[s + 4] = a[n + 4]),
                          (o[s + 5] = a[n + 5]),
                          (o[s + 6] = a[n + 6]),
                          (o[s + 7] = a[n + 7]),
                          (o[s + 8] = a[n + 8]),
                          (o[s + 9] = a[n + 9]),
                          (o[s + 10] = a[n + 10]),
                          (o[s + 11] = a[n + 11]),
                          (o[s + 12] = a[n + 12]),
                          (o[s + 13] = a[n + 13]),
                          (o[s + 14] = a[n + 14]),
                          (o[s + 15] = a[n + 15]);
                      }
                    } else o = x.subarray(i >> 2, (i + 64 * t) >> 2);
                    pt.uniformMatrix4fv(sa(e), !!r, o);
                  }
                },
                Ua = Wa,
                $a = (e) => {
                  (e = Zt.programs[e]),
                    pt.useProgram(e),
                    (pt.currentProgram = e);
                },
                Za = $a,
                qa = (e, t) => {
                  pt.vertexAttribDivisor(e, t);
                },
                Ka = qa,
                Ja = qa,
                Qa = qa,
                es = qa,
                ts = qa,
                rs = (e, t, r, i, o, a) => {
                  pt.vertexAttribPointer(e, t, r, !!i, o, a);
                },
                is = rs,
                os = (e, t, r, i) => pt.viewport(e, t, r, i),
                as = os,
                ss = (e) => {
                  var t = ((e - y.buffer.byteLength + 65535) / 65536) | 0;
                  try {
                    return y.grow(t), R(), 1;
                  } catch (e) {}
                },
                ns = () => {
                  try {
                    if (navigator.getGamepads)
                      return (ir.lastGamepadState = navigator.getGamepads())
                        ? 0
                        : -1;
                  } catch (e) {
                    navigator.getGamepads = null;
                  }
                  return -1;
                },
                ls = (e, t, r, i, o, a, s) => {
                  ir.focusEvent ||= Os(256);
                  var n = {
                    target: sr(e),
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.getNodeNameForTarget(e.target),
                        a = e.target.id ? e.target.id : "",
                        s = ir.focusEvent;
                      xt(r, s + 0, 128),
                        xt(a, s + 128, 128),
                        nt(i)(o, s, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                ds = (e, t, r, i, o, a, s) => {
                  ir.fullscreenChangeEvent ||= Os(276);
                  var n = {
                    target: e,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.fullscreenChangeEvent;
                      ((e) => {
                        var t =
                            document.fullscreenElement ||
                            document.mozFullScreenElement ||
                            document.webkitFullscreenElement ||
                            document.msFullscreenElement,
                          r = !!t;
                        (v[e] = r), (v[e + 1] = ir.fullscreenEnabled());
                        var i = r ? t : ir.previousFullscreenElement,
                          o = ir.getNodeNameForTarget(i),
                          a = i?.id || "";
                        xt(o, e + 2, 128),
                          xt(a, e + 130, 128),
                          (C[(e + 260) >> 2] = i ? i.clientWidth : 0),
                          (C[(e + 264) >> 2] = i ? i.clientHeight : 0),
                          (C[(e + 268) >> 2] = screen.width),
                          (C[(e + 272) >> 2] = screen.height),
                          r && (ir.previousFullscreenElement = t);
                      })(r),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                hs = (e, t, r, i, o, a, s) => {
                  ir.gamepadEvent ||= Os(1240);
                  var n = {
                    target: sr(e),
                    allowsDeferredCalls: !0,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.gamepadEvent;
                      vr(r, e.gamepad), nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                us = (e, t, r, i, o, a, s) => {
                  ir.keyEvent ||= Os(160);
                  var n = {
                    target: sr(e),
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e) => {
                      var r = ir.keyEvent;
                      A[r >> 3] = e.timeStamp;
                      var a = r >> 2;
                      (C[a + 2] = e.location),
                        (v[r + 12] = e.ctrlKey),
                        (v[r + 13] = e.shiftKey),
                        (v[r + 14] = e.altKey),
                        (v[r + 15] = e.metaKey),
                        (v[r + 16] = e.repeat),
                        (C[a + 5] = e.charCode),
                        (C[a + 6] = e.keyCode),
                        (C[a + 7] = e.which),
                        xt(e.key || "", r + 32, 32),
                        xt(e.code || "", r + 64, 32),
                        xt(e.char || "", r + 96, 32),
                        xt(e.locale || "", r + 128, 32),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                cs = (e, t, r) => {
                  A[e >> 3] = t.timeStamp;
                  var i = e >> 2;
                  (C[i + 2] = t.screenX),
                    (C[i + 3] = t.screenY),
                    (C[i + 4] = t.clientX),
                    (C[i + 5] = t.clientY),
                    (v[e + 24] = t.ctrlKey),
                    (v[e + 25] = t.shiftKey),
                    (v[e + 26] = t.altKey),
                    (v[e + 27] = t.metaKey),
                    (S[2 * i + 14] = t.button),
                    (S[2 * i + 15] = t.buttons),
                    (C[i + 8] = t.movementX),
                    (C[i + 9] = t.movementY);
                  var o = gr(r);
                  (C[i + 10] = t.clientX - (0 | o.left)),
                    (C[i + 11] = t.clientY - (0 | o.top));
                },
                ps = (e, t, r, i, o, a, s) => {
                  ir.mouseEvent ||= Os(64);
                  var n = {
                    target: (e = sr(e)),
                    allowsDeferredCalls:
                      "mousemove" != a &&
                      "mouseenter" != a &&
                      "mouseleave" != a,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (r = event) => {
                      cs(ir.mouseEvent, r, e),
                        nt(i)(o, ir.mouseEvent, t) && r.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                gs = (e, t, r, i, o, a, s) => {
                  ir.pointerlockChangeEvent ||= Os(257);
                  var n = {
                    target: e,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.pointerlockChangeEvent;
                      ((e) => {
                        var t =
                            document.pointerLockElement ||
                            document.mozPointerLockElement ||
                            document.webkitPointerLockElement ||
                            document.msPointerLockElement,
                          r = !!t;
                        v[e] = r;
                        var i = ir.getNodeNameForTarget(t),
                          o = t?.id || "";
                        xt(i, e + 1, 128), xt(o, e + 129, 128);
                      })(r),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                ys = (e, t, r, i, o, a, s) => {
                  ir.touchEvent ||= Os(1552);
                  var n = {
                    target: (e = sr(e)),
                    allowsDeferredCalls: "touchstart" == a || "touchend" == a,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (r) => {
                      var a = {},
                        s = r.touches;
                      for (let e of s)
                        (e.isChanged = e.onTarget = 0), (a[e.identifier] = e);
                      for (let e of r.changedTouches)
                        (e.isChanged = 1), (a[e.identifier] = e);
                      for (let e of r.targetTouches)
                        a[e.identifier].onTarget = 1;
                      var n = ir.touchEvent;
                      (A[n >> 3] = r.timeStamp),
                        (v[n + 12] = r.ctrlKey),
                        (v[n + 13] = r.shiftKey),
                        (v[n + 14] = r.altKey),
                        (v[n + 15] = r.metaKey);
                      var l = n + 16,
                        d = gr(e),
                        h = 0;
                      for (let e of Object.values(a)) {
                        var u = l >> 2;
                        if (
                          ((C[u + 0] = e.identifier),
                          (C[u + 1] = e.screenX),
                          (C[u + 2] = e.screenY),
                          (C[u + 3] = e.clientX),
                          (C[u + 4] = e.clientY),
                          (C[u + 5] = e.pageX),
                          (C[u + 6] = e.pageY),
                          (v[l + 28] = e.isChanged),
                          (v[l + 29] = e.onTarget),
                          (C[u + 8] = e.clientX - (0 | d.left)),
                          (C[u + 9] = e.clientY - (0 | d.top)),
                          (l += 48),
                          ++h > 31)
                        )
                          break;
                      }
                      (C[(n + 8) >> 2] = h),
                        nt(i)(o, n, t) && r.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                };
              class fs {
                allocated = [void 0];
                freelist = [];
                get(e) {
                  return this.allocated[e];
                }
                has(e) {
                  return void 0 !== this.allocated[e];
                }
                allocate(e) {
                  var t = this.freelist.pop() || this.allocated.length;
                  return (this.allocated[t] = e), t;
                }
                free(e) {
                  (this.allocated[e] = void 0), this.freelist.push(e);
                }
              }
              var vs = {
                openDatabase(e, t, r, i) {
                  try {
                    var o = indexedDB.open(e, t);
                  } catch (e) {
                    return i(e);
                  }
                  (o.onupgradeneeded = (e) => {
                    var t = e.target.result;
                    t.objectStoreNames.contains("FILES") &&
                      t.deleteObjectStore("FILES"),
                      t.createObjectStore("FILES");
                  }),
                    (o.onsuccess = (e) => r(e.target.result)),
                    (o.onerror = i);
                },
                init() {
                  (vs.xhrs = new fs()),
                    k(),
                    vs.openDatabase(
                      "emscripten_filesystem",
                      1,
                      (e) => {
                        (vs.dbInstance = e), _();
                      },
                      () => {
                        (vs.dbInstance = !1), _();
                      }
                    );
                },
              };
              function ms(e, t, r, i, o) {
                var a = b[(e + 8) >> 2];
                if (a) {
                  var s = Se(a),
                    n = e + 108,
                    l = Se(n + 0);
                  l ||= "GET";
                  var d = b[(n + 56) >> 2],
                    h = b[(n + 68) >> 2],
                    u = b[(n + 72) >> 2],
                    c = b[(n + 76) >> 2],
                    p = b[(n + 80) >> 2],
                    g = b[(n + 84) >> 2],
                    y = b[(n + 88) >> 2],
                    f = b[(n + 52) >> 2],
                    v = !!(1 & f),
                    P = !!(2 & f),
                    C = !!(64 & f),
                    x = h ? Se(h) : void 0,
                    A = u ? Se(u) : void 0,
                    T = new XMLHttpRequest();
                  if (
                    ((T.withCredentials = !!m[n + 60]),
                    T.open(l, s, !C, x, A),
                    C || (T.timeout = d),
                    (T.url_ = s),
                    (T.responseType = "arraybuffer"),
                    p)
                  ) {
                    var E = Se(p);
                    T.overrideMimeType(E);
                  }
                  if (c)
                    for (;;) {
                      var R = b[c >> 2];
                      if (!R) break;
                      var D = b[(c + 4) >> 2];
                      if (!D) break;
                      c += 8;
                      var w = Se(R),
                        M = Se(D);
                      T.setRequestHeader(w, M);
                    }
                  var L = vs.xhrs.allocate(T);
                  b[e >> 2] = L;
                  var O = g && y ? m.slice(g, g + y) : null;
                  (T.onload = (i) => {
                    vs.xhrs.has(L) &&
                      (I(),
                      T.status >= 200 && T.status < 300
                        ? t?.(e, T, i)
                        : r?.(e, T, i));
                  }),
                    (T.onerror = (t) => {
                      vs.xhrs.has(L) && (I(), r?.(e, T, t));
                    }),
                    (T.ontimeout = (t) => {
                      vs.xhrs.has(L) && r?.(e, T, t);
                    }),
                    (T.onprogress = (t) => {
                      if (vs.xhrs.has(L)) {
                        var r =
                            v && P && T.response ? T.response.byteLength : 0,
                          o = 0;
                        r > 0 &&
                          v &&
                          P &&
                          ((o = Os(r)), m.set(new Uint8Array(T.response), o)),
                          (b[(e + 12) >> 2] = o),
                          ko(e + 16, r),
                          ko(e + 24, t.loaded - r),
                          ko(e + 32, t.total),
                          (S[(e + 40) >> 1] = T.readyState),
                          T.readyState >= 3 &&
                            0 === T.status &&
                            t.loaded > 0 &&
                            (T.status = 200),
                          (S[(e + 42) >> 1] = T.status),
                          T.statusText && xt(T.statusText, e + 44, 64),
                          i?.(e, T, t),
                          o && Is(o);
                      }
                    }),
                    (T.onreadystatechange = (t) => {
                      vs.xhrs.has(L) &&
                        ((S[(e + 40) >> 1] = T.readyState),
                        T.readyState >= 2 && (S[(e + 42) >> 1] = T.status),
                        o?.(e, T, t));
                    });
                  try {
                    T.send(O);
                  } catch (t) {
                    r?.(e, T, t);
                  }
                } else r(e, 0, "no url specified!");
                function I() {
                  var t = 0,
                    r = 0;
                  T.response &&
                    v &&
                    0 === b[(e + 12) >> 2] &&
                    (r = T.response.byteLength),
                    r > 0 &&
                      ((t = Os(r)), m.set(new Uint8Array(T.response), t)),
                    (b[(e + 12) >> 2] = t),
                    ko(e + 16, r),
                    ko(e + 24, 0);
                  var i = T.response ? T.response.byteLength : 0;
                  i && ko(e + 32, i),
                    (S[(e + 40) >> 1] = T.readyState),
                    (S[(e + 42) >> 1] = T.status),
                    T.statusText && xt(T.statusText, e + 44, 64);
                }
              }
              function Ss(e, t, r, i, o) {
                if (e) {
                  var a = b[(t + 108 + 64) >> 2];
                  a ||= b[(t + 8) >> 2];
                  var s = Se(a);
                  try {
                    var n = e
                      .transaction(["FILES"], "readwrite")
                      .objectStore("FILES")
                      .put(r, s);
                    (n.onsuccess = (e) => {
                      (S[(t + 40) >> 1] = 4),
                        (S[(t + 42) >> 1] = 200),
                        xt("OK", t + 44, 64),
                        i(t, 0, s);
                    }),
                      (n.onerror = (e) => {
                        (S[(t + 40) >> 1] = 4),
                          (S[(t + 42) >> 1] = 413),
                          xt("Payload Too Large", t + 44, 64),
                          o(t, 0, e);
                      });
                  } catch (e) {
                    o(t, 0, e);
                  }
                } else o(t, 0, "IndexedDB not available!");
              }
              var Ps = {},
                Cs = () => {
                  if (!Cs.strings) {
                    var e = {
                      USER: "web_user",
                      LOGNAME: "web_user",
                      PATH: "/",
                      PWD: "/",
                      HOME: "/home/web_user",
                      LANG:
                        (
                          ("object" == typeof navigator &&
                            navigator.languages &&
                            navigator.languages[0]) ||
                          "C"
                        ).replace("-", "_") + ".UTF-8",
                      _: h || "./this.program",
                    };
                    for (var t in Ps)
                      void 0 === Ps[t] ? delete e[t] : (e[t] = Ps[t]);
                    var r = [];
                    for (var t in e) r.push(`${t}=${e[t]}`);
                    Cs.strings = r;
                  }
                  return Cs.strings;
                },
                bs = (e, t) => {
                  t || (t = [document, document.getElementById("canvas")]),
                    ["keydown", "mousedown", "touchstart"].forEach((r) => {
                      t.forEach((t) => {
                        t &&
                          ((t, r, i) => {
                            t.addEventListener(
                              r,
                              () => {
                                "suspended" === e.state && e.resume();
                              },
                              { once: !0 }
                            );
                          })(t, r);
                      });
                    });
                },
                xs = (e) => s["_" + e],
                As = (e, t, r, i, o) => {
                  var a = {
                      string: (e) => {
                        var t = 0;
                        return null != e && 0 !== e && (t = dr(e)), t;
                      },
                      array: (e) => {
                        var t,
                          r,
                          i = lr(e.length);
                        return (t = e), (r = i), v.set(t, r), i;
                      },
                    },
                    s = xs(e),
                    n = [],
                    l = 0;
                  if (i)
                    for (var d = 0; d < i.length; d++) {
                      var h = a[r[d]];
                      h
                        ? (0 === l && (l = $()), (n[d] = h(i[d])))
                        : (n[d] = i[d]);
                    }
                  var u = s(...n);
                  return (function (e) {
                    return (
                      0 !== l && U(l),
                      (function (e) {
                        return "string" === t
                          ? Se(e)
                          : "boolean" === t
                          ? Boolean(e)
                          : e;
                      })(e)
                    );
                  })(u);
                };
              (me.createPreloadedFile = (e, t, r, i, a, s, n, l, d, h) => {
                var u = t ? ee.resolve(J.join2(e, t)) : e;
                function c(r) {
                  function o(r) {
                    h?.(), l || ge(e, t, r, i, a, d), s?.(), _();
                  }
                  fe(r, u, o, () => {
                    n?.(), _();
                  }) || o(r);
                }
                k(),
                  "string" == typeof r
                    ? (async (e) => {
                        var t = await o(e);
                        return new Uint8Array(t);
                      })(r).then(c, n)
                    : c(r);
              }),
                me.staticInit(),
                (pe.doesNotExistError = new me.ErrnoError(44)),
                (pe.doesNotExistError.stack = "<generic error, no stack>"),
                (ne = s.BindingError =
                  class extends Error {
                    constructor(e) {
                      super(e), (this.name = "BindingError");
                    }
                  }),
                xe.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1),
                (s.count_emval_handles = () => xe.length / 2 - 5 - be.length),
                (le = s.PureVirtualError = Ee(Error, "PureVirtualError")),
                (() => {
                  for (var e = new Array(256), t = 0; t < 256; ++t)
                    e[t] = String.fromCharCode(t);
                  de = e;
                })(),
                (he = s.InternalError =
                  class extends Error {
                    constructor(e) {
                      super(e), (this.name = "InternalError");
                    }
                  }),
                Object.assign($e.prototype, {
                  isAliasOf(e) {
                    if (!(this instanceof $e)) return !1;
                    if (!(e instanceof $e)) return !1;
                    var t = this.$$.ptrType.registeredClass,
                      r = this.$$.ptr;
                    e.$$ = e.$$;
                    for (
                      var i = e.$$.ptrType.registeredClass, o = e.$$.ptr;
                      t.baseClass;

                    )
                      (r = t.upcast(r)), (t = t.baseClass);
                    for (; i.baseClass; ) (o = i.upcast(o)), (i = i.baseClass);
                    return t === i && r === o;
                  },
                  clone() {
                    if (
                      (this.$$.ptr || We(this), this.$$.preservePointerOnDelete)
                    )
                      return (this.$$.count.value += 1), this;
                    var e,
                      t = Ye(
                        Object.create(Object.getPrototypeOf(this), {
                          $$: {
                            value:
                              ((e = this.$$),
                              {
                                count: e.count,
                                deleteScheduled: e.deleteScheduled,
                                preservePointerOnDelete:
                                  e.preservePointerOnDelete,
                                ptr: e.ptr,
                                ptrType: e.ptrType,
                                smartPtr: e.smartPtr,
                                smartPtrType: e.smartPtrType,
                              }),
                          },
                        })
                      );
                    return (
                      (t.$$.count.value += 1), (t.$$.deleteScheduled = !1), t
                    );
                  },
                  delete() {
                    this.$$.ptr || We(this),
                      this.$$.deleteScheduled &&
                        !this.$$.preservePointerOnDelete &&
                        Ae("Object already scheduled for deletion"),
                      Ie(this),
                      _e(this.$$),
                      this.$$.preservePointerOnDelete ||
                        ((this.$$.smartPtr = void 0), (this.$$.ptr = void 0));
                  },
                  isDeleted() {
                    return !this.$$.ptr;
                  },
                  deleteLater() {
                    return (
                      this.$$.ptr || We(this),
                      this.$$.deleteScheduled &&
                        !this.$$.preservePointerOnDelete &&
                        Ae("Object already scheduled for deletion"),
                      Ue.push(this),
                      Ue.length,
                      (this.$$.deleteScheduled = !0),
                      this
                    );
                  },
                }),
                Object.assign(it.prototype, {
                  getPointee(e) {
                    return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
                  },
                  destructor(e) {
                    this.rawDestructor?.(e);
                  },
                  argPackAdvance: 8,
                  readValueFromPointer: rt,
                  fromWireType: function (e) {
                    var t = this.getPointee(e);
                    if (!t) return this.destructor(e), null;
                    var r = Be(this.registeredClass, t);
                    if (void 0 !== r) {
                      if (0 === r.$$.count.value)
                        return (r.$$.ptr = t), (r.$$.smartPtr = e), r.clone();
                      var i = r.clone();
                      return this.destructor(e), i;
                    }
                    function o() {
                      return this.isSmartPointer
                        ? He(this.registeredClass.instancePrototype, {
                            ptrType: this.pointeeType,
                            ptr: t,
                            smartPtrType: this,
                            smartPtr: e,
                          })
                        : He(this.registeredClass.instancePrototype, {
                            ptrType: this,
                            ptr: e,
                          });
                    }
                    var a,
                      s = this.registeredClass.getActualType(t),
                      n = Ne[s];
                    if (!n) return o.call(this);
                    a = this.isConst ? n.constPointerType : n.pointerType;
                    var l = Ve(t, this.registeredClass, a.registeredClass);
                    return null === l
                      ? o.call(this)
                      : this.isSmartPointer
                      ? He(a.registeredClass.instancePrototype, {
                          ptrType: a,
                          ptr: l,
                          smartPtrType: this,
                          smartPtr: e,
                        })
                      : He(a.registeredClass.instancePrototype, {
                          ptrType: a,
                          ptr: l,
                        });
                  },
                }),
                (at = s.UnboundTypeError = Ee(Error, "UnboundTypeError")),
                (s.requestFullscreen = Wt.requestFullscreen),
                (s.setCanvasSize = Wt.setCanvasSize),
                (s.getUserMedia = Wt.getUserMedia),
                (s.createContext = Wt.createContext),
                (s.requestAnimationFrame = Jt.requestAnimationFrame),
                (s.pauseMainLoop = Jt.pause),
                (s.resumeMainLoop = Jt.resume),
                Jt.init();
              for (var Ts = 0; Ts < 32; ++Ts) ji.push(new Array(Ts));
              var Es = new Float32Array(288);
              for (Ts = 0; Ts <= 288; ++Ts) ka[Ts] = Es.subarray(0, Ts);
              var Rs = new Int32Array(288);
              for (Ts = 0; Ts <= 288; ++Ts) Fa[Ts] = Rs.subarray(0, Ts);
              vs.init();
              var Ds,
                ws = {
                  g: (e, t, r) => {
                    throw (new Z(e).init(t, r), e);
                  },
                  _: function (e, t, r) {
                    Pe.varargs = r;
                    try {
                      var i = Pe.getStreamFromFD(e);
                      switch (t) {
                        case 0:
                          if ((o = q()) < 0) return -28;
                          for (; me.streams[o]; ) o++;
                          return me.dupStream(i, o).fd;
                        case 1:
                        case 2:
                        case 13:
                        case 14:
                          return 0;
                        case 3:
                          return i.flags;
                        case 4:
                          var o = q();
                          return (i.flags |= o), 0;
                        case 12:
                          return (o = K()), (S[(o + 0) >> 1] = 2), 0;
                      }
                      return -28;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  vb: function (e, t) {
                    try {
                      var r = Pe.getStreamFromFD(e);
                      return Pe.doStat(me.stat, r.path, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  xb: function (e, t, r) {
                    Pe.varargs = r;
                    try {
                      var i = Pe.getStreamFromFD(e);
                      switch (t) {
                        case 21509:
                        case 21510:
                        case 21511:
                        case 21512:
                        case 21524:
                        case 21515:
                          return i.tty ? 0 : -59;
                        case 21505:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tcgets) {
                            var o = i.tty.ops.ioctl_tcgets(i),
                              a = K();
                            (C[a >> 2] = o.c_iflag || 0),
                              (C[(a + 4) >> 2] = o.c_oflag || 0),
                              (C[(a + 8) >> 2] = o.c_cflag || 0),
                              (C[(a + 12) >> 2] = o.c_lflag || 0);
                            for (var s = 0; s < 32; s++)
                              v[a + s + 17] = o.c_cc[s] || 0;
                            return 0;
                          }
                          return 0;
                        case 21506:
                        case 21507:
                        case 21508:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tcsets) {
                            a = K();
                            var n = C[a >> 2],
                              l = C[(a + 4) >> 2],
                              d = C[(a + 8) >> 2],
                              h = C[(a + 12) >> 2],
                              u = [];
                            for (s = 0; s < 32; s++) u.push(v[a + s + 17]);
                            return i.tty.ops.ioctl_tcsets(i.tty, t, {
                              c_iflag: n,
                              c_oflag: l,
                              c_cflag: d,
                              c_lflag: h,
                              c_cc: u,
                            });
                          }
                          return 0;
                        case 21519:
                          return i.tty ? ((a = K()), (C[a >> 2] = 0), 0) : -59;
                        case 21520:
                          return i.tty ? -28 : -59;
                        case 21531:
                          return (a = K()), me.ioctl(i, t, a);
                        case 21523:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tiocgwinsz) {
                            var c = i.tty.ops.ioctl_tiocgwinsz(i.tty);
                            (a = K()),
                              (S[a >> 1] = c[0]),
                              (S[(a + 2) >> 1] = c[1]);
                          }
                          return 0;
                        default:
                          return -28;
                      }
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  sb: function (e, t) {
                    try {
                      return (e = Pe.getStr(e)), Pe.doStat(me.lstat, e, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  tb: function (e, t, r, i) {
                    try {
                      t = Pe.getStr(t);
                      var o = 256 & i,
                        a = 4096 & i;
                      return (
                        (i &= -6401),
                        (t = Pe.calculateAt(e, t, a)),
                        Pe.doStat(o ? me.lstat : me.stat, t, r)
                      );
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  yb: function (e, t, r, i) {
                    Pe.varargs = i;
                    try {
                      (t = Pe.getStr(t)), (t = Pe.calculateAt(e, t));
                      var o = i ? q() : 0;
                      return me.open(t, r, o).fd;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  ub: function (e, t) {
                    try {
                      return (e = Pe.getStr(e)), Pe.doStat(me.stat, e, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  Ab: () => V(""),
                  Ha: (e, t, r) => {
                    (e = Re(e)), (t = Oe(t, "wrapper")), (r = Te.toValue(r));
                    var i = t.registeredClass,
                      o = i.instancePrototype,
                      a = i.baseClass.instancePrototype,
                      s = i.baseClass.constructor,
                      n = Ce(e, function (...e) {
                        i.baseClass.pureVirtualFunctions.forEach(
                          function (e) {
                            if (this[e] === a[e])
                              throw new le(
                                `Pure virtual function ${e} must be implemented in JavaScript`
                              );
                          }.bind(this)
                        ),
                          Object.defineProperty(this, "__parent", { value: o }),
                          this.__construct(...e);
                      });
                    return (
                      (o.__construct = function (...e) {
                        this === o && Ae("Pass correct 'this' to __construct");
                        var t = s.implement(this, ...e);
                        Ie(t);
                        var r,
                          a,
                          n = t.$$;
                        t.notifyOnDestruction(),
                          (n.preservePointerOnDelete = !0),
                          Object.defineProperties(this, { $$: { value: n } }),
                          Ye(this),
                          (r = i),
                          (a = n.ptr),
                          (a = we(r, a)),
                          De.hasOwnProperty(a)
                            ? Ae(`Tried to register registered instance: ${a}`)
                            : (De[a] = this);
                      }),
                      (o.__destruct = function () {
                        var e, t;
                        this === o && Ae("Pass correct 'this' to __destruct"),
                          Ie(this),
                          (e = i),
                          (t = this.$$.ptr),
                          (t = we(e, t)),
                          De.hasOwnProperty(t)
                            ? delete De[t]
                            : Ae(
                                `Tried to unregister unregistered instance: ${t}`
                              );
                      }),
                      (n.prototype = Object.create(o)),
                      Object.assign(n.prototype, r),
                      Te.toHandle(n)
                    );
                  },
                  mb: (e, t, r, i, o) => {},
                  Ma: (e, t, r, i) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType: function (e) {
                        return !!e;
                      },
                      toWireType: function (e, t) {
                        return t ? r : i;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: function (e) {
                        return this.fromWireType(m[e]);
                      },
                      destructorFunction: null,
                    });
                  },
                  c: (e, t, r, i, o, a, s, n, l, d, h, u, c) => {
                    (h = Re(h)),
                      (a = dt(o, a)),
                      (n &&= dt(s, n)),
                      (d &&= dt(l, d)),
                      (c = dt(u, c));
                    var p = ((e) => {
                      var t = (e = e.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(
                        0
                      );
                      return t >= 48 && t <= 57 ? `_${e}` : e;
                    })(h);
                    qe(p, function () {
                      ht(`Cannot construct ${h} due to unbound types`, [i]);
                    }),
                      Xe([e, t, r], i ? [i] : [], (t) => {
                        var r, o;
                        (t = t[0]),
                          (o = i
                            ? (r = t.registeredClass).instancePrototype
                            : $e.prototype);
                        var s = Ce(h, function (...e) {
                            if (Object.getPrototypeOf(this) !== l)
                              throw new ne("Use 'new' to construct " + h);
                            if (void 0 === u.constructor_body)
                              throw new ne(
                                h + " has no accessible constructor"
                              );
                            var t = u.constructor_body[e.length];
                            if (void 0 === t)
                              throw new ne(
                                `Tried to invoke ctor of ${h} with invalid number of parameters (${
                                  e.length
                                }) - expected (${Object.keys(
                                  u.constructor_body
                                ).toString()}) parameters instead!`
                              );
                            return t.apply(this, e);
                          }),
                          l = Object.create(o, { constructor: { value: s } });
                        s.prototype = l;
                        var u = new Ke(h, s, l, c, r, a, n, d);
                        u.baseClass &&
                          ((u.baseClass.__derivedClasses ??= []),
                          u.baseClass.__derivedClasses.push(u));
                        var g = new it(h, u, !0, !1, !1),
                          y = new it(h + "*", u, !1, !1, !1),
                          f = new it(h + " const*", u, !1, !0, !1);
                        return (
                          (Ne[e] = { pointerType: y, constPointerType: f }),
                          st(p, s),
                          [g, y, f]
                        );
                      });
                  },
                  f: (e, t, r, i, o, a, s, n, l) => {
                    var d = gt(r, i);
                    (t = Re(t)),
                      (t = yt(t)),
                      (a = dt(o, a)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`;
                        function o() {
                          ht(`Cannot call ${i} due to unbound types`, d);
                        }
                        t.startsWith("@@") && (t = Symbol[t.substring(2)]);
                        var n = e.registeredClass.constructor;
                        return (
                          void 0 === n[t]
                            ? ((o.argCount = r - 1), (n[t] = o))
                            : (Ze(n, t, i), (n[t].overloadTable[r - 1] = o)),
                          Xe([], d, (o) => {
                            var l = [o[0], null].concat(o.slice(1)),
                              d = ct(i, l, null, a, s);
                            if (
                              (void 0 === n[t].overloadTable
                                ? ((d.argCount = r - 1), (n[t] = d))
                                : (n[t].overloadTable[r - 1] = d),
                              e.registeredClass.__derivedClasses)
                            )
                              for (const r of e.registeredClass
                                .__derivedClasses)
                                r.constructor.hasOwnProperty(t) ||
                                  (r.constructor[t] = d);
                            return [];
                          }),
                          []
                        );
                      });
                  },
                  e: (e, t, r, i, o, a) => {
                    var s = gt(t, r);
                    (o = dt(i, o)),
                      Xe([], [e], (e) => {
                        var r = `constructor ${(e = e[0]).name}`;
                        if (
                          (void 0 === e.registeredClass.constructor_body &&
                            (e.registeredClass.constructor_body = []),
                          void 0 !== e.registeredClass.constructor_body[t - 1])
                        )
                          throw new ne(
                            `Cannot register multiple constructors with identical number of parameters (${
                              t - 1
                            }) for class '${
                              e.name
                            }'! Overload resolution is currently only performed using the parameter count, not actual type info!`
                          );
                        return (
                          (e.registeredClass.constructor_body[t - 1] = () => {
                            ht(
                              `Cannot construct ${e.name} due to unbound types`,
                              s
                            );
                          }),
                          Xe(
                            [],
                            s,
                            (i) => (
                              i.splice(1, 0, null),
                              (e.registeredClass.constructor_body[t - 1] = ct(
                                r,
                                i,
                                null,
                                o,
                                a
                              )),
                              []
                            )
                          ),
                          []
                        );
                      });
                  },
                  a: (e, t, r, i, o, a, s, n, l, d) => {
                    var h = gt(r, i);
                    (t = Re(t)),
                      (t = yt(t)),
                      (a = dt(o, a)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`;
                        function o() {
                          ht(`Cannot call ${i} due to unbound types`, h);
                        }
                        t.startsWith("@@") && (t = Symbol[t.substring(2)]),
                          n && e.registeredClass.pureVirtualFunctions.push(t);
                        var l = e.registeredClass.instancePrototype,
                          d = l[t];
                        return (
                          void 0 === d ||
                          (void 0 === d.overloadTable &&
                            d.className !== e.name &&
                            d.argCount === r - 2)
                            ? ((o.argCount = r - 2),
                              (o.className = e.name),
                              (l[t] = o))
                            : (Ze(l, t, i), (l[t].overloadTable[r - 2] = o)),
                          Xe([], h, (o) => {
                            var n = ct(i, o, e, a, s);
                            return (
                              void 0 === l[t].overloadTable
                                ? ((n.argCount = r - 2), (l[t] = n))
                                : (l[t].overloadTable[r - 2] = n),
                              []
                            );
                          }),
                          []
                        );
                      });
                  },
                  b: (e, t, r, i, o, a, s, n, l, d) => {
                    (t = Re(t)),
                      (o = dt(i, o)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`,
                          h = {
                            get() {
                              ht(`Cannot access ${i} due to unbound types`, [
                                r,
                                s,
                              ]);
                            },
                            enumerable: !0,
                            configurable: !0,
                          };
                        return (
                          (h.set = l
                            ? () =>
                                ht(`Cannot access ${i} due to unbound types`, [
                                  r,
                                  s,
                                ])
                            : (e) => Ae(i + " is a read-only property")),
                          Object.defineProperty(
                            e.registeredClass.instancePrototype,
                            t,
                            h
                          ),
                          Xe([], l ? [r, s] : [r], (r) => {
                            var s = r[0],
                              h = {
                                get() {
                                  var t = ft(this, e, i + " getter");
                                  return s.fromWireType(o(a, t));
                                },
                                enumerable: !0,
                              };
                            if (l) {
                              l = dt(n, l);
                              var u = r[1];
                              h.set = function (t) {
                                var r = ft(this, e, i + " setter"),
                                  o = [];
                                l(d, r, u.toWireType(o, t)), ut(o);
                              };
                            }
                            return (
                              Object.defineProperty(
                                e.registeredClass.instancePrototype,
                                t,
                                h
                              ),
                              []
                            );
                          }),
                          []
                        );
                      });
                  },
                  Ka: (e) => Ge(e, mt),
                  j: (e, t, r, i) => {
                    function o() {}
                    (t = Re(t)),
                      (o.values = {}),
                      Ge(e, {
                        name: t,
                        constructor: o,
                        fromWireType: function (e) {
                          return this.constructor.values[e];
                        },
                        toWireType: (e, t) => t.value,
                        argPackAdvance: 8,
                        readValueFromPointer: St(t, r, i),
                        destructorFunction: null,
                      }),
                      qe(t, o);
                  },
                  d: (e, t, r) => {
                    var i = Oe(e, "enum");
                    t = Re(t);
                    var o = i.constructor,
                      a = Object.create(i.constructor.prototype, {
                        value: { value: r },
                        constructor: {
                          value: Ce(`${i.name}_${t}`, function () {}),
                        },
                      });
                    (o.values[r] = a), (o[t] = a);
                  },
                  Q: (e, t, r) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType: (e) => e,
                      toWireType: (e, t) => t,
                      argPackAdvance: 8,
                      readValueFromPointer: Ct(t, r),
                      destructorFunction: null,
                    });
                  },
                  h: (e, t, r, i, o, a, s, n) => {
                    var l = gt(t, r);
                    (e = Re(e)),
                      (e = yt(e)),
                      (o = dt(i, o)),
                      qe(
                        e,
                        function () {
                          ht(`Cannot call ${e} due to unbound types`, l);
                        },
                        t - 1
                      ),
                      Xe([], l, (r) => {
                        var i = [r[0], null].concat(r.slice(1));
                        return st(e, ct(e, i, null, o, a), t - 1), [];
                      });
                  },
                  q: (e, t, r, i, o) => {
                    (t = Re(t)), -1 === o && (o = 4294967295);
                    var a = (e) => e;
                    if (0 === i) {
                      var s = 32 - 8 * r;
                      a = (e) => (e << s) >>> s;
                    }
                    var n = t.includes("unsigned");
                    Ge(e, {
                      name: t,
                      fromWireType: a,
                      toWireType: n
                        ? function (e, t) {
                            return this.name, t >>> 0;
                          }
                        : function (e, t) {
                            return this.name, t;
                          },
                      argPackAdvance: 8,
                      readValueFromPointer: bt(t, r, 0 !== i),
                      destructorFunction: null,
                    });
                  },
                  k: (e, t, r) => {
                    var i = [
                      Int8Array,
                      Uint8Array,
                      Int16Array,
                      Uint16Array,
                      Int32Array,
                      Uint32Array,
                      Float32Array,
                      Float64Array,
                    ][t];
                    function o(e) {
                      var t = b[e >> 2],
                        r = b[(e + 4) >> 2];
                      return new i(v.buffer, r, t);
                    }
                    Ge(
                      e,
                      {
                        name: (r = Re(r)),
                        fromWireType: o,
                        argPackAdvance: 8,
                        readValueFromPointer: o,
                      },
                      { ignoreDuplicateRegistrations: !0 }
                    );
                  },
                  La: (e, t) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType(e) {
                        for (
                          var t, r = b[e >> 2], i = e + 4, o = i, a = 0;
                          a <= r;
                          ++a
                        ) {
                          var s = i + a;
                          if (a == r || 0 == m[s]) {
                            var n = Se(o, s - o);
                            void 0 === t
                              ? (t = n)
                              : ((t += String.fromCharCode(0)), (t += n)),
                              (o = s + 1);
                          }
                        }
                        return Is(e), t;
                      },
                      toWireType(e, t) {
                        var r;
                        t instanceof ArrayBuffer && (t = new Uint8Array(t));
                        var i = "string" == typeof t;
                        i ||
                          t instanceof Uint8Array ||
                          t instanceof Uint8ClampedArray ||
                          t instanceof Int8Array ||
                          Ae("Cannot pass non-string to std::string"),
                          (r = i ? oe(t) : t.length);
                        var o = Os(4 + r + 1),
                          a = o + 4;
                        if (((b[o >> 2] = r), i)) xt(t, a, r + 1);
                        else if (i)
                          for (var s = 0; s < r; ++s) {
                            var n = t.charCodeAt(s);
                            n > 255 &&
                              (Is(a),
                              Ae(
                                "String has UTF-16 code units that do not fit in 8 bits"
                              )),
                              (m[a + s] = n);
                          }
                        else for (s = 0; s < r; ++s) m[a + s] = t[s];
                        return null !== e && e.push(Is, o), o;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: rt,
                      destructorFunction(e) {
                        Is(e);
                      },
                    });
                  },
                  I: (e, t, r) => {
                    var i, o, a, s;
                    (r = Re(r)),
                      2 === t
                        ? ((i = Tt), (o = Et), (s = Rt), (a = (e) => P[e >> 1]))
                        : 4 === t &&
                          ((i = Dt),
                          (o = wt),
                          (s = Mt),
                          (a = (e) => b[e >> 2])),
                      Ge(e, {
                        name: r,
                        fromWireType: (e) => {
                          for (
                            var r, o = b[e >> 2], s = e + 4, n = 0;
                            n <= o;
                            ++n
                          ) {
                            var l = e + 4 + n * t;
                            if (n == o || 0 == a(l)) {
                              var d = i(s, l - s);
                              void 0 === r
                                ? (r = d)
                                : ((r += String.fromCharCode(0)), (r += d)),
                                (s = l + t);
                            }
                          }
                          return Is(e), r;
                        },
                        toWireType: (e, i) => {
                          "string" != typeof i &&
                            Ae(
                              `Cannot pass non-string to C++ string type ${r}`
                            );
                          var a = s(i),
                            n = Os(4 + a + t);
                          return (
                            (b[n >> 2] = a / t),
                            o(i, n + 4, a + t),
                            null !== e && e.push(Is, n),
                            n
                          );
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: rt,
                        destructorFunction(e) {
                          Is(e);
                        },
                      });
                  },
                  Na: (e, t) => {
                    Ge(e, {
                      isVoid: !0,
                      name: (t = Re(t)),
                      argPackAdvance: 0,
                      fromWireType: () => {},
                      toWireType: (e, t) => {},
                    });
                  },
                  Xa: function (e) {
                    if (vs.xhrs.has(e)) {
                      var t = vs.xhrs.get(e);
                      vs.xhrs.free(e),
                        t.readyState > 0 && t.readyState < 4 && t.abort();
                    }
                  },
                  nb: () => {
                    throw 1 / 0;
                  },
                  w: (e, t, r, i, o) => {
                    var a, s;
                    return (e = Ot[e])(
                      (t = Te.toValue(t)),
                      t[(r = void 0 === (s = Lt[(a = r)]) ? Re(a) : s)],
                      i,
                      o
                    );
                  },
                  Ia: vt,
                  v: (e, t, r) => {
                    var i = ((e, t) => {
                        for (var r = new Array(e), i = 0; i < e; ++i)
                          r[i] = Oe(b[(t + 4 * i) >> 2], "parameter " + i);
                        return r;
                      })(e, t),
                      o = i.shift();
                    e--;
                    var a,
                      s,
                      n = new Array(e),
                      l = `methodCaller<(${i
                        .map((e) => e.name)
                        .join(", ")}) => ${o.name}>`;
                    return (
                      (a = Ce(l, (t, a, s, l) => {
                        for (var d = 0, h = 0; h < e; ++h)
                          (n[h] = i[h].readValueFromPointer(l + d)),
                            (d += i[h].argPackAdvance);
                        var u = 1 === r ? It(a, n) : a.apply(t, n);
                        return ((e, t, r) => {
                          var i = [],
                            o = e.toWireType(i, r);
                          return i.length && (b[t >> 2] = Te.toHandle(i)), o;
                        })(o, s, u);
                      })),
                      (s = Ot.length),
                      Ot.push(a),
                      s
                    );
                  },
                  Ga: (e) => {
                    var t = Te.toValue(e);
                    ut(t), vt(e);
                  },
                  p: (e, t) => {
                    var r = (e = Oe(
                      e,
                      "_emval_take_value"
                    )).readValueFromPointer(t);
                    return Te.toHandle(r);
                  },
                  ib: function (e, t, r) {
                    var i = Vt(e, t),
                      o = new Date(1e3 * i);
                    (C[r >> 2] = o.getSeconds()),
                      (C[(r + 4) >> 2] = o.getMinutes()),
                      (C[(r + 8) >> 2] = o.getHours()),
                      (C[(r + 12) >> 2] = o.getDate()),
                      (C[(r + 16) >> 2] = o.getMonth()),
                      (C[(r + 20) >> 2] = o.getFullYear() - 1900),
                      (C[(r + 24) >> 2] = o.getDay());
                    var a =
                      0 |
                      ((e) => {
                        var t;
                        return (
                          ((t = e.getFullYear()) % 4 != 0 ||
                          (t % 100 == 0 && t % 400 != 0)
                            ? _t
                            : kt)[e.getMonth()] +
                          e.getDate() -
                          1
                        );
                      })(o);
                    (C[(r + 28) >> 2] = a),
                      (C[(r + 36) >> 2] = -60 * o.getTimezoneOffset());
                    var s = new Date(o.getFullYear(), 0, 1),
                      n = new Date(o.getFullYear(), 6, 1).getTimezoneOffset(),
                      l = s.getTimezoneOffset(),
                      d =
                        0 | (n != l && o.getTimezoneOffset() == Math.min(l, n));
                    C[(r + 32) >> 2] = d;
                  },
                  pb: (e, t, r, i) => {
                    var o = new Date().getFullYear(),
                      a = new Date(o, 0, 1),
                      s = new Date(o, 6, 1),
                      n = a.getTimezoneOffset(),
                      l = s.getTimezoneOffset(),
                      d = Math.max(n, l);
                    (b[e >> 2] = 60 * d), (C[t >> 2] = Number(n != l));
                    var h = (e) => {
                        var t = e >= 0 ? "-" : "+",
                          r = Math.abs(e);
                        return `UTC${t}${String(Math.floor(r / 60)).padStart(
                          2,
                          "0"
                        )}${String(r % 60).padStart(2, "0")}`;
                      },
                      u = h(n),
                      c = h(l);
                    l < n
                      ? (xt(u, r, 17), xt(c, i, 17))
                      : (xt(u, i, 17), xt(c, r, 17));
                  },
                  lb: function (e, t, r, i) {
                    var o, a;
                    if ((Vt(t, r), !((a = e) >= 0 && a <= 3))) return 28;
                    o = 0 === e ? Bt() : Nt();
                    var s = Math.round(1e3 * o * 1e3);
                    return (
                      (F = [
                        s >>> 0,
                        ((B = s),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[i >> 2] = F[0]),
                      (C[(i + 4) >> 2] = F[1]),
                      0
                    );
                  },
                  nh: (e) =>
                    12448 == e
                      ? (Ut.setErrorCode(12288), 1)
                      : (Ut.setErrorCode(12300), 0),
                  qh: (e, t, r, i, o) => Ut.chooseConfig(e, t, r, i, o),
                  eh: (e, t, r, i) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    for (var o = 1; ; ) {
                      var a = C[i >> 2];
                      if (12440 != a) {
                        if (12344 == a) break;
                        return Ut.setErrorCode(12292), 0;
                      }
                      (o = C[(i + 4) >> 2]), (i += 8);
                    }
                    return o < 2 || o > 3
                      ? (Ut.setErrorCode(12293), 0)
                      : ((Ut.contextAttributes.majorVersion = o - 1),
                        (Ut.contextAttributes.minorVersion = 0),
                        (Ut.context = Zt.createContext(
                          s.canvas,
                          Ut.contextAttributes
                        )),
                        0 != Ut.context
                          ? (Ut.setErrorCode(12288),
                            Zt.makeContextCurrent(Ut.context),
                            (Wt.useWebGL = !0),
                            Wt.moduleContextCreatedCallbacks.forEach((e) =>
                              e()
                            ),
                            Zt.makeContextCurrent(null),
                            62004)
                          : (Ut.setErrorCode(12297), 0));
                  },
                  gh: (e, t, r, i) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62002 != t
                      ? (Ut.setErrorCode(12293), 0)
                      : (Ut.setErrorCode(12288), 62006),
                  fh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62004 != t
                      ? (Ut.setErrorCode(12294), 0)
                      : (Zt.deleteContext(Ut.context),
                        Ut.setErrorCode(12288),
                        Ut.currentContext == t && (Ut.currentContext = 0),
                        1),
                  hh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62006 != t
                      ? (Ut.setErrorCode(12301), 1)
                      : (Ut.currentReadSurface == t &&
                          (Ut.currentReadSurface = 0),
                        Ut.currentDrawSurface == t &&
                          (Ut.currentDrawSurface = 0),
                        Ut.setErrorCode(12288),
                        1),
                  rh: (e, t, r, i) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if (62002 != t) return Ut.setErrorCode(12293), 0;
                    if (!i) return Ut.setErrorCode(12300), 0;
                    switch ((Ut.setErrorCode(12288), r)) {
                      case 12320:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.alpha ? 32 : 24), 1
                        );
                      case 12321:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.alpha ? 8 : 0), 1
                        );
                      case 12322:
                      case 12323:
                      case 12324:
                        return (C[i >> 2] = 8), 1;
                      case 12325:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.depth ? 24 : 0), 1
                        );
                      case 12326:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.stencil ? 8 : 0), 1
                        );
                      case 12327:
                      case 12335:
                      case 12340:
                        return (C[i >> 2] = 12344), 1;
                      case 12328:
                        return (C[i >> 2] = 62002), 1;
                      case 12329:
                      case 12333:
                      case 12334:
                      case 12345:
                      case 12346:
                      case 12347:
                      case 12349:
                      case 12350:
                      case 12354:
                        return (C[i >> 2] = 0), 1;
                      case 12330:
                      case 12332:
                        return (C[i >> 2] = 4096), 1;
                      case 12331:
                        return (C[i >> 2] = 16777216), 1;
                      case 12337:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.antialias ? 4 : 0),
                          1
                        );
                      case 12338:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.antialias ? 1 : 0),
                          1
                        );
                      case 12339:
                      case 12352:
                        return (C[i >> 2] = 4), 1;
                      case 12341:
                      case 12342:
                      case 12343:
                        return (C[i >> 2] = -1), 1;
                      case 12348:
                        return (C[i >> 2] = 1), 1;
                      case 12351:
                        return (C[i >> 2] = 12430), 1;
                      default:
                        return Ut.setErrorCode(12292), 0;
                    }
                  },
                  Aa: (e) => (
                    Ut.setErrorCode(12288), 0 != e && 1 != e ? 0 : 62e3
                  ),
                  dh: () => Ut.errorCode,
                  oh: (e, t, r) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : (t && (C[t >> 2] = 1),
                        r && (C[r >> 2] = 4),
                        (Ut.defaultDisplayInitialized = !0),
                        Ut.setErrorCode(12288),
                        1),
                  ih: (e, t, r, i) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 0 != i && 62004 != i
                      ? (Ut.setErrorCode(12294), 0)
                      : (0 != r && 62006 != r) || (0 != t && 62006 != t)
                      ? (Ut.setErrorCode(12301), 0)
                      : (Zt.makeContextCurrent(i ? Ut.context : null),
                        (Ut.currentContext = i),
                        (Ut.currentDrawSurface = t),
                        (Ut.currentReadSurface = r),
                        Ut.setErrorCode(12288),
                        1),
                  ch: (e, t) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if ((Ut.setErrorCode(12288), Ut.stringCache[t]))
                      return Ut.stringCache[t];
                    var r;
                    switch (t) {
                      case 12371:
                        r = qt("Emscripten");
                        break;
                      case 12372:
                        r = qt("1.4 Emscripten EGL");
                        break;
                      case 12373:
                        r = qt("");
                        break;
                      case 12429:
                        r = qt("OpenGL_ES");
                        break;
                      default:
                        return Ut.setErrorCode(12300), 0;
                    }
                    return (Ut.stringCache[t] = r), r;
                  },
                  jh: (e, t) => {
                    if (Ut.defaultDisplayInitialized)
                      if (pt) {
                        if (!pt.isContextLost())
                          return Ut.setErrorCode(12288), 1;
                        Ut.setErrorCode(12302);
                      } else Ut.setErrorCode(12290);
                    else Ut.setErrorCode(12289);
                    return 0;
                  },
                  kh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : (0 == t ? Qt(0, 0) : Qt(1, t),
                        Ut.setErrorCode(12288),
                        1),
                  ph: (e) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : ((Ut.currentContext = 0),
                        (Ut.currentReadSurface = 0),
                        (Ut.currentDrawSurface = 0),
                        (Ut.defaultDisplayInitialized = !1),
                        Ut.setErrorCode(12288),
                        1),
                  mh: () => (Ut.setErrorCode(12288), 1),
                  lh: (e) => (Ut.setErrorCode(12288), 1),
                  A: (e, t, r) =>
                    ((e, t, r) => {
                      var i = tr(t, r);
                      return z[e](...i);
                    })(e, t, r),
                  m: (e, t, r) => rr(e, t, r),
                  Fa: (e, t, r) => rr(e, t, r),
                  Oa: () => {
                    Jt.pause(), (Jt.func = null);
                  },
                  zb: Bt,
                  Zg: () => {
                    if (!ir.fullscreenEnabled()) return -1;
                    ir.removeDeferredCalls(yr);
                    var e = ar[1];
                    if (e.exitFullscreen)
                      e.fullscreenElement && e.exitFullscreen();
                    else {
                      if (!e.webkitExitFullscreen) return -1;
                      e.webkitFullscreenElement && e.webkitExitFullscreen();
                    }
                    return 0;
                  },
                  ah: () => (
                    ir.removeDeferredCalls(fr),
                    document.exitPointerLock
                      ? (document.exitPointerLock(), 0)
                      : -1
                  ),
                  z: () => devicePixelRatio,
                  u: (e, t, r) => {
                    if (!(e = sr(e))) return -4;
                    var i = gr(e);
                    return (A[t >> 3] = i.width), (A[r >> 3] = i.height), 0;
                  },
                  Da: (e, t) =>
                    e < 0 || e >= ir.lastGamepadState.length
                      ? -5
                      : ir.lastGamepadState[e]
                      ? (vr(t, ir.lastGamepadState[e]), 0)
                      : -7,
                  Y: Nt,
                  sh: () => ir.lastGamepadState.length,
                  bh: (e, t) => {
                    (C[e >> 2] = screen.width), (C[t >> 2] = screen.height);
                  },
                  Dg: Sr,
                  Cg: Cr,
                  ud: (e, t) => {
                    pt.beginQuery(e, Zt.queries[t]);
                  },
                  Vg: (e, t) => {
                    pt.disjointTimerQueryExt.beginQueryEXT(e, Zt.queries[t]);
                  },
                  $c: (e) => pt.beginTransformFeedback(e),
                  Bg: xr,
                  Ag: Tr,
                  Yc: (e, t, r) => {
                    pt.bindBufferBase(e, t, Zt.buffers[r]);
                  },
                  Zc: (e, t, r, i, o) => {
                    pt.bindBufferRange(e, t, Zt.buffers[r], i, o);
                  },
                  zg: Rr,
                  yg: (e, t) => {
                    pt.bindRenderbuffer(e, Zt.renderbuffers[t]);
                  },
                  bc: (e, t) => {
                    pt.bindSampler(e, Zt.samplers[t]);
                  },
                  xg: wr,
                  Vb: (e, t) => {
                    pt.bindTransformFeedback(e, Zt.transformFeedbacks[t]);
                  },
                  fd: Lr,
                  Mg: Ir,
                  wg: _r,
                  vg: Nr,
                  ug: (e, t) => pt.blendEquationSeparate(e, t),
                  tg: (e, t) => pt.blendFunc(e, t),
                  sg: Fr,
                  id: (e, t, r, i, o, a, s, n, l, d) =>
                    pt.blitFramebuffer(e, t, r, i, o, a, s, n, l, d),
                  rg: Yr,
                  qg: (e, t, r, i) => {
                    Zt.currentContext.version >= 2
                      ? r && pt.bufferSubData(e, t, m, i, r)
                      : pt.bufferSubData(e, t, m.subarray(i, i + r));
                  },
                  pg: jr,
                  og: Gr,
                  Ac: (e, t, r, i) => pt.clearBufferfi(e, t, r, i),
                  Bc: (e, t, r) => {
                    pt.clearBufferfv(e, t, x, r >> 2);
                  },
                  Dc: (e, t, r) => {
                    pt.clearBufferiv(e, t, C, r >> 2);
                  },
                  Cc: (e, t, r) => {
                    pt.clearBufferuiv(e, t, b, r >> 2);
                  },
                  ng: Ur,
                  mg: (e) => pt.clearDepth(e),
                  lg: (e) => pt.clearStencil(e),
                  mc: (e, t, r, i) => {
                    var o = $r(r, i);
                    return pt.clientWaitSync(Zt.syncs[e], t, o);
                  },
                  Md: (e, t) => {
                    pt.extClipControl.clipControlEXT(e, t);
                  },
                  kg: qr,
                  jg: Jr,
                  ig: ei,
                  Ad: (e, t, r, i, o, a, s, n, l) => {
                    pt.currentPixelUnpackBufferBinding
                      ? pt.compressedTexImage3D(e, t, r, i, o, a, s, n, l)
                      : pt.compressedTexImage3D(e, t, r, i, o, a, s, m, l, n);
                  },
                  hg: (e, t, r, i, o, a, s, n, l) => {
                    if (Zt.currentContext.version >= 2)
                      return pt.currentPixelUnpackBufferBinding || !n
                        ? void pt.compressedTexSubImage2D(
                            e,
                            t,
                            r,
                            i,
                            o,
                            a,
                            s,
                            n,
                            l
                          )
                        : void pt.compressedTexSubImage2D(
                            e,
                            t,
                            r,
                            i,
                            o,
                            a,
                            s,
                            m,
                            l,
                            n
                          );
                    pt.compressedTexSubImage2D(
                      e,
                      t,
                      r,
                      i,
                      o,
                      a,
                      s,
                      m.subarray(l, l + n)
                    );
                  },
                  yd: (e, t, r, i, o, a, s, n, l, d, h) => {
                    pt.currentPixelUnpackBufferBinding
                      ? pt.compressedTexSubImage3D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          l,
                          d,
                          h
                        )
                      : pt.compressedTexSubImage3D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          l,
                          m,
                          h,
                          d
                        );
                  },
                  yc: (e, t, r, i, o) => pt.copyBufferSubData(e, t, r, i, o),
                  gg: (e, t, r, i, o, a, s, n) =>
                    pt.copyTexImage2D(e, t, r, i, o, a, s, n),
                  fg: (e, t, r, i, o, a, s, n) =>
                    pt.copyTexSubImage2D(e, t, r, i, o, a, s, n),
                  Bd: (e, t, r, i, o, a, s, n, l) =>
                    pt.copyTexSubImage3D(e, t, r, i, o, a, s, n, l),
                  cg: ri,
                  bg: oi,
                  ag: si,
                  $f: li,
                  _f: hi,
                  Zf: ci,
                  wd: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.queries[i];
                      o && (pt.deleteQuery(o), (Zt.queries[i] = null));
                    }
                  },
                  Xg: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.queries[i];
                      o &&
                        (pt.disjointTimerQueryExt.deleteQueryEXT(o),
                        (Zt.queries[i] = null));
                    }
                  },
                  Yf: gi,
                  dc: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.samplers[i];
                      o &&
                        (pt.deleteSampler(o),
                        (o.name = 0),
                        (Zt.samplers[i] = null));
                    }
                  },
                  Xf: fi,
                  nc: (e) => {
                    if (e) {
                      var t = Zt.syncs[e];
                      t
                        ? (pt.deleteSync(t), (t.name = 0), (Zt.syncs[e] = null))
                        : Zt.recordError(1281);
                    }
                  },
                  Wf: mi,
                  Ub: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.transformFeedbacks[i];
                      o &&
                        (pt.deleteTransformFeedback(o),
                        (o.name = 0),
                        (Zt.transformFeedbacks[i] = null));
                    }
                  },
                  ed: Pi,
                  Lg: bi,
                  Vf: Ai,
                  Tf: Ei,
                  Sf: (e, t) => pt.depthRange(e, t),
                  Rf: Di,
                  Qf: Mi,
                  Pf: (e) => {
                    pt.disableVertexAttribArray(e);
                  },
                  Of: Oi,
                  rc: ki,
                  Gg: Vi,
                  Eb: Bi,
                  Id: Hi,
                  Fb: zi,
                  qd: Gi,
                  Gd: Ui,
                  Hg: Zi,
                  Nf: Ki,
                  qc: Qi,
                  Fg: to,
                  Cb: io,
                  Db: ao,
                  Hd: no,
                  Ed: (e, t, r, i, o, a) => {
                    qi(e, i, o, a);
                  },
                  Mf: ho,
                  Lf: co,
                  td: (e) => pt.endQuery(e),
                  Tg: (e) => {
                    pt.disjointTimerQueryExt.endQueryEXT(e);
                  },
                  _c: () => pt.endTransformFeedback(),
                  pc: (e, t) => {
                    var r = pt.fenceSync(e, t);
                    if (r) {
                      var i = Zt.getNewId(Zt.syncs);
                      return (r.name = i), (Zt.syncs[i] = r), i;
                    }
                    return 0;
                  },
                  Kf: () => pt.finish(),
                  Jf: () => pt.flush(),
                  If: (e, t, r, i) => {
                    pt.framebufferRenderbuffer(e, t, r, Zt.renderbuffers[i]);
                  },
                  Hf: go,
                  gd: (e, t, r, i, o) => {
                    pt.framebufferTextureLayer(e, t, Zt.textures[r], i, o);
                  },
                  Gf: fo,
                  Ff: mo,
                  Df: Po,
                  xd: (e, t) => {
                    Zt.genObject(e, t, "createQuery", Zt.queries);
                  },
                  Yg: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = pt.disjointTimerQueryExt.createQueryEXT();
                      if (!i) {
                        for (Zt.recordError(1282); r < e; )
                          C[(t + 4 * r++) >> 2] = 0;
                        return;
                      }
                      var o = Zt.getNewId(Zt.queries);
                      (i.name = o),
                        (Zt.queries[o] = i),
                        (C[(t + 4 * r) >> 2] = o);
                    }
                  },
                  Cf: (e, t) => {
                    Zt.genObject(e, t, "createRenderbuffer", Zt.renderbuffers);
                  },
                  gc: (e, t) => {
                    Zt.genObject(e, t, "createSampler", Zt.samplers);
                  },
                  Bf: bo,
                  Tb: (e, t) => {
                    Zt.genObject(
                      e,
                      t,
                      "createTransformFeedback",
                      Zt.transformFeedbacks
                    );
                  },
                  cd: Ao,
                  Kg: Eo,
                  Ef: Do,
                  Af: Lo,
                  zf: Io,
                  tc: (e, t, r, i, o) => {
                    e = Zt.programs[e];
                    var a = pt.getActiveUniformBlockName(e, t);
                    if (a)
                      if (o && r > 0) {
                        var s = xt(a, o, r);
                        i && (C[i >> 2] = s);
                      } else i && (C[i >> 2] = 0);
                  },
                  uc: (e, t, r, i) => {
                    if (i)
                      if (((e = Zt.programs[e]), 35393 != r)) {
                        var o = pt.getActiveUniformBlockParameter(e, t, r);
                        if (null !== o)
                          if (35395 == r)
                            for (var a = 0; a < o.length; a++)
                              C[(i + 4 * a) >> 2] = o[a];
                          else C[i >> 2] = o;
                      } else {
                        var s = pt.getActiveUniformBlockName(e, t);
                        C[i >> 2] = s.length + 1;
                      }
                    else Zt.recordError(1281);
                  },
                  wc: (e, t, r, i, o) => {
                    if (o)
                      if (t > 0 && 0 == r) Zt.recordError(1281);
                      else {
                        e = Zt.programs[e];
                        for (var a = [], s = 0; s < t; s++)
                          a.push(C[(r + 4 * s) >> 2]);
                        var n = pt.getActiveUniforms(e, a, i);
                        if (n) {
                          var l = n.length;
                          for (s = 0; s < l; s++) C[(o + 4 * s) >> 2] = n[s];
                        }
                      }
                    else Zt.recordError(1281);
                  },
                  yf: (e, t, r, i) => {
                    var o = pt.getAttachedShaders(Zt.programs[e]),
                      a = o.length;
                    a > t && (a = t), (C[r >> 2] = a);
                    for (var s = 0; s < a; ++s) {
                      var n = Zt.shaders.indexOf(o[s]);
                      C[(i + 4 * s) >> 2] = n;
                    }
                  },
                  xf: (e, t) => pt.getAttribLocation(Zt.programs[e], Se(t)),
                  wf: (e, t) => Vo(e, t, 4),
                  hc: (e, t, r) => {
                    r
                      ? ko(r, pt.getBufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  vf: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getBufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  uf: () => {
                    var e = pt.getError() || Zt.lastError;
                    return (Zt.lastError = 0), e;
                  },
                  tf: (e, t) => Vo(e, t, 2),
                  Mc: (e, t) => pt.getFragDataLocation(Zt.programs[e], Se(t)),
                  sf: (e, t, r, i) => {
                    var o = pt.getFramebufferAttachmentParameter(e, t, r);
                    (o instanceof WebGLRenderbuffer ||
                      o instanceof WebGLTexture) &&
                      (o = 0 | o.name),
                      (C[i >> 2] = o);
                  },
                  ic: (e, t, r) => No(e, t, r, 1),
                  kc: (e, t) => {
                    Vo(e, t, 1);
                  },
                  ad: (e, t, r) => No(e, t, r, 0),
                  rf: Fo,
                  Ib: (e, t, r, i, o) => {
                    if (i < 0) Zt.recordError(1281);
                    else if (o) {
                      var a = pt.getInternalformatParameter(e, t, r);
                      if (null !== a)
                        for (var s = 0; s < a.length && s < i; ++s)
                          C[(o + 4 * s) >> 2] = a[s];
                    } else Zt.recordError(1281);
                  },
                  Pb: (e, t, r, i, o) => {
                    Zt.recordError(1282);
                  },
                  pf: Yo,
                  qf: jo,
                  Og: Go,
                  Qg: Uo,
                  Ng: $o,
                  rd: (e, t, r) => {
                    if (r) {
                      var i,
                        o = Zt.queries[e],
                        a = pt.getQueryParameter(o, t);
                      (i = "boolean" == typeof a ? (a ? 1 : 0) : a),
                        (C[r >> 2] = i);
                    } else Zt.recordError(1281);
                  },
                  Pg: Zo,
                  sd: (e, t, r) => {
                    r ? (C[r >> 2] = pt.getQuery(e, t)) : Zt.recordError(1281);
                  },
                  Rg: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.disjointTimerQueryExt.getQueryEXT(e, t))
                      : Zt.recordError(1281);
                  },
                  of: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getRenderbufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  Xb: (e, t, r) => {
                    r
                      ? (x[r >> 2] = pt.getSamplerParameter(Zt.samplers[e], t))
                      : Zt.recordError(1281);
                  },
                  Yb: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getSamplerParameter(Zt.samplers[e], t))
                      : Zt.recordError(1281);
                  },
                  mf: Ko,
                  lf: (e, t, r, i) => {
                    var o = pt.getShaderPrecisionFormat(e, t);
                    (C[r >> 2] = o.rangeMin),
                      (C[(r + 4) >> 2] = o.rangeMax),
                      (C[i >> 2] = o.precision);
                  },
                  kf: (e, t, r, i) => {
                    var o = pt.getShaderSource(Zt.shaders[e]);
                    if (o) {
                      var a = t > 0 && i ? xt(o, i, t) : 0;
                      r && (C[r >> 2] = a);
                    }
                  },
                  nf: Qo,
                  jf: ta,
                  zc: (e, t) => {
                    if (Zt.currentContext.version < 2)
                      return Zt.recordError(1282), 0;
                    var r = Zt.stringiCache[e];
                    if (r)
                      return t < 0 || t >= r.length
                        ? (Zt.recordError(1281), 0)
                        : r[t];
                    if (7939 === e) {
                      var i = _o().map(qt);
                      return (
                        (r = Zt.stringiCache[e] = i),
                        t < 0 || t >= r.length
                          ? (Zt.recordError(1281), 0)
                          : r[t]
                      );
                    }
                    return Zt.recordError(1280), 0;
                  },
                  jc: (e, t, r, i, o) => {
                    if (r < 0) Zt.recordError(1281);
                    else if (o) {
                      var a = pt.getSyncParameter(Zt.syncs[e], t);
                      null !== a && ((C[o >> 2] = a), i && (C[i >> 2] = 1));
                    } else Zt.recordError(1281);
                  },
                  hf: (e, t, r) => {
                    r
                      ? (x[r >> 2] = pt.getTexParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  gf: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getTexParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  Wc: (e, t, r, i, o, a, s) => {
                    e = Zt.programs[e];
                    var n = pt.getTransformFeedbackVarying(e, t);
                    if (n) {
                      if (s && r > 0) {
                        var l = xt(n.name, s, r);
                        i && (C[i >> 2] = l);
                      } else i && (C[i >> 2] = 0);
                      o && (C[o >> 2] = n.size), a && (C[a >> 2] = n.type);
                    }
                  },
                  vc: (e, t) => pt.getUniformBlockIndex(Zt.programs[e], Se(t)),
                  xc: (e, t, r, i) => {
                    if (i)
                      if (t > 0 && (0 == r || 0 == i)) Zt.recordError(1281);
                      else {
                        e = Zt.programs[e];
                        for (var o = [], a = 0; a < t; a++)
                          o.push(Se(C[(r + 4 * a) >> 2]));
                        var s = pt.getUniformIndices(e, o);
                        if (s) {
                          var n = s.length;
                          for (a = 0; a < n; a++) C[(i + 4 * a) >> 2] = s[a];
                        }
                      }
                    else Zt.recordError(1281);
                  },
                  df: aa,
                  ff: (e, t, r) => {
                    na(e, t, r, 2);
                  },
                  ef: (e, t, r) => {
                    na(e, t, r, 0);
                  },
                  Nc: (e, t, r) => na(e, t, r, 0),
                  Tc: ha,
                  Sc: ua,
                  af: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getVertexAttribOffset(e, t))
                      : Zt.recordError(1281);
                  },
                  cf: (e, t, r) => {
                    la(e, t, r, 2);
                  },
                  bf: (e, t, r) => {
                    la(e, t, r, 5);
                  },
                  $e: (e, t) => pt.hint(e, t),
                  Mb: (e, t, r) => {
                    for (var i = ji[t], o = 0; o < t; o++)
                      i[o] = C[(r + 4 * o) >> 2];
                    pt.invalidateFramebuffer(e, i);
                  },
                  Lb: (e, t, r, i, o, a, s) => {
                    for (var n = ji[t], l = 0; l < t; l++)
                      n[l] = C[(r + 4 * l) >> 2];
                    pt.invalidateSubFramebuffer(e, n, i, o, a, s);
                  },
                  _e: (e) => {
                    var t = Zt.buffers[e];
                    return t ? pt.isBuffer(t) : 0;
                  },
                  Ze: (e) => pt.isEnabled(e),
                  Ye: (e) => {
                    var t = Zt.framebuffers[e];
                    return t ? pt.isFramebuffer(t) : 0;
                  },
                  Xe: (e) => ((e = Zt.programs[e]) ? pt.isProgram(e) : 0),
                  vd: (e) => {
                    var t = Zt.queries[e];
                    return t ? pt.isQuery(t) : 0;
                  },
                  Wg: (e) => {
                    var t = Zt.queries[e];
                    return t ? pt.disjointTimerQueryExt.isQueryEXT(t) : 0;
                  },
                  Ve: (e) => {
                    var t = Zt.renderbuffers[e];
                    return t ? pt.isRenderbuffer(t) : 0;
                  },
                  cc: (e) => {
                    var t = Zt.samplers[e];
                    return t ? pt.isSampler(t) : 0;
                  },
                  Ue: (e) => {
                    var t = Zt.shaders[e];
                    return t ? pt.isShader(t) : 0;
                  },
                  oc: (e) => pt.isSync(Zt.syncs[e]),
                  Te: (e) => {
                    var t = Zt.textures[e];
                    return t ? pt.isTexture(t) : 0;
                  },
                  Sb: (e) => pt.isTransformFeedback(Zt.transformFeedbacks[e]),
                  bd: pa,
                  Ig: ga,
                  Se: fa,
                  Re: ma,
                  Rb: () => pt.pauseTransformFeedback(),
                  Qe: Pa,
                  Ld: (e, t) => {
                    pt.webglPolygonMode.polygonModeWEBGL(e, t);
                  },
                  Pe: (e, t) => pt.polygonOffset(e, t),
                  Nd: (e, t, r) => {
                    pt.extPolygonOffsetClamp.polygonOffsetClampEXT(e, t, r);
                  },
                  Ob: (e, t, r, i) => {
                    Zt.recordError(1280);
                  },
                  Nb: (e, t, r) => {
                    Zt.recordError(1280);
                  },
                  Sg: (e, t) => {
                    pt.disjointTimerQueryExt.queryCounterEXT(Zt.queries[e], t);
                  },
                  Fd: (e) => pt.readBuffer(e),
                  Oe: Ta,
                  Ne: () => {},
                  Me: (e, t, r, i) => pt.renderbufferStorage(e, t, r, i),
                  hd: (e, t, r, i, o) =>
                    pt.renderbufferStorageMultisample(e, t, r, i, o),
                  Qb: () => pt.resumeTransformFeedback(),
                  Ke: (e, t) => {
                    pt.sampleCoverage(e, !!t);
                  },
                  _b: (e, t, r) => {
                    pt.samplerParameterf(Zt.samplers[e], t, r);
                  },
                  Zb: (e, t, r) => {
                    var i = x[r >> 2];
                    pt.samplerParameterf(Zt.samplers[e], t, i);
                  },
                  ac: (e, t, r) => {
                    pt.samplerParameteri(Zt.samplers[e], t, r);
                  },
                  $b: (e, t, r) => {
                    var i = C[r >> 2];
                    pt.samplerParameteri(Zt.samplers[e], t, i);
                  },
                  Je: Ra,
                  Ie: (e, t, r, i, o) => {
                    Zt.recordError(1280);
                  },
                  He: wa,
                  Ge: (e, t, r) => pt.stencilFunc(e, t, r),
                  Fe: (e, t, r, i) => pt.stencilFuncSeparate(e, t, r, i),
                  Ee: (e) => pt.stencilMask(e),
                  De: (e, t) => pt.stencilMaskSeparate(e, t),
                  Ce: (e, t, r) => pt.stencilOp(e, t, r),
                  Be: (e, t, r, i) => pt.stencilOpSeparate(e, t, r, i),
                  ze: La,
                  Dd: (e, t, r, i, o, a, s, n, l, d) => {
                    if (pt.currentPixelUnpackBufferBinding)
                      pt.texImage3D(e, t, r, i, o, a, s, n, l, d);
                    else if (d) {
                      var h = Ca(l);
                      pt.texImage3D(e, t, r, i, o, a, s, n, l, h, ba(d, h));
                    } else pt.texImage3D(e, t, r, i, o, a, s, n, l, null);
                  },
                  ye: (e, t, r) => pt.texParameterf(e, t, r),
                  xe: (e, t, r) => {
                    var i = x[r >> 2];
                    pt.texParameterf(e, t, i);
                  },
                  we: Ia,
                  ve: (e, t, r) => {
                    var i = C[r >> 2];
                    pt.texParameteri(e, t, i);
                  },
                  Kb: (e, t, r, i, o) => pt.texStorage2D(e, t, r, i, o),
                  Jb: (e, t, r, i, o, a) => pt.texStorage3D(e, t, r, i, o, a),
                  ue: (e, t, r, i, o, a, s, n, l) => {
                    if (Zt.currentContext.version >= 2) {
                      if (pt.currentPixelUnpackBufferBinding)
                        return void pt.texSubImage2D(e, t, r, i, o, a, s, n, l);
                      if (l) {
                        var d = Ca(n);
                        return void pt.texSubImage2D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          d,
                          ba(l, d)
                        );
                      }
                    }
                    var h = l ? xa(n, s, o, a, l) : null;
                    pt.texSubImage2D(e, t, r, i, o, a, s, n, h);
                  },
                  Cd: (e, t, r, i, o, a, s, n, l, d, h) => {
                    if (pt.currentPixelUnpackBufferBinding)
                      pt.texSubImage3D(e, t, r, i, o, a, s, n, l, d, h);
                    else if (h) {
                      var u = Ca(d);
                      pt.texSubImage3D(
                        e,
                        t,
                        r,
                        i,
                        o,
                        a,
                        s,
                        n,
                        l,
                        d,
                        u,
                        ba(h, u)
                      );
                    } else pt.texSubImage3D(e, t, r, i, o, a, s, n, l, d, null);
                  },
                  Xc: (e, t, r, i) => {
                    e = Zt.programs[e];
                    for (var o = [], a = 0; a < t; a++)
                      o.push(Se(C[(r + 4 * a) >> 2]));
                    pt.transformFeedbackVaryings(e, o, i);
                  },
                  te: (e, t) => {
                    pt.uniform1f(sa(e), t);
                  },
                  se: Va,
                  re: Ba,
                  qe: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform1iv(sa(e), C, r >> 2, t);
                    else {
                      if (t <= 288)
                        for (var i = Fa[t], o = 0; o < t; ++o)
                          i[o] = C[(r + 4 * o) >> 2];
                      else i = C.subarray(r >> 2, (r + 4 * t) >> 2);
                      pt.uniform1iv(sa(e), i);
                    }
                  },
                  Lc: (e, t) => {
                    pt.uniform1ui(sa(e), t);
                  },
                  Hc: (e, t, r) => {
                    t && pt.uniform1uiv(sa(e), b, r >> 2, t);
                  },
                  oe: (e, t, r) => {
                    pt.uniform2f(sa(e), t, r);
                  },
                  ne: Ya,
                  me: (e, t, r) => {
                    pt.uniform2i(sa(e), t, r);
                  },
                  le: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform2iv(sa(e), C, r >> 2, 2 * t);
                    else {
                      if (t <= 144)
                        for (var i = Fa[(t *= 2)], o = 0; o < t; o += 2)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 8 * t) >> 2);
                      pt.uniform2iv(sa(e), i);
                    }
                  },
                  Kc: (e, t, r) => {
                    pt.uniform2ui(sa(e), t, r);
                  },
                  Gc: (e, t, r) => {
                    t && pt.uniform2uiv(sa(e), b, r >> 2, 2 * t);
                  },
                  ke: (e, t, r, i) => {
                    pt.uniform3f(sa(e), t, r, i);
                  },
                  je: ja,
                  ie: (e, t, r, i) => {
                    pt.uniform3i(sa(e), t, r, i);
                  },
                  he: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform3iv(sa(e), C, r >> 2, 3 * t);
                    else {
                      if (t <= 96)
                        for (var i = Fa[(t *= 3)], o = 0; o < t; o += 3)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]),
                            (i[o + 2] = C[(r + (4 * o + 8)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 12 * t) >> 2);
                      pt.uniform3iv(sa(e), i);
                    }
                  },
                  Jc: (e, t, r, i) => {
                    pt.uniform3ui(sa(e), t, r, i);
                  },
                  Fc: (e, t, r) => {
                    t && pt.uniform3uiv(sa(e), b, r >> 2, 3 * t);
                  },
                  ge: (e, t, r, i, o) => {
                    pt.uniform4f(sa(e), t, r, i, o);
                  },
                  fe: Ga,
                  de: (e, t, r, i, o) => {
                    pt.uniform4i(sa(e), t, r, i, o);
                  },
                  ce: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform4iv(sa(e), C, r >> 2, 4 * t);
                    else {
                      if (t <= 72)
                        for (var i = Fa[(t *= 4)], o = 0; o < t; o += 4)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]),
                            (i[o + 2] = C[(r + (4 * o + 8)) >> 2]),
                            (i[o + 3] = C[(r + (4 * o + 12)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 16 * t) >> 2);
                      pt.uniform4iv(sa(e), i);
                    }
                  },
                  Ic: (e, t, r, i, o) => {
                    pt.uniform4ui(sa(e), t, r, i, o);
                  },
                  Ec: (e, t, r) => {
                    t && pt.uniform4uiv(sa(e), b, r >> 2, 4 * t);
                  },
                  sc: (e, t, r) => {
                    (e = Zt.programs[e]), pt.uniformBlockBinding(e, t, r);
                  },
                  be: (e, t, r, i) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniformMatrix2fv(sa(e), !!r, x, i >> 2, 4 * t);
                    else {
                      if (t <= 72)
                        for (var o = ka[(t *= 4)], a = 0; a < t; a += 4)
                          (o[a] = x[(i + 4 * a) >> 2]),
                            (o[a + 1] = x[(i + (4 * a + 4)) >> 2]),
                            (o[a + 2] = x[(i + (4 * a + 8)) >> 2]),
                            (o[a + 3] = x[(i + (4 * a + 12)) >> 2]);
                      else o = x.subarray(i >> 2, (i + 16 * t) >> 2);
                      pt.uniformMatrix2fv(sa(e), !!r, o);
                    }
                  },
                  pd: (e, t, r, i) => {
                    t && pt.uniformMatrix2x3fv(sa(e), !!r, x, i >> 2, 6 * t);
                  },
                  md: (e, t, r, i) => {
                    t && pt.uniformMatrix2x4fv(sa(e), !!r, x, i >> 2, 8 * t);
                  },
                  ae: (e, t, r, i) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniformMatrix3fv(sa(e), !!r, x, i >> 2, 9 * t);
                    else {
                      if (t <= 32)
                        for (var o = ka[(t *= 9)], a = 0; a < t; a += 9)
                          (o[a] = x[(i + 4 * a) >> 2]),
                            (o[a + 1] = x[(i + (4 * a + 4)) >> 2]),
                            (o[a + 2] = x[(i + (4 * a + 8)) >> 2]),
                            (o[a + 3] = x[(i + (4 * a + 12)) >> 2]),
                            (o[a + 4] = x[(i + (4 * a + 16)) >> 2]),
                            (o[a + 5] = x[(i + (4 * a + 20)) >> 2]),
                            (o[a + 6] = x[(i + (4 * a + 24)) >> 2]),
                            (o[a + 7] = x[(i + (4 * a + 28)) >> 2]),
                            (o[a + 8] = x[(i + (4 * a + 32)) >> 2]);
                      else o = x.subarray(i >> 2, (i + 36 * t) >> 2);
                      pt.uniformMatrix3fv(sa(e), !!r, o);
                    }
                  },
                  nd: (e, t, r, i) => {
                    t && pt.uniformMatrix3x2fv(sa(e), !!r, x, i >> 2, 6 * t);
                  },
                  kd: (e, t, r, i) => {
                    t && pt.uniformMatrix3x4fv(sa(e), !!r, x, i >> 2, 12 * t);
                  },
                  $d: Ua,
                  ld: (e, t, r, i) => {
                    t && pt.uniformMatrix4x2fv(sa(e), !!r, x, i >> 2, 8 * t);
                  },
                  jd: (e, t, r, i) => {
                    t && pt.uniformMatrix4x3fv(sa(e), !!r, x, i >> 2, 12 * t);
                  },
                  _d: Za,
                  Zd: (e) => {
                    pt.validateProgram(Zt.programs[e]);
                  },
                  Yd: (e, t) => pt.vertexAttrib1f(e, t),
                  Xd: (e, t) => {
                    pt.vertexAttrib1f(e, x[t >> 2]);
                  },
                  Wd: (e, t, r) => pt.vertexAttrib2f(e, t, r),
                  Ud: (e, t) => {
                    pt.vertexAttrib2f(e, x[t >> 2], x[(t + 4) >> 2]);
                  },
                  Td: (e, t, r, i) => pt.vertexAttrib3f(e, t, r, i),
                  Sd: (e, t) => {
                    pt.vertexAttrib3f(
                      e,
                      x[t >> 2],
                      x[(t + 4) >> 2],
                      x[(t + 8) >> 2]
                    );
                  },
                  Rd: (e, t, r, i, o) => pt.vertexAttrib4f(e, t, r, i, o),
                  Qd: (e, t) => {
                    pt.vertexAttrib4f(
                      e,
                      x[t >> 2],
                      x[(t + 4) >> 2],
                      x[(t + 8) >> 2],
                      x[(t + 12) >> 2]
                    );
                  },
                  Wb: Ka,
                  Eg: Ja,
                  Gb: Qa,
                  Jd: es,
                  Hb: ts,
                  Rc: (e, t, r, i, o) => pt.vertexAttribI4i(e, t, r, i, o),
                  Pc: (e, t) => {
                    pt.vertexAttribI4i(
                      e,
                      C[t >> 2],
                      C[(t + 4) >> 2],
                      C[(t + 8) >> 2],
                      C[(t + 12) >> 2]
                    );
                  },
                  Qc: (e, t, r, i, o) => pt.vertexAttribI4ui(e, t, r, i, o),
                  Oc: (e, t) => {
                    pt.vertexAttribI4ui(
                      e,
                      b[t >> 2],
                      b[(t + 4) >> 2],
                      b[(t + 8) >> 2],
                      b[(t + 12) >> 2]
                    );
                  },
                  Vc: (e, t, r, i, o) => {
                    pt.vertexAttribIPointer(e, t, r, i, o);
                  },
                  Pd: is,
                  Od: as,
                  lc: (e, t, r, i) => {
                    var o = $r(r, i);
                    pt.waitSync(Zt.syncs[e], t, o);
                  },
                  P: () => 0,
                  fc: () => !0,
                  _g: (e, t, r) =>
                    ((e, t) =>
                      ir.fullscreenEnabled()
                        ? (e = sr(e))
                          ? e.requestFullscreen || e.webkitRequestFullscreen
                            ? ir.canPerformEventHandlerRequests()
                              ? yr(e, t)
                              : t.deferUntilInEventHandler
                              ? (ir.deferCall(yr, 1, [e, t]), 1)
                              : -2
                            : -3
                          : -4
                        : -1)(e, {
                      scaleMode: C[r >> 2],
                      canvasResolutionScaleMode: C[(r + 4) >> 2],
                      filteringMode: C[(r + 8) >> 2],
                      deferUntilInEventHandler: t,
                      canvasResizedCallback: C[(r + 12) >> 2],
                      canvasResizedCallbackUserData: C[(r + 16) >> 2],
                    }),
                  za: (e, t) =>
                    (e = sr(e))
                      ? e.requestPointerLock
                        ? ir.canPerformEventHandlerRequests()
                          ? fr(e)
                          : t
                          ? (ir.deferCall(fr, 2, [e]), 1)
                          : -2
                        : -1
                      : -4,
                  ob: (e) => {
                    var t,
                      r = m.length,
                      i = 2147483648;
                    if ((e >>>= 0) > i) return !1;
                    for (var o = 1; o <= 4; o *= 2) {
                      var a = r * (1 + 0.2 / o);
                      a = Math.min(a, e + 100663296);
                      var s = Math.min(
                        i,
                        ((t = Math.max(e, a)),
                        65536,
                        65536 * Math.ceil(t / 65536))
                      );
                      if (ss(s)) return !0;
                    }
                    return !1;
                  },
                  Ea: ns,
                  fa: (e, t, r) =>
                    "undefined" == typeof onbeforeunload
                      ? -1
                      : 1 !== r
                      ? -5
                      : ((e, t, r, i, o, a) => {
                          var s = {
                            target: sr(2),
                            eventTypeString: "beforeunload",
                            callbackfunc: i,
                            handlerFunc: (e = event) => {
                              var r = nt(i)(28, 0, t);
                              if ((r && (r = Se(r)), r))
                                return (
                                  e.preventDefault(), (e.returnValue = r), r
                                );
                            },
                            useCapture: !0,
                          };
                          return ir.registerOrRemoveHandler(s);
                        })(0, e, 0, t),
                  ra: (e, t, r, i, o) => ls(e, t, r, i, 12, "blur"),
                  y: ur,
                  N: (e, t, r) =>
                    (e = sr(e))
                      ? ((e.style.width = t + "px"),
                        (e.style.height = r + "px"),
                        0)
                      : -4,
                  sa: (e, t, r, i, o) => ls(e, t, r, i, 13, "focus"),
                  ia: (e, t, r, i, o) =>
                    ir.fullscreenEnabled()
                      ? (e = sr(e))
                        ? (ds(e, t, r, i, 19, "webkitfullscreenchange"),
                          ds(e, t, r, i, 19, "fullscreenchange"))
                        : -4
                      : -1,
                  Ca: (e, t, r, i) =>
                    ns() ? -1 : hs(2, e, t, r, 26, "gamepadconnected"),
                  Ba: (e, t, r, i) =>
                    ns() ? -1 : hs(2, e, t, r, 27, "gamepaddisconnected"),
                  la: (e, t, r, i, o) => us(e, t, r, i, 2, "keydown"),
                  ja: (e, t, r, i, o) => us(e, t, r, i, 1, "keypress"),
                  ka: (e, t, r, i, o) => us(e, t, r, i, 3, "keyup"),
                  Ja: (e, t, r) => {
                    var i = nt(e);
                    Kt(i, t, r);
                  },
                  xa: (e, t, r, i, o) => ps(e, t, r, i, 5, "mousedown"),
                  va: (e, t, r, i, o) => ps(e, t, r, i, 33, "mouseenter"),
                  ua: (e, t, r, i, o) => ps(e, t, r, i, 34, "mouseleave"),
                  ya: (e, t, r, i, o) => ps(e, t, r, i, 8, "mousemove"),
                  wa: (e, t, r, i, o) => ps(e, t, r, i, 6, "mouseup"),
                  ma: (e, t, r, i, o) =>
                    document &&
                    document.body &&
                    (document.body.requestPointerLock ||
                      document.body.mozRequestPointerLock ||
                      document.body.webkitRequestPointerLock ||
                      document.body.msRequestPointerLock)
                      ? (e = sr(e))
                        ? (gs(e, t, r, i, 20, "mozpointerlockchange"),
                          gs(e, t, r, i, 20, "webkitpointerlockchange"),
                          gs(e, t, r, i, 20, "mspointerlockchange"),
                          gs(e, t, r, i, 20, "pointerlockchange"))
                        : -4
                      : -1,
                  ha: (e, t, r, i, o) =>
                    ((e, t, r, i, o, a, s) => {
                      ir.uiEvent ||= Os(36);
                      var n = {
                        target: (e = sr(e)),
                        eventTypeString: "resize",
                        callbackfunc: i,
                        handlerFunc: (r = event) => {
                          if (r.target == e) {
                            var o = document.body;
                            if (o) {
                              var a = ir.uiEvent;
                              (C[a >> 2] = 0),
                                (C[(a + 4) >> 2] = o.clientWidth),
                                (C[(a + 8) >> 2] = o.clientHeight),
                                (C[(a + 12) >> 2] = innerWidth),
                                (C[(a + 16) >> 2] = innerHeight),
                                (C[(a + 20) >> 2] = outerWidth),
                                (C[(a + 24) >> 2] = outerHeight),
                                (C[(a + 28) >> 2] = 0 | pageXOffset),
                                (C[(a + 32) >> 2] = 0 | pageYOffset),
                                nt(i)(10, a, t) && r.preventDefault();
                            }
                          }
                        },
                        useCapture: r,
                      };
                      return ir.registerOrRemoveHandler(n);
                    })(e, t, r, i),
                  na: (e, t, r, i, o) => ys(e, t, r, i, 25, "touchcancel"),
                  pa: (e, t, r, i, o) => ys(e, t, r, i, 23, "touchend"),
                  oa: (e, t, r, i, o) => ys(e, t, r, i, 24, "touchmove"),
                  qa: (e, t, r, i, o) => ys(e, t, r, i, 22, "touchstart"),
                  ga: (e, t, r, i) =>
                    ((e, t, r, i, o, a, s) => {
                      ir.visibilityChangeEvent ||= Os(8);
                      var n = {
                        target: e,
                        eventTypeString: a,
                        callbackfunc: i,
                        handlerFunc: (e = event) => {
                          var r,
                            a,
                            s = ir.visibilityChangeEvent;
                          (r = s),
                            (a = [
                              "hidden",
                              "visible",
                              "prerender",
                              "unloaded",
                            ].indexOf(document.visibilityState)),
                            (v[r] = document.hidden),
                            (C[(r + 4) >> 2] = a),
                            nt(i)(o, s, t) && e.preventDefault();
                        },
                        useCapture: r,
                      };
                      return ir.registerOrRemoveHandler(n);
                    })(ar[1], e, t, r, 21, "visibilitychange"),
                  ta: (e, t, r, i, o) =>
                    (e = sr(e))
                      ? void 0 !== e.onwheel
                        ? ((e, t, r, i, o, a, s) => {
                            ir.wheelEvent ||= Os(96);
                            var n = {
                              target: e,
                              allowsDeferredCalls: !0,
                              eventTypeString: "wheel",
                              callbackfunc: i,
                              handlerFunc: (r = event) => {
                                var o = ir.wheelEvent;
                                cs(o, r, e),
                                  (A[(o + 64) >> 3] = r.deltaX),
                                  (A[(o + 72) >> 3] = r.deltaY),
                                  (A[(o + 80) >> 3] = r.deltaZ),
                                  (C[(o + 88) >> 2] = r.deltaMode),
                                  nt(i)(9, o, t) && r.preventDefault();
                              },
                              useCapture: r,
                            };
                            return ir.registerOrRemoveHandler(n);
                          })(e, t, r, i)
                        : -1
                      : -4,
                  $g: (e) => (document.title = Se(e)),
                  O: () => {
                    throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
                  },
                  db: function (e, t, r, i, o) {
                    var a = e + 108,
                      s = b[(a + 36) >> 2],
                      n = b[(a + 40) >> 2],
                      l = b[(a + 44) >> 2],
                      d = b[(a + 48) >> 2],
                      h = b[(a + 52) >> 2],
                      u = !!(64 & h);
                    function c(e) {
                      u ? e() : Xt(e);
                    }
                    var p = (e, r, i) => {
                        c(() => {
                          s ? nt(s)(e) : t?.(e);
                        });
                      },
                      g = (e, t, r) => {
                        c(() => {
                          l ? nt(l)(e) : i?.(e);
                        });
                      },
                      y = (e, t, i) => {
                        c(() => {
                          n ? nt(n)(e) : r?.(e);
                        });
                      },
                      f = (e, t, r) => {
                        c(() => {
                          d ? nt(d)(e) : o?.(e);
                        });
                      },
                      v = (e, r, i) => {
                        Ss(
                          vs.dbInstance,
                          e,
                          r.response,
                          (e, r, i) => {
                            c(() => {
                              s ? nt(s)(e) : t?.(e);
                            });
                          },
                          (e, r, i) => {
                            c(() => {
                              s ? nt(s)(e) : t?.(e);
                            });
                          }
                        );
                      },
                      P = Se(a + 0),
                      C = !!(16 & h),
                      x = !!(4 & h),
                      A = !!(32 & h);
                    if ("EM_IDB_STORE" === P) {
                      var T = b[(a + 84) >> 2],
                        E = b[(a + 88) >> 2];
                      Ss(vs.dbInstance, e, m.slice(T, T + E), p, y);
                    } else if ("EM_IDB_DELETE" === P)
                      !(function (e, t, r, i) {
                        if (e) {
                          var o = b[(t + 108 + 64) >> 2];
                          o ||= b[(t + 8) >> 2];
                          var a = Se(o);
                          try {
                            var s = e
                              .transaction(["FILES"], "readwrite")
                              .objectStore("FILES")
                              .delete(a);
                            (s.onsuccess = (e) => {
                              var i = e.target.result;
                              (b[(t + 12) >> 2] = 0),
                                ko(t + 16, 0),
                                ko(t + 24, 0),
                                ko(t + 32, 0),
                                (S[(t + 40) >> 1] = 4),
                                (S[(t + 42) >> 1] = 200),
                                xt("OK", t + 44, 64),
                                r(t, 0, i);
                            }),
                              (s.onerror = (e) => {
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, e);
                              });
                          } catch (e) {
                            i(t, 0, e);
                          }
                        } else i(t, 0, "IndexedDB not available!");
                      })(vs.dbInstance, e, p, y);
                    else if (C) {
                      if (A) return 0;
                      ms(e, x ? v : p, y, g, f);
                    } else
                      !(function (e, t, r, i) {
                        if (e) {
                          var o = b[(t + 108 + 64) >> 2];
                          o ||= b[(t + 8) >> 2];
                          var a = Se(o);
                          try {
                            var s = e
                              .transaction(["FILES"], "readonly")
                              .objectStore("FILES")
                              .get(a);
                            (s.onsuccess = (e) => {
                              if (e.target.result) {
                                var o = e.target.result,
                                  a = o.byteLength || o.length,
                                  s = Os(a);
                                m.set(new Uint8Array(o), s),
                                  (b[(t + 12) >> 2] = s),
                                  ko(t + 16, a),
                                  ko(t + 24, 0),
                                  ko(t + 32, a),
                                  (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 200),
                                  xt("OK", t + 44, 64),
                                  r(t, 0, o);
                              } else
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, "no data");
                            }),
                              (s.onerror = (e) => {
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, e);
                              });
                          } catch (e) {
                            i(t, 0, e);
                          }
                        } else i(t, 0, "IndexedDB not available!");
                      })(
                        vs.dbInstance,
                        e,
                        p,
                        A
                          ? y
                          : x
                          ? (e, t, r) => {
                              ms(e, v, y, g, f);
                            }
                          : (e, t, r) => {
                              ms(e, p, y, g, f);
                            }
                      );
                    return e;
                  },
                  qb: (e, t) => {
                    var r = 0;
                    return (
                      Cs().forEach((i, o) => {
                        var a = t + r;
                        (b[(e + 4 * o) >> 2] = a),
                          ((e, t) => {
                            for (var r = 0; r < e.length; ++r)
                              v[t++] = e.charCodeAt(r);
                            v[t] = 0;
                          })(i, a),
                          (r += i.length + 1);
                      }),
                      0
                    );
                  },
                  rb: (e, t) => {
                    var r = Cs();
                    b[e >> 2] = r.length;
                    var i = 0;
                    return (
                      r.forEach((e) => (i += e.length + 1)), (b[t >> 2] = i), 0
                    );
                  },
                  $: function (e) {
                    try {
                      var t = Pe.getStreamFromFD(e);
                      return me.close(t), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  wb: function (e, t, r, i) {
                    try {
                      var o = ((e, t, r, i) => {
                        for (var o = 0, a = 0; a < r; a++) {
                          var s = b[t >> 2],
                            n = b[(t + 4) >> 2];
                          t += 8;
                          var l = me.read(e, v, s, n, i);
                          if (l < 0) return -1;
                          if (((o += l), l < n)) break;
                          void 0 !== i && (i += l);
                        }
                        return o;
                      })(Pe.getStreamFromFD(e), t, r);
                      return (b[i >> 2] = o), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  jb: function (e, t, r, i, o) {
                    var a = Vt(t, r);
                    try {
                      if (isNaN(a)) return 61;
                      var s = Pe.getStreamFromFD(e);
                      return (
                        me.llseek(s, a, i),
                        (F = [
                          s.position >>> 0,
                          ((B = s.position),
                          +Math.abs(B) >= 1
                            ? B > 0
                              ? +Math.floor(B / 4294967296) >>> 0
                              : ~~+Math.ceil(
                                  (B - +(~~B >>> 0)) / 4294967296
                                ) >>> 0
                            : 0),
                        ]),
                        (C[o >> 2] = F[0]),
                        (C[(o + 4) >> 2] = F[1]),
                        s.getdents && 0 === a && 0 === i && (s.getdents = null),
                        0
                      );
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  Z: function (e, t, r, i) {
                    try {
                      var o = ((e, t, r, i) => {
                        for (var o = 0, a = 0; a < r; a++) {
                          var s = b[t >> 2],
                            n = b[(t + 4) >> 2];
                          t += 8;
                          var l = me.write(e, v, s, n, i);
                          if (l < 0) return -1;
                          if (((o += l), l < n)) break;
                          void 0 !== i && (i += l);
                        }
                        return o;
                      })(Pe.getStreamFromFD(e), t, r);
                      return (b[i >> 2] = o), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  Pa: function () {
                    var e = "";
                    "undefined" != typeof window
                      ? (e = window.location.hostname)
                      : "undefined" != typeof process && (e = "node");
                    var t = oe(e) + 1,
                      r = Os(t);
                    return xt(e, r, t), r;
                  },
                  $a: mr,
                  aa: Pr,
                  l: br,
                  n: Ar,
                  t: Er,
                  s: Dr,
                  Kd: kr,
                  zd: Vr,
                  Vd: Br,
                  K: Hr,
                  S: zr,
                  Uf: Xr,
                  dg: Wr,
                  Uc: Zr,
                  Ya: Kr,
                  G: Qr,
                  ec: ti,
                  _a: ii,
                  We: ai,
                  B: ni,
                  Jg: di,
                  ca: ui,
                  ea: pi,
                  V: yi,
                  Va: vi,
                  ee: xi,
                  pe: Ti,
                  da: Ri,
                  E: wi,
                  R: Li,
                  J: qi,
                  Qa: Ji,
                  D: lo,
                  Ta: uo,
                  M: po,
                  Le: yo,
                  L: vo,
                  T: So,
                  H: Co,
                  Ug: Ro,
                  fb: Mo,
                  hb: Oo,
                  r: Bo,
                  kb: Ho,
                  C: zo,
                  Wa: qo,
                  U: Jo,
                  x: ea,
                  gb: oa,
                  Ae: ya,
                  Bb: va,
                  Ua: Sa,
                  od: Aa,
                  dd: Ea,
                  Za: Da,
                  o: Ma,
                  i: Oa,
                  eb: _a,
                  ab: Na,
                  cb: Ha,
                  bb: za,
                  X: Xa,
                  W: Wa,
                  ba: $a,
                  Ra: qa,
                  Sa: rs,
                  F: os,
                  th: function (e, t, r) {
                    var i = $();
                    try {
                      return nt(e)(t, r);
                    } catch (e) {
                      if ((U(i), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                  uh: function (e, t, r, i) {
                    var o = $();
                    try {
                      return nt(e)(t, r, i);
                    } catch (e) {
                      if ((U(o), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                  eg: function (e, t, r, i, o) {
                    var a = $();
                    try {
                      return nt(e)(t, r, i, o);
                    } catch (e) {
                      if ((U(a), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                };
              !(async function () {
                function e(e, t) {
                  var r;
                  return (
                    (Ds = e.exports),
                    (y = Ds.vh),
                    R(),
                    (ot = Ds.yh),
                    (r = Ds.wh),
                    w.unshift(r),
                    _(),
                    Ds
                  );
                }
                k();
                var t,
                  r,
                  o = { a: ws };
                if (s.instantiateWasm)
                  try {
                    return s.instantiateWasm(o, e);
                  } catch (e) {
                    g(
                      `Module.instantiateWasm callback failed with error: ${e}`
                    ),
                      i(e);
                  }
                N ??= H((r = "scichart2d.wasm"))
                  ? r
                  : ((t = r), s.locateFile ? s.locateFile(t, c) : c + t);
                try {
                  var a = await Y(T, N, o);
                  return (
                    (function (t) {
                      e(t.instance);
                    })(a),
                    a
                  );
                } catch (e) {
                  return void i(e);
                }
              })();
              var Ms,
                Ls = (e) => (Ls = Ds.xh)(e),
                Os = (s._malloc = (e) => (Os = s._malloc = Ds.zh)(e)),
                Is = (s._free = (e) => (Is = s._free = Ds.Ah)(e)),
                ks =
                  ((s._SCRTFillActiveTextureCharArray = (e, t, r) =>
                    (s._SCRTFillActiveTextureCharArray = Ds.Bh)(e, t, r)),
                  (s._SCRTFillActiveTextureFloat = (e, t, r) =>
                    (s._SCRTFillActiveTextureFloat = Ds.Ch)(e, t, r)),
                  (s._SCRTFillActiveDoubleVector = (e, t, r) =>
                    (s._SCRTFillActiveDoubleVector = Ds.Dh)(e, t, r)),
                  (s._main = (e, t) => (ks = s._main = Ds.Eh)(e, t))),
                _s = (s._setThrew = (e, t) => (_s = s._setThrew = Ds.Fh)(e, t)),
                Vs = (e) => (Vs = Ds.Gh)(e),
                Ns = (e) => (Ns = Ds.Hh)(e),
                Bs = () => (Bs = Ds.Ih)();
              function Fs(e = []) {
                var t = ks;
                e.unshift(h);
                var r = e.length,
                  i = lr(4 * (r + 1)),
                  o = i;
                e.forEach((e) => {
                  (b[o >> 2] = dr(e)), (o += 4);
                }),
                  (b[o >> 2] = 0);
                try {
                  var a = t(r, i);
                  return Yt(a, !0), a;
                } catch (e) {
                  return Ft(e);
                }
              }
              function Hs(e = d) {
                function t() {
                  Ms ||
                    ((Ms = !0),
                    (s.calledRun = !0),
                    E ||
                      (s.noFSInit || me.initialized || me.init(),
                      (me.ignorePermissions = !1),
                      ue.init(),
                      X(w),
                      X(M),
                      r(s),
                      s.onRuntimeInitialized?.(),
                      Ys && Fs(e),
                      (function () {
                        if (s.postRun)
                          for (
                            "function" == typeof s.postRun &&
                            (s.postRun = [s.postRun]);
                            s.postRun.length;

                          )
                            (e = s.postRun.shift()), L.unshift(e);
                        var e;
                        X(L);
                      })()));
                }
                O > 0 ||
                  ((function () {
                    if (s.preRun)
                      for (
                        "function" == typeof s.preRun &&
                        (s.preRun = [s.preRun]);
                        s.preRun.length;

                      )
                        (e = s.preRun.shift()), D.unshift(e);
                    var e;
                    X(D);
                  })(),
                  O > 0 ||
                    (s.setStatus
                      ? (s.setStatus("Running..."),
                        setTimeout(() => {
                          setTimeout(() => s.setStatus(""), 1), t();
                        }, 1))
                      : t()));
              }
              if (
                ((s.dynCall_iiiji = (e, t, r, i, o, a) =>
                  (s.dynCall_iiiji = Ds.Jh)(e, t, r, i, o, a)),
                (s.dynCall_iiij = (e, t, r, i, o) =>
                  (s.dynCall_iiij = Ds.Kh)(e, t, r, i, o)),
                (s.dynCall_iijii = (e, t, r, i, o, a) =>
                  (s.dynCall_iijii = Ds.Lh)(e, t, r, i, o, a)),
                (s.dynCall_iiijiji = (e, t, r, i, o, a, n, l, d) =>
                  (s.dynCall_iiijiji = Ds.Mh)(e, t, r, i, o, a, n, l, d)),
                (s.dynCall_jiji = (e, t, r, i, o) =>
                  (s.dynCall_jiji = Ds.Nh)(e, t, r, i, o)),
                (s.dynCall_ji = (e, t) => (s.dynCall_ji = Ds.Oh)(e, t)),
                (s.dynCall_viijii = (e, t, r, i, o, a, n) =>
                  (s.dynCall_viijii = Ds.Ph)(e, t, r, i, o, a, n)),
                (s.dynCall_iiiiij = (e, t, r, i, o, a, n) =>
                  (s.dynCall_iiiiij = Ds.Qh)(e, t, r, i, o, a, n)),
                (s.dynCall_iiiiijj = (e, t, r, i, o, a, n, l, d) =>
                  (s.dynCall_iiiiijj = Ds.Rh)(e, t, r, i, o, a, n, l, d)),
                (s.dynCall_iiiiiijj = (e, t, r, i, o, a, n, l, d, h) =>
                  (s.dynCall_iiiiiijj = Ds.Sh)(e, t, r, i, o, a, n, l, d, h)),
                (s.callMain = Fs),
                (s.ccall = As),
                (s.cwrap = (e, t, r, i) => {
                  var o =
                    !r || r.every((e) => "number" === e || "boolean" === e);
                  return "string" !== t && o && !i
                    ? xs(e)
                    : (...i) => As(e, t, r, i);
                }),
                (s.UTF8ToString = Se),
                (s.stringToUTF8 = xt),
                (s.lengthBytesUTF8 = oe),
                (I = function e() {
                  Ms || Hs(), Ms || (I = e);
                }),
                s.preInit)
              )
                for (
                  "function" == typeof s.preInit && (s.preInit = [s.preInit]);
                  s.preInit.length > 0;

                )
                  s.preInit.pop()();
              var Ys = !0;
              return (
                s.noInitialRun && (Ys = !1),
                Hs(),
                Zt &&
                  (Zt.getNewId = function (e) {
                    Zt.counter++;
                    var t = e.length;
                    if (0 === t) return 1;
                    for (var r = 1; r < t; ++r) if (null === e[r]) return r;
                    return t;
                  }),
                n
              );
            });
        (e.exports = r), (e.exports.default = r);
      },
      5877: (e) => {
        var t,
          r =
            ((t =
              "undefined" != typeof document
                ? document.currentScript?.src
                : void 0),
            function (e = {}) {
              var r,
                i,
                o,
                a,
                s = e,
                n = new Promise((e, t) => {
                  (r = e), (i = t);
                }),
                l = Object.assign({}, s),
                d = [],
                h = "./this.program",
                u = (e, t) => {
                  throw t;
                },
                c = "";
              "undefined" != typeof document &&
                document.currentScript &&
                (c = document.currentScript.src),
                t && (c = t),
                (c = c.startsWith("blob:")
                  ? ""
                  : c.substr(0, c.replace(/[?#].*/, "").lastIndexOf("/") + 1)),
                (o = async (e) => {
                  var t = await fetch(e, { credentials: "same-origin" });
                  if (t.ok) return t.arrayBuffer();
                  throw new Error(t.status + " : " + t.url);
                });
              var p = s.print || console.log.bind(console),
                g = s.printErr || console.error.bind(console);
              Object.assign(s, l),
                (l = null),
                s.arguments && (d = s.arguments),
                s.thisProgram && (h = s.thisProgram);
              var y,
                f,
                v,
                m,
                S,
                P,
                C,
                b,
                x,
                A,
                T = s.wasmBinary,
                E = !1;
              function R() {
                var e = y.buffer;
                (s.HEAP8 = v = new Int8Array(e)),
                  (s.HEAP16 = S = new Int16Array(e)),
                  (s.HEAPU8 = m = new Uint8Array(e)),
                  (s.HEAPU16 = P = new Uint16Array(e)),
                  (s.HEAP32 = C = new Int32Array(e)),
                  (s.HEAPU32 = b = new Uint32Array(e)),
                  (s.HEAPF32 = x = new Float32Array(e)),
                  (s.HEAPF64 = A = new Float64Array(e));
              }
              var D = [],
                w = [],
                M = [],
                L = [],
                O = 0,
                I = null;
              function k(e) {
                O++, s.monitorRunDependencies?.(O);
              }
              function _(e) {
                if ((O--, s.monitorRunDependencies?.(O), 0 == O && I)) {
                  var t = I;
                  (I = null), t();
                }
              }
              function V(e) {
                s.onAbort?.(e),
                  g((e = "Aborted(" + e + ")")),
                  (E = !0),
                  (e += ". Build with -sASSERTIONS for more info.");
                var t = new WebAssembly.RuntimeError(e);
                throw (i(t), t);
              }
              var N,
                B,
                F,
                H = (e) =>
                  e.startsWith("data:application/octet-stream;base64,");
              async function Y(e, t, r) {
                if (
                  !e &&
                  "function" == typeof WebAssembly.instantiateStreaming &&
                  !H(t) &&
                  "function" == typeof fetch
                )
                  try {
                    var i = fetch(t, { credentials: "same-origin" });
                    return await WebAssembly.instantiateStreaming(i, r);
                  } catch (e) {
                    g(`wasm streaming compile failed: ${e}`),
                      g("falling back to ArrayBuffer instantiation");
                  }
                return (async function (e, t) {
                  try {
                    var r = await (async function (e) {
                      if (!T)
                        try {
                          var t = await o(e);
                          return new Uint8Array(t);
                        } catch {}
                      return (function (e) {
                        if (e == N && T) return new Uint8Array(T);
                        if (a) return a(e);
                        throw "both async and sync fetching of the wasm failed";
                      })(e);
                    })(e);
                    return await WebAssembly.instantiate(r, t);
                  } catch (e) {
                    g(`failed to asynchronously prepare wasm: ${e}`), V(e);
                  }
                })(t, r);
              }
              var z = {
                961144: () => {
                  var e =
                    navigator.userAgent || navigator.vendor || window.opera;
                  return /windows phone/i.test(e)
                    ? 0
                    : /Android/i.test(e)
                    ? 1
                    : /iPad|iPhone|iPod/.test(e) && !window.MSStream
                    ? 2
                    : 0;
                },
                961414: () => {
                  ar["#canvas"] = s.canvas;
                },
                961465: () => s.getRandomValue(),
                961501: () => {
                  if (void 0 === s.getRandomValue)
                    try {
                      var e = "object" == typeof window ? window : self,
                        t = void 0 !== e.crypto ? e.crypto : e.msCrypto,
                        r = function () {
                          var e = new Uint32Array(1);
                          return t.getRandomValues(e), e[0] >>> 0;
                        };
                      r(), (s.getRandomValue = r);
                    } catch (e) {
                      try {
                        var i = Math.pow(2, 32),
                          o = function () {
                            return (
                              Math.floor(Math.random() * Math.floor(i)) >>> 0
                            );
                          };
                        o(), (s.getRandomValue = o);
                      } catch (e) {
                        throw "No secure random number generator found";
                      }
                    }
                },
                962183: (e) => {
                  var t =
                      Se(e) + "\n\nAbort/Retry/Ignore/AlwaysIgnore? [ariA] :",
                    r = window.prompt(t, "i");
                  return (
                    null === r && (r = "i"), allocate(se(r), "i8", ALLOC_NORMAL)
                  );
                },
                962408: () =>
                  "undefined" != typeof AudioContext ||
                  "undefined" != typeof webkitAudioContext,
                962555: () =>
                  (void 0 !== navigator.mediaDevices &&
                    void 0 !== navigator.mediaDevices.getUserMedia) ||
                  void 0 !== navigator.webkitGetUserMedia,
                962789: (e) => {
                  void 0 === s.SDL2 && (s.SDL2 = {});
                  var t = s.SDL2;
                  return (
                    e ? (t.capture = {}) : (t.audio = {}),
                    t.audioContext ||
                      ("undefined" != typeof AudioContext
                        ? (t.audioContext = new AudioContext())
                        : "undefined" != typeof webkitAudioContext &&
                          (t.audioContext = new webkitAudioContext()),
                      t.audioContext &&
                        void 0 === navigator.userActivation &&
                        bs(t.audioContext)),
                    void 0 === t.audioContext ? -1 : 0
                  );
                },
                963341: () => s.SDL2.audioContext.sampleRate,
                963409: (e, t, r, i) => {
                  var o = s.SDL2,
                    a = function (a) {
                      void 0 !== o.capture.silenceTimer &&
                        (clearInterval(o.capture.silenceTimer),
                        (o.capture.silenceTimer = void 0),
                        (o.capture.silenceBuffer = void 0)),
                        (o.capture.mediaStreamNode =
                          o.audioContext.createMediaStreamSource(a)),
                        (o.capture.scriptProcessorNode =
                          o.audioContext.createScriptProcessor(t, e, 1)),
                        (o.capture.scriptProcessorNode.onaudioprocess =
                          function (e) {
                            void 0 !== o &&
                              void 0 !== o.capture &&
                              (e.outputBuffer.getChannelData(0).fill(0),
                              (o.capture.currentCaptureBuffer = e.inputBuffer),
                              lt("vi", r, [i]));
                          }),
                        o.capture.mediaStreamNode.connect(
                          o.capture.scriptProcessorNode
                        ),
                        o.capture.scriptProcessorNode.connect(
                          o.audioContext.destination
                        ),
                        (o.capture.stream = a);
                    },
                    n = function (e) {};
                  (o.capture.silenceBuffer = o.audioContext.createBuffer(
                    e,
                    t,
                    o.audioContext.sampleRate
                  )),
                    o.capture.silenceBuffer.getChannelData(0).fill(0),
                    (o.capture.silenceTimer = setInterval(function () {
                      (o.capture.currentCaptureBuffer =
                        o.capture.silenceBuffer),
                        lt("vi", r, [i]);
                    }, (t / o.audioContext.sampleRate) * 1e3)),
                    void 0 !== navigator.mediaDevices &&
                    void 0 !== navigator.mediaDevices.getUserMedia
                      ? navigator.mediaDevices
                          .getUserMedia({ audio: !0, video: !1 })
                          .then(a)
                          .catch(n)
                      : void 0 !== navigator.webkitGetUserMedia &&
                        navigator.webkitGetUserMedia(
                          { audio: !0, video: !1 },
                          a,
                          n
                        );
                },
                965102: (e, t, r, i) => {
                  var o = s.SDL2;
                  (o.audio.scriptProcessorNode =
                    o.audioContext.createScriptProcessor(t, 0, e)),
                    (o.audio.scriptProcessorNode.onaudioprocess = function (e) {
                      void 0 !== o &&
                        void 0 !== o.audio &&
                        (void 0 !== o.audio.silenceTimer &&
                          (clearInterval(o.audio.silenceTimer),
                          (o.audio.silenceTimer = void 0),
                          (o.audio.silenceBuffer = void 0)),
                        (o.audio.currentOutputBuffer = e.outputBuffer),
                        lt("vi", r, [i]));
                    }),
                    o.audio.scriptProcessorNode.connect(
                      o.audioContext.destination
                    ),
                    "suspended" === o.audioContext.state &&
                      ((o.audio.silenceBuffer = o.audioContext.createBuffer(
                        e,
                        t,
                        o.audioContext.sampleRate
                      )),
                      o.audio.silenceBuffer.getChannelData(0).fill(0),
                      (o.audio.silenceTimer = setInterval(function () {
                        void 0 !== navigator.userActivation &&
                          navigator.userActivation.hasBeenActive &&
                          o.audioContext.resume(),
                          (o.audio.currentOutputBuffer = o.audio.silenceBuffer),
                          lt("vi", r, [i]),
                          (o.audio.currentOutputBuffer = void 0);
                      }, (t / o.audioContext.sampleRate) * 1e3)));
                },
                966277: (e, t) => {
                  for (
                    var r = s.SDL2,
                      i = r.capture.currentCaptureBuffer.numberOfChannels,
                      o = 0;
                    o < i;
                    ++o
                  ) {
                    var a = r.capture.currentCaptureBuffer.getChannelData(o);
                    if (a.length != t)
                      throw (
                        "Web Audio capture buffer length mismatch! Destination size: " +
                        a.length +
                        " samples vs expected " +
                        t +
                        " samples!"
                      );
                    if (1 == i)
                      for (var n = 0; n < t; ++n) W(e + 4 * n, a[n], "float");
                    else
                      for (n = 0; n < t; ++n)
                        W(e + 4 * (n * i + o), a[n], "float");
                  }
                },
                966882: (e, t) => {
                  for (
                    var r = s.SDL2,
                      i = e >>> 2,
                      o = r.audio.currentOutputBuffer.numberOfChannels,
                      a = 0;
                    a < o;
                    ++a
                  ) {
                    var n = r.audio.currentOutputBuffer.getChannelData(a);
                    if (n.length != t)
                      throw (
                        "Web Audio output buffer length mismatch! Destination size: " +
                        n.length +
                        " samples vs expected " +
                        t +
                        " samples!"
                      );
                    for (var l = 0; l < t; ++l) n[l] = x[i + (l * o + a)];
                  }
                },
                967371: (e) => {
                  var t = s.SDL2;
                  if (e) {
                    if (
                      (void 0 !== t.capture.silenceTimer &&
                        clearInterval(t.capture.silenceTimer),
                      void 0 !== t.capture.stream)
                    )
                      for (
                        var r = t.capture.stream.getAudioTracks(), i = 0;
                        i < r.length;
                        i++
                      )
                        t.capture.stream.removeTrack(r[i]);
                    void 0 !== t.capture.scriptProcessorNode &&
                      ((t.capture.scriptProcessorNode.onaudioprocess =
                        function (e) {}),
                      t.capture.scriptProcessorNode.disconnect()),
                      void 0 !== t.capture.mediaStreamNode &&
                        t.capture.mediaStreamNode.disconnect(),
                      (t.capture = void 0);
                  } else
                    null != t.audio.scriptProcessorNode &&
                      t.audio.scriptProcessorNode.disconnect(),
                      void 0 !== t.audio.silenceTimer &&
                        clearInterval(t.audio.silenceTimer),
                      (t.audio = void 0);
                  void 0 !== t.audioContext &&
                    void 0 === t.audio &&
                    void 0 === t.capture &&
                    (t.audioContext.close(), (t.audioContext = void 0));
                },
                968377: (e, t, r) => {
                  var i = e,
                    o = t,
                    a = r;
                  s.SDL2 || (s.SDL2 = {});
                  var n = s.SDL2;
                  n.ctxCanvas !== s.canvas &&
                    ((n.ctx = s.createContext(s.canvas, !1, !0)),
                    (n.ctxCanvas = s.canvas)),
                    (n.w === i && n.h === o && n.imageCtx === n.ctx) ||
                      ((n.image = n.ctx.createImageData(i, o)),
                      (n.w = i),
                      (n.h = o),
                      (n.imageCtx = n.ctx));
                  var l,
                    d = n.image.data,
                    h = a / 4,
                    u = 0;
                  if (
                    "undefined" != typeof CanvasPixelArray &&
                    d instanceof CanvasPixelArray
                  )
                    for (l = d.length; u < l; ) {
                      var c = C[h];
                      (d[u] = 255 & c),
                        (d[u + 1] = (c >> 8) & 255),
                        (d[u + 2] = (c >> 16) & 255),
                        (d[u + 3] = 255),
                        h++,
                        (u += 4);
                    }
                  else {
                    n.data32Data !== d &&
                      ((n.data32 = new Int32Array(d.buffer)),
                      (n.data8 = new Uint8Array(d.buffer)),
                      (n.data32Data = d));
                    var p = n.data32;
                    (l = p.length), p.set(C.subarray(h, h + l));
                    var g = n.data8,
                      y = 3,
                      f = y + 4 * l;
                    if (l % 8 == 0)
                      for (; y < f; )
                        (g[y] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (g[(y = (y + 4) | 0)] = 255),
                          (y = (y + 4) | 0);
                    else for (; y < f; ) (g[y] = 255), (y = (y + 4) | 0);
                  }
                  n.ctx.putImageData(n.image, 0, 0);
                },
                969845: (e, t, r, i, o) => {
                  var a = e,
                    s = t,
                    n = r,
                    l = i,
                    d = o,
                    h = document.createElement("canvas");
                  (h.width = a), (h.height = s);
                  var u,
                    c = h.getContext("2d"),
                    p = c.createImageData(a, s),
                    g = p.data,
                    y = d / 4,
                    f = 0;
                  if (
                    "undefined" != typeof CanvasPixelArray &&
                    g instanceof CanvasPixelArray
                  )
                    for (u = g.length; f < u; ) {
                      var v = C[y];
                      (g[f] = 255 & v),
                        (g[f + 1] = (v >> 8) & 255),
                        (g[f + 2] = (v >> 16) & 255),
                        (g[f + 3] = (v >> 24) & 255),
                        y++,
                        (f += 4);
                    }
                  else {
                    var m = new Int32Array(g.buffer);
                    (u = m.length), m.set(C.subarray(y, y + u));
                  }
                  c.putImageData(p, 0, 0);
                  var S =
                      0 === n && 0 === l
                        ? "url(" + h.toDataURL() + "), auto"
                        : "url(" +
                          h.toDataURL() +
                          ") " +
                          n +
                          " " +
                          l +
                          ", auto",
                    P = Os(S.length + 1);
                  return xt(S, P, S.length + 1), P;
                },
                970833: (e) => {
                  s.canvas && (s.canvas.style.cursor = Se(e));
                },
                970916: () => {
                  s.canvas && (s.canvas.style.cursor = "none");
                },
                970985: () => window.innerWidth,
                971015: () => window.innerHeight,
              };
              class j {
                name = "ExitStatus";
                constructor(e) {
                  (this.message = `Program terminated with exit(${e})`),
                    (this.status = e);
                }
              }
              var X = (e) => {
                  for (; e.length > 0; ) e.shift()(s);
                },
                G = s.noExitRuntime || !0;
              function W(e, t, r = "i8") {
                switch ((r.endsWith("*") && (r = "*"), r)) {
                  case "i1":
                  case "i8":
                    v[e] = t;
                    break;
                  case "i16":
                    S[e >> 1] = t;
                    break;
                  case "i32":
                    C[e >> 2] = t;
                    break;
                  case "i64":
                    V("to do setValue(i64) use WASM_BIGINT");
                  case "float":
                    x[e >> 2] = t;
                    break;
                  case "double":
                    A[e >> 3] = t;
                    break;
                  case "*":
                    b[e >> 2] = t;
                    break;
                  default:
                    V(`invalid type for setValue: ${r}`);
                }
              }
              var U = (e) => Vs(e),
                $ = () => Bs();
              class Z {
                constructor(e) {
                  (this.excPtr = e), (this.ptr = e - 24);
                }
                set_type(e) {
                  b[(this.ptr + 4) >> 2] = e;
                }
                get_type() {
                  return b[(this.ptr + 4) >> 2];
                }
                set_destructor(e) {
                  b[(this.ptr + 8) >> 2] = e;
                }
                get_destructor() {
                  return b[(this.ptr + 8) >> 2];
                }
                set_caught(e) {
                  (e = e ? 1 : 0), (v[this.ptr + 12] = e);
                }
                get_caught() {
                  return 0 != v[this.ptr + 12];
                }
                set_rethrown(e) {
                  (e = e ? 1 : 0), (v[this.ptr + 13] = e);
                }
                get_rethrown() {
                  return 0 != v[this.ptr + 13];
                }
                init(e, t) {
                  this.set_adjusted_ptr(0),
                    this.set_type(e),
                    this.set_destructor(t);
                }
                set_adjusted_ptr(e) {
                  b[(this.ptr + 16) >> 2] = e;
                }
                get_adjusted_ptr() {
                  return b[(this.ptr + 16) >> 2];
                }
              }
              var q = () => {
                  var e = C[+Pe.varargs >> 2];
                  return (Pe.varargs += 4), e;
                },
                K = q,
                J = {
                  isAbs: (e) => "/" === e.charAt(0),
                  splitPath: (e) =>
                    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
                      .exec(e)
                      .slice(1),
                  normalizeArray: (e, t) => {
                    for (var r = 0, i = e.length - 1; i >= 0; i--) {
                      var o = e[i];
                      "." === o
                        ? e.splice(i, 1)
                        : ".." === o
                        ? (e.splice(i, 1), r++)
                        : r && (e.splice(i, 1), r--);
                    }
                    if (t) for (; r; r--) e.unshift("..");
                    return e;
                  },
                  normalize: (e) => {
                    var t = J.isAbs(e),
                      r = "/" === e.substr(-1);
                    return (
                      (e = J.normalizeArray(
                        e.split("/").filter((e) => !!e),
                        !t
                      ).join("/")) ||
                        t ||
                        (e = "."),
                      e && r && (e += "/"),
                      (t ? "/" : "") + e
                    );
                  },
                  dirname: (e) => {
                    var t = J.splitPath(e),
                      r = t[0],
                      i = t[1];
                    return r || i
                      ? (i && (i = i.substr(0, i.length - 1)), r + i)
                      : ".";
                  },
                  basename: (e) => {
                    if ("/" === e) return "/";
                    var t = (e = (e = J.normalize(e)).replace(
                      /\/$/,
                      ""
                    )).lastIndexOf("/");
                    return -1 === t ? e : e.substr(t + 1);
                  },
                  join: (...e) => J.normalize(e.join("/")),
                  join2: (e, t) => J.normalize(e + "/" + t),
                },
                Q = (e) =>
                  (Q = (() => {
                    if (
                      "object" == typeof crypto &&
                      "function" == typeof crypto.getRandomValues
                    )
                      return (e) => crypto.getRandomValues(e);
                    V("initRandomDevice");
                  })())(e),
                ee = {
                  resolve: (...e) => {
                    for (
                      var t = "", r = !1, i = e.length - 1;
                      i >= -1 && !r;
                      i--
                    ) {
                      var o = i >= 0 ? e[i] : me.cwd();
                      if ("string" != typeof o)
                        throw new TypeError(
                          "Arguments to path.resolve must be strings"
                        );
                      if (!o) return "";
                      (t = o + "/" + t), (r = J.isAbs(o));
                    }
                    return (
                      (r ? "/" : "") +
                        (t = J.normalizeArray(
                          t.split("/").filter((e) => !!e),
                          !r
                        ).join("/")) || "."
                    );
                  },
                  relative: (e, t) => {
                    function r(e) {
                      for (var t = 0; t < e.length && "" === e[t]; t++);
                      for (var r = e.length - 1; r >= 0 && "" === e[r]; r--);
                      return t > r ? [] : e.slice(t, r - t + 1);
                    }
                    (e = ee.resolve(e).substr(1)),
                      (t = ee.resolve(t).substr(1));
                    for (
                      var i = r(e.split("/")),
                        o = r(t.split("/")),
                        a = Math.min(i.length, o.length),
                        s = a,
                        n = 0;
                      n < a;
                      n++
                    )
                      if (i[n] !== o[n]) {
                        s = n;
                        break;
                      }
                    var l = [];
                    for (n = s; n < i.length; n++) l.push("..");
                    return (l = l.concat(o.slice(s))).join("/");
                  },
                },
                te =
                  "undefined" != typeof TextDecoder
                    ? new TextDecoder()
                    : void 0,
                re = (e, t = 0, r = NaN) => {
                  for (var i = t + r, o = t; e[o] && !(o >= i); ) ++o;
                  if (o - t > 16 && e.buffer && te)
                    return te.decode(e.subarray(t, o));
                  for (var a = ""; t < o; ) {
                    var s = e[t++];
                    if (128 & s) {
                      var n = 63 & e[t++];
                      if (192 != (224 & s)) {
                        var l = 63 & e[t++];
                        if (
                          (s =
                            224 == (240 & s)
                              ? ((15 & s) << 12) | (n << 6) | l
                              : ((7 & s) << 18) |
                                (n << 12) |
                                (l << 6) |
                                (63 & e[t++])) < 65536
                        )
                          a += String.fromCharCode(s);
                        else {
                          var d = s - 65536;
                          a += String.fromCharCode(
                            55296 | (d >> 10),
                            56320 | (1023 & d)
                          );
                        }
                      } else a += String.fromCharCode(((31 & s) << 6) | n);
                    } else a += String.fromCharCode(s);
                  }
                  return a;
                },
                ie = [],
                oe = (e) => {
                  for (var t = 0, r = 0; r < e.length; ++r) {
                    var i = e.charCodeAt(r);
                    i <= 127
                      ? t++
                      : i <= 2047
                      ? (t += 2)
                      : i >= 55296 && i <= 57343
                      ? ((t += 4), ++r)
                      : (t += 3);
                  }
                  return t;
                },
                ae = (e, t, r, i) => {
                  if (!(i > 0)) return 0;
                  for (var o = r, a = r + i - 1, s = 0; s < e.length; ++s) {
                    var n = e.charCodeAt(s);
                    if (
                      (n >= 55296 &&
                        n <= 57343 &&
                        (n =
                          (65536 + ((1023 & n) << 10)) |
                          (1023 & e.charCodeAt(++s))),
                      n <= 127)
                    ) {
                      if (r >= a) break;
                      t[r++] = n;
                    } else if (n <= 2047) {
                      if (r + 1 >= a) break;
                      (t[r++] = 192 | (n >> 6)), (t[r++] = 128 | (63 & n));
                    } else if (n <= 65535) {
                      if (r + 2 >= a) break;
                      (t[r++] = 224 | (n >> 12)),
                        (t[r++] = 128 | ((n >> 6) & 63)),
                        (t[r++] = 128 | (63 & n));
                    } else {
                      if (r + 3 >= a) break;
                      (t[r++] = 240 | (n >> 18)),
                        (t[r++] = 128 | ((n >> 12) & 63)),
                        (t[r++] = 128 | ((n >> 6) & 63)),
                        (t[r++] = 128 | (63 & n));
                    }
                  }
                  return (t[r] = 0), r - o;
                };
              function se(e, t, r) {
                var i = r > 0 ? r : oe(e) + 1,
                  o = new Array(i),
                  a = ae(e, o, 0, o.length);
                return t && (o.length = a), o;
              }
              var ne,
                le,
                de,
                he,
                ue = {
                  ttys: [],
                  init() {},
                  shutdown() {},
                  register(e, t) {
                    (ue.ttys[e] = { input: [], output: [], ops: t }),
                      me.registerDevice(e, ue.stream_ops);
                  },
                  stream_ops: {
                    open(e) {
                      var t = ue.ttys[e.node.rdev];
                      if (!t) throw new me.ErrnoError(43);
                      (e.tty = t), (e.seekable = !1);
                    },
                    close(e) {
                      e.tty.ops.fsync(e.tty);
                    },
                    fsync(e) {
                      e.tty.ops.fsync(e.tty);
                    },
                    read(e, t, r, i, o) {
                      if (!e.tty || !e.tty.ops.get_char)
                        throw new me.ErrnoError(60);
                      for (var a = 0, s = 0; s < i; s++) {
                        var n;
                        try {
                          n = e.tty.ops.get_char(e.tty);
                        } catch (e) {
                          throw new me.ErrnoError(29);
                        }
                        if (void 0 === n && 0 === a) throw new me.ErrnoError(6);
                        if (null == n) break;
                        a++, (t[r + s] = n);
                      }
                      return a && (e.node.atime = Date.now()), a;
                    },
                    write(e, t, r, i, o) {
                      if (!e.tty || !e.tty.ops.put_char)
                        throw new me.ErrnoError(60);
                      try {
                        for (var a = 0; a < i; a++)
                          e.tty.ops.put_char(e.tty, t[r + a]);
                      } catch (e) {
                        throw new me.ErrnoError(29);
                      }
                      return i && (e.node.mtime = e.node.ctime = Date.now()), a;
                    },
                  },
                  default_tty_ops: {
                    get_char: (e) =>
                      (() => {
                        if (!ie.length) {
                          var e = null;
                          if (
                            ("undefined" != typeof window &&
                              "function" == typeof window.prompt &&
                              null !== (e = window.prompt("Input: ")) &&
                              (e += "\n"),
                            !e)
                          )
                            return null;
                          ie = se(e, !0);
                        }
                        return ie.shift();
                      })(),
                    put_char(e, t) {
                      null === t || 10 === t
                        ? (p(re(e.output)), (e.output = []))
                        : 0 != t && e.output.push(t);
                    },
                    fsync(e) {
                      e.output &&
                        e.output.length > 0 &&
                        (p(re(e.output)), (e.output = []));
                    },
                    ioctl_tcgets: (e) => ({
                      c_iflag: 25856,
                      c_oflag: 5,
                      c_cflag: 191,
                      c_lflag: 35387,
                      c_cc: [
                        3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23,
                        22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      ],
                    }),
                    ioctl_tcsets: (e, t, r) => 0,
                    ioctl_tiocgwinsz: (e) => [24, 80],
                  },
                  default_tty1_ops: {
                    put_char(e, t) {
                      null === t || 10 === t
                        ? (g(re(e.output)), (e.output = []))
                        : 0 != t && e.output.push(t);
                    },
                    fsync(e) {
                      e.output &&
                        e.output.length > 0 &&
                        (g(re(e.output)), (e.output = []));
                    },
                  },
                },
                ce = (e) => {
                  V();
                },
                pe = {
                  ops_table: null,
                  mount: (e) => pe.createNode(null, "/", 16895, 0),
                  createNode(e, t, r, i) {
                    if (me.isBlkdev(r) || me.isFIFO(r))
                      throw new me.ErrnoError(63);
                    pe.ops_table ||= {
                      dir: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                          lookup: pe.node_ops.lookup,
                          mknod: pe.node_ops.mknod,
                          rename: pe.node_ops.rename,
                          unlink: pe.node_ops.unlink,
                          rmdir: pe.node_ops.rmdir,
                          readdir: pe.node_ops.readdir,
                          symlink: pe.node_ops.symlink,
                        },
                        stream: { llseek: pe.stream_ops.llseek },
                      },
                      file: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                        },
                        stream: {
                          llseek: pe.stream_ops.llseek,
                          read: pe.stream_ops.read,
                          write: pe.stream_ops.write,
                          allocate: pe.stream_ops.allocate,
                          mmap: pe.stream_ops.mmap,
                          msync: pe.stream_ops.msync,
                        },
                      },
                      link: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                          readlink: pe.node_ops.readlink,
                        },
                        stream: {},
                      },
                      chrdev: {
                        node: {
                          getattr: pe.node_ops.getattr,
                          setattr: pe.node_ops.setattr,
                        },
                        stream: me.chrdev_stream_ops,
                      },
                    };
                    var o = me.createNode(e, t, r, i);
                    return (
                      me.isDir(o.mode)
                        ? ((o.node_ops = pe.ops_table.dir.node),
                          (o.stream_ops = pe.ops_table.dir.stream),
                          (o.contents = {}))
                        : me.isFile(o.mode)
                        ? ((o.node_ops = pe.ops_table.file.node),
                          (o.stream_ops = pe.ops_table.file.stream),
                          (o.usedBytes = 0),
                          (o.contents = null))
                        : me.isLink(o.mode)
                        ? ((o.node_ops = pe.ops_table.link.node),
                          (o.stream_ops = pe.ops_table.link.stream))
                        : me.isChrdev(o.mode) &&
                          ((o.node_ops = pe.ops_table.chrdev.node),
                          (o.stream_ops = pe.ops_table.chrdev.stream)),
                      (o.atime = o.mtime = o.ctime = Date.now()),
                      e &&
                        ((e.contents[t] = o),
                        (e.atime = e.mtime = e.ctime = o.atime)),
                      o
                    );
                  },
                  getFileDataAsTypedArray: (e) =>
                    e.contents
                      ? e.contents.subarray
                        ? e.contents.subarray(0, e.usedBytes)
                        : new Uint8Array(e.contents)
                      : new Uint8Array(0),
                  expandFileStorage(e, t) {
                    var r = e.contents ? e.contents.length : 0;
                    if (!(r >= t)) {
                      (t = Math.max(t, (r * (r < 1048576 ? 2 : 1.125)) >>> 0)),
                        0 != r && (t = Math.max(t, 256));
                      var i = e.contents;
                      (e.contents = new Uint8Array(t)),
                        e.usedBytes > 0 &&
                          e.contents.set(i.subarray(0, e.usedBytes), 0);
                    }
                  },
                  resizeFileStorage(e, t) {
                    if (e.usedBytes != t)
                      if (0 == t) (e.contents = null), (e.usedBytes = 0);
                      else {
                        var r = e.contents;
                        (e.contents = new Uint8Array(t)),
                          r &&
                            e.contents.set(
                              r.subarray(0, Math.min(t, e.usedBytes))
                            ),
                          (e.usedBytes = t);
                      }
                  },
                  node_ops: {
                    getattr(e) {
                      var t = {};
                      return (
                        (t.dev = me.isChrdev(e.mode) ? e.id : 1),
                        (t.ino = e.id),
                        (t.mode = e.mode),
                        (t.nlink = 1),
                        (t.uid = 0),
                        (t.gid = 0),
                        (t.rdev = e.rdev),
                        me.isDir(e.mode)
                          ? (t.size = 4096)
                          : me.isFile(e.mode)
                          ? (t.size = e.usedBytes)
                          : me.isLink(e.mode)
                          ? (t.size = e.link.length)
                          : (t.size = 0),
                        (t.atime = new Date(e.atime)),
                        (t.mtime = new Date(e.mtime)),
                        (t.ctime = new Date(e.ctime)),
                        (t.blksize = 4096),
                        (t.blocks = Math.ceil(t.size / t.blksize)),
                        t
                      );
                    },
                    setattr(e, t) {
                      for (const r of ["mode", "atime", "mtime", "ctime"])
                        t[r] && (e[r] = t[r]);
                      void 0 !== t.size && pe.resizeFileStorage(e, t.size);
                    },
                    lookup(e, t) {
                      throw pe.doesNotExistError;
                    },
                    mknod: (e, t, r, i) => pe.createNode(e, t, r, i),
                    rename(e, t, r) {
                      var i;
                      try {
                        i = me.lookupNode(t, r);
                      } catch (e) {}
                      if (i) {
                        if (me.isDir(e.mode))
                          for (var o in i.contents) throw new me.ErrnoError(55);
                        me.hashRemoveNode(i);
                      }
                      delete e.parent.contents[e.name],
                        (t.contents[r] = e),
                        (e.name = r),
                        (t.ctime =
                          t.mtime =
                          e.parent.ctime =
                          e.parent.mtime =
                            Date.now());
                    },
                    unlink(e, t) {
                      delete e.contents[t], (e.ctime = e.mtime = Date.now());
                    },
                    rmdir(e, t) {
                      var r = me.lookupNode(e, t);
                      for (var i in r.contents) throw new me.ErrnoError(55);
                      delete e.contents[t], (e.ctime = e.mtime = Date.now());
                    },
                    readdir: (e) => [".", "..", ...Object.keys(e.contents)],
                    symlink(e, t, r) {
                      var i = pe.createNode(e, t, 41471, 0);
                      return (i.link = r), i;
                    },
                    readlink(e) {
                      if (!me.isLink(e.mode)) throw new me.ErrnoError(28);
                      return e.link;
                    },
                  },
                  stream_ops: {
                    read(e, t, r, i, o) {
                      var a = e.node.contents;
                      if (o >= e.node.usedBytes) return 0;
                      var s = Math.min(e.node.usedBytes - o, i);
                      if (s > 8 && a.subarray) t.set(a.subarray(o, o + s), r);
                      else for (var n = 0; n < s; n++) t[r + n] = a[o + n];
                      return s;
                    },
                    write(e, t, r, i, o, a) {
                      if ((t.buffer === v.buffer && (a = !1), !i)) return 0;
                      var s = e.node;
                      if (
                        ((s.mtime = s.ctime = Date.now()),
                        t.subarray && (!s.contents || s.contents.subarray))
                      ) {
                        if (a)
                          return (
                            (s.contents = t.subarray(r, r + i)),
                            (s.usedBytes = i),
                            i
                          );
                        if (0 === s.usedBytes && 0 === o)
                          return (
                            (s.contents = t.slice(r, r + i)),
                            (s.usedBytes = i),
                            i
                          );
                        if (o + i <= s.usedBytes)
                          return s.contents.set(t.subarray(r, r + i), o), i;
                      }
                      if (
                        (pe.expandFileStorage(s, o + i),
                        s.contents.subarray && t.subarray)
                      )
                        s.contents.set(t.subarray(r, r + i), o);
                      else
                        for (var n = 0; n < i; n++)
                          s.contents[o + n] = t[r + n];
                      return (s.usedBytes = Math.max(s.usedBytes, o + i)), i;
                    },
                    llseek(e, t, r) {
                      var i = t;
                      if (
                        (1 === r
                          ? (i += e.position)
                          : 2 === r &&
                            me.isFile(e.node.mode) &&
                            (i += e.node.usedBytes),
                        i < 0)
                      )
                        throw new me.ErrnoError(28);
                      return i;
                    },
                    allocate(e, t, r) {
                      pe.expandFileStorage(e.node, t + r),
                        (e.node.usedBytes = Math.max(e.node.usedBytes, t + r));
                    },
                    mmap(e, t, r, i, o) {
                      if (!me.isFile(e.node.mode)) throw new me.ErrnoError(43);
                      var a,
                        s,
                        n = e.node.contents;
                      if (2 & o || !n || n.buffer !== v.buffer) {
                        if (((s = !0), !(a = ce())))
                          throw new me.ErrnoError(48);
                        n &&
                          ((r > 0 || r + t < n.length) &&
                            (n = n.subarray
                              ? n.subarray(r, r + t)
                              : Array.prototype.slice.call(n, r, r + t)),
                          v.set(n, a));
                      } else (s = !1), (a = n.byteOffset);
                      return { ptr: a, allocated: s };
                    },
                    msync: (e, t, r, i, o) => (
                      pe.stream_ops.write(e, t, 0, i, r, !1), 0
                    ),
                  },
                },
                ge = (e, t, r, i, o, a) => {
                  me.createDataFile(e, t, r, i, o, a);
                },
                ye = s.preloadPlugins || [],
                fe = (e, t, r, i) => {
                  void 0 !== Wt && Wt.init();
                  var o = !1;
                  return (
                    ye.forEach((a) => {
                      o || (a.canHandle(t) && (a.handle(e, t, r, i), (o = !0)));
                    }),
                    o
                  );
                },
                ve = (e, t) => {
                  var r = 0;
                  return e && (r |= 365), t && (r |= 146), r;
                },
                me = {
                  root: null,
                  mounts: [],
                  devices: {},
                  streams: [],
                  nextInode: 1,
                  nameTable: null,
                  currentPath: "/",
                  initialized: !1,
                  ignorePermissions: !0,
                  ErrnoError: class {
                    name = "ErrnoError";
                    constructor(e) {
                      this.errno = e;
                    }
                  },
                  filesystems: null,
                  syncFSRequests: 0,
                  readFiles: {},
                  FSStream: class {
                    shared = {};
                    get object() {
                      return this.node;
                    }
                    set object(e) {
                      this.node = e;
                    }
                    get isRead() {
                      return 1 != (2097155 & this.flags);
                    }
                    get isWrite() {
                      return 0 != (2097155 & this.flags);
                    }
                    get isAppend() {
                      return 1024 & this.flags;
                    }
                    get flags() {
                      return this.shared.flags;
                    }
                    set flags(e) {
                      this.shared.flags = e;
                    }
                    get position() {
                      return this.shared.position;
                    }
                    set position(e) {
                      this.shared.position = e;
                    }
                  },
                  FSNode: class {
                    node_ops = {};
                    stream_ops = {};
                    readMode = 365;
                    writeMode = 146;
                    mounted = null;
                    constructor(e, t, r, i) {
                      e || (e = this),
                        (this.parent = e),
                        (this.mount = e.mount),
                        (this.id = me.nextInode++),
                        (this.name = t),
                        (this.mode = r),
                        (this.rdev = i),
                        (this.atime = this.mtime = this.ctime = Date.now());
                    }
                    get read() {
                      return (this.mode & this.readMode) === this.readMode;
                    }
                    set read(e) {
                      e
                        ? (this.mode |= this.readMode)
                        : (this.mode &= ~this.readMode);
                    }
                    get write() {
                      return (this.mode & this.writeMode) === this.writeMode;
                    }
                    set write(e) {
                      e
                        ? (this.mode |= this.writeMode)
                        : (this.mode &= ~this.writeMode);
                    }
                    get isFolder() {
                      return me.isDir(this.mode);
                    }
                    get isDevice() {
                      return me.isChrdev(this.mode);
                    }
                  },
                  lookupPath(e, t = {}) {
                    if (!e) return { path: "", node: null };
                    (t.follow_mount ??= !0),
                      J.isAbs(e) || (e = me.cwd() + "/" + e);
                    e: for (var r = 0; r < 40; r++) {
                      for (
                        var i = e.split("/").filter((e) => !!e && "." !== e),
                          o = me.root,
                          a = "/",
                          s = 0;
                        s < i.length;
                        s++
                      ) {
                        var n = s === i.length - 1;
                        if (n && t.parent) break;
                        if (".." !== i[s]) {
                          a = J.join2(a, i[s]);
                          try {
                            o = me.lookupNode(o, i[s]);
                          } catch (e) {
                            if (44 === e?.errno && n && t.noent_okay)
                              return { path: a };
                            throw e;
                          }
                          if (
                            (!me.isMountpoint(o) ||
                              (n && !t.follow_mount) ||
                              (o = o.mounted.root),
                            me.isLink(o.mode) && (!n || t.follow))
                          ) {
                            if (!o.node_ops.readlink)
                              throw new me.ErrnoError(52);
                            var l = o.node_ops.readlink(o);
                            J.isAbs(l) || (l = J.dirname(a) + "/" + l),
                              (e = l + "/" + i.slice(s + 1).join("/"));
                            continue e;
                          }
                        } else (a = J.dirname(a)), (o = o.parent);
                      }
                      return { path: a, node: o };
                    }
                    throw new me.ErrnoError(32);
                  },
                  getPath(e) {
                    for (var t; ; ) {
                      if (me.isRoot(e)) {
                        var r = e.mount.mountpoint;
                        return t
                          ? "/" !== r[r.length - 1]
                            ? `${r}/${t}`
                            : r + t
                          : r;
                      }
                      (t = t ? `${e.name}/${t}` : e.name), (e = e.parent);
                    }
                  },
                  hashName(e, t) {
                    for (var r = 0, i = 0; i < t.length; i++)
                      r = ((r << 5) - r + t.charCodeAt(i)) | 0;
                    return ((e + r) >>> 0) % me.nameTable.length;
                  },
                  hashAddNode(e) {
                    var t = me.hashName(e.parent.id, e.name);
                    (e.name_next = me.nameTable[t]), (me.nameTable[t] = e);
                  },
                  hashRemoveNode(e) {
                    var t = me.hashName(e.parent.id, e.name);
                    if (me.nameTable[t] === e) me.nameTable[t] = e.name_next;
                    else
                      for (var r = me.nameTable[t]; r; ) {
                        if (r.name_next === e) {
                          r.name_next = e.name_next;
                          break;
                        }
                        r = r.name_next;
                      }
                  },
                  lookupNode(e, t) {
                    var r = me.mayLookup(e);
                    if (r) throw new me.ErrnoError(r);
                    for (
                      var i = me.hashName(e.id, t), o = me.nameTable[i];
                      o;
                      o = o.name_next
                    ) {
                      var a = o.name;
                      if (o.parent.id === e.id && a === t) return o;
                    }
                    return me.lookup(e, t);
                  },
                  createNode(e, t, r, i) {
                    var o = new me.FSNode(e, t, r, i);
                    return me.hashAddNode(o), o;
                  },
                  destroyNode(e) {
                    me.hashRemoveNode(e);
                  },
                  isRoot: (e) => e === e.parent,
                  isMountpoint: (e) => !!e.mounted,
                  isFile: (e) => 32768 == (61440 & e),
                  isDir: (e) => 16384 == (61440 & e),
                  isLink: (e) => 40960 == (61440 & e),
                  isChrdev: (e) => 8192 == (61440 & e),
                  isBlkdev: (e) => 24576 == (61440 & e),
                  isFIFO: (e) => 4096 == (61440 & e),
                  isSocket: (e) => 49152 == (49152 & e),
                  flagsToPermissionString(e) {
                    var t = ["r", "w", "rw"][3 & e];
                    return 512 & e && (t += "w"), t;
                  },
                  nodePermissions: (e, t) =>
                    me.ignorePermissions ||
                    ((!t.includes("r") || 292 & e.mode) &&
                      (!t.includes("w") || 146 & e.mode) &&
                      (!t.includes("x") || 73 & e.mode))
                      ? 0
                      : 2,
                  mayLookup: (e) =>
                    me.isDir(e.mode)
                      ? me.nodePermissions(e, "x") ||
                        (e.node_ops.lookup ? 0 : 2)
                      : 54,
                  mayCreate(e, t) {
                    if (!me.isDir(e.mode)) return 54;
                    try {
                      return me.lookupNode(e, t), 20;
                    } catch (e) {}
                    return me.nodePermissions(e, "wx");
                  },
                  mayDelete(e, t, r) {
                    var i;
                    try {
                      i = me.lookupNode(e, t);
                    } catch (e) {
                      return e.errno;
                    }
                    var o = me.nodePermissions(e, "wx");
                    if (o) return o;
                    if (r) {
                      if (!me.isDir(i.mode)) return 54;
                      if (me.isRoot(i) || me.getPath(i) === me.cwd()) return 10;
                    } else if (me.isDir(i.mode)) return 31;
                    return 0;
                  },
                  mayOpen: (e, t) =>
                    e
                      ? me.isLink(e.mode)
                        ? 32
                        : me.isDir(e.mode) &&
                          ("r" !== me.flagsToPermissionString(t) || 512 & t)
                        ? 31
                        : me.nodePermissions(e, me.flagsToPermissionString(t))
                      : 44,
                  MAX_OPEN_FDS: 4096,
                  nextfd() {
                    for (var e = 0; e <= me.MAX_OPEN_FDS; e++)
                      if (!me.streams[e]) return e;
                    throw new me.ErrnoError(33);
                  },
                  getStreamChecked(e) {
                    var t = me.getStream(e);
                    if (!t) throw new me.ErrnoError(8);
                    return t;
                  },
                  getStream: (e) => me.streams[e],
                  createStream: (e, t = -1) => (
                    (e = Object.assign(new me.FSStream(), e)),
                    -1 == t && (t = me.nextfd()),
                    (e.fd = t),
                    (me.streams[t] = e),
                    e
                  ),
                  closeStream(e) {
                    me.streams[e] = null;
                  },
                  dupStream(e, t = -1) {
                    var r = me.createStream(e, t);
                    return r.stream_ops?.dup?.(r), r;
                  },
                  chrdev_stream_ops: {
                    open(e) {
                      var t = me.getDevice(e.node.rdev);
                      (e.stream_ops = t.stream_ops), e.stream_ops.open?.(e);
                    },
                    llseek() {
                      throw new me.ErrnoError(70);
                    },
                  },
                  major: (e) => e >> 8,
                  minor: (e) => 255 & e,
                  makedev: (e, t) => (e << 8) | t,
                  registerDevice(e, t) {
                    me.devices[e] = { stream_ops: t };
                  },
                  getDevice: (e) => me.devices[e],
                  getMounts(e) {
                    for (var t = [], r = [e]; r.length; ) {
                      var i = r.pop();
                      t.push(i), r.push(...i.mounts);
                    }
                    return t;
                  },
                  syncfs(e, t) {
                    "function" == typeof e && ((t = e), (e = !1)),
                      me.syncFSRequests++,
                      me.syncFSRequests > 1 &&
                        g(
                          `warning: ${me.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
                        );
                    var r = me.getMounts(me.root.mount),
                      i = 0;
                    function o(e) {
                      return me.syncFSRequests--, t(e);
                    }
                    function a(e) {
                      if (e)
                        return a.errored ? void 0 : ((a.errored = !0), o(e));
                      ++i >= r.length && o(null);
                    }
                    r.forEach((t) => {
                      if (!t.type.syncfs) return a(null);
                      t.type.syncfs(t, e, a);
                    });
                  },
                  mount(e, t, r) {
                    var i,
                      o = "/" === r,
                      a = !r;
                    if (o && me.root) throw new me.ErrnoError(10);
                    if (!o && !a) {
                      var s = me.lookupPath(r, { follow_mount: !1 });
                      if (((r = s.path), (i = s.node), me.isMountpoint(i)))
                        throw new me.ErrnoError(10);
                      if (!me.isDir(i.mode)) throw new me.ErrnoError(54);
                    }
                    var n = { type: e, opts: t, mountpoint: r, mounts: [] },
                      l = e.mount(n);
                    return (
                      (l.mount = n),
                      (n.root = l),
                      o
                        ? (me.root = l)
                        : i &&
                          ((i.mounted = n), i.mount && i.mount.mounts.push(n)),
                      l
                    );
                  },
                  unmount(e) {
                    var t = me.lookupPath(e, { follow_mount: !1 });
                    if (!me.isMountpoint(t.node)) throw new me.ErrnoError(28);
                    var r = t.node,
                      i = r.mounted,
                      o = me.getMounts(i);
                    Object.keys(me.nameTable).forEach((e) => {
                      for (var t = me.nameTable[e]; t; ) {
                        var r = t.name_next;
                        o.includes(t.mount) && me.destroyNode(t), (t = r);
                      }
                    }),
                      (r.mounted = null);
                    var a = r.mount.mounts.indexOf(i);
                    r.mount.mounts.splice(a, 1);
                  },
                  lookup: (e, t) => e.node_ops.lookup(e, t),
                  mknod(e, t, r) {
                    var i = me.lookupPath(e, { parent: !0 }).node,
                      o = J.basename(e);
                    if (!o || "." === o || ".." === o)
                      throw new me.ErrnoError(28);
                    var a = me.mayCreate(i, o);
                    if (a) throw new me.ErrnoError(a);
                    if (!i.node_ops.mknod) throw new me.ErrnoError(63);
                    return i.node_ops.mknod(i, o, t, r);
                  },
                  statfs(e) {
                    var t = {
                        bsize: 4096,
                        frsize: 4096,
                        blocks: 1e6,
                        bfree: 5e5,
                        bavail: 5e5,
                        files: me.nextInode,
                        ffree: me.nextInode - 1,
                        fsid: 42,
                        flags: 2,
                        namelen: 255,
                      },
                      r = me.lookupPath(e, { follow: !0 }).node;
                    return (
                      r?.node_ops.statfs &&
                        Object.assign(t, r.node_ops.statfs(r.mount.opts.root)),
                      t
                    );
                  },
                  create: (e, t = 438) => (
                    (t &= 4095), (t |= 32768), me.mknod(e, t, 0)
                  ),
                  mkdir: (e, t = 511) => (
                    (t &= 1023), (t |= 16384), me.mknod(e, t, 0)
                  ),
                  mkdirTree(e, t) {
                    for (var r = e.split("/"), i = "", o = 0; o < r.length; ++o)
                      if (r[o]) {
                        i += "/" + r[o];
                        try {
                          me.mkdir(i, t);
                        } catch (e) {
                          if (20 != e.errno) throw e;
                        }
                      }
                  },
                  mkdev: (e, t, r) => (
                    void 0 === r && ((r = t), (t = 438)),
                    (t |= 8192),
                    me.mknod(e, t, r)
                  ),
                  symlink(e, t) {
                    if (!ee.resolve(e)) throw new me.ErrnoError(44);
                    var r = me.lookupPath(t, { parent: !0 }).node;
                    if (!r) throw new me.ErrnoError(44);
                    var i = J.basename(t),
                      o = me.mayCreate(r, i);
                    if (o) throw new me.ErrnoError(o);
                    if (!r.node_ops.symlink) throw new me.ErrnoError(63);
                    return r.node_ops.symlink(r, i, e);
                  },
                  rename(e, t) {
                    var r,
                      i,
                      o = J.dirname(e),
                      a = J.dirname(t),
                      s = J.basename(e),
                      n = J.basename(t);
                    if (
                      ((r = me.lookupPath(e, { parent: !0 }).node),
                      (i = me.lookupPath(t, { parent: !0 }).node),
                      !r || !i)
                    )
                      throw new me.ErrnoError(44);
                    if (r.mount !== i.mount) throw new me.ErrnoError(75);
                    var l,
                      d = me.lookupNode(r, s),
                      h = ee.relative(e, a);
                    if ("." !== h.charAt(0)) throw new me.ErrnoError(28);
                    if ("." !== (h = ee.relative(t, o)).charAt(0))
                      throw new me.ErrnoError(55);
                    try {
                      l = me.lookupNode(i, n);
                    } catch (e) {}
                    if (d !== l) {
                      var u = me.isDir(d.mode),
                        c = me.mayDelete(r, s, u);
                      if (c) throw new me.ErrnoError(c);
                      if ((c = l ? me.mayDelete(i, n, u) : me.mayCreate(i, n)))
                        throw new me.ErrnoError(c);
                      if (!r.node_ops.rename) throw new me.ErrnoError(63);
                      if (me.isMountpoint(d) || (l && me.isMountpoint(l)))
                        throw new me.ErrnoError(10);
                      if (i !== r && (c = me.nodePermissions(r, "w")))
                        throw new me.ErrnoError(c);
                      me.hashRemoveNode(d);
                      try {
                        r.node_ops.rename(d, i, n), (d.parent = i);
                      } catch (e) {
                        throw e;
                      } finally {
                        me.hashAddNode(d);
                      }
                    }
                  },
                  rmdir(e) {
                    var t = me.lookupPath(e, { parent: !0 }).node,
                      r = J.basename(e),
                      i = me.lookupNode(t, r),
                      o = me.mayDelete(t, r, !0);
                    if (o) throw new me.ErrnoError(o);
                    if (!t.node_ops.rmdir) throw new me.ErrnoError(63);
                    if (me.isMountpoint(i)) throw new me.ErrnoError(10);
                    t.node_ops.rmdir(t, r), me.destroyNode(i);
                  },
                  readdir(e) {
                    var t = me.lookupPath(e, { follow: !0 }).node;
                    if (!t.node_ops.readdir) throw new me.ErrnoError(54);
                    return t.node_ops.readdir(t);
                  },
                  unlink(e) {
                    var t = me.lookupPath(e, { parent: !0 }).node;
                    if (!t) throw new me.ErrnoError(44);
                    var r = J.basename(e),
                      i = me.lookupNode(t, r),
                      o = me.mayDelete(t, r, !1);
                    if (o) throw new me.ErrnoError(o);
                    if (!t.node_ops.unlink) throw new me.ErrnoError(63);
                    if (me.isMountpoint(i)) throw new me.ErrnoError(10);
                    t.node_ops.unlink(t, r), me.destroyNode(i);
                  },
                  readlink(e) {
                    var t = me.lookupPath(e).node;
                    if (!t) throw new me.ErrnoError(44);
                    if (!t.node_ops.readlink) throw new me.ErrnoError(28);
                    return t.node_ops.readlink(t);
                  },
                  stat(e, t) {
                    var r = me.lookupPath(e, { follow: !t }).node;
                    if (!r) throw new me.ErrnoError(44);
                    if (!r.node_ops.getattr) throw new me.ErrnoError(63);
                    return r.node_ops.getattr(r);
                  },
                  lstat: (e) => me.stat(e, !0),
                  chmod(e, t, r) {
                    var i;
                    if (
                      !(i =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !r }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    i.node_ops.setattr(i, {
                      mode: (4095 & t) | (-4096 & i.mode),
                      ctime: Date.now(),
                    });
                  },
                  lchmod(e, t) {
                    me.chmod(e, t, !0);
                  },
                  fchmod(e, t) {
                    var r = me.getStreamChecked(e);
                    me.chmod(r.node, t);
                  },
                  chown(e, t, r, i) {
                    var o;
                    if (
                      !(o =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !i }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    o.node_ops.setattr(o, { timestamp: Date.now() });
                  },
                  lchown(e, t, r) {
                    me.chown(e, t, r, !0);
                  },
                  fchown(e, t, r) {
                    var i = me.getStreamChecked(e);
                    me.chown(i.node, t, r);
                  },
                  truncate(e, t) {
                    if (t < 0) throw new me.ErrnoError(28);
                    var r;
                    if (
                      !(r =
                        "string" == typeof e
                          ? me.lookupPath(e, { follow: !0 }).node
                          : e).node_ops.setattr
                    )
                      throw new me.ErrnoError(63);
                    if (me.isDir(r.mode)) throw new me.ErrnoError(31);
                    if (!me.isFile(r.mode)) throw new me.ErrnoError(28);
                    var i = me.nodePermissions(r, "w");
                    if (i) throw new me.ErrnoError(i);
                    r.node_ops.setattr(r, { size: t, timestamp: Date.now() });
                  },
                  ftruncate(e, t) {
                    var r = me.getStreamChecked(e);
                    if (0 == (2097155 & r.flags)) throw new me.ErrnoError(28);
                    me.truncate(r.node, t);
                  },
                  utime(e, t, r) {
                    var i = me.lookupPath(e, { follow: !0 }).node;
                    i.node_ops.setattr(i, { atime: t, mtime: r });
                  },
                  open(e, t, r = 438) {
                    if ("" === e) throw new me.ErrnoError(44);
                    var i;
                    if (
                      ((r =
                        64 &
                        (t =
                          "string" == typeof t
                            ? ((e) => {
                                var t = {
                                  r: 0,
                                  "r+": 2,
                                  w: 577,
                                  "w+": 578,
                                  a: 1089,
                                  "a+": 1090,
                                }[e];
                                if (void 0 === t)
                                  throw new Error(
                                    `Unknown file open mode: ${e}`
                                  );
                                return t;
                              })(t)
                            : t)
                          ? (4095 & r) | 32768
                          : 0),
                      "object" == typeof e)
                    )
                      i = e;
                    else {
                      var o = me.lookupPath(e, {
                        follow: !(131072 & t),
                        noent_okay: !0,
                      });
                      (i = o.node), (e = o.path);
                    }
                    var a = !1;
                    if (64 & t)
                      if (i) {
                        if (128 & t) throw new me.ErrnoError(20);
                      } else (i = me.mknod(e, r, 0)), (a = !0);
                    if (!i) throw new me.ErrnoError(44);
                    if (
                      (me.isChrdev(i.mode) && (t &= -513),
                      65536 & t && !me.isDir(i.mode))
                    )
                      throw new me.ErrnoError(54);
                    if (!a) {
                      var n = me.mayOpen(i, t);
                      if (n) throw new me.ErrnoError(n);
                    }
                    512 & t && !a && me.truncate(i, 0), (t &= -131713);
                    var l = me.createStream({
                      node: i,
                      path: me.getPath(i),
                      flags: t,
                      seekable: !0,
                      position: 0,
                      stream_ops: i.stream_ops,
                      ungotten: [],
                      error: !1,
                    });
                    return (
                      l.stream_ops.open && l.stream_ops.open(l),
                      !s.logReadFiles ||
                        1 & t ||
                        e in me.readFiles ||
                        (me.readFiles[e] = 1),
                      l
                    );
                  },
                  close(e) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    e.getdents && (e.getdents = null);
                    try {
                      e.stream_ops.close && e.stream_ops.close(e);
                    } catch (e) {
                      throw e;
                    } finally {
                      me.closeStream(e.fd);
                    }
                    e.fd = null;
                  },
                  isClosed: (e) => null === e.fd,
                  llseek(e, t, r) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (!e.seekable || !e.stream_ops.llseek)
                      throw new me.ErrnoError(70);
                    if (0 != r && 1 != r && 2 != r) throw new me.ErrnoError(28);
                    return (
                      (e.position = e.stream_ops.llseek(e, t, r)),
                      (e.ungotten = []),
                      e.position
                    );
                  },
                  read(e, t, r, i, o) {
                    if (i < 0 || o < 0) throw new me.ErrnoError(28);
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (1 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (me.isDir(e.node.mode)) throw new me.ErrnoError(31);
                    if (!e.stream_ops.read) throw new me.ErrnoError(28);
                    var a = void 0 !== o;
                    if (a) {
                      if (!e.seekable) throw new me.ErrnoError(70);
                    } else o = e.position;
                    var s = e.stream_ops.read(e, t, r, i, o);
                    return a || (e.position += s), s;
                  },
                  write(e, t, r, i, o, a) {
                    if (i < 0 || o < 0) throw new me.ErrnoError(28);
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (0 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (me.isDir(e.node.mode)) throw new me.ErrnoError(31);
                    if (!e.stream_ops.write) throw new me.ErrnoError(28);
                    e.seekable && 1024 & e.flags && me.llseek(e, 0, 2);
                    var s = void 0 !== o;
                    if (s) {
                      if (!e.seekable) throw new me.ErrnoError(70);
                    } else o = e.position;
                    var n = e.stream_ops.write(e, t, r, i, o, a);
                    return s || (e.position += n), n;
                  },
                  allocate(e, t, r) {
                    if (me.isClosed(e)) throw new me.ErrnoError(8);
                    if (t < 0 || r <= 0) throw new me.ErrnoError(28);
                    if (0 == (2097155 & e.flags)) throw new me.ErrnoError(8);
                    if (!me.isFile(e.node.mode) && !me.isDir(e.node.mode))
                      throw new me.ErrnoError(43);
                    if (!e.stream_ops.allocate) throw new me.ErrnoError(138);
                    e.stream_ops.allocate(e, t, r);
                  },
                  mmap(e, t, r, i, o) {
                    if (
                      0 != (2 & i) &&
                      0 == (2 & o) &&
                      2 != (2097155 & e.flags)
                    )
                      throw new me.ErrnoError(2);
                    if (1 == (2097155 & e.flags)) throw new me.ErrnoError(2);
                    if (!e.stream_ops.mmap) throw new me.ErrnoError(43);
                    if (!t) throw new me.ErrnoError(28);
                    return e.stream_ops.mmap(e, t, r, i, o);
                  },
                  msync: (e, t, r, i, o) =>
                    e.stream_ops.msync ? e.stream_ops.msync(e, t, r, i, o) : 0,
                  ioctl(e, t, r) {
                    if (!e.stream_ops.ioctl) throw new me.ErrnoError(59);
                    return e.stream_ops.ioctl(e, t, r);
                  },
                  readFile(e, t = {}) {
                    if (
                      ((t.flags = t.flags || 0),
                      (t.encoding = t.encoding || "binary"),
                      "utf8" !== t.encoding && "binary" !== t.encoding)
                    )
                      throw new Error(`Invalid encoding type "${t.encoding}"`);
                    var r,
                      i = me.open(e, t.flags),
                      o = me.stat(e).size,
                      a = new Uint8Array(o);
                    return (
                      me.read(i, a, 0, o, 0),
                      "utf8" === t.encoding
                        ? (r = re(a))
                        : "binary" === t.encoding && (r = a),
                      me.close(i),
                      r
                    );
                  },
                  writeFile(e, t, r = {}) {
                    r.flags = r.flags || 577;
                    var i = me.open(e, r.flags, r.mode);
                    if ("string" == typeof t) {
                      var o = new Uint8Array(oe(t) + 1),
                        a = ae(t, o, 0, o.length);
                      me.write(i, o, 0, a, void 0, r.canOwn);
                    } else {
                      if (!ArrayBuffer.isView(t))
                        throw new Error("Unsupported data type");
                      me.write(i, t, 0, t.byteLength, void 0, r.canOwn);
                    }
                    me.close(i);
                  },
                  cwd: () => me.currentPath,
                  chdir(e) {
                    var t = me.lookupPath(e, { follow: !0 });
                    if (null === t.node) throw new me.ErrnoError(44);
                    if (!me.isDir(t.node.mode)) throw new me.ErrnoError(54);
                    var r = me.nodePermissions(t.node, "x");
                    if (r) throw new me.ErrnoError(r);
                    me.currentPath = t.path;
                  },
                  createDefaultDirectories() {
                    me.mkdir("/tmp"),
                      me.mkdir("/home"),
                      me.mkdir("/home/web_user");
                  },
                  createDefaultDevices() {
                    me.mkdir("/dev"),
                      me.registerDevice(me.makedev(1, 3), {
                        read: () => 0,
                        write: (e, t, r, i, o) => i,
                        llseek: () => 0,
                      }),
                      me.mkdev("/dev/null", me.makedev(1, 3)),
                      ue.register(me.makedev(5, 0), ue.default_tty_ops),
                      ue.register(me.makedev(6, 0), ue.default_tty1_ops),
                      me.mkdev("/dev/tty", me.makedev(5, 0)),
                      me.mkdev("/dev/tty1", me.makedev(6, 0));
                    var e = new Uint8Array(1024),
                      t = 0,
                      r = () => (0 === t && (t = Q(e).byteLength), e[--t]);
                    me.createDevice("/dev", "random", r),
                      me.createDevice("/dev", "urandom", r),
                      me.mkdir("/dev/shm"),
                      me.mkdir("/dev/shm/tmp");
                  },
                  createSpecialDirectories() {
                    me.mkdir("/proc");
                    var e = me.mkdir("/proc/self");
                    me.mkdir("/proc/self/fd"),
                      me.mount(
                        {
                          mount() {
                            var t = me.createNode(e, "fd", 16895, 73);
                            return (
                              (t.stream_ops = { llseek: pe.stream_ops.llseek }),
                              (t.node_ops = {
                                lookup(e, t) {
                                  var r = +t,
                                    i = me.getStreamChecked(r),
                                    o = {
                                      parent: null,
                                      mount: { mountpoint: "fake" },
                                      node_ops: { readlink: () => i.path },
                                      id: r + 1,
                                    };
                                  return (o.parent = o), o;
                                },
                                readdir: () =>
                                  Array.from(me.streams.entries())
                                    .filter(([e, t]) => t)
                                    .map(([e, t]) => e.toString()),
                              }),
                              t
                            );
                          },
                        },
                        {},
                        "/proc/self/fd"
                      );
                  },
                  createStandardStreams(e, t, r) {
                    e
                      ? me.createDevice("/dev", "stdin", e)
                      : me.symlink("/dev/tty", "/dev/stdin"),
                      t
                        ? me.createDevice("/dev", "stdout", null, t)
                        : me.symlink("/dev/tty", "/dev/stdout"),
                      r
                        ? me.createDevice("/dev", "stderr", null, r)
                        : me.symlink("/dev/tty1", "/dev/stderr"),
                      me.open("/dev/stdin", 0),
                      me.open("/dev/stdout", 1),
                      me.open("/dev/stderr", 1);
                  },
                  staticInit() {
                    (me.nameTable = new Array(4096)),
                      me.mount(pe, {}, "/"),
                      me.createDefaultDirectories(),
                      me.createDefaultDevices(),
                      me.createSpecialDirectories(),
                      (me.filesystems = { MEMFS: pe });
                  },
                  init(e, t, r) {
                    (me.initialized = !0),
                      (e ??= s.stdin),
                      (t ??= s.stdout),
                      (r ??= s.stderr),
                      me.createStandardStreams(e, t, r);
                  },
                  quit() {
                    me.initialized = !1;
                    for (var e = 0; e < me.streams.length; e++) {
                      var t = me.streams[e];
                      t && me.close(t);
                    }
                  },
                  findObject(e, t) {
                    var r = me.analyzePath(e, t);
                    return r.exists ? r.object : null;
                  },
                  analyzePath(e, t) {
                    try {
                      e = (i = me.lookupPath(e, { follow: !t })).path;
                    } catch (e) {}
                    var r = {
                      isRoot: !1,
                      exists: !1,
                      error: 0,
                      name: null,
                      path: null,
                      object: null,
                      parentExists: !1,
                      parentPath: null,
                      parentObject: null,
                    };
                    try {
                      var i = me.lookupPath(e, { parent: !0 });
                      (r.parentExists = !0),
                        (r.parentPath = i.path),
                        (r.parentObject = i.node),
                        (r.name = J.basename(e)),
                        (i = me.lookupPath(e, { follow: !t })),
                        (r.exists = !0),
                        (r.path = i.path),
                        (r.object = i.node),
                        (r.name = i.node.name),
                        (r.isRoot = "/" === i.path);
                    } catch (e) {
                      r.error = e.errno;
                    }
                    return r;
                  },
                  createPath(e, t, r, i) {
                    e = "string" == typeof e ? e : me.getPath(e);
                    for (var o = t.split("/").reverse(); o.length; ) {
                      var a = o.pop();
                      if (a) {
                        var s = J.join2(e, a);
                        try {
                          me.mkdir(s);
                        } catch (e) {}
                        e = s;
                      }
                    }
                    return s;
                  },
                  createFile(e, t, r, i, o) {
                    var a = J.join2(
                        "string" == typeof e ? e : me.getPath(e),
                        t
                      ),
                      s = ve(i, o);
                    return me.create(a, s);
                  },
                  createDataFile(e, t, r, i, o, a) {
                    var s = t;
                    e &&
                      ((e = "string" == typeof e ? e : me.getPath(e)),
                      (s = t ? J.join2(e, t) : e));
                    var n = ve(i, o),
                      l = me.create(s, n);
                    if (r) {
                      if ("string" == typeof r) {
                        for (
                          var d = new Array(r.length), h = 0, u = r.length;
                          h < u;
                          ++h
                        )
                          d[h] = r.charCodeAt(h);
                        r = d;
                      }
                      me.chmod(l, 146 | n);
                      var c = me.open(l, 577);
                      me.write(c, r, 0, r.length, 0, a),
                        me.close(c),
                        me.chmod(l, n);
                    }
                  },
                  createDevice(e, t, r, i) {
                    var o = J.join2(
                        "string" == typeof e ? e : me.getPath(e),
                        t
                      ),
                      a = ve(!!r, !!i);
                    me.createDevice.major ??= 64;
                    var s = me.makedev(me.createDevice.major++, 0);
                    return (
                      me.registerDevice(s, {
                        open(e) {
                          e.seekable = !1;
                        },
                        close(e) {
                          i?.buffer?.length && i(10);
                        },
                        read(e, t, i, o, a) {
                          for (var s = 0, n = 0; n < o; n++) {
                            var l;
                            try {
                              l = r();
                            } catch (e) {
                              throw new me.ErrnoError(29);
                            }
                            if (void 0 === l && 0 === s)
                              throw new me.ErrnoError(6);
                            if (null == l) break;
                            s++, (t[i + n] = l);
                          }
                          return s && (e.node.atime = Date.now()), s;
                        },
                        write(e, t, r, o, a) {
                          for (var s = 0; s < o; s++)
                            try {
                              i(t[r + s]);
                            } catch (e) {
                              throw new me.ErrnoError(29);
                            }
                          return (
                            o && (e.node.mtime = e.node.ctime = Date.now()), s
                          );
                        },
                      }),
                      me.mkdev(o, a, s)
                    );
                  },
                  forceLoadFile(e) {
                    if (e.isDevice || e.isFolder || e.link || e.contents)
                      return !0;
                    if ("undefined" != typeof XMLHttpRequest)
                      throw new Error(
                        "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
                      );
                    try {
                      (e.contents = a(e.url)),
                        (e.usedBytes = e.contents.length);
                    } catch (e) {
                      throw new me.ErrnoError(29);
                    }
                  },
                  createLazyFile(e, t, r, i, o) {
                    if ("undefined" != typeof XMLHttpRequest)
                      throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                    var a = { isDevice: !1, url: r },
                      s = me.createFile(e, t, a, i, o);
                    a.contents
                      ? (s.contents = a.contents)
                      : a.url && ((s.contents = null), (s.url = a.url)),
                      Object.defineProperties(s, {
                        usedBytes: {
                          get: function () {
                            return this.contents.length;
                          },
                        },
                      });
                    var n = {};
                    function l(e, t, r, i, o) {
                      var a = e.node.contents;
                      if (o >= a.length) return 0;
                      var s = Math.min(a.length - o, i);
                      if (a.slice)
                        for (var n = 0; n < s; n++) t[r + n] = a[o + n];
                      else for (n = 0; n < s; n++) t[r + n] = a.get(o + n);
                      return s;
                    }
                    return (
                      Object.keys(s.stream_ops).forEach((e) => {
                        var t = s.stream_ops[e];
                        n[e] = (...e) => (me.forceLoadFile(s), t(...e));
                      }),
                      (n.read = (e, t, r, i, o) => (
                        me.forceLoadFile(s), l(e, t, r, i, o)
                      )),
                      (n.mmap = (e, t, r, i, o) => {
                        me.forceLoadFile(s);
                        var a = ce();
                        if (!a) throw new me.ErrnoError(48);
                        return l(e, v, a, t, r), { ptr: a, allocated: !0 };
                      }),
                      (s.stream_ops = n),
                      s
                    );
                  },
                },
                Se = (e, t) => (e ? re(m, e, t) : ""),
                Pe = {
                  DEFAULT_POLLMASK: 5,
                  calculateAt(e, t, r) {
                    if (J.isAbs(t)) return t;
                    var i;
                    if (
                      ((i = -100 === e ? me.cwd() : Pe.getStreamFromFD(e).path),
                      0 == t.length)
                    ) {
                      if (!r) throw new me.ErrnoError(44);
                      return i;
                    }
                    return i + "/" + t;
                  },
                  doStat(e, t, r) {
                    var i = e(t);
                    (C[r >> 2] = i.dev),
                      (C[(r + 4) >> 2] = i.mode),
                      (b[(r + 8) >> 2] = i.nlink),
                      (C[(r + 12) >> 2] = i.uid),
                      (C[(r + 16) >> 2] = i.gid),
                      (C[(r + 20) >> 2] = i.rdev),
                      (F = [
                        i.size >>> 0,
                        ((B = i.size),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 24) >> 2] = F[0]),
                      (C[(r + 28) >> 2] = F[1]),
                      (C[(r + 32) >> 2] = 4096),
                      (C[(r + 36) >> 2] = i.blocks);
                    var o = i.atime.getTime(),
                      a = i.mtime.getTime(),
                      s = i.ctime.getTime();
                    return (
                      (F = [
                        Math.floor(o / 1e3) >>> 0,
                        ((B = Math.floor(o / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 40) >> 2] = F[0]),
                      (C[(r + 44) >> 2] = F[1]),
                      (b[(r + 48) >> 2] = (o % 1e3) * 1e3 * 1e3),
                      (F = [
                        Math.floor(a / 1e3) >>> 0,
                        ((B = Math.floor(a / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 56) >> 2] = F[0]),
                      (C[(r + 60) >> 2] = F[1]),
                      (b[(r + 64) >> 2] = (a % 1e3) * 1e3 * 1e3),
                      (F = [
                        Math.floor(s / 1e3) >>> 0,
                        ((B = Math.floor(s / 1e3)),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 72) >> 2] = F[0]),
                      (C[(r + 76) >> 2] = F[1]),
                      (b[(r + 80) >> 2] = (s % 1e3) * 1e3 * 1e3),
                      (F = [
                        i.ino >>> 0,
                        ((B = i.ino),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[(r + 88) >> 2] = F[0]),
                      (C[(r + 92) >> 2] = F[1]),
                      0
                    );
                  },
                  doMsync(e, t, r, i, o) {
                    if (!me.isFile(t.node.mode)) throw new me.ErrnoError(43);
                    if (2 & i) return 0;
                    var a = m.slice(e, e + r);
                    me.msync(t, a, o, r, i);
                  },
                  getStreamFromFD: (e) => me.getStreamChecked(e),
                  varargs: void 0,
                  getStr: (e) => Se(e),
                },
                Ce = (e, t) => Object.defineProperty(t, "name", { value: e }),
                be = [],
                xe = [],
                Ae = (e) => {
                  throw new ne(e);
                },
                Te = {
                  toValue: (e) => (
                    e || Ae("Cannot use deleted val. handle = " + e), xe[e]
                  ),
                  toHandle: (e) => {
                    switch (e) {
                      case void 0:
                        return 2;
                      case null:
                        return 4;
                      case !0:
                        return 6;
                      case !1:
                        return 8;
                      default: {
                        const t = be.pop() || xe.length;
                        return (xe[t] = e), (xe[t + 1] = 1), t;
                      }
                    }
                  },
                },
                Ee = (e, t) => {
                  var r = Ce(t, function (e) {
                    (this.name = t), (this.message = e);
                    var r = new Error(e).stack;
                    void 0 !== r &&
                      (this.stack =
                        this.toString() +
                        "\n" +
                        r.replace(/^Error(:[^\n]*)?\n/, ""));
                  });
                  return (
                    (r.prototype = Object.create(e.prototype)),
                    (r.prototype.constructor = r),
                    (r.prototype.toString = function () {
                      return void 0 === this.message
                        ? this.name
                        : `${this.name}: ${this.message}`;
                    }),
                    r
                  );
                },
                Re = (e) => {
                  for (var t = "", r = e; m[r]; ) t += de[m[r++]];
                  return t;
                },
                De = {},
                we = (e, t) => {
                  for (
                    void 0 === t && Ae("ptr should not be undefined");
                    e.baseClass;

                  )
                    (t = e.upcast(t)), (e = e.baseClass);
                  return t;
                },
                Me = {},
                Le = (e) => {
                  var t = Ls(e),
                    r = Re(t);
                  return Is(t), r;
                },
                Oe = (e, t) => {
                  var r = Me[e];
                  return (
                    void 0 === r && Ae(`${t} has unknown type ${Le(e)}`), r
                  );
                },
                Ie = (e) => {},
                ke = !1,
                _e = (e) => {
                  (e.count.value -= 1),
                    0 === e.count.value &&
                      ((e) => {
                        e.smartPtr
                          ? e.smartPtrType.rawDestructor(e.smartPtr)
                          : e.ptrType.registeredClass.rawDestructor(e.ptr);
                      })(e);
                },
                Ve = (e, t, r) => {
                  if (t === r) return e;
                  if (void 0 === r.baseClass) return null;
                  var i = Ve(e, t, r.baseClass);
                  return null === i ? null : r.downcast(i);
                },
                Ne = {},
                Be = (e, t) => ((t = we(e, t)), De[t]),
                Fe = (e) => {
                  throw new he(e);
                },
                He = (e, t) => (
                  (t.ptrType && t.ptr) ||
                    Fe("makeClassHandle requires ptr and ptrType"),
                  !!t.smartPtrType != !!t.smartPtr &&
                    Fe("Both smartPtrType and smartPtr must be specified"),
                  (t.count = { value: 1 }),
                  Ye(Object.create(e, { $$: { value: t, writable: !0 } }))
                );
              var Ye = (e) =>
                  "undefined" == typeof FinalizationRegistry
                    ? ((Ye = (e) => e), e)
                    : ((ke = new FinalizationRegistry((e) => {
                        _e(e.$$);
                      })),
                      (Ye = (e) => {
                        var t = e.$$;
                        if (t.smartPtr) {
                          var r = { $$: t };
                          ke.register(e, r, e);
                        }
                        return e;
                      }),
                      (Ie = (e) => ke.unregister(e)),
                      Ye(e)),
                ze = {},
                je = {},
                Xe = (e, t, r) => {
                  function i(t) {
                    var i = r(t);
                    i.length !== e.length &&
                      Fe("Mismatched type converter count");
                    for (var o = 0; o < e.length; ++o) Ge(e[o], i[o]);
                  }
                  e.forEach((e) => (je[e] = t));
                  var o = new Array(t.length),
                    a = [],
                    s = 0;
                  t.forEach((e, t) => {
                    Me.hasOwnProperty(e)
                      ? (o[t] = Me[e])
                      : (a.push(e),
                        ze.hasOwnProperty(e) || (ze[e] = []),
                        ze[e].push(() => {
                          (o[t] = Me[e]), ++s === a.length && i(o);
                        }));
                  }),
                    0 === a.length && i(o);
                };
              function Ge(e, t, r = {}) {
                return (function (e, t, r = {}) {
                  var i = t.name;
                  if (
                    (e ||
                      Ae(
                        `type "${i}" must have a positive integer typeid pointer`
                      ),
                    Me.hasOwnProperty(e))
                  ) {
                    if (r.ignoreDuplicateRegistrations) return;
                    Ae(`Cannot register type '${i}' twice`);
                  }
                  if (((Me[e] = t), delete je[e], ze.hasOwnProperty(e))) {
                    var o = ze[e];
                    delete ze[e], o.forEach((e) => e());
                  }
                })(e, t, r);
              }
              var We = (e) => {
                  Ae(
                    e.$$.ptrType.registeredClass.name +
                      " instance already deleted"
                  );
                },
                Ue = [];
              function $e() {}
              var Ze = (e, t, r) => {
                  if (void 0 === e[t].overloadTable) {
                    var i = e[t];
                    (e[t] = function (...i) {
                      return (
                        e[t].overloadTable.hasOwnProperty(i.length) ||
                          Ae(
                            `Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`
                          ),
                        e[t].overloadTable[i.length].apply(this, i)
                      );
                    }),
                      (e[t].overloadTable = []),
                      (e[t].overloadTable[i.argCount] = i);
                  }
                },
                qe = (e, t, r) => {
                  s.hasOwnProperty(e)
                    ? ((void 0 === r ||
                        (void 0 !== s[e].overloadTable &&
                          void 0 !== s[e].overloadTable[r])) &&
                        Ae(`Cannot register public name '${e}' twice`),
                      Ze(s, e, e),
                      s[e].overloadTable.hasOwnProperty(r) &&
                        Ae(
                          `Cannot register multiple overloads of a function with the same number of arguments (${r})!`
                        ),
                      (s[e].overloadTable[r] = t))
                    : ((s[e] = t), (s[e].argCount = r));
                };
              function Ke(e, t, r, i, o, a, s, n) {
                (this.name = e),
                  (this.constructor = t),
                  (this.instancePrototype = r),
                  (this.rawDestructor = i),
                  (this.baseClass = o),
                  (this.getActualType = a),
                  (this.upcast = s),
                  (this.downcast = n),
                  (this.pureVirtualFunctions = []);
              }
              var Je = (e, t, r) => {
                for (; t !== r; )
                  t.upcast ||
                    Ae(
                      `Expected null or instance of ${r.name}, got an instance of ${t.name}`
                    ),
                    (e = t.upcast(e)),
                    (t = t.baseClass);
                return e;
              };
              function Qe(e, t) {
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    0
                  );
                t.$$ || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    );
                var r = t.$$.ptrType.registeredClass;
                return Je(t.$$.ptr, r, this.registeredClass);
              }
              function et(e, t) {
                var r;
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    this.isSmartPointer
                      ? ((r = this.rawConstructor()),
                        null !== e && e.push(this.rawDestructor, r),
                        r)
                      : 0
                  );
                (t && t.$$) || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    ),
                  !this.isConst &&
                    t.$$.ptrType.isConst &&
                    Ae(
                      `Cannot convert argument of type ${
                        t.$$.smartPtrType
                          ? t.$$.smartPtrType.name
                          : t.$$.ptrType.name
                      } to parameter type ${this.name}`
                    );
                var i = t.$$.ptrType.registeredClass;
                if (
                  ((r = Je(t.$$.ptr, i, this.registeredClass)),
                  this.isSmartPointer)
                )
                  switch (
                    (void 0 === t.$$.smartPtr &&
                      Ae("Passing raw pointer to smart pointer is illegal"),
                    this.sharingPolicy)
                  ) {
                    case 0:
                      t.$$.smartPtrType === this
                        ? (r = t.$$.smartPtr)
                        : Ae(
                            `Cannot convert argument of type ${
                              t.$$.smartPtrType
                                ? t.$$.smartPtrType.name
                                : t.$$.ptrType.name
                            } to parameter type ${this.name}`
                          );
                      break;
                    case 1:
                      r = t.$$.smartPtr;
                      break;
                    case 2:
                      if (t.$$.smartPtrType === this) r = t.$$.smartPtr;
                      else {
                        var o = t.clone();
                        (r = this.rawShare(
                          r,
                          Te.toHandle(() => o.delete())
                        )),
                          null !== e && e.push(this.rawDestructor, r);
                      }
                      break;
                    default:
                      Ae("Unsupporting sharing policy");
                  }
                return r;
              }
              function tt(e, t) {
                if (null === t)
                  return (
                    this.isReference && Ae(`null is not a valid ${this.name}`),
                    0
                  );
                t.$$ || Ae(`Cannot pass "${Pt(t)}" as a ${this.name}`),
                  t.$$.ptr ||
                    Ae(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    ),
                  t.$$.ptrType.isConst &&
                    Ae(
                      `Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`
                    );
                var r = t.$$.ptrType.registeredClass;
                return Je(t.$$.ptr, r, this.registeredClass);
              }
              function rt(e) {
                return this.fromWireType(b[e >> 2]);
              }
              function it(e, t, r, i, o, a, s, n, l, d, h) {
                (this.name = e),
                  (this.registeredClass = t),
                  (this.isReference = r),
                  (this.isConst = i),
                  (this.isSmartPointer = o),
                  (this.pointeeType = a),
                  (this.sharingPolicy = s),
                  (this.rawGetPointee = n),
                  (this.rawConstructor = l),
                  (this.rawShare = d),
                  (this.rawDestructor = h),
                  o || void 0 !== t.baseClass
                    ? (this.toWireType = et)
                    : i
                    ? ((this.toWireType = Qe), (this.destructorFunction = null))
                    : ((this.toWireType = tt),
                      (this.destructorFunction = null));
              }
              var ot,
                at,
                st = (e, t, r) => {
                  s.hasOwnProperty(e) ||
                    Fe("Replacing nonexistent public symbol"),
                    void 0 !== s[e].overloadTable && void 0 !== r
                      ? (s[e].overloadTable[r] = t)
                      : ((s[e] = t), (s[e].argCount = r));
                },
                nt = (e) => ot.get(e),
                lt = (e, t, r = []) =>
                  e.includes("j")
                    ? ((e, t, r) => (
                        (e = e.replace(/p/g, "i")),
                        (0, s["dynCall_" + e])(t, ...r)
                      ))(e, t, r)
                    : nt(t)(...r),
                dt = (e, t) => {
                  var r,
                    i,
                    o = (e = Re(e)).includes("j")
                      ? ((r = e), (i = t), (...e) => lt(r, i, e))
                      : nt(t);
                  return (
                    "function" != typeof o &&
                      Ae(`unknown function pointer with signature ${e}: ${t}`),
                    o
                  );
                },
                ht = (e, t) => {
                  var r = [],
                    i = {};
                  throw (
                    (t.forEach(function e(t) {
                      i[t] ||
                        Me[t] ||
                        (je[t] ? je[t].forEach(e) : (r.push(t), (i[t] = !0)));
                    }),
                    new at(`${e}: ` + r.map(Le).join([", "])))
                  );
                },
                ut = (e) => {
                  for (; e.length; ) {
                    var t = e.pop();
                    e.pop()(t);
                  }
                };
              function ct(e, t, r, i, o, a) {
                var s = t.length;
                s < 2 &&
                  Ae(
                    "argTypes array size mismatch! Must at least get return value and 'this' types!"
                  );
                var n = null !== t[1] && null !== r,
                  l = (function (e) {
                    for (var t = 1; t < e.length; ++t)
                      if (null !== e[t] && void 0 === e[t].destructorFunction)
                        return !0;
                    return !1;
                  })(t),
                  d = "void" !== t[0].name,
                  h = s - 2,
                  u = new Array(h),
                  c = [],
                  p = [];
                return Ce(e, function (...e) {
                  var r;
                  (p.length = 0),
                    (c.length = n ? 2 : 1),
                    (c[0] = o),
                    n && ((r = t[1].toWireType(p, this)), (c[1] = r));
                  for (var a = 0; a < h; ++a)
                    (u[a] = t[a + 2].toWireType(p, e[a])), c.push(u[a]);
                  return (function (e) {
                    if (l) ut(p);
                    else
                      for (var i = n ? 1 : 2; i < t.length; i++) {
                        var o = 1 === i ? r : u[i - 2];
                        null !== t[i].destructorFunction &&
                          t[i].destructorFunction(o);
                      }
                    if (d) return t[0].fromWireType(e);
                  })(i(...c));
                });
              }
              var pt,
                gt = (e, t) => {
                  for (var r = [], i = 0; i < e; i++)
                    r.push(b[(t + 4 * i) >> 2]);
                  return r;
                },
                yt = (e) => {
                  const t = (e = e.trim()).indexOf("(");
                  return -1 !== t ? e.substr(0, t) : e;
                },
                ft = (e, t, r) => (
                  e instanceof Object || Ae(`${r} with invalid "this": ${e}`),
                  e instanceof t.registeredClass.constructor ||
                    Ae(
                      `${r} incompatible with "this" of type ${e.constructor.name}`
                    ),
                  e.$$.ptr ||
                    Ae(
                      `cannot call emscripten binding method ${r} on deleted object`
                    ),
                  Je(e.$$.ptr, e.$$.ptrType.registeredClass, t.registeredClass)
                ),
                vt = (e) => {
                  e > 9 && 0 == --xe[e + 1] && ((xe[e] = void 0), be.push(e));
                },
                mt = {
                  name: "emscripten::val",
                  fromWireType: (e) => {
                    var t = Te.toValue(e);
                    return vt(e), t;
                  },
                  toWireType: (e, t) => Te.toHandle(t),
                  argPackAdvance: 8,
                  readValueFromPointer: rt,
                  destructorFunction: null,
                },
                St = (e, t, r) => {
                  switch (t) {
                    case 1:
                      return r
                        ? function (e) {
                            return this.fromWireType(v[e]);
                          }
                        : function (e) {
                            return this.fromWireType(m[e]);
                          };
                    case 2:
                      return r
                        ? function (e) {
                            return this.fromWireType(S[e >> 1]);
                          }
                        : function (e) {
                            return this.fromWireType(P[e >> 1]);
                          };
                    case 4:
                      return r
                        ? function (e) {
                            return this.fromWireType(C[e >> 2]);
                          }
                        : function (e) {
                            return this.fromWireType(b[e >> 2]);
                          };
                    default:
                      throw new TypeError(`invalid integer width (${t}): ${e}`);
                  }
                },
                Pt = (e) => {
                  if (null === e) return "null";
                  var t = typeof e;
                  return "object" === t || "array" === t || "function" === t
                    ? e.toString()
                    : "" + e;
                },
                Ct = (e, t) => {
                  switch (t) {
                    case 4:
                      return function (e) {
                        return this.fromWireType(x[e >> 2]);
                      };
                    case 8:
                      return function (e) {
                        return this.fromWireType(A[e >> 3]);
                      };
                    default:
                      throw new TypeError(`invalid float width (${t}): ${e}`);
                  }
                },
                bt = (e, t, r) => {
                  switch (t) {
                    case 1:
                      return r ? (e) => v[e] : (e) => m[e];
                    case 2:
                      return r ? (e) => S[e >> 1] : (e) => P[e >> 1];
                    case 4:
                      return r ? (e) => C[e >> 2] : (e) => b[e >> 2];
                    default:
                      throw new TypeError(`invalid integer width (${t}): ${e}`);
                  }
                },
                xt = (e, t, r) => ae(e, m, t, r),
                At =
                  "undefined" != typeof TextDecoder
                    ? new TextDecoder("utf-16le")
                    : void 0,
                Tt = (e, t) => {
                  for (
                    var r = e, i = r >> 1, o = i + t / 2;
                    !(i >= o) && P[i];

                  )
                    ++i;
                  if ((r = i << 1) - e > 32 && At)
                    return At.decode(m.subarray(e, r));
                  for (var a = "", s = 0; !(s >= t / 2); ++s) {
                    var n = S[(e + 2 * s) >> 1];
                    if (0 == n) break;
                    a += String.fromCharCode(n);
                  }
                  return a;
                },
                Et = (e, t, r) => {
                  if (((r ??= 2147483647), r < 2)) return 0;
                  for (
                    var i = t,
                      o = (r -= 2) < 2 * e.length ? r / 2 : e.length,
                      a = 0;
                    a < o;
                    ++a
                  ) {
                    var s = e.charCodeAt(a);
                    (S[t >> 1] = s), (t += 2);
                  }
                  return (S[t >> 1] = 0), t - i;
                },
                Rt = (e) => 2 * e.length,
                Dt = (e, t) => {
                  for (var r = 0, i = ""; !(r >= t / 4); ) {
                    var o = C[(e + 4 * r) >> 2];
                    if (0 == o) break;
                    if ((++r, o >= 65536)) {
                      var a = o - 65536;
                      i += String.fromCharCode(
                        55296 | (a >> 10),
                        56320 | (1023 & a)
                      );
                    } else i += String.fromCharCode(o);
                  }
                  return i;
                },
                wt = (e, t, r) => {
                  if (((r ??= 2147483647), r < 4)) return 0;
                  for (var i = t, o = i + r - 4, a = 0; a < e.length; ++a) {
                    var s = e.charCodeAt(a);
                    if (
                      (s >= 55296 &&
                        s <= 57343 &&
                        (s =
                          (65536 + ((1023 & s) << 10)) |
                          (1023 & e.charCodeAt(++a))),
                      (C[t >> 2] = s),
                      (t += 4) + 4 > o)
                    )
                      break;
                  }
                  return (C[t >> 2] = 0), t - i;
                },
                Mt = (e) => {
                  for (var t = 0, r = 0; r < e.length; ++r) {
                    var i = e.charCodeAt(r);
                    i >= 55296 && i <= 57343 && ++r, (t += 4);
                  }
                  return t;
                },
                Lt = {},
                Ot = [],
                It = Reflect.construct,
                kt = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
                _t = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
                Vt = (e, t) =>
                  (t + 2097152) >>> 0 < 4194305 - !!e
                    ? (e >>> 0) + 4294967296 * t
                    : NaN,
                Nt = () => performance.now(),
                Bt = () => Date.now(),
                Ft = (e) => {
                  if (e instanceof j || "unwind" == e) return f;
                  u(0, e);
                },
                Ht = () => G || !1,
                Yt = (e, t) => {
                  var r;
                  (f = e),
                    (f = r = e),
                    Ht() || (s.onExit?.(r), (E = !0)),
                    u(0, new j(r));
                },
                zt = Yt,
                jt = () => {
                  if (!Ht())
                    try {
                      zt(f);
                    } catch (e) {
                      Ft(e);
                    }
                },
                Xt = (e) => {
                  if (!E)
                    try {
                      e(), jt();
                    } catch (e) {
                      Ft(e);
                    }
                },
                Gt = (e, t) =>
                  setTimeout(() => {
                    Xt(e);
                  }, t),
                Wt = {
                  useWebGL: !1,
                  isFullscreen: !1,
                  pointerLock: !1,
                  moduleContextCreatedCallbacks: [],
                  workers: [],
                  preloadedImages: {},
                  preloadedAudios: {},
                  init() {
                    if (!Wt.initted) {
                      Wt.initted = !0;
                      var e = {
                        canHandle: function (e) {
                          return (
                            !s.noImageDecoding &&
                            /\.(jpg|jpeg|png|bmp|webp)$/i.test(e)
                          );
                        },
                        handle: function (e, t, r, i) {
                          var o = new Blob([e], { type: Wt.getMimetype(t) });
                          o.size !== e.length &&
                            (o = new Blob([new Uint8Array(e).buffer], {
                              type: Wt.getMimetype(t),
                            }));
                          var a = URL.createObjectURL(o),
                            s = new Image();
                          (s.onload = () => {
                            var i = document.createElement("canvas");
                            (i.width = s.width),
                              (i.height = s.height),
                              i.getContext("2d").drawImage(s, 0, 0),
                              (Wt.preloadedImages[t] = i),
                              URL.revokeObjectURL(a),
                              r?.(e);
                          }),
                            (s.onerror = (e) => {
                              g(`Image ${a} could not be decoded`), i?.();
                            }),
                            (s.src = a);
                        },
                      };
                      ye.push(e);
                      var t = {
                        canHandle: function (e) {
                          return (
                            !s.noAudioDecoding &&
                            e.substr(-4) in { ".ogg": 1, ".wav": 1, ".mp3": 1 }
                          );
                        },
                        handle: function (e, t, r, i) {
                          var o = !1;
                          function a(i) {
                            o ||
                              ((o = !0), (Wt.preloadedAudios[t] = i), r?.(e));
                          }
                          var s = new Blob([e], { type: Wt.getMimetype(t) }),
                            n = URL.createObjectURL(s),
                            l = new Audio();
                          l.addEventListener("canplaythrough", () => a(l), !1),
                            (l.onerror = function (r) {
                              o ||
                                (g(
                                  `warning: browser could not fully decode audio ${t}, trying slower base64 approach`
                                ),
                                (l.src =
                                  "data:audio/x-" +
                                  t.substr(-3) +
                                  ";base64," +
                                  (function (e) {
                                    for (
                                      var t =
                                          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                                        r = "",
                                        i = 0,
                                        o = 0,
                                        a = 0;
                                      a < e.length;
                                      a++
                                    )
                                      for (
                                        i = (i << 8) | e[a], o += 8;
                                        o >= 6;

                                      ) {
                                        var s = (i >> (o - 6)) & 63;
                                        (o -= 6), (r += t[s]);
                                      }
                                    return (
                                      2 == o
                                        ? ((r += t[(3 & i) << 4]), (r += "=="))
                                        : 4 == o &&
                                          ((r += t[(15 & i) << 2]), (r += "=")),
                                      r
                                    );
                                  })(e)),
                                a(l));
                            }),
                            (l.src = n),
                            Gt(() => {
                              a(l);
                            }, 1e4);
                        },
                      };
                      ye.push(t);
                      var r = s.canvas;
                      r &&
                        ((r.requestPointerLock =
                          r.requestPointerLock ||
                          r.mozRequestPointerLock ||
                          r.webkitRequestPointerLock ||
                          r.msRequestPointerLock ||
                          (() => {})),
                        (r.exitPointerLock =
                          document.exitPointerLock ||
                          document.mozExitPointerLock ||
                          document.webkitExitPointerLock ||
                          document.msExitPointerLock ||
                          (() => {})),
                        (r.exitPointerLock = r.exitPointerLock.bind(document)),
                        document.addEventListener("pointerlockchange", i, !1),
                        document.addEventListener(
                          "mozpointerlockchange",
                          i,
                          !1
                        ),
                        document.addEventListener(
                          "webkitpointerlockchange",
                          i,
                          !1
                        ),
                        document.addEventListener("mspointerlockchange", i, !1),
                        s.elementPointerLock &&
                          r.addEventListener(
                            "click",
                            (e) => {
                              !Wt.pointerLock &&
                                s.canvas.requestPointerLock &&
                                (s.canvas.requestPointerLock(),
                                e.preventDefault());
                            },
                            !1
                          ));
                    }
                    function i() {
                      Wt.pointerLock =
                        document.pointerLockElement === s.canvas ||
                        document.mozPointerLockElement === s.canvas ||
                        document.webkitPointerLockElement === s.canvas ||
                        document.msPointerLockElement === s.canvas;
                    }
                  },
                  createContext(e, t, r, i) {
                    if (t && s.ctx && e == s.canvas) return s.ctx;
                    var o, a;
                    if (t) {
                      var n = {
                        antialias: !1,
                        alpha: !1,
                        majorVersion:
                          "undefined" != typeof WebGL2RenderingContext ? 2 : 1,
                      };
                      if (i) for (var l in i) n[l] = i[l];
                      void 0 !== Zt &&
                        (a = Zt.createContext(e, n)) &&
                        (o = Zt.getContext(a).GLctx);
                    } else o = e.getContext("2d");
                    return o
                      ? (r &&
                          ((s.ctx = o),
                          t && Zt.makeContextCurrent(a),
                          (Wt.useWebGL = t),
                          Wt.moduleContextCreatedCallbacks.forEach((e) => e()),
                          Wt.init()),
                        o)
                      : null;
                  },
                  fullscreenHandlersInstalled: !1,
                  lockPointer: void 0,
                  resizeCanvas: void 0,
                  requestFullscreen(e, t) {
                    (Wt.lockPointer = e),
                      (Wt.resizeCanvas = t),
                      void 0 === Wt.lockPointer && (Wt.lockPointer = !0),
                      void 0 === Wt.resizeCanvas && (Wt.resizeCanvas = !1);
                    var r = s.canvas;
                    function i() {
                      Wt.isFullscreen = !1;
                      var e = r.parentNode;
                      (document.fullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.webkitCurrentFullScreenElement) === e
                        ? ((r.exitFullscreen = Wt.exitFullscreen),
                          Wt.lockPointer && r.requestPointerLock(),
                          (Wt.isFullscreen = !0),
                          Wt.resizeCanvas
                            ? Wt.setFullscreenCanvasSize()
                            : Wt.updateCanvasDimensions(r))
                        : (e.parentNode.insertBefore(r, e),
                          e.parentNode.removeChild(e),
                          Wt.resizeCanvas
                            ? Wt.setWindowedCanvasSize()
                            : Wt.updateCanvasDimensions(r)),
                        s.onFullScreen?.(Wt.isFullscreen),
                        s.onFullscreen?.(Wt.isFullscreen);
                    }
                    Wt.fullscreenHandlersInstalled ||
                      ((Wt.fullscreenHandlersInstalled = !0),
                      document.addEventListener("fullscreenchange", i, !1),
                      document.addEventListener("mozfullscreenchange", i, !1),
                      document.addEventListener(
                        "webkitfullscreenchange",
                        i,
                        !1
                      ),
                      document.addEventListener("MSFullscreenChange", i, !1));
                    var o = document.createElement("div");
                    r.parentNode.insertBefore(o, r),
                      o.appendChild(r),
                      (o.requestFullscreen =
                        o.requestFullscreen ||
                        o.mozRequestFullScreen ||
                        o.msRequestFullscreen ||
                        (o.webkitRequestFullscreen
                          ? () =>
                              o.webkitRequestFullscreen(
                                Element.ALLOW_KEYBOARD_INPUT
                              )
                          : null) ||
                        (o.webkitRequestFullScreen
                          ? () =>
                              o.webkitRequestFullScreen(
                                Element.ALLOW_KEYBOARD_INPUT
                              )
                          : null)),
                      o.requestFullscreen();
                  },
                  exitFullscreen: () =>
                    !!Wt.isFullscreen &&
                    ((
                      document.exitFullscreen ||
                      document.cancelFullScreen ||
                      document.mozCancelFullScreen ||
                      document.msExitFullscreen ||
                      document.webkitCancelFullScreen ||
                      (() => {})
                    ).apply(document, []),
                    !0),
                  safeSetTimeout: (e, t) => Gt(e, t),
                  getMimetype: (e) =>
                    ({
                      jpg: "image/jpeg",
                      jpeg: "image/jpeg",
                      png: "image/png",
                      bmp: "image/bmp",
                      ogg: "audio/ogg",
                      wav: "audio/wav",
                      mp3: "audio/mpeg",
                    }[e.substr(e.lastIndexOf(".") + 1)]),
                  getUserMedia(e) {
                    (window.getUserMedia ||=
                      navigator.getUserMedia || navigator.mozGetUserMedia),
                      window.getUserMedia(e);
                  },
                  getMovementX: (e) =>
                    e.movementX || e.mozMovementX || e.webkitMovementX || 0,
                  getMovementY: (e) =>
                    e.movementY || e.mozMovementY || e.webkitMovementY || 0,
                  getMouseWheelDelta(e) {
                    var t = 0;
                    switch (e.type) {
                      case "DOMMouseScroll":
                        t = e.detail / 3;
                        break;
                      case "mousewheel":
                        t = e.wheelDelta / 120;
                        break;
                      case "wheel":
                        switch (((t = e.deltaY), e.deltaMode)) {
                          case 0:
                            t /= 100;
                            break;
                          case 1:
                            t /= 3;
                            break;
                          case 2:
                            t *= 80;
                            break;
                          default:
                            throw (
                              "unrecognized mouse wheel delta mode: " +
                              e.deltaMode
                            );
                        }
                        break;
                      default:
                        throw "unrecognized mouse wheel event: " + e.type;
                    }
                    return t;
                  },
                  mouseX: 0,
                  mouseY: 0,
                  mouseMovementX: 0,
                  mouseMovementY: 0,
                  touches: {},
                  lastTouches: {},
                  calculateMouseCoords(e, t) {
                    var r = s.canvas.getBoundingClientRect(),
                      i = s.canvas.width,
                      o = s.canvas.height,
                      a =
                        void 0 !== window.scrollX
                          ? window.scrollX
                          : window.pageXOffset,
                      n =
                        void 0 !== window.scrollY
                          ? window.scrollY
                          : window.pageYOffset,
                      l = e - (a + r.left),
                      d = t - (n + r.top);
                    return { x: (l *= i / r.width), y: (d *= o / r.height) };
                  },
                  setMouseCoords(e, t) {
                    const { x: r, y: i } = Wt.calculateMouseCoords(e, t);
                    (Wt.mouseMovementX = r - Wt.mouseX),
                      (Wt.mouseMovementY = i - Wt.mouseY),
                      (Wt.mouseX = r),
                      (Wt.mouseY = i);
                  },
                  calculateMouseEvent(e) {
                    if (Wt.pointerLock)
                      "mousemove" != e.type && "mozMovementX" in e
                        ? (Wt.mouseMovementX = Wt.mouseMovementY = 0)
                        : ((Wt.mouseMovementX = Wt.getMovementX(e)),
                          (Wt.mouseMovementY = Wt.getMovementY(e))),
                        (Wt.mouseX += Wt.mouseMovementX),
                        (Wt.mouseY += Wt.mouseMovementY);
                    else {
                      if (
                        "touchstart" === e.type ||
                        "touchend" === e.type ||
                        "touchmove" === e.type
                      ) {
                        var t = e.touch;
                        if (void 0 === t) return;
                        var r = Wt.calculateMouseCoords(t.pageX, t.pageY);
                        if ("touchstart" === e.type)
                          (Wt.lastTouches[t.identifier] = r),
                            (Wt.touches[t.identifier] = r);
                        else if (
                          "touchend" === e.type ||
                          "touchmove" === e.type
                        ) {
                          var i = Wt.touches[t.identifier];
                          (i ||= r),
                            (Wt.lastTouches[t.identifier] = i),
                            (Wt.touches[t.identifier] = r);
                        }
                        return;
                      }
                      Wt.setMouseCoords(e.pageX, e.pageY);
                    }
                  },
                  resizeListeners: [],
                  updateResizeListeners() {
                    var e = s.canvas;
                    Wt.resizeListeners.forEach((t) => t(e.width, e.height));
                  },
                  setCanvasSize(e, t, r) {
                    var i = s.canvas;
                    Wt.updateCanvasDimensions(i, e, t),
                      r || Wt.updateResizeListeners();
                  },
                  windowedWidth: 0,
                  windowedHeight: 0,
                  setFullscreenCanvasSize() {
                    if ("undefined" != typeof SDL) {
                      var e = b[SDL.screen >> 2];
                      (e |= 8388608), (C[SDL.screen >> 2] = e);
                    }
                    Wt.updateCanvasDimensions(s.canvas),
                      Wt.updateResizeListeners();
                  },
                  setWindowedCanvasSize() {
                    if ("undefined" != typeof SDL) {
                      var e = b[SDL.screen >> 2];
                      (e &= -8388609), (C[SDL.screen >> 2] = e);
                    }
                    Wt.updateCanvasDimensions(s.canvas),
                      Wt.updateResizeListeners();
                  },
                  updateCanvasDimensions(e, t, r) {
                    t && r
                      ? ((e.widthNative = t), (e.heightNative = r))
                      : ((t = e.widthNative), (r = e.heightNative));
                    var i = t,
                      o = r;
                    if (
                      (s.forcedAspectRatio &&
                        s.forcedAspectRatio > 0 &&
                        (i / o < s.forcedAspectRatio
                          ? (i = Math.round(o * s.forcedAspectRatio))
                          : (o = Math.round(i / s.forcedAspectRatio))),
                      (document.fullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.webkitCurrentFullScreenElement) ===
                        e.parentNode && "undefined" != typeof screen)
                    ) {
                      var a = Math.min(screen.width / i, screen.height / o);
                      (i = Math.round(i * a)), (o = Math.round(o * a));
                    }
                    Wt.resizeCanvas
                      ? (e.width != i && (e.width = i),
                        e.height != o && (e.height = o),
                        void 0 !== e.style &&
                          (e.style.removeProperty("width"),
                          e.style.removeProperty("height")))
                      : (e.width != t && (e.width = t),
                        e.height != r && (e.height = r),
                        void 0 !== e.style &&
                          (i != t || o != r
                            ? (e.style.setProperty(
                                "width",
                                i + "px",
                                "important"
                              ),
                              e.style.setProperty(
                                "height",
                                o + "px",
                                "important"
                              ))
                            : (e.style.removeProperty("width"),
                              e.style.removeProperty("height"))));
                  },
                },
                Ut = {
                  errorCode: 12288,
                  defaultDisplayInitialized: !1,
                  currentContext: 0,
                  currentReadSurface: 0,
                  currentDrawSurface: 0,
                  contextAttributes: {
                    alpha: !1,
                    depth: !1,
                    stencil: !1,
                    antialias: !1,
                  },
                  stringCache: {},
                  setErrorCode(e) {
                    Ut.errorCode = e;
                  },
                  chooseConfig(e, t, r, i, o) {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if (t)
                      for (;;) {
                        var a = C[t >> 2];
                        if (12321 == a) {
                          var s = C[(t + 4) >> 2];
                          Ut.contextAttributes.alpha = s > 0;
                        } else if (12325 == a) {
                          var n = C[(t + 4) >> 2];
                          Ut.contextAttributes.depth = n > 0;
                        } else if (12326 == a) {
                          var l = C[(t + 4) >> 2];
                          Ut.contextAttributes.stencil = l > 0;
                        } else if (12337 == a) {
                          var d = C[(t + 4) >> 2];
                          Ut.contextAttributes.antialias = d > 0;
                        } else if (12338 == a)
                          (d = C[(t + 4) >> 2]),
                            (Ut.contextAttributes.antialias = 1 == d);
                        else if (12544 == a) {
                          var h = C[(t + 4) >> 2];
                          Ut.contextAttributes.lowLatency = 12547 != h;
                        } else if (12344 == a) break;
                        t += 8;
                      }
                    return (r && i) || o
                      ? (o && (C[o >> 2] = 1),
                        r && i > 0 && (b[r >> 2] = 62002),
                        Ut.setErrorCode(12288),
                        1)
                      : (Ut.setErrorCode(12300), 0);
                  },
                },
                $t = (e) => {
                  var t = [
                    "ANGLE_instanced_arrays",
                    "EXT_blend_minmax",
                    "EXT_disjoint_timer_query",
                    "EXT_frag_depth",
                    "EXT_shader_texture_lod",
                    "EXT_sRGB",
                    "OES_element_index_uint",
                    "OES_fbo_render_mipmap",
                    "OES_standard_derivatives",
                    "OES_texture_float",
                    "OES_texture_half_float",
                    "OES_texture_half_float_linear",
                    "OES_vertex_array_object",
                    "WEBGL_color_buffer_float",
                    "WEBGL_depth_texture",
                    "WEBGL_draw_buffers",
                    "EXT_color_buffer_float",
                    "EXT_conservative_depth",
                    "EXT_disjoint_timer_query_webgl2",
                    "EXT_texture_norm16",
                    "NV_shader_noperspective_interpolation",
                    "WEBGL_clip_cull_distance",
                    "EXT_clip_control",
                    "EXT_color_buffer_half_float",
                    "EXT_depth_clamp",
                    "EXT_float_blend",
                    "EXT_polygon_offset_clamp",
                    "EXT_texture_compression_bptc",
                    "EXT_texture_compression_rgtc",
                    "EXT_texture_filter_anisotropic",
                    "KHR_parallel_shader_compile",
                    "OES_texture_float_linear",
                    "WEBGL_blend_func_extended",
                    "WEBGL_compressed_texture_astc",
                    "WEBGL_compressed_texture_etc",
                    "WEBGL_compressed_texture_etc1",
                    "WEBGL_compressed_texture_s3tc",
                    "WEBGL_compressed_texture_s3tc_srgb",
                    "WEBGL_debug_renderer_info",
                    "WEBGL_debug_shaders",
                    "WEBGL_lose_context",
                    "WEBGL_multi_draw",
                    "WEBGL_polygon_mode",
                  ];
                  return (e.getSupportedExtensions() || []).filter((e) =>
                    t.includes(e)
                  );
                },
                Zt = {
                  counter: 1,
                  buffers: [],
                  programs: [],
                  framebuffers: [],
                  renderbuffers: [],
                  textures: [],
                  shaders: [],
                  vaos: [],
                  contexts: [],
                  offscreenCanvases: {},
                  queries: [],
                  samplers: [],
                  transformFeedbacks: [],
                  syncs: [],
                  stringCache: {},
                  stringiCache: {},
                  unpackAlignment: 4,
                  unpackRowLength: 0,
                  recordError: (e) => {
                    Zt.lastError || (Zt.lastError = e);
                  },
                  getNewId: (e) => {
                    for (var t = Zt.counter++, r = e.length; r < t; r++)
                      e[r] = null;
                    return t;
                  },
                  genObject: (e, t, r, i) => {
                    for (var o = 0; o < e; o++) {
                      var a = pt[r](),
                        s = a && Zt.getNewId(i);
                      a ? ((a.name = s), (i[s] = a)) : Zt.recordError(1282),
                        (C[(t + 4 * o) >> 2] = s);
                    }
                  },
                  getSource: (e, t, r, i) => {
                    for (var o = "", a = 0; a < t; ++a) {
                      var s = i ? b[(i + 4 * a) >> 2] : void 0;
                      o += Se(b[(r + 4 * a) >> 2], s);
                    }
                    return o;
                  },
                  createContext: (e, t) => {
                    var r =
                      t.majorVersion > 1
                        ? e.getContext("webgl2", t)
                        : e.getContext("webgl", t);
                    return r ? Zt.registerContext(r, t) : 0;
                  },
                  registerContext: (e, t) => {
                    var r = Zt.getNewId(Zt.contexts),
                      i = {
                        handle: r,
                        attributes: t,
                        version: t.majorVersion,
                        GLctx: e,
                      };
                    return (
                      e.canvas && (e.canvas.GLctxObject = i),
                      (Zt.contexts[r] = i),
                      (void 0 === t.enableExtensionsByDefault ||
                        t.enableExtensionsByDefault) &&
                        Zt.initExtensions(i),
                      r
                    );
                  },
                  makeContextCurrent: (e) => (
                    (Zt.currentContext = Zt.contexts[e]),
                    (s.ctx = pt = Zt.currentContext?.GLctx),
                    !(e && !pt)
                  ),
                  getContext: (e) => Zt.contexts[e],
                  deleteContext: (e) => {
                    Zt.currentContext === Zt.contexts[e] &&
                      (Zt.currentContext = null),
                      "object" == typeof ir &&
                        ir.removeAllHandlersOnTarget(
                          Zt.contexts[e].GLctx.canvas
                        ),
                      Zt.contexts[e] &&
                        Zt.contexts[e].GLctx.canvas &&
                        (Zt.contexts[e].GLctx.canvas.GLctxObject = void 0),
                      (Zt.contexts[e] = null);
                  },
                  initExtensions: (e) => {
                    if (((e ||= Zt.currentContext), !e.initExtensionsDone)) {
                      e.initExtensionsDone = !0;
                      var t,
                        r = e.GLctx;
                      ((t = r).multiDrawWebgl =
                        t.getExtension("WEBGL_multi_draw")),
                        ((e) => {
                          e.extPolygonOffsetClamp = e.getExtension(
                            "EXT_polygon_offset_clamp"
                          );
                        })(r),
                        ((e) => {
                          e.extClipControl = e.getExtension("EXT_clip_control");
                        })(r),
                        ((e) => {
                          e.webglPolygonMode =
                            e.getExtension("WEBGL_polygon_mode");
                        })(r),
                        ((e) => {
                          var t = e.getExtension("ANGLE_instanced_arrays");
                          t &&
                            ((e.vertexAttribDivisor = (e, r) =>
                              t.vertexAttribDivisorANGLE(e, r)),
                            (e.drawArraysInstanced = (e, r, i, o) =>
                              t.drawArraysInstancedANGLE(e, r, i, o)),
                            (e.drawElementsInstanced = (e, r, i, o, a) =>
                              t.drawElementsInstancedANGLE(e, r, i, o, a)));
                        })(r),
                        ((e) => {
                          var t = e.getExtension("OES_vertex_array_object");
                          t &&
                            ((e.createVertexArray = () =>
                              t.createVertexArrayOES()),
                            (e.deleteVertexArray = (e) =>
                              t.deleteVertexArrayOES(e)),
                            (e.bindVertexArray = (e) =>
                              t.bindVertexArrayOES(e)),
                            (e.isVertexArray = (e) => t.isVertexArrayOES(e)));
                        })(r),
                        ((e) => {
                          var t = e.getExtension("WEBGL_draw_buffers");
                          t &&
                            (e.drawBuffers = (e, r) =>
                              t.drawBuffersWEBGL(e, r));
                        })(r),
                        ((e) => {
                          e.dibvbi = e.getExtension(
                            "WEBGL_draw_instanced_base_vertex_base_instance"
                          );
                        })(r),
                        ((e) => {
                          e.mdibvbi = e.getExtension(
                            "WEBGL_multi_draw_instanced_base_vertex_base_instance"
                          );
                        })(r),
                        e.version >= 2 &&
                          (r.disjointTimerQueryExt = r.getExtension(
                            "EXT_disjoint_timer_query_webgl2"
                          )),
                        (e.version < 2 || !r.disjointTimerQueryExt) &&
                          (r.disjointTimerQueryExt = r.getExtension(
                            "EXT_disjoint_timer_query"
                          )),
                        $t(r).forEach((e) => {
                          e.includes("lose_context") ||
                            e.includes("debug") ||
                            r.getExtension(e);
                        });
                    }
                  },
                },
                qt = (e) => {
                  var t = oe(e) + 1,
                    r = Os(t);
                  return r && xt(e, r, t), r;
                },
                Kt = (e, t, r, i, o) => {
                  (Jt.func = e), (Jt.arg = i);
                  var a = Jt.currentlyRunningMainloop;
                  function s() {
                    return !(a < Jt.currentlyRunningMainloop && (jt(), 1));
                  }
                  if (
                    ((Jt.running = !1),
                    (Jt.runner = function () {
                      if (!E)
                        if (Jt.queue.length > 0) {
                          Date.now();
                          var t = Jt.queue.shift();
                          if ((t.func(t.arg), Jt.remainingBlockers)) {
                            var r = Jt.remainingBlockers,
                              i = r % 1 == 0 ? r - 1 : Math.floor(r);
                            t.counted
                              ? (Jt.remainingBlockers = i)
                              : ((i += 0.5),
                                (Jt.remainingBlockers = (8 * r + i) / 9));
                          }
                          if ((Jt.updateStatus(), !s())) return;
                          setTimeout(Jt.runner, 0);
                        } else
                          s() &&
                            ((Jt.currentFrameNumber =
                              (Jt.currentFrameNumber + 1) | 0),
                            1 == Jt.timingMode &&
                            Jt.timingValue > 1 &&
                            Jt.currentFrameNumber % Jt.timingValue != 0
                              ? Jt.scheduler()
                              : (0 == Jt.timingMode &&
                                  (Jt.tickStartTime = Nt()),
                                Jt.runIter(e),
                                s() && Jt.scheduler()));
                    }),
                    o ||
                      (t && t > 0 ? Qt(0, 1e3 / t) : Qt(1, 1), Jt.scheduler()),
                    r)
                  )
                    throw "unwind";
                },
                Jt = {
                  running: !1,
                  scheduler: null,
                  method: "",
                  currentlyRunningMainloop: 0,
                  func: null,
                  arg: 0,
                  timingMode: 0,
                  timingValue: 0,
                  currentFrameNumber: 0,
                  queue: [],
                  preMainLoop: [],
                  postMainLoop: [],
                  pause() {
                    (Jt.scheduler = null), Jt.currentlyRunningMainloop++;
                  },
                  resume() {
                    Jt.currentlyRunningMainloop++;
                    var e = Jt.timingMode,
                      t = Jt.timingValue,
                      r = Jt.func;
                    (Jt.func = null),
                      Kt(r, 0, !1, Jt.arg, !0),
                      Qt(e, t),
                      Jt.scheduler();
                  },
                  updateStatus() {
                    if (s.setStatus) {
                      var e = s.statusMessage || "Please wait...",
                        t = Jt.remainingBlockers ?? 0,
                        r = Jt.expectedBlockers ?? 0;
                      t
                        ? t < r
                          ? s.setStatus(
                              "{message} ({expected - remaining}/{expected})"
                            )
                          : s.setStatus(e)
                        : s.setStatus("");
                    }
                  },
                  init() {
                    s.preMainLoop && Jt.preMainLoop.push(s.preMainLoop),
                      s.postMainLoop && Jt.postMainLoop.push(s.postMainLoop);
                  },
                  runIter(e) {
                    if (!E) {
                      for (var t of Jt.preMainLoop) if (!1 === t()) return;
                      for (var r of (Xt(e), Jt.postMainLoop)) r();
                    }
                  },
                  nextRAF: 0,
                  fakeRequestAnimationFrame(e) {
                    var t = Date.now();
                    if (0 === Jt.nextRAF) Jt.nextRAF = t + 1e3 / 60;
                    else for (; t + 2 >= Jt.nextRAF; ) Jt.nextRAF += 1e3 / 60;
                    var r = Math.max(Jt.nextRAF - t, 0);
                    setTimeout(e, r);
                  },
                  requestAnimationFrame(e) {
                    "function" != typeof requestAnimationFrame
                      ? (0, Jt.fakeRequestAnimationFrame)(e)
                      : requestAnimationFrame(e);
                  },
                },
                Qt = (e, t) => {
                  if (((Jt.timingMode = e), (Jt.timingValue = t), !Jt.func))
                    return 1;
                  if ((Jt.running || (Jt.running = !0), 0 == e))
                    (Jt.scheduler = function () {
                      var e = 0 | Math.max(0, Jt.tickStartTime + t - Nt());
                      setTimeout(Jt.runner, e);
                    }),
                      (Jt.method = "timeout");
                  else if (1 == e)
                    (Jt.scheduler = function () {
                      Jt.requestAnimationFrame(Jt.runner);
                    }),
                      (Jt.method = "rAF");
                  else if (2 == e) {
                    if (void 0 === Jt.setImmediate)
                      if ("undefined" == typeof setImmediate) {
                        var r = [],
                          i = "setimmediate";
                        addEventListener(
                          "message",
                          (e) => {
                            (e.data !== i && e.data.target !== i) ||
                              (e.stopPropagation(), r.shift()());
                          },
                          !0
                        ),
                          (Jt.setImmediate = (e) => {
                            r.push(e), postMessage(i, "*");
                          });
                      } else Jt.setImmediate = setImmediate;
                    (Jt.scheduler = function () {
                      Jt.setImmediate(Jt.runner);
                    }),
                      (Jt.method = "immediate");
                  }
                  return 0;
                },
                er = [],
                tr = (e, t) => {
                  var r;
                  for (er.length = 0; (r = m[e++]); ) {
                    var i = 105 != r;
                    (t += (i &= 112 != r) && t % 8 ? 4 : 0),
                      er.push(
                        112 == r ? b[t >> 2] : 105 == r ? C[t >> 2] : A[t >> 3]
                      ),
                      (t += i ? 8 : 4);
                  }
                  return er;
                },
                rr = (e, t, r, i) => {
                  var o = tr(t, r);
                  return z[e](...o);
                },
                ir = {
                  memcpy(e, t, r) {
                    v.set(v.subarray(t, t + r), e);
                  },
                  removeAllEventListeners() {
                    for (; ir.eventHandlers.length; )
                      ir._removeHandler(ir.eventHandlers.length - 1);
                    ir.deferredCalls = [];
                  },
                  inEventHandler: 0,
                  deferredCalls: [],
                  deferCall(e, t, r) {
                    function i(e, t) {
                      if (e.length != t.length) return !1;
                      for (var r in e) if (e[r] != t[r]) return !1;
                      return !0;
                    }
                    for (var o of ir.deferredCalls)
                      if (o.targetFunction == e && i(o.argsList, r)) return;
                    ir.deferredCalls.push({
                      targetFunction: e,
                      precedence: t,
                      argsList: r,
                    }),
                      ir.deferredCalls.sort(
                        (e, t) => e.precedence < t.precedence
                      );
                  },
                  removeDeferredCalls(e) {
                    ir.deferredCalls = ir.deferredCalls.filter(
                      (t) => t.targetFunction != e
                    );
                  },
                  canPerformEventHandlerRequests: () =>
                    navigator.userActivation
                      ? navigator.userActivation.isActive
                      : ir.inEventHandler &&
                        ir.currentEventHandler.allowsDeferredCalls,
                  runDeferredCalls() {
                    if (ir.canPerformEventHandlerRequests()) {
                      var e = ir.deferredCalls;
                      for (var t of ((ir.deferredCalls = []), e))
                        t.targetFunction(...t.argsList);
                    }
                  },
                  eventHandlers: [],
                  removeAllHandlersOnTarget: (e, t) => {
                    for (var r = 0; r < ir.eventHandlers.length; ++r)
                      ir.eventHandlers[r].target != e ||
                        (t && t != ir.eventHandlers[r].eventTypeString) ||
                        ir._removeHandler(r--);
                  },
                  _removeHandler(e) {
                    var t = ir.eventHandlers[e];
                    t.target.removeEventListener(
                      t.eventTypeString,
                      t.eventListenerFunc,
                      t.useCapture
                    ),
                      ir.eventHandlers.splice(e, 1);
                  },
                  registerOrRemoveHandler(e) {
                    if (!e.target) return -4;
                    if (e.callbackfunc)
                      (e.eventListenerFunc = function (t) {
                        ++ir.inEventHandler,
                          (ir.currentEventHandler = e),
                          ir.runDeferredCalls(),
                          e.handlerFunc(t),
                          ir.runDeferredCalls(),
                          --ir.inEventHandler;
                      }),
                        e.target.addEventListener(
                          e.eventTypeString,
                          e.eventListenerFunc,
                          e.useCapture
                        ),
                        ir.eventHandlers.push(e);
                    else
                      for (var t = 0; t < ir.eventHandlers.length; ++t)
                        ir.eventHandlers[t].target == e.target &&
                          ir.eventHandlers[t].eventTypeString ==
                            e.eventTypeString &&
                          ir._removeHandler(t--);
                    return 0;
                  },
                  getNodeNameForTarget: (e) =>
                    e
                      ? e == window
                        ? "#window"
                        : e == screen
                        ? "#screen"
                        : e?.nodeName || ""
                      : "",
                  fullscreenEnabled: () =>
                    document.fullscreenEnabled ||
                    document.webkitFullscreenEnabled,
                },
                or = {},
                ar = [0, document, window],
                sr = (e) => {
                  var t;
                  return (
                    (e = (t = e) > 2 ? Se(t) : t),
                    ar[e] || document.querySelector(e)
                  );
                },
                nr = sr,
                lr = (e) => Ns(e),
                dr = (e) => {
                  var t = oe(e) + 1,
                    r = lr(t);
                  return xt(e, r, t), r;
                },
                hr = (e) => {
                  var t = $(),
                    r = lr(8),
                    i = r + 4,
                    o =
                      (((e, t, r) => {
                        var i = nr(e);
                        if (!i) return -4;
                        (C[t >> 2] = i.width), (C[r >> 2] = i.height);
                      })(dr(e.id), r, i),
                      [C[r >> 2], C[i >> 2]]);
                  return U(t), o;
                },
                ur = (e, t, r) => {
                  var i = nr(e);
                  return i ? ((i.width = t), (i.height = r), 0) : -4;
                },
                cr = (e, t, r) => {
                  if (e.controlTransferredOffscreen) {
                    var i = $(),
                      o = dr(e.id);
                    ur(o, t, r), U(i);
                  } else (e.width = t), (e.height = r);
                },
                pr = (e, t, r) => {
                  (e.style.paddingLeft = e.style.paddingRight = r + "px"),
                    (e.style.paddingTop = e.style.paddingBottom = t + "px");
                },
                gr = (e) =>
                  ar.indexOf(e) < 0
                    ? e.getBoundingClientRect()
                    : { left: 0, top: 0 },
                yr = (e, t) => {
                  if (
                    ((0 == t.scaleMode && 0 == t.canvasResolutionScaleMode) ||
                      ((e, t) => {
                        var r = ((e) => {
                            var t = hr(e),
                              r = t[0],
                              i = t[1],
                              o = e.style.width,
                              a = e.style.height,
                              s = e.style.backgroundColor,
                              n = document.body.style.backgroundColor,
                              l = e.style.paddingLeft,
                              d = e.style.paddingRight,
                              h = e.style.paddingTop,
                              u = e.style.paddingBottom,
                              c = e.style.marginLeft,
                              p = e.style.marginRight,
                              g = e.style.marginTop,
                              y = e.style.marginBottom,
                              f = document.body.style.margin,
                              v = document.documentElement.style.overflow,
                              m = document.body.scroll,
                              S = e.style.imageRendering;
                            function P() {
                              document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                (document.removeEventListener(
                                  "fullscreenchange",
                                  P
                                ),
                                document.removeEventListener(
                                  "webkitfullscreenchange",
                                  P
                                ),
                                cr(e, r, i),
                                (e.style.width = o),
                                (e.style.height = a),
                                (e.style.backgroundColor = s),
                                n ||
                                  (document.body.style.backgroundColor =
                                    "white"),
                                (document.body.style.backgroundColor = n),
                                (e.style.paddingLeft = l),
                                (e.style.paddingRight = d),
                                (e.style.paddingTop = h),
                                (e.style.paddingBottom = u),
                                (e.style.marginLeft = c),
                                (e.style.marginRight = p),
                                (e.style.marginTop = g),
                                (e.style.marginBottom = y),
                                (document.body.style.margin = f),
                                (document.documentElement.style.overflow = v),
                                (document.body.scroll = m),
                                (e.style.imageRendering = S),
                                e.GLctxObject &&
                                  e.GLctxObject.GLctx.viewport(0, 0, r, i),
                                or.canvasResizedCallback &&
                                  nt(or.canvasResizedCallback)(
                                    37,
                                    0,
                                    or.canvasResizedCallbackUserData
                                  ));
                            }
                            return (
                              document.addEventListener("fullscreenchange", P),
                              document.addEventListener(
                                "webkitfullscreenchange",
                                P
                              ),
                              P
                            );
                          })(e),
                          i = t.softFullscreen ? innerWidth : screen.width,
                          o = t.softFullscreen ? innerHeight : screen.height,
                          a = gr(e),
                          s = a.width,
                          n = a.height,
                          l = hr(e),
                          d = l[0],
                          h = l[1];
                        if (3 == t.scaleMode)
                          pr(e, (o - n) / 2, (i - s) / 2), (i = s), (o = n);
                        else if (2 == t.scaleMode)
                          if (i * h < d * o) {
                            var u = (h * i) / d;
                            pr(e, (o - u) / 2, 0), (o = u);
                          } else {
                            var c = (d * o) / h;
                            pr(e, 0, (i - c) / 2), (i = c);
                          }
                        (e.style.backgroundColor ||= "black"),
                          (document.body.style.backgroundColor ||= "black"),
                          (e.style.width = i + "px"),
                          (e.style.height = o + "px"),
                          1 == t.filteringMode &&
                            ((e.style.imageRendering = "optimizeSpeed"),
                            (e.style.imageRendering = "-moz-crisp-edges"),
                            (e.style.imageRendering = "-o-crisp-edges"),
                            (e.style.imageRendering =
                              "-webkit-optimize-contrast"),
                            (e.style.imageRendering = "optimize-contrast"),
                            (e.style.imageRendering = "crisp-edges"),
                            (e.style.imageRendering = "pixelated"));
                        var p =
                          2 == t.canvasResolutionScaleMode
                            ? devicePixelRatio
                            : 1;
                        if (0 != t.canvasResolutionScaleMode) {
                          var g = (i * p) | 0,
                            y = (o * p) | 0;
                          cr(e, g, y),
                            e.GLctxObject &&
                              e.GLctxObject.GLctx.viewport(0, 0, g, y);
                        }
                      })(e, t),
                    e.requestFullscreen)
                  )
                    e.requestFullscreen();
                  else {
                    if (!e.webkitRequestFullscreen)
                      return ir.fullscreenEnabled() ? -3 : -1;
                    e.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                  }
                  return (
                    (or = t),
                    t.canvasResizedCallback &&
                      nt(t.canvasResizedCallback)(
                        37,
                        0,
                        t.canvasResizedCallbackUserData
                      ),
                    0
                  );
                },
                fr = (e) =>
                  e.requestPointerLock
                    ? (e.requestPointerLock(), 0)
                    : document.body.requestPointerLock
                    ? -3
                    : -1,
                vr = (e, t) => {
                  A[e >> 3] = t.timestamp;
                  for (var r = 0; r < t.axes.length; ++r)
                    A[(e + 8 * r + 16) >> 3] = t.axes[r];
                  for (r = 0; r < t.buttons.length; ++r)
                    "object" == typeof t.buttons[r]
                      ? (A[(e + 8 * r + 528) >> 3] = t.buttons[r].value)
                      : (A[(e + 8 * r + 528) >> 3] = t.buttons[r]);
                  for (r = 0; r < t.buttons.length; ++r)
                    "object" == typeof t.buttons[r]
                      ? (v[e + r + 1040] = t.buttons[r].pressed)
                      : (v[e + r + 1040] = 1 == t.buttons[r]);
                  (v[e + 1104] = t.connected),
                    (C[(e + 1108) >> 2] = t.index),
                    (C[(e + 8) >> 2] = t.axes.length),
                    (C[(e + 12) >> 2] = t.buttons.length),
                    xt(t.id, e + 1112, 64),
                    xt(t.mapping, e + 1176, 64);
                },
                mr = (e) => pt.activeTexture(e),
                Sr = mr,
                Pr = (e, t) => {
                  pt.attachShader(Zt.programs[e], Zt.shaders[t]);
                },
                Cr = Pr,
                br = (e, t, r) => {
                  pt.bindAttribLocation(Zt.programs[e], t, Se(r));
                },
                xr = br,
                Ar = (e, t) => {
                  35051 == e
                    ? (pt.currentPixelPackBufferBinding = t)
                    : 35052 == e && (pt.currentPixelUnpackBufferBinding = t),
                    pt.bindBuffer(e, Zt.buffers[t]);
                },
                Tr = Ar,
                Er = (e, t) => {
                  pt.bindFramebuffer(e, Zt.framebuffers[t]);
                },
                Rr = Er,
                Dr = (e, t) => {
                  pt.bindTexture(e, Zt.textures[t]);
                },
                wr = Dr,
                Mr = (e) => {
                  pt.bindVertexArray(Zt.vaos[e]);
                },
                Lr = Mr,
                Or = Mr,
                Ir = Or,
                kr = (e, t, r, i) => pt.blendColor(e, t, r, i),
                _r = kr,
                Vr = (e) => pt.blendEquation(e),
                Nr = Vr,
                Br = (e, t, r, i) => pt.blendFuncSeparate(e, t, r, i),
                Fr = Br,
                Hr = (e, t, r, i) => {
                  Zt.currentContext.version >= 2
                    ? r && t
                      ? pt.bufferData(e, m, i, r, t)
                      : pt.bufferData(e, t, i)
                    : pt.bufferData(e, r ? m.subarray(r, r + t) : t, i);
                },
                Yr = Hr,
                zr = (e) => pt.checkFramebufferStatus(e),
                jr = zr,
                Xr = (e) => pt.clear(e),
                Gr = Xr,
                Wr = (e, t, r, i) => pt.clearColor(e, t, r, i),
                Ur = Wr,
                $r = (e, t) => (e >>> 0) + 4294967296 * t,
                Zr = (e, t, r, i) => {
                  pt.colorMask(!!e, !!t, !!r, !!i);
                },
                qr = Zr,
                Kr = (e) => {
                  pt.compileShader(Zt.shaders[e]);
                },
                Jr = Kr,
                Qr = (e, t, r, i, o, a, s, n) => {
                  if (Zt.currentContext.version >= 2)
                    return pt.currentPixelUnpackBufferBinding || !s
                      ? void pt.compressedTexImage2D(e, t, r, i, o, a, s, n)
                      : void pt.compressedTexImage2D(e, t, r, i, o, a, m, n, s);
                  pt.compressedTexImage2D(
                    e,
                    t,
                    r,
                    i,
                    o,
                    a,
                    m.subarray(n, n + s)
                  );
                },
                ei = Qr,
                ti = () => {
                  var e = Zt.getNewId(Zt.programs),
                    t = pt.createProgram();
                  return (
                    (t.name = e),
                    (t.maxUniformLength =
                      t.maxAttributeLength =
                      t.maxUniformBlockNameLength =
                        0),
                    (t.uniformIdCounter = 1),
                    (Zt.programs[e] = t),
                    e
                  );
                },
                ri = ti,
                ii = (e) => {
                  var t = Zt.getNewId(Zt.shaders);
                  return (Zt.shaders[t] = pt.createShader(e)), t;
                },
                oi = ii,
                ai = (e) => pt.cullFace(e),
                si = ai,
                ni = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.buffers[i];
                    o &&
                      (pt.deleteBuffer(o),
                      (o.name = 0),
                      (Zt.buffers[i] = null),
                      i == pt.currentPixelPackBufferBinding &&
                        (pt.currentPixelPackBufferBinding = 0),
                      i == pt.currentPixelUnpackBufferBinding &&
                        (pt.currentPixelUnpackBufferBinding = 0));
                  }
                },
                li = ni,
                di = (e, t) => {
                  for (var r = 0; r < e; ++r) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.framebuffers[i];
                    o &&
                      (pt.deleteFramebuffer(o),
                      (o.name = 0),
                      (Zt.framebuffers[i] = null));
                  }
                },
                hi = di,
                ui = (e) => {
                  if (e) {
                    var t = Zt.programs[e];
                    t
                      ? (pt.deleteProgram(t),
                        (t.name = 0),
                        (Zt.programs[e] = null))
                      : Zt.recordError(1281);
                  }
                },
                ci = ui,
                pi = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.renderbuffers[i];
                    o &&
                      (pt.deleteRenderbuffer(o),
                      (o.name = 0),
                      (Zt.renderbuffers[i] = null));
                  }
                },
                gi = pi,
                yi = (e) => {
                  if (e) {
                    var t = Zt.shaders[e];
                    t
                      ? (pt.deleteShader(t), (Zt.shaders[e] = null))
                      : Zt.recordError(1281);
                  }
                },
                fi = yi,
                vi = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2],
                      o = Zt.textures[i];
                    o &&
                      (pt.deleteTexture(o),
                      (o.name = 0),
                      (Zt.textures[i] = null));
                  }
                },
                mi = vi,
                Si = (e, t) => {
                  for (var r = 0; r < e; r++) {
                    var i = C[(t + 4 * r) >> 2];
                    pt.deleteVertexArray(Zt.vaos[i]), (Zt.vaos[i] = null);
                  }
                },
                Pi = Si,
                Ci = Si,
                bi = Ci,
                xi = (e) => pt.depthFunc(e),
                Ai = xi,
                Ti = (e) => {
                  pt.depthMask(!!e);
                },
                Ei = Ti,
                Ri = (e, t) => {
                  pt.detachShader(Zt.programs[e], Zt.shaders[t]);
                },
                Di = Ri,
                wi = (e) => pt.disable(e),
                Mi = wi,
                Li = (e, t, r) => {
                  pt.drawArrays(e, t, r);
                },
                Oi = Li,
                Ii = (e, t, r, i) => {
                  pt.drawArraysInstanced(e, t, r, i);
                },
                ki = Ii,
                _i = Ii,
                Vi = _i,
                Ni = Ii,
                Bi = Ni,
                Fi = Ii,
                Hi = Fi,
                Yi = Ii,
                zi = Yi,
                ji = [],
                Xi = (e, t) => {
                  for (var r = ji[e], i = 0; i < e; i++)
                    r[i] = C[(t + 4 * i) >> 2];
                  pt.drawBuffers(r);
                },
                Gi = Xi,
                Wi = Xi,
                Ui = Wi,
                $i = Xi,
                Zi = $i,
                qi = (e, t, r, i) => {
                  pt.drawElements(e, t, r, i);
                },
                Ki = qi,
                Ji = (e, t, r, i, o) => {
                  pt.drawElementsInstanced(e, t, r, i, o);
                },
                Qi = Ji,
                eo = Ji,
                to = eo,
                ro = Ji,
                io = ro,
                oo = Ji,
                ao = oo,
                so = Ji,
                no = so,
                lo = (e) => pt.enable(e),
                ho = lo,
                uo = (e) => {
                  pt.enableVertexAttribArray(e);
                },
                co = uo,
                po = (e, t, r, i, o) => {
                  pt.framebufferTexture2D(e, t, r, Zt.textures[i], o);
                },
                go = po,
                yo = (e) => pt.frontFace(e),
                fo = yo,
                vo = (e, t) => {
                  Zt.genObject(e, t, "createBuffer", Zt.buffers);
                },
                mo = vo,
                So = (e, t) => {
                  Zt.genObject(e, t, "createFramebuffer", Zt.framebuffers);
                },
                Po = So,
                Co = (e, t) => {
                  Zt.genObject(e, t, "createTexture", Zt.textures);
                },
                bo = Co,
                xo = (e, t) => {
                  Zt.genObject(e, t, "createVertexArray", Zt.vaos);
                },
                Ao = xo,
                To = xo,
                Eo = To,
                Ro = (e) => pt.generateMipmap(e),
                Do = Ro,
                wo = (e, t, r, i, o, a, s, n) => {
                  t = Zt.programs[t];
                  var l = pt[e](t, r);
                  if (l) {
                    var d = n && xt(l.name, n, i);
                    o && (C[o >> 2] = d),
                      a && (C[a >> 2] = l.size),
                      s && (C[s >> 2] = l.type);
                  }
                },
                Mo = (e, t, r, i, o, a, s) =>
                  wo("getActiveAttrib", e, t, r, i, o, a, s),
                Lo = Mo,
                Oo = (e, t, r, i, o, a, s) =>
                  wo("getActiveUniform", e, t, r, i, o, a, s),
                Io = Oo,
                ko = (e, t) => {
                  b[e >> 2] = t;
                  var r = b[e >> 2];
                  b[(e + 4) >> 2] = (t - r) / 4294967296;
                },
                _o = () => {
                  var e = $t(pt);
                  return e.concat(e.map((e) => "GL_" + e));
                },
                Vo = (e, t, r) => {
                  if (t) {
                    var i = void 0;
                    switch (e) {
                      case 36346:
                        i = 1;
                        break;
                      case 36344:
                        return void (0 != r && 1 != r && Zt.recordError(1280));
                      case 34814:
                      case 36345:
                        i = 0;
                        break;
                      case 34466:
                        var o = pt.getParameter(34467);
                        i = o ? o.length : 0;
                        break;
                      case 33309:
                        if (Zt.currentContext.version < 2)
                          return void Zt.recordError(1282);
                        i = _o().length;
                        break;
                      case 33307:
                      case 33308:
                        if (Zt.currentContext.version < 2)
                          return void Zt.recordError(1280);
                        i = 33307 == e ? 3 : 0;
                    }
                    if (void 0 === i) {
                      var a = pt.getParameter(e);
                      switch (typeof a) {
                        case "number":
                          i = a;
                          break;
                        case "boolean":
                          i = a ? 1 : 0;
                          break;
                        case "string":
                          return void Zt.recordError(1280);
                        case "object":
                          if (null === a)
                            switch (e) {
                              case 34964:
                              case 35725:
                              case 34965:
                              case 36006:
                              case 36007:
                              case 32873:
                              case 34229:
                              case 36662:
                              case 36663:
                              case 35053:
                              case 35055:
                              case 36010:
                              case 35097:
                              case 35869:
                              case 32874:
                              case 36389:
                              case 35983:
                              case 35368:
                              case 34068:
                                i = 0;
                                break;
                              default:
                                return void Zt.recordError(1280);
                            }
                          else {
                            if (
                              a instanceof Float32Array ||
                              a instanceof Uint32Array ||
                              a instanceof Int32Array ||
                              a instanceof Array
                            ) {
                              for (var s = 0; s < a.length; ++s)
                                switch (r) {
                                  case 0:
                                    C[(t + 4 * s) >> 2] = a[s];
                                    break;
                                  case 2:
                                    x[(t + 4 * s) >> 2] = a[s];
                                    break;
                                  case 4:
                                    v[t + s] = a[s] ? 1 : 0;
                                }
                              return;
                            }
                            try {
                              i = 0 | a.name;
                            } catch (t) {
                              return (
                                Zt.recordError(1280),
                                void g(
                                  `GL_INVALID_ENUM in glGet${r}v: Unknown object returned from WebGL getParameter(${e})! (error: ${t})`
                                )
                              );
                            }
                          }
                          break;
                        default:
                          return (
                            Zt.recordError(1280),
                            void g(
                              `GL_INVALID_ENUM in glGet${r}v: Native code calling glGet${r}v(${e}) and it returns ${a} of type ${typeof a}!`
                            )
                          );
                      }
                    }
                    switch (r) {
                      case 1:
                        ko(t, i);
                        break;
                      case 0:
                        C[t >> 2] = i;
                        break;
                      case 2:
                        x[t >> 2] = i;
                        break;
                      case 4:
                        v[t] = i ? 1 : 0;
                    }
                  } else Zt.recordError(1281);
                },
                No = (e, t, r, i) => {
                  if (r) {
                    var o,
                      a = pt.getIndexedParameter(e, t);
                    switch (typeof a) {
                      case "boolean":
                        o = a ? 1 : 0;
                        break;
                      case "number":
                        o = a;
                        break;
                      case "object":
                        if (null === a)
                          switch (e) {
                            case 35983:
                            case 35368:
                              o = 0;
                              break;
                            default:
                              return void Zt.recordError(1280);
                          }
                        else {
                          if (!(a instanceof WebGLBuffer))
                            return void Zt.recordError(1280);
                          o = 0 | a.name;
                        }
                        break;
                      default:
                        return void Zt.recordError(1280);
                    }
                    switch (i) {
                      case 1:
                        ko(r, o);
                        break;
                      case 0:
                        C[r >> 2] = o;
                        break;
                      case 2:
                        x[r >> 2] = o;
                        break;
                      case 4:
                        v[r] = o ? 1 : 0;
                        break;
                      default:
                        throw (
                          "internal emscriptenWebGLGetIndexed() error, bad type: " +
                          i
                        );
                    }
                  } else Zt.recordError(1281);
                },
                Bo = (e, t) => Vo(e, t, 0),
                Fo = Bo,
                Ho = (e, t, r, i) => {
                  var o = pt.getProgramInfoLog(Zt.programs[e]);
                  null === o && (o = "(unknown error)");
                  var a = t > 0 && i ? xt(o, i, t) : 0;
                  r && (C[r >> 2] = a);
                },
                Yo = Ho,
                zo = (e, t, r) => {
                  if (r)
                    if (e >= Zt.counter) Zt.recordError(1281);
                    else if (((e = Zt.programs[e]), 35716 == t)) {
                      var i = pt.getProgramInfoLog(e);
                      null === i && (i = "(unknown error)"),
                        (C[r >> 2] = i.length + 1);
                    } else if (35719 == t) {
                      if (!e.maxUniformLength)
                        for (
                          var o = pt.getProgramParameter(e, 35718), a = 0;
                          a < o;
                          ++a
                        )
                          e.maxUniformLength = Math.max(
                            e.maxUniformLength,
                            pt.getActiveUniform(e, a).name.length + 1
                          );
                      C[r >> 2] = e.maxUniformLength;
                    } else if (35722 == t) {
                      if (!e.maxAttributeLength) {
                        var s = pt.getProgramParameter(e, 35721);
                        for (a = 0; a < s; ++a)
                          e.maxAttributeLength = Math.max(
                            e.maxAttributeLength,
                            pt.getActiveAttrib(e, a).name.length + 1
                          );
                      }
                      C[r >> 2] = e.maxAttributeLength;
                    } else if (35381 == t) {
                      if (!e.maxUniformBlockNameLength) {
                        var n = pt.getProgramParameter(e, 35382);
                        for (a = 0; a < n; ++a)
                          e.maxUniformBlockNameLength = Math.max(
                            e.maxUniformBlockNameLength,
                            pt.getActiveUniformBlockName(e, a).length + 1
                          );
                      }
                      C[r >> 2] = e.maxUniformBlockNameLength;
                    } else C[r >> 2] = pt.getProgramParameter(e, t);
                  else Zt.recordError(1281);
                },
                jo = zo,
                Xo = (e, t, r) => {
                  if (r) {
                    var i,
                      o = Zt.queries[e];
                    (i =
                      Zt.currentContext.version < 2
                        ? pt.disjointTimerQueryExt.getQueryObjectEXT(o, t)
                        : pt.getQueryParameter(o, t)),
                      ko(r, "boolean" == typeof i ? (i ? 1 : 0) : i);
                  } else Zt.recordError(1281);
                },
                Go = Xo,
                Wo = (e, t, r) => {
                  if (r) {
                    var i,
                      o = Zt.queries[e],
                      a = pt.disjointTimerQueryExt.getQueryObjectEXT(o, t);
                    (i = "boolean" == typeof a ? (a ? 1 : 0) : a),
                      (C[r >> 2] = i);
                  } else Zt.recordError(1281);
                },
                Uo = Wo,
                $o = Xo,
                Zo = Wo,
                qo = (e, t, r, i) => {
                  var o = pt.getShaderInfoLog(Zt.shaders[e]);
                  null === o && (o = "(unknown error)");
                  var a = t > 0 && i ? xt(o, i, t) : 0;
                  r && (C[r >> 2] = a);
                },
                Ko = qo,
                Jo = (e, t, r) => {
                  if (r)
                    if (35716 == t) {
                      var i = pt.getShaderInfoLog(Zt.shaders[e]);
                      null === i && (i = "(unknown error)");
                      var o = i ? i.length + 1 : 0;
                      C[r >> 2] = o;
                    } else if (35720 == t) {
                      var a = pt.getShaderSource(Zt.shaders[e]),
                        s = a ? a.length + 1 : 0;
                      C[r >> 2] = s;
                    } else C[r >> 2] = pt.getShaderParameter(Zt.shaders[e], t);
                  else Zt.recordError(1281);
                },
                Qo = Jo,
                ea = (e) => {
                  var t = Zt.stringCache[e];
                  if (!t) {
                    switch (e) {
                      case 7939:
                        t = qt(_o().join(" "));
                        break;
                      case 7936:
                      case 7937:
                      case 37445:
                      case 37446:
                        var r = pt.getParameter(e);
                        r || Zt.recordError(1280), (t = r ? qt(r) : 0);
                        break;
                      case 7938:
                        var i = pt.getParameter(7938),
                          o = `OpenGL ES 2.0 (${i})`;
                        Zt.currentContext.version >= 2 &&
                          (o = `OpenGL ES 3.0 (${i})`),
                          (t = qt(o));
                        break;
                      case 35724:
                        var a = pt.getParameter(35724),
                          s = a.match(
                            /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/
                          );
                        null !== s &&
                          (3 == s[1].length && (s[1] = s[1] + "0"),
                          (a = `OpenGL ES GLSL ES ${s[1]} (${a})`)),
                          (t = qt(a));
                        break;
                      default:
                        Zt.recordError(1280);
                    }
                    Zt.stringCache[e] = t;
                  }
                  return t;
                },
                ta = ea,
                ra = (e) => "]" == e.slice(-1) && e.lastIndexOf("["),
                ia = (e) => {
                  var t,
                    r,
                    i = e.uniformLocsById,
                    o = e.uniformSizeAndIdsByName;
                  if (!i) {
                    (e.uniformLocsById = i = {}),
                      (e.uniformArrayNamesById = {});
                    var a = pt.getProgramParameter(e, 35718);
                    for (t = 0; t < a; ++t) {
                      var s = pt.getActiveUniform(e, t),
                        n = s.name,
                        l = s.size,
                        d = ra(n),
                        h = d > 0 ? n.slice(0, d) : n,
                        u = e.uniformIdCounter;
                      for (
                        e.uniformIdCounter += l, o[h] = [l, u], r = 0;
                        r < l;
                        ++r
                      )
                        (i[u] = r), (e.uniformArrayNamesById[u++] = h);
                    }
                  }
                },
                oa = (e, t) => {
                  if (((t = Se(t)), (e = Zt.programs[e]))) {
                    ia(e);
                    var r = e.uniformLocsById,
                      i = 0,
                      o = t,
                      a = ra(t);
                    a > 0 &&
                      ((n = t.slice(a + 1)),
                      (i = parseInt(n) >>> 0),
                      (o = t.slice(0, a)));
                    var s = e.uniformSizeAndIdsByName[o];
                    if (
                      s &&
                      i < s[0] &&
                      (r[(i += s[1])] = r[i] || pt.getUniformLocation(e, t))
                    )
                      return i;
                  } else Zt.recordError(1281);
                  var n;
                  return -1;
                },
                aa = oa,
                sa = (e) => {
                  var t = pt.currentProgram;
                  if (t) {
                    var r = t.uniformLocsById[e];
                    return (
                      "number" == typeof r &&
                        (t.uniformLocsById[e] = r =
                          pt.getUniformLocation(
                            t,
                            t.uniformArrayNamesById[e] + (r > 0 ? `[${r}]` : "")
                          )),
                      r
                    );
                  }
                  Zt.recordError(1282);
                },
                na = (e, t, r, i) => {
                  if (r) {
                    (e = Zt.programs[e]), ia(e);
                    var o = pt.getUniform(e, sa(t));
                    if ("number" == typeof o || "boolean" == typeof o)
                      switch (i) {
                        case 0:
                          C[r >> 2] = o;
                          break;
                        case 2:
                          x[r >> 2] = o;
                      }
                    else
                      for (var a = 0; a < o.length; a++)
                        switch (i) {
                          case 0:
                            C[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 2:
                            x[(r + 4 * a) >> 2] = o[a];
                        }
                  } else Zt.recordError(1281);
                },
                la = (e, t, r, i) => {
                  if (r) {
                    var o = pt.getVertexAttrib(e, t);
                    if (34975 == t) C[r >> 2] = o && o.name;
                    else if ("number" == typeof o || "boolean" == typeof o)
                      switch (i) {
                        case 0:
                          C[r >> 2] = o;
                          break;
                        case 2:
                          x[r >> 2] = o;
                          break;
                        case 5:
                          C[r >> 2] = Math.fround(o);
                      }
                    else
                      for (var a = 0; a < o.length; a++)
                        switch (i) {
                          case 0:
                            C[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 2:
                            x[(r + 4 * a) >> 2] = o[a];
                            break;
                          case 5:
                            C[(r + 4 * a) >> 2] = Math.fround(o[a]);
                        }
                  } else Zt.recordError(1281);
                },
                da = (e, t, r) => {
                  la(e, t, r, 0);
                },
                ha = da,
                ua = da,
                ca = (e) => {
                  var t = Zt.vaos[e];
                  return t ? pt.isVertexArray(t) : 0;
                },
                pa = ca,
                ga = ca,
                ya = (e) => pt.lineWidth(e),
                fa = ya,
                va = (e) => {
                  (e = Zt.programs[e]),
                    pt.linkProgram(e),
                    (e.uniformLocsById = 0),
                    (e.uniformSizeAndIdsByName = {});
                },
                ma = va,
                Sa = (e, t) => {
                  3317 == e
                    ? (Zt.unpackAlignment = t)
                    : 3314 == e && (Zt.unpackRowLength = t),
                    pt.pixelStorei(e, t);
                },
                Pa = Sa,
                Ca = (e) =>
                  0 == (e -= 5120)
                    ? v
                    : 1 == e
                    ? m
                    : 2 == e
                    ? S
                    : 4 == e
                    ? C
                    : 6 == e
                    ? x
                    : 5 == e ||
                      28922 == e ||
                      28520 == e ||
                      30779 == e ||
                      30782 == e
                    ? b
                    : P,
                ba = (e, t) => e >>> (31 - Math.clz32(t.BYTES_PER_ELEMENT)),
                xa = (e, t, r, i, o, a) => {
                  var s = Ca(e),
                    n =
                      ((e) =>
                        ({
                          5: 3,
                          6: 4,
                          8: 2,
                          29502: 3,
                          29504: 4,
                          26917: 2,
                          26918: 2,
                          29846: 3,
                          29847: 4,
                        }[e - 6402] || 1))(t) * s.BYTES_PER_ELEMENT,
                    l = ((e, t, r) => {
                      var i;
                      return (
                        t *
                        (((Zt.unpackRowLength || e) * r +
                          (i = Zt.unpackAlignment) -
                          1) &
                          -i)
                      );
                    })(r, i, n);
                  return s.subarray(ba(o, s), ba(o + l, s));
                },
                Aa = (e, t, r, i, o, a, s) => {
                  if (Zt.currentContext.version >= 2) {
                    if (pt.currentPixelPackBufferBinding)
                      return void pt.readPixels(e, t, r, i, o, a, s);
                    var n = Ca(a),
                      l = ba(s, n);
                    pt.readPixels(e, t, r, i, o, a, n, l);
                  } else {
                    var d = xa(a, o, r, i, s);
                    d
                      ? pt.readPixels(e, t, r, i, o, a, d)
                      : Zt.recordError(1280);
                  }
                },
                Ta = Aa,
                Ea = (e, t, r, i) => pt.scissor(e, t, r, i),
                Ra = Ea,
                Da = (e, t, r, i) => {
                  var o = Zt.getSource(e, t, r, i);
                  pt.shaderSource(Zt.shaders[e], o);
                },
                wa = Da,
                Ma = (e, t, r, i, o, a, s, n, l) => {
                  if (Zt.currentContext.version >= 2) {
                    if (pt.currentPixelUnpackBufferBinding)
                      return void pt.texImage2D(e, t, r, i, o, a, s, n, l);
                    if (l) {
                      var d = Ca(n),
                        h = ba(l, d);
                      return void pt.texImage2D(e, t, r, i, o, a, s, n, d, h);
                    }
                  }
                  var u = l ? xa(n, s, i, o, l) : null;
                  pt.texImage2D(e, t, r, i, o, a, s, n, u);
                },
                La = Ma,
                Oa = (e, t, r) => pt.texParameteri(e, t, r),
                Ia = Oa,
                ka = [],
                _a = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform1fv(sa(e), x, r >> 2, t);
                  else {
                    if (t <= 288)
                      for (var i = ka[t], o = 0; o < t; ++o)
                        i[o] = x[(r + 4 * o) >> 2];
                    else i = x.subarray(r >> 2, (r + 4 * t) >> 2);
                    pt.uniform1fv(sa(e), i);
                  }
                },
                Va = _a,
                Na = (e, t) => {
                  pt.uniform1i(sa(e), t);
                },
                Ba = Na,
                Fa = [],
                Ha = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform2fv(sa(e), x, r >> 2, 2 * t);
                  else {
                    if (t <= 144)
                      for (var i = ka[(t *= 2)], o = 0; o < t; o += 2)
                        (i[o] = x[(r + 4 * o) >> 2]),
                          (i[o + 1] = x[(r + (4 * o + 4)) >> 2]);
                    else i = x.subarray(r >> 2, (r + 8 * t) >> 2);
                    pt.uniform2fv(sa(e), i);
                  }
                },
                Ya = Ha,
                za = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform3fv(sa(e), x, r >> 2, 3 * t);
                  else {
                    if (t <= 96)
                      for (var i = ka[(t *= 3)], o = 0; o < t; o += 3)
                        (i[o] = x[(r + 4 * o) >> 2]),
                          (i[o + 1] = x[(r + (4 * o + 4)) >> 2]),
                          (i[o + 2] = x[(r + (4 * o + 8)) >> 2]);
                    else i = x.subarray(r >> 2, (r + 12 * t) >> 2);
                    pt.uniform3fv(sa(e), i);
                  }
                },
                ja = za,
                Xa = (e, t, r) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniform4fv(sa(e), x, r >> 2, 4 * t);
                  else {
                    if (t <= 72) {
                      var i = ka[4 * t],
                        o = x;
                      (r >>= 2), (t *= 4);
                      for (var a = 0; a < t; a += 4) {
                        var s = r + a;
                        (i[a] = o[s]),
                          (i[a + 1] = o[s + 1]),
                          (i[a + 2] = o[s + 2]),
                          (i[a + 3] = o[s + 3]);
                      }
                    } else i = x.subarray(r >> 2, (r + 16 * t) >> 2);
                    pt.uniform4fv(sa(e), i);
                  }
                },
                Ga = Xa,
                Wa = (e, t, r, i) => {
                  if (Zt.currentContext.version >= 2)
                    t && pt.uniformMatrix4fv(sa(e), !!r, x, i >> 2, 16 * t);
                  else {
                    if (t <= 18) {
                      var o = ka[16 * t],
                        a = x;
                      (i >>= 2), (t *= 16);
                      for (var s = 0; s < t; s += 16) {
                        var n = i + s;
                        (o[s] = a[n]),
                          (o[s + 1] = a[n + 1]),
                          (o[s + 2] = a[n + 2]),
                          (o[s + 3] = a[n + 3]),
                          (o[s + 4] = a[n + 4]),
                          (o[s + 5] = a[n + 5]),
                          (o[s + 6] = a[n + 6]),
                          (o[s + 7] = a[n + 7]),
                          (o[s + 8] = a[n + 8]),
                          (o[s + 9] = a[n + 9]),
                          (o[s + 10] = a[n + 10]),
                          (o[s + 11] = a[n + 11]),
                          (o[s + 12] = a[n + 12]),
                          (o[s + 13] = a[n + 13]),
                          (o[s + 14] = a[n + 14]),
                          (o[s + 15] = a[n + 15]);
                      }
                    } else o = x.subarray(i >> 2, (i + 64 * t) >> 2);
                    pt.uniformMatrix4fv(sa(e), !!r, o);
                  }
                },
                Ua = Wa,
                $a = (e) => {
                  (e = Zt.programs[e]),
                    pt.useProgram(e),
                    (pt.currentProgram = e);
                },
                Za = $a,
                qa = (e, t) => {
                  pt.vertexAttribDivisor(e, t);
                },
                Ka = qa,
                Ja = qa,
                Qa = qa,
                es = qa,
                ts = qa,
                rs = (e, t, r, i, o, a) => {
                  pt.vertexAttribPointer(e, t, r, !!i, o, a);
                },
                is = rs,
                os = (e, t, r, i) => pt.viewport(e, t, r, i),
                as = os,
                ss = (e) => {
                  var t = ((e - y.buffer.byteLength + 65535) / 65536) | 0;
                  try {
                    return y.grow(t), R(), 1;
                  } catch (e) {}
                },
                ns = () => {
                  try {
                    if (navigator.getGamepads)
                      return (ir.lastGamepadState = navigator.getGamepads())
                        ? 0
                        : -1;
                  } catch (e) {
                    navigator.getGamepads = null;
                  }
                  return -1;
                },
                ls = (e, t, r, i, o, a, s) => {
                  ir.focusEvent ||= Os(256);
                  var n = {
                    target: sr(e),
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.getNodeNameForTarget(e.target),
                        a = e.target.id ? e.target.id : "",
                        s = ir.focusEvent;
                      xt(r, s + 0, 128),
                        xt(a, s + 128, 128),
                        nt(i)(o, s, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                ds = (e, t, r, i, o, a, s) => {
                  ir.fullscreenChangeEvent ||= Os(276);
                  var n = {
                    target: e,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.fullscreenChangeEvent;
                      ((e) => {
                        var t =
                            document.fullscreenElement ||
                            document.mozFullScreenElement ||
                            document.webkitFullscreenElement ||
                            document.msFullscreenElement,
                          r = !!t;
                        (v[e] = r), (v[e + 1] = ir.fullscreenEnabled());
                        var i = r ? t : ir.previousFullscreenElement,
                          o = ir.getNodeNameForTarget(i),
                          a = i?.id || "";
                        xt(o, e + 2, 128),
                          xt(a, e + 130, 128),
                          (C[(e + 260) >> 2] = i ? i.clientWidth : 0),
                          (C[(e + 264) >> 2] = i ? i.clientHeight : 0),
                          (C[(e + 268) >> 2] = screen.width),
                          (C[(e + 272) >> 2] = screen.height),
                          r && (ir.previousFullscreenElement = t);
                      })(r),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                hs = (e, t, r, i, o, a, s) => {
                  ir.gamepadEvent ||= Os(1240);
                  var n = {
                    target: sr(e),
                    allowsDeferredCalls: !0,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.gamepadEvent;
                      vr(r, e.gamepad), nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                us = (e, t, r, i, o, a, s) => {
                  ir.keyEvent ||= Os(160);
                  var n = {
                    target: sr(e),
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e) => {
                      var r = ir.keyEvent;
                      A[r >> 3] = e.timeStamp;
                      var a = r >> 2;
                      (C[a + 2] = e.location),
                        (v[r + 12] = e.ctrlKey),
                        (v[r + 13] = e.shiftKey),
                        (v[r + 14] = e.altKey),
                        (v[r + 15] = e.metaKey),
                        (v[r + 16] = e.repeat),
                        (C[a + 5] = e.charCode),
                        (C[a + 6] = e.keyCode),
                        (C[a + 7] = e.which),
                        xt(e.key || "", r + 32, 32),
                        xt(e.code || "", r + 64, 32),
                        xt(e.char || "", r + 96, 32),
                        xt(e.locale || "", r + 128, 32),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                cs = (e, t, r) => {
                  A[e >> 3] = t.timeStamp;
                  var i = e >> 2;
                  (C[i + 2] = t.screenX),
                    (C[i + 3] = t.screenY),
                    (C[i + 4] = t.clientX),
                    (C[i + 5] = t.clientY),
                    (v[e + 24] = t.ctrlKey),
                    (v[e + 25] = t.shiftKey),
                    (v[e + 26] = t.altKey),
                    (v[e + 27] = t.metaKey),
                    (S[2 * i + 14] = t.button),
                    (S[2 * i + 15] = t.buttons),
                    (C[i + 8] = t.movementX),
                    (C[i + 9] = t.movementY);
                  var o = gr(r);
                  (C[i + 10] = t.clientX - (0 | o.left)),
                    (C[i + 11] = t.clientY - (0 | o.top));
                },
                ps = (e, t, r, i, o, a, s) => {
                  ir.mouseEvent ||= Os(64);
                  var n = {
                    target: (e = sr(e)),
                    allowsDeferredCalls:
                      "mousemove" != a &&
                      "mouseenter" != a &&
                      "mouseleave" != a,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (r = event) => {
                      cs(ir.mouseEvent, r, e),
                        nt(i)(o, ir.mouseEvent, t) && r.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                gs = (e, t, r, i, o, a, s) => {
                  ir.pointerlockChangeEvent ||= Os(257);
                  var n = {
                    target: e,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (e = event) => {
                      var r = ir.pointerlockChangeEvent;
                      ((e) => {
                        var t =
                            document.pointerLockElement ||
                            document.mozPointerLockElement ||
                            document.webkitPointerLockElement ||
                            document.msPointerLockElement,
                          r = !!t;
                        v[e] = r;
                        var i = ir.getNodeNameForTarget(t),
                          o = t?.id || "";
                        xt(i, e + 1, 128), xt(o, e + 129, 128);
                      })(r),
                        nt(i)(o, r, t) && e.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                },
                ys = (e, t, r, i, o, a, s) => {
                  ir.touchEvent ||= Os(1552);
                  var n = {
                    target: (e = sr(e)),
                    allowsDeferredCalls: "touchstart" == a || "touchend" == a,
                    eventTypeString: a,
                    callbackfunc: i,
                    handlerFunc: (r) => {
                      var a = {},
                        s = r.touches;
                      for (let e of s)
                        (e.isChanged = e.onTarget = 0), (a[e.identifier] = e);
                      for (let e of r.changedTouches)
                        (e.isChanged = 1), (a[e.identifier] = e);
                      for (let e of r.targetTouches)
                        a[e.identifier].onTarget = 1;
                      var n = ir.touchEvent;
                      (A[n >> 3] = r.timeStamp),
                        (v[n + 12] = r.ctrlKey),
                        (v[n + 13] = r.shiftKey),
                        (v[n + 14] = r.altKey),
                        (v[n + 15] = r.metaKey);
                      var l = n + 16,
                        d = gr(e),
                        h = 0;
                      for (let e of Object.values(a)) {
                        var u = l >> 2;
                        if (
                          ((C[u + 0] = e.identifier),
                          (C[u + 1] = e.screenX),
                          (C[u + 2] = e.screenY),
                          (C[u + 3] = e.clientX),
                          (C[u + 4] = e.clientY),
                          (C[u + 5] = e.pageX),
                          (C[u + 6] = e.pageY),
                          (v[l + 28] = e.isChanged),
                          (v[l + 29] = e.onTarget),
                          (C[u + 8] = e.clientX - (0 | d.left)),
                          (C[u + 9] = e.clientY - (0 | d.top)),
                          (l += 48),
                          ++h > 31)
                        )
                          break;
                      }
                      (C[(n + 8) >> 2] = h),
                        nt(i)(o, n, t) && r.preventDefault();
                    },
                    useCapture: r,
                  };
                  return ir.registerOrRemoveHandler(n);
                };
              class fs {
                allocated = [void 0];
                freelist = [];
                get(e) {
                  return this.allocated[e];
                }
                has(e) {
                  return void 0 !== this.allocated[e];
                }
                allocate(e) {
                  var t = this.freelist.pop() || this.allocated.length;
                  return (this.allocated[t] = e), t;
                }
                free(e) {
                  (this.allocated[e] = void 0), this.freelist.push(e);
                }
              }
              var vs = {
                openDatabase(e, t, r, i) {
                  try {
                    var o = indexedDB.open(e, t);
                  } catch (e) {
                    return i(e);
                  }
                  (o.onupgradeneeded = (e) => {
                    var t = e.target.result;
                    t.objectStoreNames.contains("FILES") &&
                      t.deleteObjectStore("FILES"),
                      t.createObjectStore("FILES");
                  }),
                    (o.onsuccess = (e) => r(e.target.result)),
                    (o.onerror = i);
                },
                init() {
                  (vs.xhrs = new fs()),
                    k(),
                    vs.openDatabase(
                      "emscripten_filesystem",
                      1,
                      (e) => {
                        (vs.dbInstance = e), _();
                      },
                      () => {
                        (vs.dbInstance = !1), _();
                      }
                    );
                },
              };
              function ms(e, t, r, i, o) {
                var a = b[(e + 8) >> 2];
                if (a) {
                  var s = Se(a),
                    n = e + 108,
                    l = Se(n + 0);
                  l ||= "GET";
                  var d = b[(n + 56) >> 2],
                    h = b[(n + 68) >> 2],
                    u = b[(n + 72) >> 2],
                    c = b[(n + 76) >> 2],
                    p = b[(n + 80) >> 2],
                    g = b[(n + 84) >> 2],
                    y = b[(n + 88) >> 2],
                    f = b[(n + 52) >> 2],
                    v = !!(1 & f),
                    P = !!(2 & f),
                    C = !!(64 & f),
                    x = h ? Se(h) : void 0,
                    A = u ? Se(u) : void 0,
                    T = new XMLHttpRequest();
                  if (
                    ((T.withCredentials = !!m[n + 60]),
                    T.open(l, s, !C, x, A),
                    C || (T.timeout = d),
                    (T.url_ = s),
                    (T.responseType = "arraybuffer"),
                    p)
                  ) {
                    var E = Se(p);
                    T.overrideMimeType(E);
                  }
                  if (c)
                    for (;;) {
                      var R = b[c >> 2];
                      if (!R) break;
                      var D = b[(c + 4) >> 2];
                      if (!D) break;
                      c += 8;
                      var w = Se(R),
                        M = Se(D);
                      T.setRequestHeader(w, M);
                    }
                  var L = vs.xhrs.allocate(T);
                  b[e >> 2] = L;
                  var O = g && y ? m.slice(g, g + y) : null;
                  (T.onload = (i) => {
                    vs.xhrs.has(L) &&
                      (I(),
                      T.status >= 200 && T.status < 300
                        ? t?.(e, T, i)
                        : r?.(e, T, i));
                  }),
                    (T.onerror = (t) => {
                      vs.xhrs.has(L) && (I(), r?.(e, T, t));
                    }),
                    (T.ontimeout = (t) => {
                      vs.xhrs.has(L) && r?.(e, T, t);
                    }),
                    (T.onprogress = (t) => {
                      if (vs.xhrs.has(L)) {
                        var r =
                            v && P && T.response ? T.response.byteLength : 0,
                          o = 0;
                        r > 0 &&
                          v &&
                          P &&
                          ((o = Os(r)), m.set(new Uint8Array(T.response), o)),
                          (b[(e + 12) >> 2] = o),
                          ko(e + 16, r),
                          ko(e + 24, t.loaded - r),
                          ko(e + 32, t.total),
                          (S[(e + 40) >> 1] = T.readyState),
                          T.readyState >= 3 &&
                            0 === T.status &&
                            t.loaded > 0 &&
                            (T.status = 200),
                          (S[(e + 42) >> 1] = T.status),
                          T.statusText && xt(T.statusText, e + 44, 64),
                          i?.(e, T, t),
                          o && Is(o);
                      }
                    }),
                    (T.onreadystatechange = (t) => {
                      vs.xhrs.has(L) &&
                        ((S[(e + 40) >> 1] = T.readyState),
                        T.readyState >= 2 && (S[(e + 42) >> 1] = T.status),
                        o?.(e, T, t));
                    });
                  try {
                    T.send(O);
                  } catch (t) {
                    r?.(e, T, t);
                  }
                } else r(e, 0, "no url specified!");
                function I() {
                  var t = 0,
                    r = 0;
                  T.response &&
                    v &&
                    0 === b[(e + 12) >> 2] &&
                    (r = T.response.byteLength),
                    r > 0 &&
                      ((t = Os(r)), m.set(new Uint8Array(T.response), t)),
                    (b[(e + 12) >> 2] = t),
                    ko(e + 16, r),
                    ko(e + 24, 0);
                  var i = T.response ? T.response.byteLength : 0;
                  i && ko(e + 32, i),
                    (S[(e + 40) >> 1] = T.readyState),
                    (S[(e + 42) >> 1] = T.status),
                    T.statusText && xt(T.statusText, e + 44, 64);
                }
              }
              function Ss(e, t, r, i, o) {
                if (e) {
                  var a = b[(t + 108 + 64) >> 2];
                  a ||= b[(t + 8) >> 2];
                  var s = Se(a);
                  try {
                    var n = e
                      .transaction(["FILES"], "readwrite")
                      .objectStore("FILES")
                      .put(r, s);
                    (n.onsuccess = (e) => {
                      (S[(t + 40) >> 1] = 4),
                        (S[(t + 42) >> 1] = 200),
                        xt("OK", t + 44, 64),
                        i(t, 0, s);
                    }),
                      (n.onerror = (e) => {
                        (S[(t + 40) >> 1] = 4),
                          (S[(t + 42) >> 1] = 413),
                          xt("Payload Too Large", t + 44, 64),
                          o(t, 0, e);
                      });
                  } catch (e) {
                    o(t, 0, e);
                  }
                } else o(t, 0, "IndexedDB not available!");
              }
              var Ps = {},
                Cs = () => {
                  if (!Cs.strings) {
                    var e = {
                      USER: "web_user",
                      LOGNAME: "web_user",
                      PATH: "/",
                      PWD: "/",
                      HOME: "/home/web_user",
                      LANG:
                        (
                          ("object" == typeof navigator &&
                            navigator.languages &&
                            navigator.languages[0]) ||
                          "C"
                        ).replace("-", "_") + ".UTF-8",
                      _: h || "./this.program",
                    };
                    for (var t in Ps)
                      void 0 === Ps[t] ? delete e[t] : (e[t] = Ps[t]);
                    var r = [];
                    for (var t in e) r.push(`${t}=${e[t]}`);
                    Cs.strings = r;
                  }
                  return Cs.strings;
                },
                bs = (e, t) => {
                  t || (t = [document, document.getElementById("canvas")]),
                    ["keydown", "mousedown", "touchstart"].forEach((r) => {
                      t.forEach((t) => {
                        t &&
                          ((t, r, i) => {
                            t.addEventListener(
                              r,
                              () => {
                                "suspended" === e.state && e.resume();
                              },
                              { once: !0 }
                            );
                          })(t, r);
                      });
                    });
                },
                xs = (e) => s["_" + e],
                As = (e, t, r, i, o) => {
                  var a = {
                      string: (e) => {
                        var t = 0;
                        return null != e && 0 !== e && (t = dr(e)), t;
                      },
                      array: (e) => {
                        var t,
                          r,
                          i = lr(e.length);
                        return (t = e), (r = i), v.set(t, r), i;
                      },
                    },
                    s = xs(e),
                    n = [],
                    l = 0;
                  if (i)
                    for (var d = 0; d < i.length; d++) {
                      var h = a[r[d]];
                      h
                        ? (0 === l && (l = $()), (n[d] = h(i[d])))
                        : (n[d] = i[d]);
                    }
                  var u = s(...n);
                  return (function (e) {
                    return (
                      0 !== l && U(l),
                      (function (e) {
                        return "string" === t
                          ? Se(e)
                          : "boolean" === t
                          ? Boolean(e)
                          : e;
                      })(e)
                    );
                  })(u);
                };
              (me.createPreloadedFile = (e, t, r, i, a, s, n, l, d, h) => {
                var u = t ? ee.resolve(J.join2(e, t)) : e;
                function c(r) {
                  function o(r) {
                    h?.(), l || ge(e, t, r, i, a, d), s?.(), _();
                  }
                  fe(r, u, o, () => {
                    n?.(), _();
                  }) || o(r);
                }
                k(),
                  "string" == typeof r
                    ? (async (e) => {
                        var t = await o(e);
                        return new Uint8Array(t);
                      })(r).then(c, n)
                    : c(r);
              }),
                me.staticInit(),
                (pe.doesNotExistError = new me.ErrnoError(44)),
                (pe.doesNotExistError.stack = "<generic error, no stack>"),
                (ne = s.BindingError =
                  class extends Error {
                    constructor(e) {
                      super(e), (this.name = "BindingError");
                    }
                  }),
                xe.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1),
                (s.count_emval_handles = () => xe.length / 2 - 5 - be.length),
                (le = s.PureVirtualError = Ee(Error, "PureVirtualError")),
                (() => {
                  for (var e = new Array(256), t = 0; t < 256; ++t)
                    e[t] = String.fromCharCode(t);
                  de = e;
                })(),
                (he = s.InternalError =
                  class extends Error {
                    constructor(e) {
                      super(e), (this.name = "InternalError");
                    }
                  }),
                Object.assign($e.prototype, {
                  isAliasOf(e) {
                    if (!(this instanceof $e)) return !1;
                    if (!(e instanceof $e)) return !1;
                    var t = this.$$.ptrType.registeredClass,
                      r = this.$$.ptr;
                    e.$$ = e.$$;
                    for (
                      var i = e.$$.ptrType.registeredClass, o = e.$$.ptr;
                      t.baseClass;

                    )
                      (r = t.upcast(r)), (t = t.baseClass);
                    for (; i.baseClass; ) (o = i.upcast(o)), (i = i.baseClass);
                    return t === i && r === o;
                  },
                  clone() {
                    if (
                      (this.$$.ptr || We(this), this.$$.preservePointerOnDelete)
                    )
                      return (this.$$.count.value += 1), this;
                    var e,
                      t = Ye(
                        Object.create(Object.getPrototypeOf(this), {
                          $$: {
                            value:
                              ((e = this.$$),
                              {
                                count: e.count,
                                deleteScheduled: e.deleteScheduled,
                                preservePointerOnDelete:
                                  e.preservePointerOnDelete,
                                ptr: e.ptr,
                                ptrType: e.ptrType,
                                smartPtr: e.smartPtr,
                                smartPtrType: e.smartPtrType,
                              }),
                          },
                        })
                      );
                    return (
                      (t.$$.count.value += 1), (t.$$.deleteScheduled = !1), t
                    );
                  },
                  delete() {
                    this.$$.ptr || We(this),
                      this.$$.deleteScheduled &&
                        !this.$$.preservePointerOnDelete &&
                        Ae("Object already scheduled for deletion"),
                      Ie(this),
                      _e(this.$$),
                      this.$$.preservePointerOnDelete ||
                        ((this.$$.smartPtr = void 0), (this.$$.ptr = void 0));
                  },
                  isDeleted() {
                    return !this.$$.ptr;
                  },
                  deleteLater() {
                    return (
                      this.$$.ptr || We(this),
                      this.$$.deleteScheduled &&
                        !this.$$.preservePointerOnDelete &&
                        Ae("Object already scheduled for deletion"),
                      Ue.push(this),
                      Ue.length,
                      (this.$$.deleteScheduled = !0),
                      this
                    );
                  },
                }),
                Object.assign(it.prototype, {
                  getPointee(e) {
                    return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
                  },
                  destructor(e) {
                    this.rawDestructor?.(e);
                  },
                  argPackAdvance: 8,
                  readValueFromPointer: rt,
                  fromWireType: function (e) {
                    var t = this.getPointee(e);
                    if (!t) return this.destructor(e), null;
                    var r = Be(this.registeredClass, t);
                    if (void 0 !== r) {
                      if (0 === r.$$.count.value)
                        return (r.$$.ptr = t), (r.$$.smartPtr = e), r.clone();
                      var i = r.clone();
                      return this.destructor(e), i;
                    }
                    function o() {
                      return this.isSmartPointer
                        ? He(this.registeredClass.instancePrototype, {
                            ptrType: this.pointeeType,
                            ptr: t,
                            smartPtrType: this,
                            smartPtr: e,
                          })
                        : He(this.registeredClass.instancePrototype, {
                            ptrType: this,
                            ptr: e,
                          });
                    }
                    var a,
                      s = this.registeredClass.getActualType(t),
                      n = Ne[s];
                    if (!n) return o.call(this);
                    a = this.isConst ? n.constPointerType : n.pointerType;
                    var l = Ve(t, this.registeredClass, a.registeredClass);
                    return null === l
                      ? o.call(this)
                      : this.isSmartPointer
                      ? He(a.registeredClass.instancePrototype, {
                          ptrType: a,
                          ptr: l,
                          smartPtrType: this,
                          smartPtr: e,
                        })
                      : He(a.registeredClass.instancePrototype, {
                          ptrType: a,
                          ptr: l,
                        });
                  },
                }),
                (at = s.UnboundTypeError = Ee(Error, "UnboundTypeError")),
                (s.requestFullscreen = Wt.requestFullscreen),
                (s.setCanvasSize = Wt.setCanvasSize),
                (s.getUserMedia = Wt.getUserMedia),
                (s.createContext = Wt.createContext),
                (s.requestAnimationFrame = Jt.requestAnimationFrame),
                (s.pauseMainLoop = Jt.pause),
                (s.resumeMainLoop = Jt.resume),
                Jt.init();
              for (var Ts = 0; Ts < 32; ++Ts) ji.push(new Array(Ts));
              var Es = new Float32Array(288);
              for (Ts = 0; Ts <= 288; ++Ts) ka[Ts] = Es.subarray(0, Ts);
              var Rs = new Int32Array(288);
              for (Ts = 0; Ts <= 288; ++Ts) Fa[Ts] = Rs.subarray(0, Ts);
              vs.init();
              var Ds,
                ws = {
                  f: (e, t, r) => {
                    throw (new Z(e).init(t, r), e);
                  },
                  _: function (e, t, r) {
                    Pe.varargs = r;
                    try {
                      var i = Pe.getStreamFromFD(e);
                      switch (t) {
                        case 0:
                          if ((o = q()) < 0) return -28;
                          for (; me.streams[o]; ) o++;
                          return me.dupStream(i, o).fd;
                        case 1:
                        case 2:
                        case 13:
                        case 14:
                          return 0;
                        case 3:
                          return i.flags;
                        case 4:
                          var o = q();
                          return (i.flags |= o), 0;
                        case 12:
                          return (o = K()), (S[(o + 0) >> 1] = 2), 0;
                      }
                      return -28;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  wb: function (e, t) {
                    try {
                      var r = Pe.getStreamFromFD(e);
                      return Pe.doStat(me.stat, r.path, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  yb: function (e, t, r) {
                    Pe.varargs = r;
                    try {
                      var i = Pe.getStreamFromFD(e);
                      switch (t) {
                        case 21509:
                        case 21510:
                        case 21511:
                        case 21512:
                        case 21524:
                        case 21515:
                          return i.tty ? 0 : -59;
                        case 21505:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tcgets) {
                            var o = i.tty.ops.ioctl_tcgets(i),
                              a = K();
                            (C[a >> 2] = o.c_iflag || 0),
                              (C[(a + 4) >> 2] = o.c_oflag || 0),
                              (C[(a + 8) >> 2] = o.c_cflag || 0),
                              (C[(a + 12) >> 2] = o.c_lflag || 0);
                            for (var s = 0; s < 32; s++)
                              v[a + s + 17] = o.c_cc[s] || 0;
                            return 0;
                          }
                          return 0;
                        case 21506:
                        case 21507:
                        case 21508:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tcsets) {
                            a = K();
                            var n = C[a >> 2],
                              l = C[(a + 4) >> 2],
                              d = C[(a + 8) >> 2],
                              h = C[(a + 12) >> 2],
                              u = [];
                            for (s = 0; s < 32; s++) u.push(v[a + s + 17]);
                            return i.tty.ops.ioctl_tcsets(i.tty, t, {
                              c_iflag: n,
                              c_oflag: l,
                              c_cflag: d,
                              c_lflag: h,
                              c_cc: u,
                            });
                          }
                          return 0;
                        case 21519:
                          return i.tty ? ((a = K()), (C[a >> 2] = 0), 0) : -59;
                        case 21520:
                          return i.tty ? -28 : -59;
                        case 21531:
                          return (a = K()), me.ioctl(i, t, a);
                        case 21523:
                          if (!i.tty) return -59;
                          if (i.tty.ops.ioctl_tiocgwinsz) {
                            var c = i.tty.ops.ioctl_tiocgwinsz(i.tty);
                            (a = K()),
                              (S[a >> 1] = c[0]),
                              (S[(a + 2) >> 1] = c[1]);
                          }
                          return 0;
                        default:
                          return -28;
                      }
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  tb: function (e, t) {
                    try {
                      return (e = Pe.getStr(e)), Pe.doStat(me.lstat, e, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  ub: function (e, t, r, i) {
                    try {
                      t = Pe.getStr(t);
                      var o = 256 & i,
                        a = 4096 & i;
                      return (
                        (i &= -6401),
                        (t = Pe.calculateAt(e, t, a)),
                        Pe.doStat(o ? me.lstat : me.stat, t, r)
                      );
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  zb: function (e, t, r, i) {
                    Pe.varargs = i;
                    try {
                      (t = Pe.getStr(t)), (t = Pe.calculateAt(e, t));
                      var o = i ? q() : 0;
                      return me.open(t, r, o).fd;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  vb: function (e, t) {
                    try {
                      return (e = Pe.getStr(e)), Pe.doStat(me.stat, e, t);
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return -e.errno;
                    }
                  },
                  Ab: () => V(""),
                  Ia: (e, t, r) => {
                    (e = Re(e)), (t = Oe(t, "wrapper")), (r = Te.toValue(r));
                    var i = t.registeredClass,
                      o = i.instancePrototype,
                      a = i.baseClass.instancePrototype,
                      s = i.baseClass.constructor,
                      n = Ce(e, function (...e) {
                        i.baseClass.pureVirtualFunctions.forEach(
                          function (e) {
                            if (this[e] === a[e])
                              throw new le(
                                `Pure virtual function ${e} must be implemented in JavaScript`
                              );
                          }.bind(this)
                        ),
                          Object.defineProperty(this, "__parent", { value: o }),
                          this.__construct(...e);
                      });
                    return (
                      (o.__construct = function (...e) {
                        this === o && Ae("Pass correct 'this' to __construct");
                        var t = s.implement(this, ...e);
                        Ie(t);
                        var r,
                          a,
                          n = t.$$;
                        t.notifyOnDestruction(),
                          (n.preservePointerOnDelete = !0),
                          Object.defineProperties(this, { $$: { value: n } }),
                          Ye(this),
                          (r = i),
                          (a = n.ptr),
                          (a = we(r, a)),
                          De.hasOwnProperty(a)
                            ? Ae(`Tried to register registered instance: ${a}`)
                            : (De[a] = this);
                      }),
                      (o.__destruct = function () {
                        var e, t;
                        this === o && Ae("Pass correct 'this' to __destruct"),
                          Ie(this),
                          (e = i),
                          (t = this.$$.ptr),
                          (t = we(e, t)),
                          De.hasOwnProperty(t)
                            ? delete De[t]
                            : Ae(
                                `Tried to unregister unregistered instance: ${t}`
                              );
                      }),
                      (n.prototype = Object.create(o)),
                      Object.assign(n.prototype, r),
                      Te.toHandle(n)
                    );
                  },
                  nb: (e, t, r, i, o) => {},
                  Oa: (e, t, r, i) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType: function (e) {
                        return !!e;
                      },
                      toWireType: function (e, t) {
                        return t ? r : i;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: function (e) {
                        return this.fromWireType(m[e]);
                      },
                      destructorFunction: null,
                    });
                  },
                  d: (e, t, r, i, o, a, s, n, l, d, h, u, c) => {
                    (h = Re(h)),
                      (a = dt(o, a)),
                      (n &&= dt(s, n)),
                      (d &&= dt(l, d)),
                      (c = dt(u, c));
                    var p = ((e) => {
                      var t = (e = e.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(
                        0
                      );
                      return t >= 48 && t <= 57 ? `_${e}` : e;
                    })(h);
                    qe(p, function () {
                      ht(`Cannot construct ${h} due to unbound types`, [i]);
                    }),
                      Xe([e, t, r], i ? [i] : [], (t) => {
                        var r, o;
                        (t = t[0]),
                          (o = i
                            ? (r = t.registeredClass).instancePrototype
                            : $e.prototype);
                        var s = Ce(h, function (...e) {
                            if (Object.getPrototypeOf(this) !== l)
                              throw new ne("Use 'new' to construct " + h);
                            if (void 0 === u.constructor_body)
                              throw new ne(
                                h + " has no accessible constructor"
                              );
                            var t = u.constructor_body[e.length];
                            if (void 0 === t)
                              throw new ne(
                                `Tried to invoke ctor of ${h} with invalid number of parameters (${
                                  e.length
                                }) - expected (${Object.keys(
                                  u.constructor_body
                                ).toString()}) parameters instead!`
                              );
                            return t.apply(this, e);
                          }),
                          l = Object.create(o, { constructor: { value: s } });
                        s.prototype = l;
                        var u = new Ke(h, s, l, c, r, a, n, d);
                        u.baseClass &&
                          ((u.baseClass.__derivedClasses ??= []),
                          u.baseClass.__derivedClasses.push(u));
                        var g = new it(h, u, !0, !1, !1),
                          y = new it(h + "*", u, !1, !1, !1),
                          f = new it(h + " const*", u, !1, !0, !1);
                        return (
                          (Ne[e] = { pointerType: y, constPointerType: f }),
                          st(p, s),
                          [g, y, f]
                        );
                      });
                  },
                  e: (e, t, r, i, o, a, s, n, l) => {
                    var d = gt(r, i);
                    (t = Re(t)),
                      (t = yt(t)),
                      (a = dt(o, a)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`;
                        function o() {
                          ht(`Cannot call ${i} due to unbound types`, d);
                        }
                        t.startsWith("@@") && (t = Symbol[t.substring(2)]);
                        var n = e.registeredClass.constructor;
                        return (
                          void 0 === n[t]
                            ? ((o.argCount = r - 1), (n[t] = o))
                            : (Ze(n, t, i), (n[t].overloadTable[r - 1] = o)),
                          Xe([], d, (o) => {
                            var l = [o[0], null].concat(o.slice(1)),
                              d = ct(i, l, null, a, s);
                            if (
                              (void 0 === n[t].overloadTable
                                ? ((d.argCount = r - 1), (n[t] = d))
                                : (n[t].overloadTable[r - 1] = d),
                              e.registeredClass.__derivedClasses)
                            )
                              for (const r of e.registeredClass
                                .__derivedClasses)
                                r.constructor.hasOwnProperty(t) ||
                                  (r.constructor[t] = d);
                            return [];
                          }),
                          []
                        );
                      });
                  },
                  g: (e, t, r, i, o, a) => {
                    var s = gt(t, r);
                    (o = dt(i, o)),
                      Xe([], [e], (e) => {
                        var r = `constructor ${(e = e[0]).name}`;
                        if (
                          (void 0 === e.registeredClass.constructor_body &&
                            (e.registeredClass.constructor_body = []),
                          void 0 !== e.registeredClass.constructor_body[t - 1])
                        )
                          throw new ne(
                            `Cannot register multiple constructors with identical number of parameters (${
                              t - 1
                            }) for class '${
                              e.name
                            }'! Overload resolution is currently only performed using the parameter count, not actual type info!`
                          );
                        return (
                          (e.registeredClass.constructor_body[t - 1] = () => {
                            ht(
                              `Cannot construct ${e.name} due to unbound types`,
                              s
                            );
                          }),
                          Xe(
                            [],
                            s,
                            (i) => (
                              i.splice(1, 0, null),
                              (e.registeredClass.constructor_body[t - 1] = ct(
                                r,
                                i,
                                null,
                                o,
                                a
                              )),
                              []
                            )
                          ),
                          []
                        );
                      });
                  },
                  a: (e, t, r, i, o, a, s, n, l, d) => {
                    var h = gt(r, i);
                    (t = Re(t)),
                      (t = yt(t)),
                      (a = dt(o, a)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`;
                        function o() {
                          ht(`Cannot call ${i} due to unbound types`, h);
                        }
                        t.startsWith("@@") && (t = Symbol[t.substring(2)]),
                          n && e.registeredClass.pureVirtualFunctions.push(t);
                        var l = e.registeredClass.instancePrototype,
                          d = l[t];
                        return (
                          void 0 === d ||
                          (void 0 === d.overloadTable &&
                            d.className !== e.name &&
                            d.argCount === r - 2)
                            ? ((o.argCount = r - 2),
                              (o.className = e.name),
                              (l[t] = o))
                            : (Ze(l, t, i), (l[t].overloadTable[r - 2] = o)),
                          Xe([], h, (o) => {
                            var n = ct(i, o, e, a, s);
                            return (
                              void 0 === l[t].overloadTable
                                ? ((n.argCount = r - 2), (l[t] = n))
                                : (l[t].overloadTable[r - 2] = n),
                              []
                            );
                          }),
                          []
                        );
                      });
                  },
                  c: (e, t, r, i, o, a, s, n, l, d) => {
                    (t = Re(t)),
                      (o = dt(i, o)),
                      Xe([], [e], (e) => {
                        var i = `${(e = e[0]).name}.${t}`,
                          h = {
                            get() {
                              ht(`Cannot access ${i} due to unbound types`, [
                                r,
                                s,
                              ]);
                            },
                            enumerable: !0,
                            configurable: !0,
                          };
                        return (
                          (h.set = l
                            ? () =>
                                ht(`Cannot access ${i} due to unbound types`, [
                                  r,
                                  s,
                                ])
                            : (e) => Ae(i + " is a read-only property")),
                          Object.defineProperty(
                            e.registeredClass.instancePrototype,
                            t,
                            h
                          ),
                          Xe([], l ? [r, s] : [r], (r) => {
                            var s = r[0],
                              h = {
                                get() {
                                  var t = ft(this, e, i + " getter");
                                  return s.fromWireType(o(a, t));
                                },
                                enumerable: !0,
                              };
                            if (l) {
                              l = dt(n, l);
                              var u = r[1];
                              h.set = function (t) {
                                var r = ft(this, e, i + " setter"),
                                  o = [];
                                l(d, r, u.toWireType(o, t)), ut(o);
                              };
                            }
                            return (
                              Object.defineProperty(
                                e.registeredClass.instancePrototype,
                                t,
                                h
                              ),
                              []
                            );
                          }),
                          []
                        );
                      });
                  },
                  La: (e) => Ge(e, mt),
                  i: (e, t, r, i) => {
                    function o() {}
                    (t = Re(t)),
                      (o.values = {}),
                      Ge(e, {
                        name: t,
                        constructor: o,
                        fromWireType: function (e) {
                          return this.constructor.values[e];
                        },
                        toWireType: (e, t) => t.value,
                        argPackAdvance: 8,
                        readValueFromPointer: St(t, r, i),
                        destructorFunction: null,
                      }),
                      qe(t, o);
                  },
                  b: (e, t, r) => {
                    var i = Oe(e, "enum");
                    t = Re(t);
                    var o = i.constructor,
                      a = Object.create(i.constructor.prototype, {
                        value: { value: r },
                        constructor: {
                          value: Ce(`${i.name}_${t}`, function () {}),
                        },
                      });
                    (o.values[r] = a), (o[t] = a);
                  },
                  Q: (e, t, r) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType: (e) => e,
                      toWireType: (e, t) => t,
                      argPackAdvance: 8,
                      readValueFromPointer: Ct(t, r),
                      destructorFunction: null,
                    });
                  },
                  j: (e, t, r, i, o, a, s, n) => {
                    var l = gt(t, r);
                    (e = Re(e)),
                      (e = yt(e)),
                      (o = dt(i, o)),
                      qe(
                        e,
                        function () {
                          ht(`Cannot call ${e} due to unbound types`, l);
                        },
                        t - 1
                      ),
                      Xe([], l, (r) => {
                        var i = [r[0], null].concat(r.slice(1));
                        return st(e, ct(e, i, null, o, a), t - 1), [];
                      });
                  },
                  p: (e, t, r, i, o) => {
                    (t = Re(t)), -1 === o && (o = 4294967295);
                    var a = (e) => e;
                    if (0 === i) {
                      var s = 32 - 8 * r;
                      a = (e) => (e << s) >>> s;
                    }
                    var n = t.includes("unsigned");
                    Ge(e, {
                      name: t,
                      fromWireType: a,
                      toWireType: n
                        ? function (e, t) {
                            return this.name, t >>> 0;
                          }
                        : function (e, t) {
                            return this.name, t;
                          },
                      argPackAdvance: 8,
                      readValueFromPointer: bt(t, r, 0 !== i),
                      destructorFunction: null,
                    });
                  },
                  k: (e, t, r) => {
                    var i = [
                      Int8Array,
                      Uint8Array,
                      Int16Array,
                      Uint16Array,
                      Int32Array,
                      Uint32Array,
                      Float32Array,
                      Float64Array,
                    ][t];
                    function o(e) {
                      var t = b[e >> 2],
                        r = b[(e + 4) >> 2];
                      return new i(v.buffer, r, t);
                    }
                    Ge(
                      e,
                      {
                        name: (r = Re(r)),
                        fromWireType: o,
                        argPackAdvance: 8,
                        readValueFromPointer: o,
                      },
                      { ignoreDuplicateRegistrations: !0 }
                    );
                  },
                  Ma: (e, t) => {
                    Ge(e, {
                      name: (t = Re(t)),
                      fromWireType(e) {
                        for (
                          var t, r = b[e >> 2], i = e + 4, o = i, a = 0;
                          a <= r;
                          ++a
                        ) {
                          var s = i + a;
                          if (a == r || 0 == m[s]) {
                            var n = Se(o, s - o);
                            void 0 === t
                              ? (t = n)
                              : ((t += String.fromCharCode(0)), (t += n)),
                              (o = s + 1);
                          }
                        }
                        return Is(e), t;
                      },
                      toWireType(e, t) {
                        var r;
                        t instanceof ArrayBuffer && (t = new Uint8Array(t));
                        var i = "string" == typeof t;
                        i ||
                          t instanceof Uint8Array ||
                          t instanceof Uint8ClampedArray ||
                          t instanceof Int8Array ||
                          Ae("Cannot pass non-string to std::string"),
                          (r = i ? oe(t) : t.length);
                        var o = Os(4 + r + 1),
                          a = o + 4;
                        if (((b[o >> 2] = r), i)) xt(t, a, r + 1);
                        else if (i)
                          for (var s = 0; s < r; ++s) {
                            var n = t.charCodeAt(s);
                            n > 255 &&
                              (Is(a),
                              Ae(
                                "String has UTF-16 code units that do not fit in 8 bits"
                              )),
                              (m[a + s] = n);
                          }
                        else for (s = 0; s < r; ++s) m[a + s] = t[s];
                        return null !== e && e.push(Is, o), o;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: rt,
                      destructorFunction(e) {
                        Is(e);
                      },
                    });
                  },
                  I: (e, t, r) => {
                    var i, o, a, s;
                    (r = Re(r)),
                      2 === t
                        ? ((i = Tt), (o = Et), (s = Rt), (a = (e) => P[e >> 1]))
                        : 4 === t &&
                          ((i = Dt),
                          (o = wt),
                          (s = Mt),
                          (a = (e) => b[e >> 2])),
                      Ge(e, {
                        name: r,
                        fromWireType: (e) => {
                          for (
                            var r, o = b[e >> 2], s = e + 4, n = 0;
                            n <= o;
                            ++n
                          ) {
                            var l = e + 4 + n * t;
                            if (n == o || 0 == a(l)) {
                              var d = i(s, l - s);
                              void 0 === r
                                ? (r = d)
                                : ((r += String.fromCharCode(0)), (r += d)),
                                (s = l + t);
                            }
                          }
                          return Is(e), r;
                        },
                        toWireType: (e, i) => {
                          "string" != typeof i &&
                            Ae(
                              `Cannot pass non-string to C++ string type ${r}`
                            );
                          var a = s(i),
                            n = Os(4 + a + t);
                          return (
                            (b[n >> 2] = a / t),
                            o(i, n + 4, a + t),
                            null !== e && e.push(Is, n),
                            n
                          );
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: rt,
                        destructorFunction(e) {
                          Is(e);
                        },
                      });
                  },
                  Pa: (e, t) => {
                    Ge(e, {
                      isVoid: !0,
                      name: (t = Re(t)),
                      argPackAdvance: 0,
                      fromWireType: () => {},
                      toWireType: (e, t) => {},
                    });
                  },
                  Ya: function (e) {
                    if (vs.xhrs.has(e)) {
                      var t = vs.xhrs.get(e);
                      vs.xhrs.free(e),
                        t.readyState > 0 && t.readyState < 4 && t.abort();
                    }
                  },
                  ob: () => {
                    throw 1 / 0;
                  },
                  v: (e, t, r, i, o) => {
                    var a, s;
                    return (e = Ot[e])(
                      (t = Te.toValue(t)),
                      t[(r = void 0 === (s = Lt[(a = r)]) ? Re(a) : s)],
                      i,
                      o
                    );
                  },
                  Ja: vt,
                  u: (e, t, r) => {
                    var i = ((e, t) => {
                        for (var r = new Array(e), i = 0; i < e; ++i)
                          r[i] = Oe(b[(t + 4 * i) >> 2], "parameter " + i);
                        return r;
                      })(e, t),
                      o = i.shift();
                    e--;
                    var a,
                      s,
                      n = new Array(e),
                      l = `methodCaller<(${i
                        .map((e) => e.name)
                        .join(", ")}) => ${o.name}>`;
                    return (
                      (a = Ce(l, (t, a, s, l) => {
                        for (var d = 0, h = 0; h < e; ++h)
                          (n[h] = i[h].readValueFromPointer(l + d)),
                            (d += i[h].argPackAdvance);
                        var u = 1 === r ? It(a, n) : a.apply(t, n);
                        return ((e, t, r) => {
                          var i = [],
                            o = e.toWireType(i, r);
                          return i.length && (b[t >> 2] = Te.toHandle(i)), o;
                        })(o, s, u);
                      })),
                      (s = Ot.length),
                      Ot.push(a),
                      s
                    );
                  },
                  Ha: (e) => {
                    var t = Te.toValue(e);
                    ut(t), vt(e);
                  },
                  x: (e, t) => {
                    var r = (e = Oe(
                      e,
                      "_emval_take_value"
                    )).readValueFromPointer(t);
                    return Te.toHandle(r);
                  },
                  jb: function (e, t, r) {
                    var i = Vt(e, t),
                      o = new Date(1e3 * i);
                    (C[r >> 2] = o.getSeconds()),
                      (C[(r + 4) >> 2] = o.getMinutes()),
                      (C[(r + 8) >> 2] = o.getHours()),
                      (C[(r + 12) >> 2] = o.getDate()),
                      (C[(r + 16) >> 2] = o.getMonth()),
                      (C[(r + 20) >> 2] = o.getFullYear() - 1900),
                      (C[(r + 24) >> 2] = o.getDay());
                    var a =
                      0 |
                      ((e) => {
                        var t;
                        return (
                          ((t = e.getFullYear()) % 4 != 0 ||
                          (t % 100 == 0 && t % 400 != 0)
                            ? _t
                            : kt)[e.getMonth()] +
                          e.getDate() -
                          1
                        );
                      })(o);
                    (C[(r + 28) >> 2] = a),
                      (C[(r + 36) >> 2] = -60 * o.getTimezoneOffset());
                    var s = new Date(o.getFullYear(), 0, 1),
                      n = new Date(o.getFullYear(), 6, 1).getTimezoneOffset(),
                      l = s.getTimezoneOffset(),
                      d =
                        0 | (n != l && o.getTimezoneOffset() == Math.min(l, n));
                    C[(r + 32) >> 2] = d;
                  },
                  qb: (e, t, r, i) => {
                    var o = new Date().getFullYear(),
                      a = new Date(o, 0, 1),
                      s = new Date(o, 6, 1),
                      n = a.getTimezoneOffset(),
                      l = s.getTimezoneOffset(),
                      d = Math.max(n, l);
                    (b[e >> 2] = 60 * d), (C[t >> 2] = Number(n != l));
                    var h = (e) => {
                        var t = e >= 0 ? "-" : "+",
                          r = Math.abs(e);
                        return `UTC${t}${String(Math.floor(r / 60)).padStart(
                          2,
                          "0"
                        )}${String(r % 60).padStart(2, "0")}`;
                      },
                      u = h(n),
                      c = h(l);
                    l < n
                      ? (xt(u, r, 17), xt(c, i, 17))
                      : (xt(u, i, 17), xt(c, r, 17));
                  },
                  mb: function (e, t, r, i) {
                    var o, a;
                    if ((Vt(t, r), !((a = e) >= 0 && a <= 3))) return 28;
                    o = 0 === e ? Bt() : Nt();
                    var s = Math.round(1e3 * o * 1e3);
                    return (
                      (F = [
                        s >>> 0,
                        ((B = s),
                        +Math.abs(B) >= 1
                          ? B > 0
                            ? +Math.floor(B / 4294967296) >>> 0
                            : ~~+Math.ceil((B - +(~~B >>> 0)) / 4294967296) >>>
                              0
                          : 0),
                      ]),
                      (C[i >> 2] = F[0]),
                      (C[(i + 4) >> 2] = F[1]),
                      0
                    );
                  },
                  nh: (e) =>
                    12448 == e
                      ? (Ut.setErrorCode(12288), 1)
                      : (Ut.setErrorCode(12300), 0),
                  qh: (e, t, r, i, o) => Ut.chooseConfig(e, t, r, i, o),
                  eh: (e, t, r, i) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    for (var o = 1; ; ) {
                      var a = C[i >> 2];
                      if (12440 != a) {
                        if (12344 == a) break;
                        return Ut.setErrorCode(12292), 0;
                      }
                      (o = C[(i + 4) >> 2]), (i += 8);
                    }
                    return o < 2 || o > 3
                      ? (Ut.setErrorCode(12293), 0)
                      : ((Ut.contextAttributes.majorVersion = o - 1),
                        (Ut.contextAttributes.minorVersion = 0),
                        (Ut.context = Zt.createContext(
                          s.canvas,
                          Ut.contextAttributes
                        )),
                        0 != Ut.context
                          ? (Ut.setErrorCode(12288),
                            Zt.makeContextCurrent(Ut.context),
                            (Wt.useWebGL = !0),
                            Wt.moduleContextCreatedCallbacks.forEach((e) =>
                              e()
                            ),
                            Zt.makeContextCurrent(null),
                            62004)
                          : (Ut.setErrorCode(12297), 0));
                  },
                  gh: (e, t, r, i) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62002 != t
                      ? (Ut.setErrorCode(12293), 0)
                      : (Ut.setErrorCode(12288), 62006),
                  fh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62004 != t
                      ? (Ut.setErrorCode(12294), 0)
                      : (Zt.deleteContext(Ut.context),
                        Ut.setErrorCode(12288),
                        Ut.currentContext == t && (Ut.currentContext = 0),
                        1),
                  hh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 62006 != t
                      ? (Ut.setErrorCode(12301), 1)
                      : (Ut.currentReadSurface == t &&
                          (Ut.currentReadSurface = 0),
                        Ut.currentDrawSurface == t &&
                          (Ut.currentDrawSurface = 0),
                        Ut.setErrorCode(12288),
                        1),
                  rh: (e, t, r, i) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if (62002 != t) return Ut.setErrorCode(12293), 0;
                    if (!i) return Ut.setErrorCode(12300), 0;
                    switch ((Ut.setErrorCode(12288), r)) {
                      case 12320:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.alpha ? 32 : 24), 1
                        );
                      case 12321:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.alpha ? 8 : 0), 1
                        );
                      case 12322:
                      case 12323:
                      case 12324:
                        return (C[i >> 2] = 8), 1;
                      case 12325:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.depth ? 24 : 0), 1
                        );
                      case 12326:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.stencil ? 8 : 0), 1
                        );
                      case 12327:
                      case 12335:
                      case 12340:
                        return (C[i >> 2] = 12344), 1;
                      case 12328:
                        return (C[i >> 2] = 62002), 1;
                      case 12329:
                      case 12333:
                      case 12334:
                      case 12345:
                      case 12346:
                      case 12347:
                      case 12349:
                      case 12350:
                      case 12354:
                        return (C[i >> 2] = 0), 1;
                      case 12330:
                      case 12332:
                        return (C[i >> 2] = 4096), 1;
                      case 12331:
                        return (C[i >> 2] = 16777216), 1;
                      case 12337:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.antialias ? 4 : 0),
                          1
                        );
                      case 12338:
                        return (
                          (C[i >> 2] = Ut.contextAttributes.antialias ? 1 : 0),
                          1
                        );
                      case 12339:
                      case 12352:
                        return (C[i >> 2] = 4), 1;
                      case 12341:
                      case 12342:
                      case 12343:
                        return (C[i >> 2] = -1), 1;
                      case 12348:
                        return (C[i >> 2] = 1), 1;
                      case 12351:
                        return (C[i >> 2] = 12430), 1;
                      default:
                        return Ut.setErrorCode(12292), 0;
                    }
                  },
                  Ba: (e) => (
                    Ut.setErrorCode(12288), 0 != e && 1 != e ? 0 : 62e3
                  ),
                  dh: () => Ut.errorCode,
                  oh: (e, t, r) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : (t && (C[t >> 2] = 1),
                        r && (C[r >> 2] = 4),
                        (Ut.defaultDisplayInitialized = !0),
                        Ut.setErrorCode(12288),
                        1),
                  ih: (e, t, r, i) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : 0 != i && 62004 != i
                      ? (Ut.setErrorCode(12294), 0)
                      : (0 != r && 62006 != r) || (0 != t && 62006 != t)
                      ? (Ut.setErrorCode(12301), 0)
                      : (Zt.makeContextCurrent(i ? Ut.context : null),
                        (Ut.currentContext = i),
                        (Ut.currentDrawSurface = t),
                        (Ut.currentReadSurface = r),
                        Ut.setErrorCode(12288),
                        1),
                  ch: (e, t) => {
                    if (62e3 != e) return Ut.setErrorCode(12296), 0;
                    if ((Ut.setErrorCode(12288), Ut.stringCache[t]))
                      return Ut.stringCache[t];
                    var r;
                    switch (t) {
                      case 12371:
                        r = qt("Emscripten");
                        break;
                      case 12372:
                        r = qt("1.4 Emscripten EGL");
                        break;
                      case 12373:
                        r = qt("");
                        break;
                      case 12429:
                        r = qt("OpenGL_ES");
                        break;
                      default:
                        return Ut.setErrorCode(12300), 0;
                    }
                    return (Ut.stringCache[t] = r), r;
                  },
                  jh: (e, t) => {
                    if (Ut.defaultDisplayInitialized)
                      if (pt) {
                        if (!pt.isContextLost())
                          return Ut.setErrorCode(12288), 1;
                        Ut.setErrorCode(12302);
                      } else Ut.setErrorCode(12290);
                    else Ut.setErrorCode(12289);
                    return 0;
                  },
                  kh: (e, t) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : (0 == t ? Qt(0, 0) : Qt(1, t),
                        Ut.setErrorCode(12288),
                        1),
                  ph: (e) =>
                    62e3 != e
                      ? (Ut.setErrorCode(12296), 0)
                      : ((Ut.currentContext = 0),
                        (Ut.currentReadSurface = 0),
                        (Ut.currentDrawSurface = 0),
                        (Ut.defaultDisplayInitialized = !1),
                        Ut.setErrorCode(12288),
                        1),
                  mh: () => (Ut.setErrorCode(12288), 1),
                  lh: (e) => (Ut.setErrorCode(12288), 1),
                  A: (e, t, r) =>
                    ((e, t, r) => {
                      var i = tr(t, r);
                      return z[e](...i);
                    })(e, t, r),
                  m: (e, t, r) => rr(e, t, r),
                  Ga: (e, t, r) => rr(e, t, r),
                  Na: () => {
                    Jt.pause(), (Jt.func = null);
                  },
                  $: Bt,
                  Zg: () => {
                    if (!ir.fullscreenEnabled()) return -1;
                    ir.removeDeferredCalls(yr);
                    var e = ar[1];
                    if (e.exitFullscreen)
                      e.fullscreenElement && e.exitFullscreen();
                    else {
                      if (!e.webkitExitFullscreen) return -1;
                      e.webkitFullscreenElement && e.webkitExitFullscreen();
                    }
                    return 0;
                  },
                  ah: () => (
                    ir.removeDeferredCalls(fr),
                    document.exitPointerLock
                      ? (document.exitPointerLock(), 0)
                      : -1
                  ),
                  z: () => devicePixelRatio,
                  t: (e, t, r) => {
                    if (!(e = sr(e))) return -4;
                    var i = gr(e);
                    return (A[t >> 3] = i.width), (A[r >> 3] = i.height), 0;
                  },
                  Ea: (e, t) =>
                    e < 0 || e >= ir.lastGamepadState.length
                      ? -5
                      : ir.lastGamepadState[e]
                      ? (vr(t, ir.lastGamepadState[e]), 0)
                      : -7,
                  Y: Nt,
                  sh: () => ir.lastGamepadState.length,
                  bh: (e, t) => {
                    (C[e >> 2] = screen.width), (C[t >> 2] = screen.height);
                  },
                  Dg: Sr,
                  Cg: Cr,
                  ud: (e, t) => {
                    pt.beginQuery(e, Zt.queries[t]);
                  },
                  Vg: (e, t) => {
                    pt.disjointTimerQueryExt.beginQueryEXT(e, Zt.queries[t]);
                  },
                  $c: (e) => pt.beginTransformFeedback(e),
                  Bg: xr,
                  Ag: Tr,
                  Yc: (e, t, r) => {
                    pt.bindBufferBase(e, t, Zt.buffers[r]);
                  },
                  Zc: (e, t, r, i, o) => {
                    pt.bindBufferRange(e, t, Zt.buffers[r], i, o);
                  },
                  zg: Rr,
                  yg: (e, t) => {
                    pt.bindRenderbuffer(e, Zt.renderbuffers[t]);
                  },
                  bc: (e, t) => {
                    pt.bindSampler(e, Zt.samplers[t]);
                  },
                  xg: wr,
                  Vb: (e, t) => {
                    pt.bindTransformFeedback(e, Zt.transformFeedbacks[t]);
                  },
                  fd: Lr,
                  Mg: Ir,
                  wg: _r,
                  vg: Nr,
                  ug: (e, t) => pt.blendEquationSeparate(e, t),
                  tg: (e, t) => pt.blendFunc(e, t),
                  sg: Fr,
                  id: (e, t, r, i, o, a, s, n, l, d) =>
                    pt.blitFramebuffer(e, t, r, i, o, a, s, n, l, d),
                  rg: Yr,
                  qg: (e, t, r, i) => {
                    Zt.currentContext.version >= 2
                      ? r && pt.bufferSubData(e, t, m, i, r)
                      : pt.bufferSubData(e, t, m.subarray(i, i + r));
                  },
                  pg: jr,
                  og: Gr,
                  Ac: (e, t, r, i) => pt.clearBufferfi(e, t, r, i),
                  Bc: (e, t, r) => {
                    pt.clearBufferfv(e, t, x, r >> 2);
                  },
                  Dc: (e, t, r) => {
                    pt.clearBufferiv(e, t, C, r >> 2);
                  },
                  Cc: (e, t, r) => {
                    pt.clearBufferuiv(e, t, b, r >> 2);
                  },
                  ng: Ur,
                  mg: (e) => pt.clearDepth(e),
                  lg: (e) => pt.clearStencil(e),
                  mc: (e, t, r, i) => {
                    var o = $r(r, i);
                    return pt.clientWaitSync(Zt.syncs[e], t, o);
                  },
                  Md: (e, t) => {
                    pt.extClipControl.clipControlEXT(e, t);
                  },
                  kg: qr,
                  jg: Jr,
                  ig: ei,
                  Ad: (e, t, r, i, o, a, s, n, l) => {
                    pt.currentPixelUnpackBufferBinding
                      ? pt.compressedTexImage3D(e, t, r, i, o, a, s, n, l)
                      : pt.compressedTexImage3D(e, t, r, i, o, a, s, m, l, n);
                  },
                  hg: (e, t, r, i, o, a, s, n, l) => {
                    if (Zt.currentContext.version >= 2)
                      return pt.currentPixelUnpackBufferBinding || !n
                        ? void pt.compressedTexSubImage2D(
                            e,
                            t,
                            r,
                            i,
                            o,
                            a,
                            s,
                            n,
                            l
                          )
                        : void pt.compressedTexSubImage2D(
                            e,
                            t,
                            r,
                            i,
                            o,
                            a,
                            s,
                            m,
                            l,
                            n
                          );
                    pt.compressedTexSubImage2D(
                      e,
                      t,
                      r,
                      i,
                      o,
                      a,
                      s,
                      m.subarray(l, l + n)
                    );
                  },
                  yd: (e, t, r, i, o, a, s, n, l, d, h) => {
                    pt.currentPixelUnpackBufferBinding
                      ? pt.compressedTexSubImage3D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          l,
                          d,
                          h
                        )
                      : pt.compressedTexSubImage3D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          l,
                          m,
                          h,
                          d
                        );
                  },
                  yc: (e, t, r, i, o) => pt.copyBufferSubData(e, t, r, i, o),
                  gg: (e, t, r, i, o, a, s, n) =>
                    pt.copyTexImage2D(e, t, r, i, o, a, s, n),
                  fg: (e, t, r, i, o, a, s, n) =>
                    pt.copyTexSubImage2D(e, t, r, i, o, a, s, n),
                  Bd: (e, t, r, i, o, a, s, n, l) =>
                    pt.copyTexSubImage3D(e, t, r, i, o, a, s, n, l),
                  cg: ri,
                  bg: oi,
                  ag: si,
                  $f: li,
                  _f: hi,
                  Zf: ci,
                  wd: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.queries[i];
                      o && (pt.deleteQuery(o), (Zt.queries[i] = null));
                    }
                  },
                  Xg: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.queries[i];
                      o &&
                        (pt.disjointTimerQueryExt.deleteQueryEXT(o),
                        (Zt.queries[i] = null));
                    }
                  },
                  Yf: gi,
                  dc: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.samplers[i];
                      o &&
                        (pt.deleteSampler(o),
                        (o.name = 0),
                        (Zt.samplers[i] = null));
                    }
                  },
                  Xf: fi,
                  nc: (e) => {
                    if (e) {
                      var t = Zt.syncs[e];
                      t
                        ? (pt.deleteSync(t), (t.name = 0), (Zt.syncs[e] = null))
                        : Zt.recordError(1281);
                    }
                  },
                  Wf: mi,
                  Ub: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = C[(t + 4 * r) >> 2],
                        o = Zt.transformFeedbacks[i];
                      o &&
                        (pt.deleteTransformFeedback(o),
                        (o.name = 0),
                        (Zt.transformFeedbacks[i] = null));
                    }
                  },
                  ed: Pi,
                  Lg: bi,
                  Vf: Ai,
                  Tf: Ei,
                  Sf: (e, t) => pt.depthRange(e, t),
                  Rf: Di,
                  Qf: Mi,
                  Pf: (e) => {
                    pt.disableVertexAttribArray(e);
                  },
                  Of: Oi,
                  rc: ki,
                  Gg: Vi,
                  Eb: Bi,
                  Id: Hi,
                  Fb: zi,
                  qd: Gi,
                  Gd: Ui,
                  Hg: Zi,
                  Nf: Ki,
                  qc: Qi,
                  Fg: to,
                  Cb: io,
                  Db: ao,
                  Hd: no,
                  Ed: (e, t, r, i, o, a) => {
                    qi(e, i, o, a);
                  },
                  Mf: ho,
                  Lf: co,
                  td: (e) => pt.endQuery(e),
                  Tg: (e) => {
                    pt.disjointTimerQueryExt.endQueryEXT(e);
                  },
                  _c: () => pt.endTransformFeedback(),
                  pc: (e, t) => {
                    var r = pt.fenceSync(e, t);
                    if (r) {
                      var i = Zt.getNewId(Zt.syncs);
                      return (r.name = i), (Zt.syncs[i] = r), i;
                    }
                    return 0;
                  },
                  Kf: () => pt.finish(),
                  Jf: () => pt.flush(),
                  If: (e, t, r, i) => {
                    pt.framebufferRenderbuffer(e, t, r, Zt.renderbuffers[i]);
                  },
                  Hf: go,
                  gd: (e, t, r, i, o) => {
                    pt.framebufferTextureLayer(e, t, Zt.textures[r], i, o);
                  },
                  Gf: fo,
                  Ff: mo,
                  Df: Po,
                  xd: (e, t) => {
                    Zt.genObject(e, t, "createQuery", Zt.queries);
                  },
                  Yg: (e, t) => {
                    for (var r = 0; r < e; r++) {
                      var i = pt.disjointTimerQueryExt.createQueryEXT();
                      if (!i) {
                        for (Zt.recordError(1282); r < e; )
                          C[(t + 4 * r++) >> 2] = 0;
                        return;
                      }
                      var o = Zt.getNewId(Zt.queries);
                      (i.name = o),
                        (Zt.queries[o] = i),
                        (C[(t + 4 * r) >> 2] = o);
                    }
                  },
                  Cf: (e, t) => {
                    Zt.genObject(e, t, "createRenderbuffer", Zt.renderbuffers);
                  },
                  gc: (e, t) => {
                    Zt.genObject(e, t, "createSampler", Zt.samplers);
                  },
                  Bf: bo,
                  Tb: (e, t) => {
                    Zt.genObject(
                      e,
                      t,
                      "createTransformFeedback",
                      Zt.transformFeedbacks
                    );
                  },
                  cd: Ao,
                  Kg: Eo,
                  Ef: Do,
                  Af: Lo,
                  zf: Io,
                  tc: (e, t, r, i, o) => {
                    e = Zt.programs[e];
                    var a = pt.getActiveUniformBlockName(e, t);
                    if (a)
                      if (o && r > 0) {
                        var s = xt(a, o, r);
                        i && (C[i >> 2] = s);
                      } else i && (C[i >> 2] = 0);
                  },
                  uc: (e, t, r, i) => {
                    if (i)
                      if (((e = Zt.programs[e]), 35393 != r)) {
                        var o = pt.getActiveUniformBlockParameter(e, t, r);
                        if (null !== o)
                          if (35395 == r)
                            for (var a = 0; a < o.length; a++)
                              C[(i + 4 * a) >> 2] = o[a];
                          else C[i >> 2] = o;
                      } else {
                        var s = pt.getActiveUniformBlockName(e, t);
                        C[i >> 2] = s.length + 1;
                      }
                    else Zt.recordError(1281);
                  },
                  wc: (e, t, r, i, o) => {
                    if (o)
                      if (t > 0 && 0 == r) Zt.recordError(1281);
                      else {
                        e = Zt.programs[e];
                        for (var a = [], s = 0; s < t; s++)
                          a.push(C[(r + 4 * s) >> 2]);
                        var n = pt.getActiveUniforms(e, a, i);
                        if (n) {
                          var l = n.length;
                          for (s = 0; s < l; s++) C[(o + 4 * s) >> 2] = n[s];
                        }
                      }
                    else Zt.recordError(1281);
                  },
                  yf: (e, t, r, i) => {
                    var o = pt.getAttachedShaders(Zt.programs[e]),
                      a = o.length;
                    a > t && (a = t), (C[r >> 2] = a);
                    for (var s = 0; s < a; ++s) {
                      var n = Zt.shaders.indexOf(o[s]);
                      C[(i + 4 * s) >> 2] = n;
                    }
                  },
                  xf: (e, t) => pt.getAttribLocation(Zt.programs[e], Se(t)),
                  wf: (e, t) => Vo(e, t, 4),
                  hc: (e, t, r) => {
                    r
                      ? ko(r, pt.getBufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  vf: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getBufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  uf: () => {
                    var e = pt.getError() || Zt.lastError;
                    return (Zt.lastError = 0), e;
                  },
                  tf: (e, t) => Vo(e, t, 2),
                  Mc: (e, t) => pt.getFragDataLocation(Zt.programs[e], Se(t)),
                  sf: (e, t, r, i) => {
                    var o = pt.getFramebufferAttachmentParameter(e, t, r);
                    (o instanceof WebGLRenderbuffer ||
                      o instanceof WebGLTexture) &&
                      (o = 0 | o.name),
                      (C[i >> 2] = o);
                  },
                  ic: (e, t, r) => No(e, t, r, 1),
                  kc: (e, t) => {
                    Vo(e, t, 1);
                  },
                  ad: (e, t, r) => No(e, t, r, 0),
                  rf: Fo,
                  Ib: (e, t, r, i, o) => {
                    if (i < 0) Zt.recordError(1281);
                    else if (o) {
                      var a = pt.getInternalformatParameter(e, t, r);
                      if (null !== a)
                        for (var s = 0; s < a.length && s < i; ++s)
                          C[(o + 4 * s) >> 2] = a[s];
                    } else Zt.recordError(1281);
                  },
                  Pb: (e, t, r, i, o) => {
                    Zt.recordError(1282);
                  },
                  pf: Yo,
                  qf: jo,
                  Og: Go,
                  Qg: Uo,
                  Ng: $o,
                  rd: (e, t, r) => {
                    if (r) {
                      var i,
                        o = Zt.queries[e],
                        a = pt.getQueryParameter(o, t);
                      (i = "boolean" == typeof a ? (a ? 1 : 0) : a),
                        (C[r >> 2] = i);
                    } else Zt.recordError(1281);
                  },
                  Pg: Zo,
                  sd: (e, t, r) => {
                    r ? (C[r >> 2] = pt.getQuery(e, t)) : Zt.recordError(1281);
                  },
                  Rg: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.disjointTimerQueryExt.getQueryEXT(e, t))
                      : Zt.recordError(1281);
                  },
                  of: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getRenderbufferParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  Xb: (e, t, r) => {
                    r
                      ? (x[r >> 2] = pt.getSamplerParameter(Zt.samplers[e], t))
                      : Zt.recordError(1281);
                  },
                  Yb: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getSamplerParameter(Zt.samplers[e], t))
                      : Zt.recordError(1281);
                  },
                  mf: Ko,
                  lf: (e, t, r, i) => {
                    var o = pt.getShaderPrecisionFormat(e, t);
                    (C[r >> 2] = o.rangeMin),
                      (C[(r + 4) >> 2] = o.rangeMax),
                      (C[i >> 2] = o.precision);
                  },
                  kf: (e, t, r, i) => {
                    var o = pt.getShaderSource(Zt.shaders[e]);
                    if (o) {
                      var a = t > 0 && i ? xt(o, i, t) : 0;
                      r && (C[r >> 2] = a);
                    }
                  },
                  nf: Qo,
                  jf: ta,
                  zc: (e, t) => {
                    if (Zt.currentContext.version < 2)
                      return Zt.recordError(1282), 0;
                    var r = Zt.stringiCache[e];
                    if (r)
                      return t < 0 || t >= r.length
                        ? (Zt.recordError(1281), 0)
                        : r[t];
                    if (7939 === e) {
                      var i = _o().map(qt);
                      return (
                        (r = Zt.stringiCache[e] = i),
                        t < 0 || t >= r.length
                          ? (Zt.recordError(1281), 0)
                          : r[t]
                      );
                    }
                    return Zt.recordError(1280), 0;
                  },
                  jc: (e, t, r, i, o) => {
                    if (r < 0) Zt.recordError(1281);
                    else if (o) {
                      var a = pt.getSyncParameter(Zt.syncs[e], t);
                      null !== a && ((C[o >> 2] = a), i && (C[i >> 2] = 1));
                    } else Zt.recordError(1281);
                  },
                  hf: (e, t, r) => {
                    r
                      ? (x[r >> 2] = pt.getTexParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  gf: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getTexParameter(e, t))
                      : Zt.recordError(1281);
                  },
                  Wc: (e, t, r, i, o, a, s) => {
                    e = Zt.programs[e];
                    var n = pt.getTransformFeedbackVarying(e, t);
                    if (n) {
                      if (s && r > 0) {
                        var l = xt(n.name, s, r);
                        i && (C[i >> 2] = l);
                      } else i && (C[i >> 2] = 0);
                      o && (C[o >> 2] = n.size), a && (C[a >> 2] = n.type);
                    }
                  },
                  vc: (e, t) => pt.getUniformBlockIndex(Zt.programs[e], Se(t)),
                  xc: (e, t, r, i) => {
                    if (i)
                      if (t > 0 && (0 == r || 0 == i)) Zt.recordError(1281);
                      else {
                        e = Zt.programs[e];
                        for (var o = [], a = 0; a < t; a++)
                          o.push(Se(C[(r + 4 * a) >> 2]));
                        var s = pt.getUniformIndices(e, o);
                        if (s) {
                          var n = s.length;
                          for (a = 0; a < n; a++) C[(i + 4 * a) >> 2] = s[a];
                        }
                      }
                    else Zt.recordError(1281);
                  },
                  df: aa,
                  ff: (e, t, r) => {
                    na(e, t, r, 2);
                  },
                  ef: (e, t, r) => {
                    na(e, t, r, 0);
                  },
                  Nc: (e, t, r) => na(e, t, r, 0),
                  Tc: ha,
                  Sc: ua,
                  af: (e, t, r) => {
                    r
                      ? (C[r >> 2] = pt.getVertexAttribOffset(e, t))
                      : Zt.recordError(1281);
                  },
                  cf: (e, t, r) => {
                    la(e, t, r, 2);
                  },
                  bf: (e, t, r) => {
                    la(e, t, r, 5);
                  },
                  $e: (e, t) => pt.hint(e, t),
                  Mb: (e, t, r) => {
                    for (var i = ji[t], o = 0; o < t; o++)
                      i[o] = C[(r + 4 * o) >> 2];
                    pt.invalidateFramebuffer(e, i);
                  },
                  Lb: (e, t, r, i, o, a, s) => {
                    for (var n = ji[t], l = 0; l < t; l++)
                      n[l] = C[(r + 4 * l) >> 2];
                    pt.invalidateSubFramebuffer(e, n, i, o, a, s);
                  },
                  _e: (e) => {
                    var t = Zt.buffers[e];
                    return t ? pt.isBuffer(t) : 0;
                  },
                  Ze: (e) => pt.isEnabled(e),
                  Ye: (e) => {
                    var t = Zt.framebuffers[e];
                    return t ? pt.isFramebuffer(t) : 0;
                  },
                  Xe: (e) => ((e = Zt.programs[e]) ? pt.isProgram(e) : 0),
                  vd: (e) => {
                    var t = Zt.queries[e];
                    return t ? pt.isQuery(t) : 0;
                  },
                  Wg: (e) => {
                    var t = Zt.queries[e];
                    return t ? pt.disjointTimerQueryExt.isQueryEXT(t) : 0;
                  },
                  Ve: (e) => {
                    var t = Zt.renderbuffers[e];
                    return t ? pt.isRenderbuffer(t) : 0;
                  },
                  cc: (e) => {
                    var t = Zt.samplers[e];
                    return t ? pt.isSampler(t) : 0;
                  },
                  Ue: (e) => {
                    var t = Zt.shaders[e];
                    return t ? pt.isShader(t) : 0;
                  },
                  oc: (e) => pt.isSync(Zt.syncs[e]),
                  Te: (e) => {
                    var t = Zt.textures[e];
                    return t ? pt.isTexture(t) : 0;
                  },
                  Sb: (e) => pt.isTransformFeedback(Zt.transformFeedbacks[e]),
                  bd: pa,
                  Ig: ga,
                  Se: fa,
                  Re: ma,
                  Rb: () => pt.pauseTransformFeedback(),
                  Qe: Pa,
                  Ld: (e, t) => {
                    pt.webglPolygonMode.polygonModeWEBGL(e, t);
                  },
                  Pe: (e, t) => pt.polygonOffset(e, t),
                  Nd: (e, t, r) => {
                    pt.extPolygonOffsetClamp.polygonOffsetClampEXT(e, t, r);
                  },
                  Ob: (e, t, r, i) => {
                    Zt.recordError(1280);
                  },
                  Nb: (e, t, r) => {
                    Zt.recordError(1280);
                  },
                  Sg: (e, t) => {
                    pt.disjointTimerQueryExt.queryCounterEXT(Zt.queries[e], t);
                  },
                  Fd: (e) => pt.readBuffer(e),
                  Oe: Ta,
                  Ne: () => {},
                  Me: (e, t, r, i) => pt.renderbufferStorage(e, t, r, i),
                  hd: (e, t, r, i, o) =>
                    pt.renderbufferStorageMultisample(e, t, r, i, o),
                  Qb: () => pt.resumeTransformFeedback(),
                  Ke: (e, t) => {
                    pt.sampleCoverage(e, !!t);
                  },
                  _b: (e, t, r) => {
                    pt.samplerParameterf(Zt.samplers[e], t, r);
                  },
                  Zb: (e, t, r) => {
                    var i = x[r >> 2];
                    pt.samplerParameterf(Zt.samplers[e], t, i);
                  },
                  ac: (e, t, r) => {
                    pt.samplerParameteri(Zt.samplers[e], t, r);
                  },
                  $b: (e, t, r) => {
                    var i = C[r >> 2];
                    pt.samplerParameteri(Zt.samplers[e], t, i);
                  },
                  Je: Ra,
                  Ie: (e, t, r, i, o) => {
                    Zt.recordError(1280);
                  },
                  He: wa,
                  Ge: (e, t, r) => pt.stencilFunc(e, t, r),
                  Fe: (e, t, r, i) => pt.stencilFuncSeparate(e, t, r, i),
                  Ee: (e) => pt.stencilMask(e),
                  De: (e, t) => pt.stencilMaskSeparate(e, t),
                  Ce: (e, t, r) => pt.stencilOp(e, t, r),
                  Be: (e, t, r, i) => pt.stencilOpSeparate(e, t, r, i),
                  ze: La,
                  Dd: (e, t, r, i, o, a, s, n, l, d) => {
                    if (pt.currentPixelUnpackBufferBinding)
                      pt.texImage3D(e, t, r, i, o, a, s, n, l, d);
                    else if (d) {
                      var h = Ca(l);
                      pt.texImage3D(e, t, r, i, o, a, s, n, l, h, ba(d, h));
                    } else pt.texImage3D(e, t, r, i, o, a, s, n, l, null);
                  },
                  ye: (e, t, r) => pt.texParameterf(e, t, r),
                  xe: (e, t, r) => {
                    var i = x[r >> 2];
                    pt.texParameterf(e, t, i);
                  },
                  we: Ia,
                  ve: (e, t, r) => {
                    var i = C[r >> 2];
                    pt.texParameteri(e, t, i);
                  },
                  Kb: (e, t, r, i, o) => pt.texStorage2D(e, t, r, i, o),
                  Jb: (e, t, r, i, o, a) => pt.texStorage3D(e, t, r, i, o, a),
                  ue: (e, t, r, i, o, a, s, n, l) => {
                    if (Zt.currentContext.version >= 2) {
                      if (pt.currentPixelUnpackBufferBinding)
                        return void pt.texSubImage2D(e, t, r, i, o, a, s, n, l);
                      if (l) {
                        var d = Ca(n);
                        return void pt.texSubImage2D(
                          e,
                          t,
                          r,
                          i,
                          o,
                          a,
                          s,
                          n,
                          d,
                          ba(l, d)
                        );
                      }
                    }
                    var h = l ? xa(n, s, o, a, l) : null;
                    pt.texSubImage2D(e, t, r, i, o, a, s, n, h);
                  },
                  Cd: (e, t, r, i, o, a, s, n, l, d, h) => {
                    if (pt.currentPixelUnpackBufferBinding)
                      pt.texSubImage3D(e, t, r, i, o, a, s, n, l, d, h);
                    else if (h) {
                      var u = Ca(d);
                      pt.texSubImage3D(
                        e,
                        t,
                        r,
                        i,
                        o,
                        a,
                        s,
                        n,
                        l,
                        d,
                        u,
                        ba(h, u)
                      );
                    } else pt.texSubImage3D(e, t, r, i, o, a, s, n, l, d, null);
                  },
                  Xc: (e, t, r, i) => {
                    e = Zt.programs[e];
                    for (var o = [], a = 0; a < t; a++)
                      o.push(Se(C[(r + 4 * a) >> 2]));
                    pt.transformFeedbackVaryings(e, o, i);
                  },
                  te: (e, t) => {
                    pt.uniform1f(sa(e), t);
                  },
                  se: Va,
                  re: Ba,
                  qe: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform1iv(sa(e), C, r >> 2, t);
                    else {
                      if (t <= 288)
                        for (var i = Fa[t], o = 0; o < t; ++o)
                          i[o] = C[(r + 4 * o) >> 2];
                      else i = C.subarray(r >> 2, (r + 4 * t) >> 2);
                      pt.uniform1iv(sa(e), i);
                    }
                  },
                  Lc: (e, t) => {
                    pt.uniform1ui(sa(e), t);
                  },
                  Hc: (e, t, r) => {
                    t && pt.uniform1uiv(sa(e), b, r >> 2, t);
                  },
                  oe: (e, t, r) => {
                    pt.uniform2f(sa(e), t, r);
                  },
                  ne: Ya,
                  me: (e, t, r) => {
                    pt.uniform2i(sa(e), t, r);
                  },
                  le: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform2iv(sa(e), C, r >> 2, 2 * t);
                    else {
                      if (t <= 144)
                        for (var i = Fa[(t *= 2)], o = 0; o < t; o += 2)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 8 * t) >> 2);
                      pt.uniform2iv(sa(e), i);
                    }
                  },
                  Kc: (e, t, r) => {
                    pt.uniform2ui(sa(e), t, r);
                  },
                  Gc: (e, t, r) => {
                    t && pt.uniform2uiv(sa(e), b, r >> 2, 2 * t);
                  },
                  ke: (e, t, r, i) => {
                    pt.uniform3f(sa(e), t, r, i);
                  },
                  je: ja,
                  ie: (e, t, r, i) => {
                    pt.uniform3i(sa(e), t, r, i);
                  },
                  he: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform3iv(sa(e), C, r >> 2, 3 * t);
                    else {
                      if (t <= 96)
                        for (var i = Fa[(t *= 3)], o = 0; o < t; o += 3)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]),
                            (i[o + 2] = C[(r + (4 * o + 8)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 12 * t) >> 2);
                      pt.uniform3iv(sa(e), i);
                    }
                  },
                  Jc: (e, t, r, i) => {
                    pt.uniform3ui(sa(e), t, r, i);
                  },
                  Fc: (e, t, r) => {
                    t && pt.uniform3uiv(sa(e), b, r >> 2, 3 * t);
                  },
                  ge: (e, t, r, i, o) => {
                    pt.uniform4f(sa(e), t, r, i, o);
                  },
                  fe: Ga,
                  de: (e, t, r, i, o) => {
                    pt.uniform4i(sa(e), t, r, i, o);
                  },
                  ce: (e, t, r) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniform4iv(sa(e), C, r >> 2, 4 * t);
                    else {
                      if (t <= 72)
                        for (var i = Fa[(t *= 4)], o = 0; o < t; o += 4)
                          (i[o] = C[(r + 4 * o) >> 2]),
                            (i[o + 1] = C[(r + (4 * o + 4)) >> 2]),
                            (i[o + 2] = C[(r + (4 * o + 8)) >> 2]),
                            (i[o + 3] = C[(r + (4 * o + 12)) >> 2]);
                      else i = C.subarray(r >> 2, (r + 16 * t) >> 2);
                      pt.uniform4iv(sa(e), i);
                    }
                  },
                  Ic: (e, t, r, i, o) => {
                    pt.uniform4ui(sa(e), t, r, i, o);
                  },
                  Ec: (e, t, r) => {
                    t && pt.uniform4uiv(sa(e), b, r >> 2, 4 * t);
                  },
                  sc: (e, t, r) => {
                    (e = Zt.programs[e]), pt.uniformBlockBinding(e, t, r);
                  },
                  be: (e, t, r, i) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniformMatrix2fv(sa(e), !!r, x, i >> 2, 4 * t);
                    else {
                      if (t <= 72)
                        for (var o = ka[(t *= 4)], a = 0; a < t; a += 4)
                          (o[a] = x[(i + 4 * a) >> 2]),
                            (o[a + 1] = x[(i + (4 * a + 4)) >> 2]),
                            (o[a + 2] = x[(i + (4 * a + 8)) >> 2]),
                            (o[a + 3] = x[(i + (4 * a + 12)) >> 2]);
                      else o = x.subarray(i >> 2, (i + 16 * t) >> 2);
                      pt.uniformMatrix2fv(sa(e), !!r, o);
                    }
                  },
                  pd: (e, t, r, i) => {
                    t && pt.uniformMatrix2x3fv(sa(e), !!r, x, i >> 2, 6 * t);
                  },
                  md: (e, t, r, i) => {
                    t && pt.uniformMatrix2x4fv(sa(e), !!r, x, i >> 2, 8 * t);
                  },
                  ae: (e, t, r, i) => {
                    if (Zt.currentContext.version >= 2)
                      t && pt.uniformMatrix3fv(sa(e), !!r, x, i >> 2, 9 * t);
                    else {
                      if (t <= 32)
                        for (var o = ka[(t *= 9)], a = 0; a < t; a += 9)
                          (o[a] = x[(i + 4 * a) >> 2]),
                            (o[a + 1] = x[(i + (4 * a + 4)) >> 2]),
                            (o[a + 2] = x[(i + (4 * a + 8)) >> 2]),
                            (o[a + 3] = x[(i + (4 * a + 12)) >> 2]),
                            (o[a + 4] = x[(i + (4 * a + 16)) >> 2]),
                            (o[a + 5] = x[(i + (4 * a + 20)) >> 2]),
                            (o[a + 6] = x[(i + (4 * a + 24)) >> 2]),
                            (o[a + 7] = x[(i + (4 * a + 28)) >> 2]),
                            (o[a + 8] = x[(i + (4 * a + 32)) >> 2]);
                      else o = x.subarray(i >> 2, (i + 36 * t) >> 2);
                      pt.uniformMatrix3fv(sa(e), !!r, o);
                    }
                  },
                  nd: (e, t, r, i) => {
                    t && pt.uniformMatrix3x2fv(sa(e), !!r, x, i >> 2, 6 * t);
                  },
                  kd: (e, t, r, i) => {
                    t && pt.uniformMatrix3x4fv(sa(e), !!r, x, i >> 2, 12 * t);
                  },
                  $d: Ua,
                  ld: (e, t, r, i) => {
                    t && pt.uniformMatrix4x2fv(sa(e), !!r, x, i >> 2, 8 * t);
                  },
                  jd: (e, t, r, i) => {
                    t && pt.uniformMatrix4x3fv(sa(e), !!r, x, i >> 2, 12 * t);
                  },
                  _d: Za,
                  Zd: (e) => {
                    pt.validateProgram(Zt.programs[e]);
                  },
                  Yd: (e, t) => pt.vertexAttrib1f(e, t),
                  Xd: (e, t) => {
                    pt.vertexAttrib1f(e, x[t >> 2]);
                  },
                  Wd: (e, t, r) => pt.vertexAttrib2f(e, t, r),
                  Ud: (e, t) => {
                    pt.vertexAttrib2f(e, x[t >> 2], x[(t + 4) >> 2]);
                  },
                  Td: (e, t, r, i) => pt.vertexAttrib3f(e, t, r, i),
                  Sd: (e, t) => {
                    pt.vertexAttrib3f(
                      e,
                      x[t >> 2],
                      x[(t + 4) >> 2],
                      x[(t + 8) >> 2]
                    );
                  },
                  Rd: (e, t, r, i, o) => pt.vertexAttrib4f(e, t, r, i, o),
                  Qd: (e, t) => {
                    pt.vertexAttrib4f(
                      e,
                      x[t >> 2],
                      x[(t + 4) >> 2],
                      x[(t + 8) >> 2],
                      x[(t + 12) >> 2]
                    );
                  },
                  Wb: Ka,
                  Eg: Ja,
                  Gb: Qa,
                  Jd: es,
                  Hb: ts,
                  Rc: (e, t, r, i, o) => pt.vertexAttribI4i(e, t, r, i, o),
                  Pc: (e, t) => {
                    pt.vertexAttribI4i(
                      e,
                      C[t >> 2],
                      C[(t + 4) >> 2],
                      C[(t + 8) >> 2],
                      C[(t + 12) >> 2]
                    );
                  },
                  Qc: (e, t, r, i, o) => pt.vertexAttribI4ui(e, t, r, i, o),
                  Oc: (e, t) => {
                    pt.vertexAttribI4ui(
                      e,
                      b[t >> 2],
                      b[(t + 4) >> 2],
                      b[(t + 8) >> 2],
                      b[(t + 12) >> 2]
                    );
                  },
                  Vc: (e, t, r, i, o) => {
                    pt.vertexAttribIPointer(e, t, r, i, o);
                  },
                  Pd: is,
                  Od: as,
                  lc: (e, t, r, i) => {
                    var o = $r(r, i);
                    pt.waitSync(Zt.syncs[e], t, o);
                  },
                  P: () => 0,
                  fc: () => !0,
                  _g: (e, t, r) =>
                    ((e, t) =>
                      ir.fullscreenEnabled()
                        ? (e = sr(e))
                          ? e.requestFullscreen || e.webkitRequestFullscreen
                            ? ir.canPerformEventHandlerRequests()
                              ? yr(e, t)
                              : t.deferUntilInEventHandler
                              ? (ir.deferCall(yr, 1, [e, t]), 1)
                              : -2
                            : -3
                          : -4
                        : -1)(e, {
                      scaleMode: C[r >> 2],
                      canvasResolutionScaleMode: C[(r + 4) >> 2],
                      filteringMode: C[(r + 8) >> 2],
                      deferUntilInEventHandler: t,
                      canvasResizedCallback: C[(r + 12) >> 2],
                      canvasResizedCallbackUserData: C[(r + 16) >> 2],
                    }),
                  Aa: (e, t) =>
                    (e = sr(e))
                      ? e.requestPointerLock
                        ? ir.canPerformEventHandlerRequests()
                          ? fr(e)
                          : t
                          ? (ir.deferCall(fr, 2, [e]), 1)
                          : -2
                        : -1
                      : -4,
                  pb: (e) => {
                    var t,
                      r = m.length,
                      i = 2147483648;
                    if ((e >>>= 0) > i) return !1;
                    for (var o = 1; o <= 4; o *= 2) {
                      var a = r * (1 + 0.2 / o);
                      a = Math.min(a, e + 100663296);
                      var s = Math.min(
                        i,
                        ((t = Math.max(e, a)),
                        65536,
                        65536 * Math.ceil(t / 65536))
                      );
                      if (ss(s)) return !0;
                    }
                    return !1;
                  },
                  Fa: ns,
                  ga: (e, t, r) =>
                    "undefined" == typeof onbeforeunload
                      ? -1
                      : 1 !== r
                      ? -5
                      : ((e, t, r, i, o, a) => {
                          var s = {
                            target: sr(2),
                            eventTypeString: "beforeunload",
                            callbackfunc: i,
                            handlerFunc: (e = event) => {
                              var r = nt(i)(28, 0, t);
                              if ((r && (r = Se(r)), r))
                                return (
                                  e.preventDefault(), (e.returnValue = r), r
                                );
                            },
                            useCapture: !0,
                          };
                          return ir.registerOrRemoveHandler(s);
                        })(0, e, 0, t),
                  sa: (e, t, r, i, o) => ls(e, t, r, i, 12, "blur"),
                  y: ur,
                  N: (e, t, r) =>
                    (e = sr(e))
                      ? ((e.style.width = t + "px"),
                        (e.style.height = r + "px"),
                        0)
                      : -4,
                  ta: (e, t, r, i, o) => ls(e, t, r, i, 13, "focus"),
                  ja: (e, t, r, i, o) =>
                    ir.fullscreenEnabled()
                      ? (e = sr(e))
                        ? (ds(e, t, r, i, 19, "webkitfullscreenchange"),
                          ds(e, t, r, i, 19, "fullscreenchange"))
                        : -4
                      : -1,
                  Da: (e, t, r, i) =>
                    ns() ? -1 : hs(2, e, t, r, 26, "gamepadconnected"),
                  Ca: (e, t, r, i) =>
                    ns() ? -1 : hs(2, e, t, r, 27, "gamepaddisconnected"),
                  ma: (e, t, r, i, o) => us(e, t, r, i, 2, "keydown"),
                  ka: (e, t, r, i, o) => us(e, t, r, i, 1, "keypress"),
                  la: (e, t, r, i, o) => us(e, t, r, i, 3, "keyup"),
                  Ka: (e, t, r) => {
                    var i = nt(e);
                    Kt(i, t, r);
                  },
                  ya: (e, t, r, i, o) => ps(e, t, r, i, 5, "mousedown"),
                  wa: (e, t, r, i, o) => ps(e, t, r, i, 33, "mouseenter"),
                  va: (e, t, r, i, o) => ps(e, t, r, i, 34, "mouseleave"),
                  za: (e, t, r, i, o) => ps(e, t, r, i, 8, "mousemove"),
                  xa: (e, t, r, i, o) => ps(e, t, r, i, 6, "mouseup"),
                  na: (e, t, r, i, o) =>
                    document &&
                    document.body &&
                    (document.body.requestPointerLock ||
                      document.body.mozRequestPointerLock ||
                      document.body.webkitRequestPointerLock ||
                      document.body.msRequestPointerLock)
                      ? (e = sr(e))
                        ? (gs(e, t, r, i, 20, "mozpointerlockchange"),
                          gs(e, t, r, i, 20, "webkitpointerlockchange"),
                          gs(e, t, r, i, 20, "mspointerlockchange"),
                          gs(e, t, r, i, 20, "pointerlockchange"))
                        : -4
                      : -1,
                  ia: (e, t, r, i, o) =>
                    ((e, t, r, i, o, a, s) => {
                      ir.uiEvent ||= Os(36);
                      var n = {
                        target: (e = sr(e)),
                        eventTypeString: "resize",
                        callbackfunc: i,
                        handlerFunc: (r = event) => {
                          if (r.target == e) {
                            var o = document.body;
                            if (o) {
                              var a = ir.uiEvent;
                              (C[a >> 2] = 0),
                                (C[(a + 4) >> 2] = o.clientWidth),
                                (C[(a + 8) >> 2] = o.clientHeight),
                                (C[(a + 12) >> 2] = innerWidth),
                                (C[(a + 16) >> 2] = innerHeight),
                                (C[(a + 20) >> 2] = outerWidth),
                                (C[(a + 24) >> 2] = outerHeight),
                                (C[(a + 28) >> 2] = 0 | pageXOffset),
                                (C[(a + 32) >> 2] = 0 | pageYOffset),
                                nt(i)(10, a, t) && r.preventDefault();
                            }
                          }
                        },
                        useCapture: r,
                      };
                      return ir.registerOrRemoveHandler(n);
                    })(e, t, r, i),
                  oa: (e, t, r, i, o) => ys(e, t, r, i, 25, "touchcancel"),
                  qa: (e, t, r, i, o) => ys(e, t, r, i, 23, "touchend"),
                  pa: (e, t, r, i, o) => ys(e, t, r, i, 24, "touchmove"),
                  ra: (e, t, r, i, o) => ys(e, t, r, i, 22, "touchstart"),
                  ha: (e, t, r, i) =>
                    ((e, t, r, i, o, a, s) => {
                      ir.visibilityChangeEvent ||= Os(8);
                      var n = {
                        target: e,
                        eventTypeString: a,
                        callbackfunc: i,
                        handlerFunc: (e = event) => {
                          var r,
                            a,
                            s = ir.visibilityChangeEvent;
                          (r = s),
                            (a = [
                              "hidden",
                              "visible",
                              "prerender",
                              "unloaded",
                            ].indexOf(document.visibilityState)),
                            (v[r] = document.hidden),
                            (C[(r + 4) >> 2] = a),
                            nt(i)(o, s, t) && e.preventDefault();
                        },
                        useCapture: r,
                      };
                      return ir.registerOrRemoveHandler(n);
                    })(ar[1], e, t, r, 21, "visibilitychange"),
                  ua: (e, t, r, i, o) =>
                    (e = sr(e))
                      ? void 0 !== e.onwheel
                        ? ((e, t, r, i, o, a, s) => {
                            ir.wheelEvent ||= Os(96);
                            var n = {
                              target: e,
                              allowsDeferredCalls: !0,
                              eventTypeString: "wheel",
                              callbackfunc: i,
                              handlerFunc: (r = event) => {
                                var o = ir.wheelEvent;
                                cs(o, r, e),
                                  (A[(o + 64) >> 3] = r.deltaX),
                                  (A[(o + 72) >> 3] = r.deltaY),
                                  (A[(o + 80) >> 3] = r.deltaZ),
                                  (C[(o + 88) >> 2] = r.deltaMode),
                                  nt(i)(9, o, t) && r.preventDefault();
                              },
                              useCapture: r,
                            };
                            return ir.registerOrRemoveHandler(n);
                          })(e, t, r, i)
                        : -1
                      : -4,
                  $g: (e) => (document.title = Se(e)),
                  O: () => {
                    throw "Please compile your program with async support in order to use asynchronous operations like emscripten_sleep";
                  },
                  eb: function (e, t, r, i, o) {
                    var a = e + 108,
                      s = b[(a + 36) >> 2],
                      n = b[(a + 40) >> 2],
                      l = b[(a + 44) >> 2],
                      d = b[(a + 48) >> 2],
                      h = b[(a + 52) >> 2],
                      u = !!(64 & h);
                    function c(e) {
                      u ? e() : Xt(e);
                    }
                    var p = (e, r, i) => {
                        c(() => {
                          s ? nt(s)(e) : t?.(e);
                        });
                      },
                      g = (e, t, r) => {
                        c(() => {
                          l ? nt(l)(e) : i?.(e);
                        });
                      },
                      y = (e, t, i) => {
                        c(() => {
                          n ? nt(n)(e) : r?.(e);
                        });
                      },
                      f = (e, t, r) => {
                        c(() => {
                          d ? nt(d)(e) : o?.(e);
                        });
                      },
                      v = (e, r, i) => {
                        Ss(
                          vs.dbInstance,
                          e,
                          r.response,
                          (e, r, i) => {
                            c(() => {
                              s ? nt(s)(e) : t?.(e);
                            });
                          },
                          (e, r, i) => {
                            c(() => {
                              s ? nt(s)(e) : t?.(e);
                            });
                          }
                        );
                      },
                      P = Se(a + 0),
                      C = !!(16 & h),
                      x = !!(4 & h),
                      A = !!(32 & h);
                    if ("EM_IDB_STORE" === P) {
                      var T = b[(a + 84) >> 2],
                        E = b[(a + 88) >> 2];
                      Ss(vs.dbInstance, e, m.slice(T, T + E), p, y);
                    } else if ("EM_IDB_DELETE" === P)
                      !(function (e, t, r, i) {
                        if (e) {
                          var o = b[(t + 108 + 64) >> 2];
                          o ||= b[(t + 8) >> 2];
                          var a = Se(o);
                          try {
                            var s = e
                              .transaction(["FILES"], "readwrite")
                              .objectStore("FILES")
                              .delete(a);
                            (s.onsuccess = (e) => {
                              var i = e.target.result;
                              (b[(t + 12) >> 2] = 0),
                                ko(t + 16, 0),
                                ko(t + 24, 0),
                                ko(t + 32, 0),
                                (S[(t + 40) >> 1] = 4),
                                (S[(t + 42) >> 1] = 200),
                                xt("OK", t + 44, 64),
                                r(t, 0, i);
                            }),
                              (s.onerror = (e) => {
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, e);
                              });
                          } catch (e) {
                            i(t, 0, e);
                          }
                        } else i(t, 0, "IndexedDB not available!");
                      })(vs.dbInstance, e, p, y);
                    else if (C) {
                      if (A) return 0;
                      ms(e, x ? v : p, y, g, f);
                    } else
                      !(function (e, t, r, i) {
                        if (e) {
                          var o = b[(t + 108 + 64) >> 2];
                          o ||= b[(t + 8) >> 2];
                          var a = Se(o);
                          try {
                            var s = e
                              .transaction(["FILES"], "readonly")
                              .objectStore("FILES")
                              .get(a);
                            (s.onsuccess = (e) => {
                              if (e.target.result) {
                                var o = e.target.result,
                                  a = o.byteLength || o.length,
                                  s = Os(a);
                                m.set(new Uint8Array(o), s),
                                  (b[(t + 12) >> 2] = s),
                                  ko(t + 16, a),
                                  ko(t + 24, 0),
                                  ko(t + 32, a),
                                  (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 200),
                                  xt("OK", t + 44, 64),
                                  r(t, 0, o);
                              } else
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, "no data");
                            }),
                              (s.onerror = (e) => {
                                (S[(t + 40) >> 1] = 4),
                                  (S[(t + 42) >> 1] = 404),
                                  xt("Not Found", t + 44, 64),
                                  i(t, 0, e);
                              });
                          } catch (e) {
                            i(t, 0, e);
                          }
                        } else i(t, 0, "IndexedDB not available!");
                      })(
                        vs.dbInstance,
                        e,
                        p,
                        A
                          ? y
                          : x
                          ? (e, t, r) => {
                              ms(e, v, y, g, f);
                            }
                          : (e, t, r) => {
                              ms(e, p, y, g, f);
                            }
                      );
                    return e;
                  },
                  rb: (e, t) => {
                    var r = 0;
                    return (
                      Cs().forEach((i, o) => {
                        var a = t + r;
                        (b[(e + 4 * o) >> 2] = a),
                          ((e, t) => {
                            for (var r = 0; r < e.length; ++r)
                              v[t++] = e.charCodeAt(r);
                            v[t] = 0;
                          })(i, a),
                          (r += i.length + 1);
                      }),
                      0
                    );
                  },
                  sb: (e, t) => {
                    var r = Cs();
                    b[e >> 2] = r.length;
                    var i = 0;
                    return (
                      r.forEach((e) => (i += e.length + 1)), (b[t >> 2] = i), 0
                    );
                  },
                  aa: function (e) {
                    try {
                      var t = Pe.getStreamFromFD(e);
                      return me.close(t), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  xb: function (e, t, r, i) {
                    try {
                      var o = ((e, t, r, i) => {
                        for (var o = 0, a = 0; a < r; a++) {
                          var s = b[t >> 2],
                            n = b[(t + 4) >> 2];
                          t += 8;
                          var l = me.read(e, v, s, n, i);
                          if (l < 0) return -1;
                          if (((o += l), l < n)) break;
                          void 0 !== i && (i += l);
                        }
                        return o;
                      })(Pe.getStreamFromFD(e), t, r);
                      return (b[i >> 2] = o), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  kb: function (e, t, r, i, o) {
                    var a = Vt(t, r);
                    try {
                      if (isNaN(a)) return 61;
                      var s = Pe.getStreamFromFD(e);
                      return (
                        me.llseek(s, a, i),
                        (F = [
                          s.position >>> 0,
                          ((B = s.position),
                          +Math.abs(B) >= 1
                            ? B > 0
                              ? +Math.floor(B / 4294967296) >>> 0
                              : ~~+Math.ceil(
                                  (B - +(~~B >>> 0)) / 4294967296
                                ) >>> 0
                            : 0),
                        ]),
                        (C[o >> 2] = F[0]),
                        (C[(o + 4) >> 2] = F[1]),
                        s.getdents && 0 === a && 0 === i && (s.getdents = null),
                        0
                      );
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  Z: function (e, t, r, i) {
                    try {
                      var o = ((e, t, r, i) => {
                        for (var o = 0, a = 0; a < r; a++) {
                          var s = b[t >> 2],
                            n = b[(t + 4) >> 2];
                          t += 8;
                          var l = me.write(e, v, s, n, i);
                          if (l < 0) return -1;
                          if (((o += l), l < n)) break;
                          void 0 !== i && (i += l);
                        }
                        return o;
                      })(Pe.getStreamFromFD(e), t, r);
                      return (b[i >> 2] = o), 0;
                    } catch (e) {
                      if (void 0 === me || "ErrnoError" !== e.name) throw e;
                      return e.errno;
                    }
                  },
                  Qa: function () {
                    var e = "";
                    "undefined" != typeof window
                      ? (e = window.location.hostname)
                      : "undefined" != typeof process && (e = "node");
                    var t = oe(e) + 1,
                      r = Os(t);
                    return xt(e, r, t), r;
                  },
                  ab: mr,
                  ba: Pr,
                  l: br,
                  n: Ar,
                  s: Er,
                  r: Dr,
                  Kd: kr,
                  zd: Vr,
                  Vd: Br,
                  K: Hr,
                  S: zr,
                  Uf: Xr,
                  dg: Wr,
                  Uc: Zr,
                  Za: Kr,
                  G: Qr,
                  ec: ti,
                  $a: ii,
                  We: ai,
                  B: ni,
                  Jg: di,
                  da: ui,
                  fa: pi,
                  V: yi,
                  Wa: vi,
                  ee: xi,
                  pe: Ti,
                  ea: Ri,
                  E: wi,
                  R: Li,
                  J: qi,
                  Ra: Ji,
                  D: lo,
                  Ua: uo,
                  M: po,
                  Le: yo,
                  L: vo,
                  T: So,
                  H: Co,
                  Ug: Ro,
                  gb: Mo,
                  ib: Oo,
                  q: Bo,
                  lb: Ho,
                  C: zo,
                  Xa: qo,
                  U: Jo,
                  w: ea,
                  hb: oa,
                  Ae: ya,
                  Bb: va,
                  Va: Sa,
                  od: Aa,
                  dd: Ea,
                  _a: Da,
                  o: Ma,
                  h: Oa,
                  fb: _a,
                  bb: Na,
                  db: Ha,
                  cb: za,
                  X: Xa,
                  W: Wa,
                  ca: $a,
                  Sa: qa,
                  Ta: rs,
                  F: os,
                  th: function (e, t, r) {
                    var i = $();
                    try {
                      return nt(e)(t, r);
                    } catch (e) {
                      if ((U(i), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                  uh: function (e, t, r, i) {
                    var o = $();
                    try {
                      return nt(e)(t, r, i);
                    } catch (e) {
                      if ((U(o), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                  eg: function (e, t, r, i, o) {
                    var a = $();
                    try {
                      return nt(e)(t, r, i, o);
                    } catch (e) {
                      if ((U(a), e !== e + 0)) throw e;
                      _s(1, 0);
                    }
                  },
                };
              !(async function () {
                function e(e, t) {
                  var r;
                  return (
                    (Ds = e.exports),
                    (y = Ds.vh),
                    R(),
                    (ot = Ds.yh),
                    (r = Ds.wh),
                    w.unshift(r),
                    _(),
                    Ds
                  );
                }
                k();
                var t,
                  r,
                  o = { a: ws };
                if (s.instantiateWasm)
                  try {
                    return s.instantiateWasm(o, e);
                  } catch (e) {
                    g(
                      `Module.instantiateWasm callback failed with error: ${e}`
                    ),
                      i(e);
                  }
                N ??= H((r = "scichart3d.wasm"))
                  ? r
                  : ((t = r), s.locateFile ? s.locateFile(t, c) : c + t);
                try {
                  var a = await Y(T, N, o);
                  return (
                    (function (t) {
                      e(t.instance);
                    })(a),
                    a
                  );
                } catch (e) {
                  return void i(e);
                }
              })();
              var Ms,
                Ls = (e) => (Ls = Ds.xh)(e),
                Os = (s._malloc = (e) => (Os = s._malloc = Ds.zh)(e)),
                Is = (s._free = (e) => (Is = s._free = Ds.Ah)(e)),
                ks =
                  ((s._SCRTFillActiveTextureCharArray = (e, t, r) =>
                    (s._SCRTFillActiveTextureCharArray = Ds.Bh)(e, t, r)),
                  (s._main = (e, t) => (ks = s._main = Ds.Ch)(e, t))),
                _s = (s._setThrew = (e, t) => (_s = s._setThrew = Ds.Dh)(e, t)),
                Vs = (e) => (Vs = Ds.Eh)(e),
                Ns = (e) => (Ns = Ds.Fh)(e),
                Bs = () => (Bs = Ds.Gh)();
              function Fs(e = []) {
                var t = ks;
                e.unshift(h);
                var r = e.length,
                  i = lr(4 * (r + 1)),
                  o = i;
                e.forEach((e) => {
                  (b[o >> 2] = dr(e)), (o += 4);
                }),
                  (b[o >> 2] = 0);
                try {
                  var a = t(r, i);
                  return Yt(a, !0), a;
                } catch (e) {
                  return Ft(e);
                }
              }
              function Hs(e = d) {
                function t() {
                  Ms ||
                    ((Ms = !0),
                    (s.calledRun = !0),
                    E ||
                      (s.noFSInit || me.initialized || me.init(),
                      (me.ignorePermissions = !1),
                      ue.init(),
                      X(w),
                      X(M),
                      r(s),
                      s.onRuntimeInitialized?.(),
                      Ys && Fs(e),
                      (function () {
                        if (s.postRun)
                          for (
                            "function" == typeof s.postRun &&
                            (s.postRun = [s.postRun]);
                            s.postRun.length;

                          )
                            (e = s.postRun.shift()), L.unshift(e);
                        var e;
                        X(L);
                      })()));
                }
                O > 0 ||
                  ((function () {
                    if (s.preRun)
                      for (
                        "function" == typeof s.preRun &&
                        (s.preRun = [s.preRun]);
                        s.preRun.length;

                      )
                        (e = s.preRun.shift()), D.unshift(e);
                    var e;
                    X(D);
                  })(),
                  O > 0 ||
                    (s.setStatus
                      ? (s.setStatus("Running..."),
                        setTimeout(() => {
                          setTimeout(() => s.setStatus(""), 1), t();
                        }, 1))
                      : t()));
              }
              if (
                ((s.dynCall_iiiji = (e, t, r, i, o, a) =>
                  (s.dynCall_iiiji = Ds.Hh)(e, t, r, i, o, a)),
                (s.dynCall_iiij = (e, t, r, i, o) =>
                  (s.dynCall_iiij = Ds.Ih)(e, t, r, i, o)),
                (s.dynCall_iijii = (e, t, r, i, o, a) =>
                  (s.dynCall_iijii = Ds.Jh)(e, t, r, i, o, a)),
                (s.dynCall_iiijiji = (e, t, r, i, o, a, n, l, d) =>
                  (s.dynCall_iiijiji = Ds.Kh)(e, t, r, i, o, a, n, l, d)),
                (s.dynCall_vij = (e, t, r, i) =>
                  (s.dynCall_vij = Ds.Lh)(e, t, r, i)),
                (s.dynCall_jiji = (e, t, r, i, o) =>
                  (s.dynCall_jiji = Ds.Mh)(e, t, r, i, o)),
                (s.dynCall_ji = (e, t) => (s.dynCall_ji = Ds.Nh)(e, t)),
                (s.dynCall_viijii = (e, t, r, i, o, a, n) =>
                  (s.dynCall_viijii = Ds.Oh)(e, t, r, i, o, a, n)),
                (s.dynCall_iiiiij = (e, t, r, i, o, a, n) =>
                  (s.dynCall_iiiiij = Ds.Ph)(e, t, r, i, o, a, n)),
                (s.dynCall_iiiiijj = (e, t, r, i, o, a, n, l, d) =>
                  (s.dynCall_iiiiijj = Ds.Qh)(e, t, r, i, o, a, n, l, d)),
                (s.dynCall_iiiiiijj = (e, t, r, i, o, a, n, l, d, h) =>
                  (s.dynCall_iiiiiijj = Ds.Rh)(e, t, r, i, o, a, n, l, d, h)),
                (s.callMain = Fs),
                (s.ccall = As),
                (s.cwrap = (e, t, r, i) => {
                  var o =
                    !r || r.every((e) => "number" === e || "boolean" === e);
                  return "string" !== t && o && !i
                    ? xs(e)
                    : (...i) => As(e, t, r, i);
                }),
                (s.UTF8ToString = Se),
                (s.stringToUTF8 = xt),
                (s.lengthBytesUTF8 = oe),
                (I = function e() {
                  Ms || Hs(), Ms || (I = e);
                }),
                s.preInit)
              )
                for (
                  "function" == typeof s.preInit && (s.preInit = [s.preInit]);
                  s.preInit.length > 0;

                )
                  s.preInit.pop()();
              var Ys = !0;
              return (
                s.noInitialRun && (Ys = !1),
                Hs(),
                Zt &&
                  (Zt.getNewId = function (e) {
                    Zt.counter++;
                    var t = e.length;
                    if (0 === t) return 1;
                    for (var r = 1; r < t; ++r) if (null === e[r]) return r;
                    return t;
                  }),
                n
              );
            });
        (e.exports = r), (e.exports.default = r);
      },
    },
    t = {};
  function r(i) {
    var o = t[i];
    if (void 0 !== o) return o.exports;
    var a = (t[i] = { exports: {} });
    return e[i].call(a.exports, a, a.exports, r), a.exports;
  }
  var i = {};
  (() => {
    "use strict";
    var e = i;
    const t = r(71993),
      o = r(25924),
      a = r(25924),
      s = r(44544),
      n = r(44544),
      l = r(96841),
      d = r(96841),
      h = r(12193),
      u = r(12193),
      c = r(64931),
      p = r(64931),
      g = r(64931),
      y = r(64931),
      f = r(64931),
      v = r(64931),
      m = r(64931),
      S = r(58996),
      P = r(58996),
      C = r(58996),
      b = r(58996),
      x = r(58996),
      A = r(45921),
      T = r(45921),
      E = r(45921),
      R = r(45921),
      D = r(45921),
      w = r(45921),
      M = r(49975),
      L = r(89046),
      O = r(89046),
      I = r(62773),
      k = r(62773),
      _ = r(62773),
      V = r(62773),
      N = r(42639),
      B = r(36534),
      F = r(897),
      H = r(71575),
      Y = r(71575),
      z = r(9656),
      j = r(14290),
      X = r(39299),
      G = r(56985),
      W = r(56985),
      U = r(55526),
      $ = r(21562),
      Z = r(63903),
      q = r(63903),
      K = r(18809),
      J = r(18809),
      Q = r(32545),
      ee = r(96408),
      te = r(9809),
      re = r(3397),
      ie = r(63407),
      oe = r(64171),
      ae = r(95648),
      se = r(94118),
      ne = r(37221),
      le = r(99389),
      de = r(30580),
      he = r(27524),
      ue = r(27524),
      ce = r(36463),
      pe = r(93113),
      ge = r(51269),
      ye = r(51269),
      fe = r(51269),
      ve = r(21915),
      me = r(21915),
      Se = r(21915),
      Pe = r(53831),
      Ce = r(33512),
      be = r(55444),
      xe = r(16185),
      Ae = r(16185),
      Te = r(16185),
      Ee = r(5100),
      Re = r(5100),
      De = r(5100),
      we = r(5100),
      Me = r(5100),
      Le = r(5100),
      Oe = r(5100),
      Ie = r(5100),
      ke = r(5100),
      _e = r(5100),
      Ve = r(5100),
      Ne = r(5100),
      Be = r(5100),
      Fe = r(60872),
      He = r(53521),
      Ye = r(57384),
      ze = r(70397),
      je = r(2310),
      Xe = r(41344),
      Ge = r(45481),
      We = r(83638),
      Ue = r(6153),
      $e = r(55173),
      Ze = r(24478),
      qe = r(27282),
      Ke = r(12119),
      Je = r(66086),
      Qe = r(78499),
      et = r(8959),
      tt = r(27194),
      rt = r(73145),
      it = r(55696),
      ot = r(1908),
      at = r(24696),
      st = r(57230),
      nt = r(24933),
      lt = r(57835),
      dt = r(75619),
      ht = r(84366),
      ut = r(84366),
      ct = r(22382),
      pt = r(51885),
      gt = r(51885),
      yt = r(51885),
      ft = r(32747),
      vt = r(32747),
      mt = r(32747),
      St = r(33906),
      Pt = r(25907),
      Ct = r(43427),
      bt = r(35471),
      xt = r(35471),
      At = r(52881),
      Tt = r(15799),
      Et = r(52452),
      Rt = r(9682),
      Dt = r(38446),
      wt = r(29803),
      Mt = r(73016),
      Lt = r(19663),
      Ot = r(75650),
      It = r(75650),
      kt = r(35508),
      _t = r(51185),
      Vt = r(14883),
      Nt = r(84754),
      Bt = r(97041),
      Ft = r(32025),
      Ht = r(75662),
      Yt = r(43808),
      zt = r(50874),
      jt = r(21780),
      Xt = r(19581),
      Gt = r(33435),
      Wt = r(37947),
      Ut = r(58465),
      $t = r(12954),
      Zt = r(73165),
      qt = r(65936),
      Kt = r(95079),
      Jt = r(95079),
      Qt = r(26974),
      er = r(95632),
      tr = r(55007),
      rr = r(39892),
      ir = r(42790),
      or = r(91154),
      ar = r(86241),
      sr = r(92475),
      nr = r(39484),
      lr = r(33070),
      dr = r(22769),
      hr = r(89236),
      ur = r(65052),
      cr = r(6328),
      pr = r(25919),
      gr = r(58564),
      yr = r(88915),
      fr = r(14023),
      vr = r(2354),
      mr = r(45425),
      Sr = r(62507),
      Pr = r(48804),
      Cr = r(25762),
      br = r(33166),
      xr = r(46650),
      Ar = r(40194),
      Tr = r(78644),
      Er = r(33240),
      Rr = r(97742),
      Dr = r(65707),
      wr = r(21430),
      Mr = r(22019),
      Lr = r(98172),
      Or = r(98172),
      Ir = r(98172),
      kr = r(3346),
      _r = r(3434),
      Vr = r(48570),
      Nr = r(648),
      Br = r(17611),
      Fr = r(23059),
      Hr = r(24156),
      Yr = r(24156),
      zr = r(84392),
      jr = r(84392),
      Xr = r(99016),
      Gr = r(2705),
      Wr = r(60819),
      Ur = r(66010),
      $r = r(23447),
      Zr = r(23447),
      qr = r(31858),
      Kr = r(2056),
      Jr = r(66570),
      Qr = r(85479),
      ei = r(36544),
      ti = r(8320),
      ri = r(94416),
      ii = r(25610),
      oi = r(75112),
      ai = r(84626),
      si = r(84626),
      ni = r(14184),
      li = r(14184),
      di = r(83823),
      hi = r(5102),
      ui = r(31306),
      ci = r(31306),
      pi = r(28792),
      gi = r(78895),
      yi = r(92415),
      fi = r(49641),
      vi = r(40301),
      mi = r(29371),
      Si = r(89171),
      Pi = r(64584),
      Ci = r(48882),
      bi = r(25107),
      xi = r(96696),
      Ai = r(23272),
      Ti = r(84736),
      Ei = r(84736),
      Ri = r(28677),
      Di = r(40734),
      wi = r(40734),
      Mi = r(74370),
      Li = r(74370),
      Oi = r(12021),
      Ii = r(11396),
      ki = r(26977),
      _i = r(69302),
      Vi = r(66443),
      Ni = r(60915),
      Bi = r(49617),
      Fi = r(98409),
      Hi = r(57397),
      Yi = r(87673),
      zi = r(87673),
      ji = r(74736),
      Xi = r(14790),
      Gi = r(59516),
      Wi = r(2296),
      Ui = r(74734),
      $i = r(74734),
      Zi = r(51392),
      qi = r(51392),
      Ki = r(54948),
      Ji = r(83989),
      Qi = r(4220),
      eo = r(7899),
      to = r(19643),
      ro = r(40059),
      io = r(78471),
      oo = r(16155),
      ao = r(19833),
      so = r(48767),
      no = r(39920),
      lo = r(92596),
      ho = r(20268),
      uo = r(68695),
      co = r(68695),
      po = r(18184),
      go = r(18184),
      yo = r(31951),
      fo = r(1370),
      vo = r(63922),
      mo = r(16989),
      So = r(80574),
      Po = r(8827),
      Co = r(63458),
      bo = r(47376),
      xo = r(33841),
      Ao = r(94389),
      To = r(3441),
      Eo = r(3441),
      Ro = r(3441),
      Do = r(3441),
      wo = r(10572),
      Mo = r(98353),
      Lo = r(98353),
      Oo = r(98353),
      Io = r(98353),
      ko = r(98353),
      _o = r(98353),
      Vo = r(98353),
      No = r(98353),
      Bo = r(98353),
      Fo = r(98353),
      Ho = r(98353),
      Yo = r(98353),
      zo = r(98353),
      jo = r(98353),
      Xo = r(98353),
      Go = r(98353),
      Wo = r(98353),
      Uo = r(62288),
      $o = r(97703),
      Zo = r(96260),
      qo = r(88266),
      Ko = r(88266),
      Jo = r(88266),
      Qo = r(88266),
      ea = r(88266),
      ta = r(28243),
      ra = r(22745),
      ia = r(10749),
      oa = r(21033),
      aa = r(77057),
      sa = r(58229),
      na = r(61704),
      la = r(20782),
      da = r(98550),
      ha = r(33236),
      ua = r(11555),
      ca = r(12641),
      pa = r(20667),
      ga = r(20667),
      ya = r(43852),
      fa = r(93522),
      va = r(65297),
      ma = r(72362),
      Sa = r(95179),
      Pa = r(16098),
      Ca = r(89078),
      ba = r(21037),
      xa = r(60981),
      Aa = r(69570),
      Ta = r(55303),
      Ea = r(50085),
      Ra = r(9150),
      Da = r(57318),
      wa = r(29593),
      Ma = r(72469),
      La = r(68264),
      Oa = r(56664),
      Ia = r(78146),
      ka = r(32471),
      _a = r(86109),
      Va = r(1406),
      Na = r(83262),
      Ba = r(71719),
      Fa = r(1391),
      Ha = r(51852),
      Ya = r(88189),
      za = r(88189),
      ja = r(70033),
      Xa = r(52954),
      Ga = r(54580),
      Wa = r(27501),
      Ua = r(25923),
      $a = r(63642),
      Za = r(88227),
      qa = r(61690),
      Ka = r(86551),
      Ja = r(50951),
      Qa = r(9687),
      es = r(37886),
      ts = r(386),
      rs = r(62314),
      is = r(98499),
      os = r(65122),
      as = r(3911),
      ss = r(86717),
      ns = r(54938),
      ls = r(49987),
      ds = r(56705),
      hs = r(16911),
      us = r(592),
      cs = r(56498),
      ps = r(81856),
      gs = r(15273),
      ys = r(1367),
      fs = r(1367),
      vs = r(9488),
      ms = r(77110),
      Ss = r(96852),
      Ps = r(55172),
      Cs = r(75933),
      bs = r(33802),
      xs = r(31544),
      As = r(98585),
      Ts = r(70027),
      Es = r(93752),
      Rs = r(74026),
      Ds = r(1126),
      ws = r(7807),
      Ms = r(79687),
      Ls = r(9297),
      Os = r(50836),
      Is = r(71788),
      ks = r(24315),
      _s = r(24315),
      Vs = r(24315),
      Ns = r(24315),
      Bs = r(24315),
      Fs = r(24315),
      Hs = r(81284),
      Ys = r(66743),
      zs = r(36898),
      js = r(36877),
      Xs = r(37182),
      Gs = r(88302),
      Ws = r(88302),
      Us = r(94707),
      $s = r(13473),
      Zs = r(68015),
      qs = r(74397),
      Ks = r(9184),
      Js = r(76566),
      Qs = r(72704),
      en = r(82767),
      tn = r(89748),
      rn = r(18314),
      on = r(99828),
      an = r(85414),
      sn = r(51462),
      nn = r(35013),
      ln = r(30995),
      dn = r(98888),
      hn = r(28628),
      un = r(47453),
      cn = r(80456),
      pn = r(8535),
      gn = r(92762),
      yn = r(64485),
      fn = r(51825),
      vn = r(99846),
      mn = r(92231),
      Sn = r(22735),
      Pn = r(3798),
      Cn = r(83187),
      bn = r(38831),
      xn = r(4455),
      An = r(88409),
      Tn = r(2928),
      En = r(2270),
      Rn = r(68584),
      Dn = r(38595),
      wn = r(10947),
      Mn = r(69773),
      Ln = r(72979),
      On = r(15518),
      In = r(19963),
      kn = r(62652),
      _n = r(192),
      Vn = r(90262),
      Nn = r(77339),
      Bn = r(40997),
      Fn = r(16556),
      Hn = r(37874),
      Yn = r(14082),
      zn = r(46495),
      jn = r(16256),
      Xn = r(4450),
      Gn = r(4450),
      Wn = r(4450),
      Un = r(89136),
      $n = r(89136),
      Zn = r(89136),
      qn = r(89136),
      Kn = r(87836),
      Jn = r(61566),
      Qn = r(95103),
      el = r(69133),
      tl = r(54962),
      rl = r(90182),
      il = r(79548),
      ol = r(79548),
      al = r(79548),
      sl = r(79548),
      nl = r(57419),
      ll = r(35992),
      dl = r(86127),
      hl = r(76829),
      ul = r(76829),
      cl = r(76829),
      pl = r(3810),
      gl = r(3810),
      yl = r(16110),
      fl = r(89577),
      vl = r(47737),
      ml = r(17707),
      Sl = r(73792),
      Pl = r(68491),
      Cl = r(66477),
      bl = r(66477),
      xl = r(23291),
      Al = r(75869),
      Tl = r(98102),
      El = r(86753),
      Rl = r(36561),
      Dl = r(1989),
      wl = r(228),
      Ml = r(20254),
      Ll = r(52361),
      Ol = r(52361),
      Il = r(58042),
      kl = r(79135),
      _l = r(22054),
      Vl = r(99441),
      Nl = r(69412),
      Bl = r(77103),
      Fl = r(77103),
      Hl = r(77103),
      Yl = r(77103),
      zl = r(77103),
      jl = r(48936),
      Xl = r(71906),
      Gl = r(37622),
      Wl = r(37622),
      Ul = r(37622),
      $l = r(37622),
      Zl = r(37622),
      ql = r(37622),
      Kl = r(37622),
      Jl = r(37622),
      Ql = r(33517),
      ed = r(84501),
      td = r(26079),
      rd = r(21240),
      id = r(54005),
      od = r(75816),
      ad = r(72476),
      sd = r(77162),
      nd = r(41859),
      ld = r(98694),
      dd = r(98694),
      hd = r(56675),
      ud = r(45265),
      cd = r(56172),
      pd = r(39927),
      gd = r(72954),
      yd = r(94574),
      fd = r(80995),
      vd = r(19221),
      md = r(28009),
      Sd = r(25889),
      Pd = r(10435),
      Cd = r(10435),
      bd = r(10435),
      xd = r(10435),
      Ad = r(66549),
      Td = r(34238),
      Ed = r(34238),
      Rd = r(56744),
      Dd = r(21079),
      wd = r(3214),
      Md = r(58599),
      Ld = r(23866),
      Od = r(77354),
      Id = r(98869),
      kd = r(98140),
      _d = r(64645),
      Vd = r(37796),
      Nd = r(37796),
      Bd = r(71664),
      Fd = r(71664),
      Hd = r(63508),
      Yd = r(75772),
      zd = r(50605),
      jd = r(87459),
      Xd = r(33519),
      Gd = r(33519),
      Wd = r(33519),
      Ud = r(87108),
      $d = r(62049),
      Zd = r(62049),
      qd = r(82229),
      Kd = r(82229),
      Jd = r(82229),
      Qd = r(82229),
      eh = r(90995),
      th = r(33485),
      rh = r(10276),
      ih = r(10276),
      oh = r(70162),
      ah = r(31194),
      sh = r(85258),
      nh = r(31601),
      lh = r(60986),
      dh = r(60986),
      hh = r(10763),
      uh = r(26520),
      ch = r(39922),
      ph = r(12785),
      gh = r(38215),
      yh = r(38215),
      fh = r(38215),
      vh = r(38215),
      mh = r(2192),
      Sh = r(11043),
      Ph = r(89955),
      Ch = r(89955),
      bh = r(72072),
      xh = r(60960),
      Ah = r(60960),
      Th = r(60960),
      Eh = r(60960),
      Rh = r(14278),
      Dh = r(51097),
      wh = r(2963),
      Mh = r(62993),
      Lh = r(27970),
      Oh = r(3777),
      Ih = r(7980),
      kh = r(79226),
      _h = r(32287),
      Vh = r(28268),
      Nh = r(74218),
      Bh = r(10581),
      Fh = r(63415),
      Hh = r(11805),
      Yh = r(11805),
      zh = r(11805),
      jh = r(11805),
      Xh = r(11805),
      Gh = r(40359),
      Wh = r(883),
      Uh = r(73785),
      $h = r(66405),
      Zh = r(57935),
      qh = r(65885),
      Kh = r(65885),
      Jh = r(65885),
      Qh = r(96528),
      eu = r(34496),
      tu = r(28436),
      ru = r(56356),
      iu = r(30323),
      ou = r(32406),
      au = r(34116),
      su = r(91465),
      nu = r(26361),
      lu = r(26361),
      du = r(5337),
      hu = r(75323),
      uu = r(22022),
      cu = r(19145),
      pu = r(36420),
      gu = r(36420),
      yu = r(36420),
      fu = r(36420),
      vu = r(71238),
      mu = r(71238),
      Su = r(62916),
      Pu = r(62186),
      Cu = r(95808),
      bu = r(54624),
      xu = r(54624),
      Au = r(24149),
      Tu = r(86699),
      Eu = r(9073),
      Ru = r(14379),
      Du = r(6859),
      wu = r(32616),
      Mu = r(44431),
      Lu = r(45215),
      Ou = r(45215),
      Iu = r(45215),
      ku = r(45215),
      _u = r(45215),
      Vu = r(45215),
      Nu = r(45215),
      Bu = r(19387),
      Fu = r(19387),
      Hu = r(22950),
      Yu = r(22950),
      zu = r(22950),
      ju = r(22950),
      Xu = r(22950),
      Gu = r(22950),
      Wu = r(22950),
      Uu = r(22950),
      $u = r(85505),
      Zu = r(85505),
      qu = r(76630),
      Ku = r(46544),
      Ju = r(72633),
      Qu = r(72633),
      ec = r(72633),
      tc = r(72633),
      rc = r(72633),
      ic = r(72633),
      oc = r(72633),
      ac = r(72633),
      sc = r(72633),
      nc = r(72633),
      lc = r(72633),
      dc = r(71497),
      hc = r(52578),
      uc = r(52578),
      cc = r(52578),
      pc = r(11665),
      gc = r(73538),
      yc = r(73538),
      fc = r(54535),
      vc = r(17575),
      mc = r(69854),
      Sc = r(69854),
      Pc = r(99064),
      Cc = r(99064),
      bc = r(34483),
      xc = r(34483),
      Ac = r(72934),
      Tc = r(9254),
      Ec = r(67492),
      Rc = r(67492),
      Dc = r(67492),
      wc = r(4748),
      Mc = r(27307),
      Lc = r(27307),
      Oc = r(8591),
      Ic = r(8591),
      kc = r(8591),
      _c = r(8591),
      Vc = r(8591),
      Nc = r(8591),
      Bc = r(8591),
      Fc = r(48008),
      Hc = r(48008),
      Yc = r(48008),
      zc = r(48008),
      jc = r(48008),
      Xc = r(48008),
      Gc = r(48008),
      Wc = r(48008),
      Uc = r(16602),
      $c = r(16602),
      Zc = r(16602),
      qc = r(16602),
      Kc = r(21670),
      Jc = r(21670),
      Qc = r(21670),
      ep = r(21670),
      tp = r(21670),
      rp = r(21670),
      ip = r(21670),
      op = r(21670),
      ap = r(21670),
      sp = r(21670),
      np = r(20346),
      lp = r(61090),
      dp = r(61090),
      hp = r(94532),
      up = r(87092),
      cp = r(87092),
      pp = r(58345),
      gp = r(58345),
      yp = r(58345),
      fp = r(32873),
      vp = r(32873),
      mp = r(32873),
      Sp = r(32873),
      Pp = r(32873),
      Cp = r(32873),
      bp = r(32873),
      xp = r(32873),
      Ap = r(32873),
      Tp = r(32873),
      Ep = r(32873),
      Rp = r(11727),
      Dp = r(11727),
      wp = r(77376),
      Mp = r(14936),
      Lp = {
        buildAnnotations: t.buildAnnotations,
        buildAxes: o.buildAxes,
        buildAxis3D: a.buildAxis3D,
        buildDataSeries: s.buildDataSeries,
        buildDataSeries3D: n.buildDataSeries3D,
        buildModifiers: l.buildModifiers,
        buildModifiers3D: d.buildModifiers3D,
        buildSeries: h.buildSeries,
        buildSeries3D: u.buildSeries3D,
        build2DChart: c.build2DChart,
        build2DPolarChart: p.build2DPolarChart,
        buildPieChart: g.buildPieChart,
        build3DChart: y.build3DChart,
        buildSubCharts: f.buildSubCharts,
        configure2DSurface: v.configure2DSurface,
        configure3DSurface: m.configure3DSurface,
        chartReviver: S.chartReviver,
        buildChart: P.buildChart,
        configureChart: C.configureChart,
        ensureRegistrations: b.ensureRegistrations,
        chartBuilder: x.chartBuilder,
        registerType: A.registerType,
        registerWasmType: T.registerWasmType,
        registerFunction: E.registerFunction,
        getFunction: R.getFunction,
        createType: D.createType,
        getSubTypes: w.getSubTypes,
        AnnotationHoverModifier: M.AnnotationHoverModifier,
        testIsOverAxes: L.testIsOverAxes,
        getActiveAxes: O.getActiveAxes,
        CursorModifier: I.CursorModifier,
        defaultCursorTooltipSvgTemplate: k.defaultCursorTooltipSvgTemplate,
        calcTooltipSize: _.calcTooltipSize,
        adjustTooltipPosition: V.adjustTooltipPosition,
        CustomChartModifier2D: N.CustomChartModifier2D,
        DataPointInfo: B.DataPointInfo,
        DataPointSelectionChangedArgs: F.DataPointSelectionChangedArgs,
        ESelectionMode: H.ESelectionMode,
        DataPointSelectionModifier: Y.DataPointSelectionModifier,
        LegendModifier: z.LegendModifier,
        ModifierArgsBase: j.ModifierArgsBase,
        ModifierMouseArgs: X.ModifierMouseArgs,
        EActionType: G.EActionType,
        MouseWheelZoomModifier: W.MouseWheelZoomModifier,
        OverviewRangeSelectionModifier: U.OverviewRangeSelectionModifier,
        PinchZoomModifier: $.PinchZoomModifier,
        RolloverModifier: Z.RolloverModifier,
        splitIntoClusters: q.splitIntoClusters,
        RubberBandXyZoomModifier: K.RubberBandXyZoomModifier,
        getRubberBandRect: J.getRubberBandRect,
        SeriesSelectionModifier: Q.SeriesSelectionModifier,
        VerticalSliceModifier: ee.VerticalSliceModifier,
        XAxisDragModifier: te.XAxisDragModifier,
        YAxisDragModifier: re.YAxisDragModifier,
        ZoomExtentsModifier: ie.ZoomExtentsModifier,
        ZoomPanModifier: oe.ZoomPanModifier,
        PolarArcZoomModifier: ae.PolarArcZoomModifier,
        PolarCursorModifier: se.PolarCursorModifier,
        PolarDataPointSelectionModifier: ne.PolarDataPointSelectionModifier,
        PolarLegendModifier: le.PolarLegendModifier,
        PolarMouseWheelZoomModifier: de.PolarMouseWheelZoomModifier,
        EPolarPanModifierPanMode: he.EPolarPanModifierPanMode,
        PolarPanModifier: ue.PolarPanModifier,
        PolarZoomExtentsModifier: ce.PolarZoomExtentsModifier,
        BatchRenderContext: pe.BatchRenderContext,
        getWebGlBrushFromCache: ge.getWebGlBrushFromCache,
        getScrtBrushFromCache: ye.getScrtBrushFromCache,
        createBrushInCache: fe.createBrushInCache,
        getWebGlPenFromCache: ve.getWebGlPenFromCache,
        getScrtPenFromCache: me.getScrtPenFromCache,
        createPenInCache: Se.createPenInCache,
        RenderContext2D: Pe.RenderContext2D,
        WebGlBrush: Ce.WebGlBrush,
        WebGlPen: be.WebGlPen,
        calculateAbsoluteRenderLayer: xe.calculateAbsoluteRenderLayer,
        ELineDrawMode: Ae.ELineDrawMode,
        WebGlRenderContext2D: Te.WebGlRenderContext2D,
        updateAxisLayoutState: Ee.updateAxisLayoutState,
        layoutAxisParts: Re.layoutAxisParts,
        layoutAxisPartsLeftStrategy: De.layoutAxisPartsLeftStrategy,
        layoutAxisPartsRightStrategy: we.layoutAxisPartsRightStrategy,
        layoutAxisPartsTopStrategy: Me.layoutAxisPartsTopStrategy,
        layoutAxisPartsBottomStrategy: Le.layoutAxisPartsBottomStrategy,
        getHorizontalAxisRequiredSize: Oe.getHorizontalAxisRequiredSize,
        getVerticalAxisRequiredSize: Ie.getVerticalAxisRequiredSize,
        updateLeftAndRightChartLayoutState:
          ke.updateLeftAndRightChartLayoutState,
        updateTopAndBottomChartLayoutState:
          _e.updateTopAndBottomChartLayoutState,
        getValueWithCoordinateMode: Ve.getValueWithCoordinateMode,
        getCoordinateWithCoordinateMode: Ne.getCoordinateWithCoordinateMode,
        testLayoutManager: Be.testLayoutManager,
        BottomAlignedInnerAxisLayoutStrategy:
          Fe.BottomAlignedInnerAxisLayoutStrategy,
        BottomAlignedOuterAxisLayoutStrategy:
          He.BottomAlignedOuterAxisLayoutStrategy,
        BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy:
          Ye.BottomAlignedOuterHorizontallyStackedAxisLayoutStrategy,
        CentralAxesLayoutManager: ze.CentralAxesLayoutManager,
        ChartLayoutState: je.ChartLayoutState,
        EInnerAxisPlacementCoordinateMode: Xe.EInnerAxisPlacementCoordinateMode,
        LayoutManager: Ge.LayoutManager,
        LeftAlignedInnerAxisLayoutStrategy:
          We.LeftAlignedInnerAxisLayoutStrategy,
        LeftAlignedOuterAxisLayoutStrategy:
          Ue.LeftAlignedOuterAxisLayoutStrategy,
        LeftAlignedOuterVerticallyStackedAxisLayoutStrategy:
          $e.LeftAlignedOuterVerticallyStackedAxisLayoutStrategy,
        RightAlignedInnerAxisLayoutStrategy:
          Ze.RightAlignedInnerAxisLayoutStrategy,
        RightAlignedOuterAxisLayoutStrategy:
          qe.RightAlignedOuterAxisLayoutStrategy,
        RightAlignedOuterVerticallyStackedAxisLayoutStrategy:
          Ke.RightAlignedOuterVerticallyStackedAxisLayoutStrategy,
        SciChartHorizontalGroup: Je.SciChartHorizontalGroup,
        SciChartVerticalGroup: Qe.SciChartVerticalGroup,
        SynchronizedLayoutManager: et.SynchronizedLayoutManager,
        TopAlignedInnerAxisLayoutStrategy: tt.TopAlignedInnerAxisLayoutStrategy,
        TopAlignedOuterAxisLayoutStrategy: rt.TopAlignedOuterAxisLayoutStrategy,
        TopAlignedOuterHorizontallyStackedAxisLayoutStrategy:
          it.TopAlignedOuterHorizontallyStackedAxisLayoutStrategy,
        AngularAxisLayoutStrategy: ot.AngularAxisLayoutStrategy,
        PolarLayoutManager: at.PolarLayoutManager,
        RadialAxisLayoutStrategy: st.RadialAxisLayoutStrategy,
        getWindowedYRange: nt.getWindowedYRange,
        BoxPlotDataSeries: lt.BoxPlotDataSeries,
        DataPointSelectionPaletteProvider: dt.DataPointSelectionPaletteProvider,
        DoubleVectorProvider: ht.DoubleVectorProvider,
        FIFOVectorProvider: ut.FIFOVectorProvider,
        HlcDataSeries: ct.HlcDataSeries,
        EDataSeriesType: pt.EDataSeriesType,
        EDataChangeType: gt.EDataChangeType,
        EDataSeriesValueType: yt.EDataSeriesValueType,
        EStrokePaletteMode: ft.EStrokePaletteMode,
        EFillPaletteMode: vt.EFillPaletteMode,
        DefaultPaletteProvider: mt.DefaultPaletteProvider,
        TemplateMetadataGenerator: St.TemplateMetadataGenerator,
        MetadataPaletteProvider: Pt.MetadataPaletteProvider,
        NonUniformHeatmapDataSeries: Ct.NonUniformHeatmapDataSeries,
        OhlcDataSeries: bt.OhlcDataSeries,
        getOHLCYRange: xt.getOHLCYRange,
        PaletteFactory: At.PaletteFactory,
        UniformHeatmapDataSeries: Tt.UniformHeatmapDataSeries,
        XDataSeries: Et.XDataSeries,
        XyDataSeries: Rt.XyDataSeries,
        XyNDataSeries: Dt.XyNDataSeries,
        XyTextDataSeries: wt.XyTextDataSeries,
        XyxDataSeries: Mt.XyxDataSeries,
        XyxyDataSeries: Lt.XyxyDataSeries,
        XyyDataSeries: Ot.XyyDataSeries,
        getYyYRange: It.getYyYRange,
        XyzDataSeries: kt.XyzDataSeries,
        BoxPlotSeriesInfo: _t.BoxPlotSeriesInfo,
        HeatmapSeriesInfo: Vt.HeatmapSeriesInfo,
        HlcSeriesInfo: Nt.HlcSeriesInfo,
        OhlcSeriesInfo: Bt.OhlcSeriesInfo,
        SeriesInfo: Ft.SeriesInfo,
        StackedXySeriesInfo: Ht.StackedXySeriesInfo,
        TriangleSeriesInfo: Yt.TriangleSeriesInfo,
        XySeriesInfo: zt.XySeriesInfo,
        XyySeriesInfo: jt.XyySeriesInfo,
        XyzSeriesInfo: Xt.XyzSeriesInfo,
        DataDistributionCalculator: Gt.DataDistributionCalculator,
        HlcCustomFilter: Wt.HlcCustomFilter,
        HlcScaleOffsetFilter: Ut.HlcScaleOffsetFilter,
        OhlcCustomFilter: $t.OhlcCustomFilter,
        OhlcScaleOffsetFilter: Zt.OhlcScaleOffsetFilter,
        XyCustomFilter: qt.XyCustomFilter,
        EDataSeriesField: Kt.EDataSeriesField,
        switchData: Jt.switchData,
        XyLinearTrendFilter: Qt.XyLinearTrendFilter,
        XyMovingAverageFilter: er.XyMovingAverageFilter,
        XyRatioFilter: tr.XyRatioFilter,
        XyScaleOffsetFilter: rr.XyScaleOffsetFilter,
        XyyCustomFilter: ir.XyyCustomFilter,
        XyyScaleOffsetFilter: or.XyyScaleOffsetFilter,
        XyzCustomFilter: ar.XyzCustomFilter,
        XyzScaleOffsetFilter: sr.XyzScaleOffsetFilter,
        BasePointSeriesResampled: nr.BasePointSeriesResampled,
        BasePointSeriesWrapped: lr.BasePointSeriesWrapped,
        BoxPlotPointSeriesWrapped: dr.BoxPlotPointSeriesWrapped,
        HlcPointSeriesWrapped: hr.HlcPointSeriesWrapped,
        OhlcPointSeriesResampled: ur.OhlcPointSeriesResampled,
        OhlcPointSeriesWrapped: cr.OhlcPointSeriesWrapped,
        XyNPointSeriesResampled: pr.XyNPointSeriesResampled,
        XyPointSeriesResampled: gr.XyPointSeriesResampled,
        XyPointSeriesWrapped: yr.XyPointSeriesWrapped,
        XyyPointSeriesResampled: fr.XyyPointSeriesResampled,
        XyyPointSeriesWrapped: vr.XyyPointSeriesWrapped,
        XyzPointSeriesResampled: mr.XyzPointSeriesResampled,
        XyzPointSeriesWrapped: Sr.XyzPointSeriesWrapped,
        CategoryCoordinateCalculator: Pr.CategoryCoordinateCalculator,
        FlippedCategoryCoordinateCalculator:
          Cr.FlippedCategoryCoordinateCalculator,
        FlippedNumericCoordinateCalculator:
          br.FlippedNumericCoordinateCalculator,
        LogarithmicCoordinateCalculator: xr.LogarithmicCoordinateCalculator,
        NumericCoordinateCalculator: Ar.NumericCoordinateCalculator,
        ExtremeResamplerHelper: Tr.ExtremeResamplerHelper,
        EResamplingMode: Er.EResamplingMode,
        ResamplingParams: Rr.ResamplingParams,
        DefaultTickCoordinatesProvider: Dr.DefaultTickCoordinatesProvider,
        PolarTickCoordinatesProvider: wr.PolarTickCoordinatesProvider,
        StaticTickCoordinatesProvider: Mr.StaticTickCoordinatesProvider,
        ELogarithmicMinorTickMode: Lr.ELogarithmicMinorTickMode,
        ELogarithmicMajorTickMode: Or.ELogarithmicMajorTickMode,
        LogarithmicTickProvider: Ir.LogarithmicTickProvider,
        NumericTickProvider: kr.NumericTickProvider,
        ChartTitleRenderer: _r.ChartTitleRenderer,
        RenderPassData: Vr.RenderPassData,
        RenderPassDataCollection: Nr.RenderPassDataCollection,
        RenderPassInfo: Br.RenderPassInfo,
        SciChartRenderer: Fr.SciChartRenderer,
        TitleRendererBase: Hr.TitleRendererBase,
        getAdjustedRotation: Yr.getAdjustedRotation,
        AUTO_COLOR: zr.AUTO_COLOR,
        stripAutoColor: jr.stripAutoColor,
        SciChartJSDarkTheme: Xr.SciChartJSDarkTheme,
        SciChartJSDarkv2Theme: Gr.SciChartJSDarkv2Theme,
        SciChartJSLightTheme: Wr.SciChartJSLightTheme,
        SciChartJsNavyTheme: Ur.SciChartJsNavyTheme,
        getSharedWasmContext: $r.getSharedWasmContext,
        initializeChartEngine2D: Zr.initializeChartEngine2D,
        HeatmapLegend: qr.HeatmapLegend,
        licenseManager2dState: Kr.licenseManager2dState,
        DefaultSciChartLoader: Jr.DefaultSciChartLoader,
        SciChartDefaults: Qr.SciChartDefaults,
        SciChartOverview: ei.SciChartOverview,
        SciChartPolarSubSurface: ti.SciChartPolarSubSurface,
        SciChartPolarSurface: ri.SciChartPolarSurface,
        SciChartSubSurface: ii.SciChartSubSurface,
        sciChartSubSurfaceCommon: oi.sciChartSubSurfaceCommon,
        sciChartConfig: ai.sciChartConfig,
        SciChartSurface: si.SciChartSurface,
        DebugForDpi: ni.DebugForDpi,
        createChartDestination: li.createChartDestination,
        UpdateSuspender: di.UpdateSuspender,
        AdornerLayer: hi.AdornerLayer,
        EDraggingGripPoint: ui.EDraggingGripPoint,
        ECoordinateMode: ci.ECoordinateMode,
        AnnotationClickEventArgs: pi.AnnotationClickEventArgs,
        AnnotationDragDeltaEventArgs: gi.AnnotationDragDeltaEventArgs,
        annotationHelpers: yi.annotationHelpers,
        AnnotationHoverEventArgs: fi.AnnotationHoverEventArgs,
        ArcAnnotation: vi.ArcAnnotation,
        AxisMarkerAnnotation: mi.AxisMarkerAnnotation,
        BoxAnnotation: Si.BoxAnnotation,
        CursorTooltipSvgAnnotation: Pi.CursorTooltipSvgAnnotation,
        CustomAnnotation: Ci.CustomAnnotation,
        CustomHtmlAnnotation: bi.CustomHtmlAnnotation,
        HorizontalLineAnnotation: xi.HorizontalLineAnnotation,
        HtmlTextAnnotation: Ai.HtmlTextAnnotation,
        EAnnotationLayer: Ti.EAnnotationLayer,
        EAnnotationType: Ei.EAnnotationType,
        LineAnnotation: Ri.LineAnnotation,
        EArrowHeadPosition: Di.EArrowHeadPosition,
        LineArrowAnnotation: wi.LineArrowAnnotation,
        EWrapTo: Mi.EWrapTo,
        NativeTextAnnotation: Li.NativeTextAnnotation,
        OverviewCustomResizableAnnotation: Oi.OverviewCustomResizableAnnotation,
        PolarArcAnnotation: Ii.PolarArcAnnotation,
        PolarPointerAnnotation: ki.PolarPointerAnnotation,
        RolloverLegendSvgAnnotation: _i.RolloverLegendSvgAnnotation,
        RolloverMarkerSvgAnnotation: Vi.RolloverMarkerSvgAnnotation,
        RolloverTooltipSvgAnnotation: Ni.RolloverTooltipSvgAnnotation,
        TextAnnotation: Bi.TextAnnotation,
        VerticalLineAnnotation: Fi.VerticalLineAnnotation,
        EClipMode: Hi.EClipMode,
        AxisLayoutState: Yi.AxisLayoutState,
        PolarAxisLayoutState: zi.PolarAxisLayoutState,
        AxisRenderer: ji.AxisRenderer,
        AxisTitleRenderer: Xi.AxisTitleRenderer,
        CategoryAxis: Gi.CategoryAxis,
        DateTimeNumericAxis: Wi.DateTimeNumericAxis,
        getAxisById: Ui.getAxisById,
        getAxis3dById: $i.getAxis3dById,
        MIN_LOG_AXIS_VALUE: Zi.MIN_LOG_AXIS_VALUE,
        LogarithmicAxis: qi.LogarithmicAxis,
        NumericAxis: Ki.NumericAxis,
        VisibleRangeChangedArgs: Ji.VisibleRangeChangedArgs,
        CategoryDeltaCalculator: Qi.CategoryDeltaCalculator,
        DateTimeDeltaCalculator: eo.DateTimeDeltaCalculator,
        LogarithmicDeltaCalculator: to.LogarithmicDeltaCalculator,
        NumericDeltaCalculator: ro.NumericDeltaCalculator,
        DateLabelProvider: io.DateLabelProvider,
        labelCache: oo.labelCache,
        LabelInfo: ao.LabelInfo,
        LogarithmicLabelProvider: so.LogarithmicLabelProvider,
        NumericLabelProvider: no.NumericLabelProvider,
        PieLabelProvider: lo.PieLabelProvider,
        RadianLabelProvider: ho.RadianLabelProvider,
        ETradeChartLabelFormat: uo.ETradeChartLabelFormat,
        SmartDateLabelProvider: co.SmartDateLabelProvider,
        TextLabelProvider: po.TextLabelProvider,
        wrapText: go.wrapText,
        PolarAxisRenderer: yo.PolarAxisRenderer,
        PolarCategoryAxis: fo.PolarCategoryAxis,
        PolarNumericAxis: vo.PolarNumericAxis,
        EPolarAxisMode: mo.EPolarAxisMode,
        EPolarGridlineMode: So.EPolarGridlineMode,
        EPolarLabelMode: Po.EPolarLabelMode,
        createNativeRect: Co.createNativeRect,
        createSCRTPen: bo.createSCRTPen,
        createSolidBrush: xo.createSolidBrush,
        drawBorder: Ao.drawBorder,
        drawModifiersAxisLabel: To.drawModifiersAxisLabel,
        drawLineAnnotation: Eo.drawLineAnnotation,
        drawAxisMarkerAnnotation: Ro.drawAxisMarkerAnnotation,
        getLabelCoordinates: Do.getLabelCoordinates,
        labelHelper: wo.labelHelper,
        FontKey: Mo.FontKey,
        deleteCache: Lo.deleteCache,
        freeCache: Oo.freeCache,
        getVectorRectVertex: Io.getVectorRectVertex,
        getVectorColorVertex: ko.getVectorColorVertex,
        getVectorColorTextureVertex: _o.getVectorColorTextureVertex,
        getVectorArcVertex: Vo.getVectorArcVertex,
        getVertex: No.getVertex,
        getArcVertex: Bo.getArcVertex,
        getTextureVertex: Fo.getTextureVertex,
        getTextBounds: Ho.getTextBounds,
        getNativeRect: Yo.getNativeRect,
        getVector4: zo.getVector4,
        getVector2: jo.getVector2,
        getVector3: Xo.getVector3,
        getFontKey: Go.getFontKey,
        getAllFontKeys: Wo.getAllFontKeys,
        polarChartHelper: Uo.polarChartHelper,
        ManualLegend: $o.ManualLegend,
        SciChartLegend: Zo.SciChartLegend,
        ELegendOrientation: qo.ELegendOrientation,
        ELegendPlacement: Ko.ELegendPlacement,
        ELegendType: Jo.ELegendType,
        getLegendItemHtml: Qo.getLegendItemHtml,
        getLegendContainerHtml: ea.getLegendContainerHtml,
        SciChartPieLegend: ta.SciChartPieLegend,
        CrossPointMarker: ra.CrossPointMarker,
        EllipsePointMarker: ia.EllipsePointMarker,
        SpritePointMarker: oa.SpritePointMarker,
        SquarePointMarker: aa.SquarePointMarker,
        TrianglePointMarker: sa.TrianglePointMarker,
        XPointMarker: na.XPointMarker,
        ELineType: la.ELineType,
        FastBandRenderableSeries: da.FastBandRenderableSeries,
        FastBoxPlotRenderableSeries: ha.FastBoxPlotRenderableSeries,
        FastBubbleRenderableSeries: ua.FastBubbleRenderableSeries,
        FastCandlestickRenderableSeries: ca.FastCandlestickRenderableSeries,
        FastColumnRenderableSeries: pa.FastColumnRenderableSeries,
        getXRange: ga.getXRange,
        FastErrorBarsRenderableSeries: ya.FastErrorBarsRenderableSeries,
        FastImpulseRenderableSeries: fa.FastImpulseRenderableSeries,
        FastLineRenderableSeries: va.FastLineRenderableSeries,
        FastMountainRenderableSeries: ma.FastMountainRenderableSeries,
        FastOhlcRenderableSeries: Sa.FastOhlcRenderableSeries,
        FastRectangleRenderableSeries: Pa.FastRectangleRenderableSeries,
        FastTextRenderableSeries: Ca.FastTextRenderableSeries,
        GlowEffect: ba.GlowEffect,
        HeatmapColorMap: xa.HeatmapColorMap,
        HoveredChangedArgs: Aa.HoveredChangedArgs,
        LineSegmentRenderableSeries: Ta.LineSegmentRenderableSeries,
        NonUniformHeatmapRenderableSeries: Ea.NonUniformHeatmapRenderableSeries,
        SelectionChangedArgs: Ra.SelectionChangedArgs,
        SeriesHoveredArgs: Da.SeriesHoveredArgs,
        SeriesSelectedArgs: wa.SeriesSelectedArgs,
        SeriesVisibleChangedArgs: Ma.SeriesVisibleChangedArgs,
        ShadowEffect: La.ShadowEffect,
        SmoothStackedMountainRenderableSeries:
          Oa.SmoothStackedMountainRenderableSeries,
        SplineBandRenderableSeries: Ia.SplineBandRenderableSeries,
        SplineLineRenderableSeries: ka.SplineLineRenderableSeries,
        SplineMountainRenderableSeries: _a.SplineMountainRenderableSeries,
        StackedColumnCollection: Va.StackedColumnCollection,
        StackedColumnRenderableSeries: Na.StackedColumnRenderableSeries,
        StackedMountainCollection: Ba.StackedMountainCollection,
        StackedMountainRenderableSeries: Fa.StackedMountainRenderableSeries,
        TriangleRenderableSeries: Ha.TriangleRenderableSeries,
        EContourColorMapMode: Ya.EContourColorMapMode,
        UniformContoursRenderableSeries: za.UniformContoursRenderableSeries,
        UniformHeatmapRenderableSeries: ja.UniformHeatmapRenderableSeries,
        XyScatterRenderableSeries: Xa.XyScatterRenderableSeries,
        animationHelpers: Ga.animationHelpers,
        BandAnimation: Wa.BandAnimation,
        BandAnimationStyle: Ua.BandAnimationStyle,
        BaseAnimationStyle: $a.BaseAnimationStyle,
        BasePointMarkerStyle: Za.BasePointMarkerStyle,
        BubbleAnimation: qa.BubbleAnimation,
        CandlestickAnimation: Ka.CandlestickAnimation,
        CandlestickAnimationStyle: Ja.CandlestickAnimationStyle,
        ColumnAnimation: Qa.ColumnAnimation,
        ColumnAnimationStyle: es.ColumnAnimationStyle,
        CustomPointMarkerStyle: ts.CustomPointMarkerStyle,
        FadeAnimation: rs.FadeAnimation,
        LineAnimation: is.LineAnimation,
        MountainAnimation: os.MountainAnimation,
        MountainAnimationStyle: as.MountainAnimationStyle,
        OhlcAnimation: ss.OhlcAnimation,
        OhlcAnimationStyle: ns.OhlcAnimationStyle,
        PointMarkerStyle: ls.PointMarkerStyle,
        ScaleAnimation: ds.ScaleAnimation,
        ScatterAnimation: hs.ScatterAnimation,
        SweepAnimation: us.SweepAnimation,
        WaveAnimation: cs.WaveAnimation,
        BandSeriesDataLabelProvider: ps.BandSeriesDataLabelProvider,
        BubbleSeriesDataLabelProvider: gs.BubbleSeriesDataLabelProvider,
        EColumnDataLabelPosition: ys.EColumnDataLabelPosition,
        ColumnSeriesDataLabelProvider: fs.ColumnSeriesDataLabelProvider,
        ContoursDataLabelProvider: vs.ContoursDataLabelProvider,
        dataLabelHelpers: ms.dataLabelHelpers,
        DataLabelProvider: Ss.DataLabelProvider,
        DataLabelState: Ps.DataLabelState,
        HeatMapDataLabelProvider: Cs.HeatMapDataLabelProvider,
        LineSeriesDataLabelProvider: bs.LineSeriesDataLabelProvider,
        NonUniformHeatMapDataLabelProvider:
          xs.NonUniformHeatMapDataLabelProvider,
        RectangleDataLabelState: As.RectangleDataLabelState,
        RectangleSeriesDataLabelProvider: Ts.RectangleSeriesDataLabelProvider,
        StackedCollectionDataLabelProvider:
          Es.StackedCollectionDataLabelProvider,
        StackedColumnSeriesDataLabelProvider:
          Rs.StackedColumnSeriesDataLabelProvider,
        TextDataLabelProvider: Ds.TextDataLabelProvider,
        BandSeriesDrawingProvider: ws.BandSeriesDrawingProvider,
        BoxPlotSeriesDrawingProvider: Ms.BoxPlotSeriesDrawingProvider,
        BubbleSeriesDrawingProvider: Ls.BubbleSeriesDrawingProvider,
        ColumnSeriesDrawingProvider: Os.ColumnSeriesDrawingProvider,
        ErrorSeriesDrawingProvider: Is.ErrorSeriesDrawingProvider,
        getColorDataForTexture: ks.getColorDataForTexture,
        getColor: _s.getColor,
        createColorMap: Vs.createColorMap,
        calculateOffsets: Ns.calculateOffsets,
        calculateCellCoordinates: Bs.calculateCellCoordinates,
        calculateHeatmapTexture: Fs.calculateHeatmapTexture,
        HeightSeriesDrawingProvider: Hs.HeightSeriesDrawingProvider,
        LineSegmentSeriesDrawingProvider: Ys.LineSegmentSeriesDrawingProvider,
        LineSeriesDrawingProvider: zs.LineSeriesDrawingProvider,
        MountainSeriesDrawingProvider: js.MountainSeriesDrawingProvider,
        NonUniformHeatmapDrawingProvider: Xs.NonUniformHeatmapDrawingProvider,
        EOhlcDrawingMode: Gs.EOhlcDrawingMode,
        OhlcSeriesDrawingProvider: Ws.OhlcSeriesDrawingProvider,
        PointMarkerDrawingProvider: Us.PointMarkerDrawingProvider,
        RectangleSeriesDrawingProvider: $s.RectangleSeriesDrawingProvider,
        SmearSeriesDrawingProvider: Zs.SmearSeriesDrawingProvider,
        TriangleSeriesDrawingProvider: qs.TriangleSeriesDrawingProvider,
        UniformContoursDrawingProvider: Ks.UniformContoursDrawingProvider,
        UniformHeatmapDrawingProvider: Js.UniformHeatmapDrawingProvider,
        BandSeriesHitTestProvider: Qs.BandSeriesHitTestProvider,
        BoxPlotSeriesHitTestProvider: en.BoxPlotSeriesHitTestProvider,
        BubbleSeriesHitTestProvider: tn.BubbleSeriesHitTestProvider,
        ColumnSeriesHitTestProvider: rn.ColumnSeriesHitTestProvider,
        ErrorSeriesHitTestProvider: on.ErrorSeriesHitTestProvider,
        hitTestHelpers: an.hitTestHelpers,
        hitTestHelpersRectangleSeries: sn.hitTestHelpersRectangleSeries,
        HitTestInfo: nn.HitTestInfo,
        ImpulseSeriesHitTestProvider: ln.ImpulseSeriesHitTestProvider,
        LineSegmentSeriesHitTestProvider: dn.LineSegmentSeriesHitTestProvider,
        LineSeriesHitTestProvider: hn.LineSeriesHitTestProvider,
        MountainSeriesHitTestProvider: un.MountainSeriesHitTestProvider,
        NonUniformHeatmapHitTestProvider: cn.NonUniformHeatmapHitTestProvider,
        OhlcSeriesHitTestProvider: pn.OhlcSeriesHitTestProvider,
        RectangleSeriesHitTestProvider: gn.RectangleSeriesHitTestProvider,
        ScatterSeriesHitTestProvider: yn.ScatterSeriesHitTestProvider,
        StackedColumnSeriesHitTestProvider:
          fn.StackedColumnSeriesHitTestProvider,
        StackedMountainSeriesHitTestProvider:
          vn.StackedMountainSeriesHitTestProvider,
        TextSeriesHitTestProvider: mn.TextSeriesHitTestProvider,
        TriangleSeriesHitTestProvider: Sn.TriangleSeriesHitTestProvider,
        UniformHeatmapHitTestProvider: Pn.UniformHeatmapHitTestProvider,
        PolarBandRenderableSeries: Cn.PolarBandRenderableSeries,
        PolarColumnRenderableSeries: bn.PolarColumnRenderableSeries,
        PolarLineRenderableSeries: xn.PolarLineRenderableSeries,
        PolarMountainRenderableSeries: An.PolarMountainRenderableSeries,
        PolarStackedColumnCollection: Tn.PolarStackedColumnCollection,
        PolarStackedColumnRenderableSeries:
          En.PolarStackedColumnRenderableSeries,
        PolarStackedMountainCollection: Rn.PolarStackedMountainCollection,
        PolarStackedMountainRenderableSeries:
          Dn.PolarStackedMountainRenderableSeries,
        PolarUniformHeatmapRenderableSeries:
          wn.PolarUniformHeatmapRenderableSeries,
        PolarXyScatterRenderableSeries: Mn.PolarXyScatterRenderableSeries,
        PolarColumnDataLabelState: Ln.PolarColumnDataLabelState,
        PolarColumnSeriesDataLabelProvider:
          On.PolarColumnSeriesDataLabelProvider,
        PolarDataLabelProvider: In.PolarDataLabelProvider,
        PolarDataLabelState: kn.PolarDataLabelState,
        PolarHeatMapDataLabelProvider: _n.PolarHeatMapDataLabelProvider,
        PolarBandSeriesDrawingProvider: Vn.PolarBandSeriesDrawingProvider,
        PolarColumnSeriesDrawingProvider: Nn.PolarColumnSeriesDrawingProvider,
        PolarHeatmapDrawingProvider: Bn.PolarHeatmapDrawingProvider,
        PolarLineSeriesDrawingProvider: Fn.PolarLineSeriesDrawingProvider,
        PolarPointMarkerDrawingProvider: Hn.PolarPointMarkerDrawingProvider,
        PolarDataPointHitTestProvider: Yn.PolarDataPointHitTestProvider,
        polarHitTestHelpers: zn.polarHitTestHelpers,
        PolarLineSeriesHitTestProvider: jn.PolarLineSeriesHitTestProvider,
        XyBaseRenderDataTransform: Xn.XyBaseRenderDataTransform,
        XyyBaseRenderDataTransform: Gn.XyyBaseRenderDataTransform,
        OhlcBaseRenderDataTransform: Wn.OhlcBaseRenderDataTransform,
        bezierTransform: Un.bezierTransform,
        BezierRenderDataTransform: $n.BezierRenderDataTransform,
        XyyBezierRenderDataTransform: Zn.XyyBezierRenderDataTransform,
        SmoothStackedRenderDataTransform: qn.SmoothStackedRenderDataTransform,
        PolarInterpolateBandRenderDataTransform:
          Kn.PolarInterpolateBandRenderDataTransform,
        PolarInterpolateLineRenderDataTransform:
          Jn.PolarInterpolateLineRenderDataTransform,
        SplineRenderDataTransform: Qn.SplineRenderDataTransform,
        XyySplineRenderDataTransform: el.XyySplineRenderDataTransform,
        RolloverModifierRenderableSeriesProps:
          tl.RolloverModifierRenderableSeriesProps,
        RubberBandSvgRect: rl.RubberBandSvgRect,
        ESizingMode: il.ESizingMode,
        EPieType: ol.EPieType,
        EPieValueMode: al.EPieValueMode,
        SciChartPieSurface: sl.SciChartPieSurface,
        PieSegment: nl.PieSegment,
        CanvasTexture: ll.CanvasTexture,
        DpiHelper: dl.DpiHelper,
        TextureManager: hl.TextureManager,
        measureTextHeight: ul.measureTextHeight,
        measureTextWidth: cl.measureTextWidth,
        ECameraProjectionMode: pl.ECameraProjectionMode,
        CameraController: gl.CameraController,
        Vector3: yl.Vector3,
        CustomChartModifier3D: fl.CustomChartModifier3D,
        MouseWheelZoomModifier3D: vl.MouseWheelZoomModifier3D,
        OrbitModifier3D: ml.OrbitModifier3D,
        PinchZoomModifier3D: Sl.PinchZoomModifier3D,
        ResetCamera3DModifier: Pl.ResetCamera3DModifier,
        TooltipModifier3D: Cl.TooltipModifier3D,
        adjustTooltipPosition3D: bl.adjustTooltipPosition3D,
        EDataSeriesType3D: xl.EDataSeriesType3D,
        UniformGridDataSeries3D: Al.UniformGridDataSeries3D,
        XyzDataSeries3D: Tl.XyzDataSeries3D,
        createSingle3dInternal: El.createSingle3dInternal,
        DefaultViewportManager3D: Rl.DefaultViewportManager3D,
        GizmoEntity: Dl.GizmoEntity,
        RootSceneEntity: wl.RootSceneEntity,
        SciChart3DRenderer: Ml.SciChart3DRenderer,
        sciChartConfig3D: Ll.sciChartConfig3D,
        SciChart3DSurface: Ol.SciChart3DSurface,
        TooltipSvgAnnotation3D: Il.TooltipSvgAnnotation3D,
        EWhichAxis: kl.EWhichAxis,
        AxisCubeEntity: _l.AxisCubeEntity,
        EAxisSideClipping: Vl.EAxisSideClipping,
        ETextAlignment3D: Nl.ETextAlignment3D,
        getDescriptorsEqual: Bl.getDescriptorsEqual,
        getLineStylesEqual: Fl.getLineStylesEqual,
        getTArgbEqual: Hl.getTArgbEqual,
        getTextStylesEqual: Yl.getTextStylesEqual,
        getArraysEqual: zl.getArraysEqual,
        NumericAxis3D: jl.NumericAxis3D,
        EMarkerType: Xl.EMarkerType,
        SpherePointMarker3D: Gl.SpherePointMarker3D,
        CubePointMarker3D: Wl.CubePointMarker3D,
        PyramidPointMarker3D: Ul.PyramidPointMarker3D,
        CylinderPointMarker3D: $l.CylinderPointMarker3D,
        PixelPointMarker3D: Zl.PixelPointMarker3D,
        QuadPointMarker: ql.QuadPointMarker,
        EllipsePointMarker3D: Kl.EllipsePointMarker3D,
        TrianglePointMarker3D: Jl.TrianglePointMarker3D,
        AxisCubeDescriptor: Ql.AxisCubeDescriptor,
        ColumnSceneEntity: ed.ColumnSceneEntity,
        CrosshairLinesSceneEntity: td.CrosshairLinesSceneEntity,
        DefaultEntityIdProvider: rd.DefaultEntityIdProvider,
        PointLine3DSceneEntity: id.PointLine3DSceneEntity,
        RenderableSeriesSceneEntityState: od.RenderableSeriesSceneEntityState,
        RenderPassInfo3D: ad.RenderPassInfo3D,
        ScatterPointsSceneEntity: sd.ScatterPointsSceneEntity,
        SceneDescriptor: nd.SceneDescriptor,
        SurfaceMeshSceneEntityState: ld.SurfaceMeshSceneEntityState,
        SurfaceMeshSceneEntity: dd.SurfaceMeshSceneEntity,
        ColumnRenderableSeries3D: hd.ColumnRenderableSeries3D,
        ESeriesType3D: ud.ESeriesType3D,
        HitTestInfo3D: cd.HitTestInfo3D,
        PointLineRenderableSeries3D: pd.PointLineRenderableSeries3D,
        ScatterRenderableSeries3D: gd.ScatterRenderableSeries3D,
        SeriesInfo3D: yd.SeriesInfo3D,
        SurfaceMeshSeriesInfo3D: fd.SurfaceMeshSeriesInfo3D,
        XyzSeriesInfo3D: vd.XyzSeriesInfo3D,
        GradientColorPalette: md.GradientColorPalette,
        SolidColorBrushPalette: Sd.SolidColorBrushPalette,
        EDrawMeshAs: Pd.EDrawMeshAs,
        EMeshPaletteMode: Cd.EMeshPaletteMode,
        EMeshResolution: bd.EMeshResolution,
        SurfaceMeshRenderableSeries3D: xd.SurfaceMeshRenderableSeries3D,
        AnimationToken: Ad.AnimationToken,
        libraryVersion: Td.libraryVersion,
        checkBuildStamp: Ed.checkBuildStamp,
        deleteSafe: Rd.deleteSafe,
        Dictionary: Dd.Dictionary,
        EventHandler: wd.EventHandler,
        GradientParams: Md.GradientParams,
        Guard: Ld.Guard,
        IncludedItems: Od.IncludedItems,
        List: Id.List,
        NumberRange: kd.NumberRange,
        NumberUtil: _d.NumberUtil,
        ObservableArrayBase: Vd.ObservableArrayBase,
        ObservableArray: Nd.ObservableArray,
        EObservableArrayChangedAction: Bd.EObservableArrayChangedAction,
        ObservableArrayChangedArgs: Fd.ObservableArrayChangedArgs,
        OneTimePerformanceWarning: Hd.OneTimePerformanceWarning,
        Point: Yd.Point,
        PropertyChangedEventArgs: zd.PropertyChangedEventArgs,
        Rect: jd.Rect,
        getUserCookie: Xd.getUserCookie,
        shouldSendTelemetry: Gd.shouldSendTelemetry,
        sendTelemetry: Wd.sendTelemetry,
        Thickness: Ud.Thickness,
        EWebGLSupport: $d.EWebGLSupport,
        WebGlHelper: Zd.WebGlHelper,
        EAnimationState: qd.EAnimationState,
        EAnimationStateTransition: Kd.EAnimationStateTransition,
        AnimationFiniteStateMachine: Jd.AnimationFiniteStateMachine,
        SeriesAnimationFiniteStateMachine: Qd.SeriesAnimationFiniteStateMachine,
        animateAny: eh.animateAny,
        DoubleAnimator: th.DoubleAnimator,
        easing: rh.easing,
        autoReverseEasing: ih.autoReverseEasing,
        GenericAnimation: oh.GenericAnimation,
        NumberRangeAnimator: ah.NumberRangeAnimator,
        MouseManager: sh.MouseManager,
        localStorageApi: nh.localStorageApi,
        EHorizontalAnchorPoint: lh.EHorizontalAnchorPoint,
        EVerticalAnchorPoint: dh.EVerticalAnchorPoint,
        EAnimationType: hh.EAnimationType,
        EAnnotationClippingMode: uh.EAnnotationClippingMode,
        EAutoColorMode: ch.EAutoColorMode,
        EAutoRange: ph.EAutoRange,
        EAxisAlignment: gh.EAxisAlignment,
        getIsHorizontal: yh.getIsHorizontal,
        getIsVertical: fh.getIsVertical,
        handleInvalidAxisAlignment: vh.handleInvalidAxisAlignment,
        EAxisType: mh.EAxisType,
        EBaseType: Sh.EBaseType,
        EChart2DModifierType: Ph.EChart2DModifierType,
        EChart3DModifierType: Ch.EChart3DModifierType,
        EColor: bh.EColor,
        EColumnMode: xh.EColumnMode,
        convertColumnMode: Ah.convertColumnMode,
        EColumnYMode: Th.EColumnYMode,
        convertYColumnMode: Eh.convertYColumnMode,
        ECursorStyle: Rh.ECursorStyle,
        EDataFilterType: Dh.EDataFilterType,
        EDataLabelProviderType: wh.EDataLabelProviderType,
        EDataLabelSkipMode: Mh.EDataLabelSkipMode,
        EDataPointWidthMode: Lh.EDataPointWidthMode,
        EDefaultRenderLayer: Oh.EDefaultRenderLayer,
        EDragMode: Ih.EDragMode,
        EErrorDirection: kh.EErrorDirection,
        EErrorMode: _h.EErrorMode,
        EColorPickMode: Vh.EColorPickMode,
        EHeightSeriesMode: Nh.EHeightSeriesMode,
        EHoverMode: Bh.EHoverMode,
        ELabelAlignment: Fh.ELabelAlignment,
        ELabelPlacement: Hh.ELabelPlacement,
        EHorizontalAlignment: Yh.EHorizontalAlignment,
        EVerticalAlignment: zh.EVerticalAlignment,
        EAngularAxisLabelPlacement: jh.EAngularAxisLabelPlacement,
        ERadialAxisLabelPlacement: Xh.ERadialAxisLabelPlacement,
        ELabelProviderType: Gh.ELabelProviderType,
        ELayoutManagerType: Wh.ELayoutManagerType,
        ELayoutStrategyType: Uh.ELayoutStrategyType,
        EModifierType: $h.EModifierType,
        EMousePosition: Zh.EMousePosition,
        isTypedArray: qh.isTypedArray,
        isNumberArray: Kh.isNumberArray,
        subArray: Jh.subArray,
        ENumericFormat: Qh.ENumericFormat,
        OrderedRenderable: eu.OrderedRenderable,
        EPaletteProviderType: tu.EPaletteProviderType,
        EPointMarker3DType: ru.EPointMarker3DType,
        EPointMarkerType: iu.EPointMarkerType,
        ERenderLayer: ou.ERenderLayer,
        ESceneEntityType: au.ESceneEntityType,
        ESciChartSurfaceType: su.ESciChartSurfaceType,
        ESearchMode: nu.ESearchMode,
        convertSearchMode: lu.convertSearchMode,
        ESeriesType: du.ESeriesType,
        EShaderEffectType: hu.EShaderEffectType,
        Size: uu.Size,
        ESurfaceType: cu.ESurfaceType,
        EHorizontalTextPosition: pu.EHorizontalTextPosition,
        EVerticalTextPosition: gu.EVerticalTextPosition,
        EMultiLineAlignment: yu.EMultiLineAlignment,
        convertMultiLineAlignment: fu.convertMultiLineAlignment,
        ETextAlignment: vu.ETextAlignment,
        ETitlePosition: mu.ETitlePosition,
        EThemeProviderType: Su.EThemeProviderType,
        EColorMapMode: Pu.EColorMapMode,
        ETriangleSeriesDrawMode: Cu.ETriangleSeriesDrawMode,
        EValueName: bu.EValueName,
        generateValueNamesForDataSeries: xu.generateValueNamesForDataSeries,
        EWatermarkPosition: Au.EWatermarkPosition,
        EXyDirection: Tu.EXyDirection,
        EYRangeMode: Eu.EYRangeMode,
        EZoomState: Ru.EZoomState,
        EExecuteOn: Du.EExecuteOn,
        EModifierMouseArgKey: wu.EModifierMouseArgKey,
        EStrokeLineJoin: Mu.EStrokeLineJoin,
        getUniqueValues: Lu.getUniqueValues,
        countUnique: Ou.countUnique,
        areArraysEqual: Iu.areArraysEqual,
        arrayRemove: ku.arrayRemove,
        isArraySorted: _u.isArraySorted,
        makeIncArray: Vu.makeIncArray,
        appendRangeFifo: Nu.appendRangeFifo,
        calcAverageForDoubleVector: Bu.calcAverageForDoubleVector,
        calcAverageForArray: Fu.calcAverageForArray,
        uintArgbColorLerp24bit: Hu.uintArgbColorLerp24bit,
        uintArgbColorLerp: Yu.uintArgbColorLerp,
        linearColorMapLerp: zu.linearColorMapLerp,
        uintArgbColorToAbgr: ju.uintArgbColorToAbgr,
        uintArgbColorMultiplyOpacity: Xu.uintArgbColorMultiplyOpacity,
        uintArgbColorOverrideOpacity: Gu.uintArgbColorOverrideOpacity,
        uintArgbColorIsTransparent: Wu.uintArgbColorIsTransparent,
        applyOpacityToHtmlColor: Uu.applyOpacityToHtmlColor,
        convertColor: $u.convertColor,
        convertRgbToHexColor: Zu.convertRgbToHexColor,
        convertToPixel: qu.convertToPixel,
        copyDoubleVector: Ku.copyDoubleVector,
        formatUnixDateToHumanString: Ju.formatUnixDateToHumanString,
        formatUnixDateToHumanStringDDMMYY: Qu.formatUnixDateToHumanStringDDMMYY,
        formatUnixDateToHumanStringDDMMHHMM:
          ec.formatUnixDateToHumanStringDDMMHHMM,
        formatUnixDateToHumanStringDDMM: tc.formatUnixDateToHumanStringDDMM,
        formatUnixDateToHumanStringHHMMSS: rc.formatUnixDateToHumanStringHHMMSS,
        formatUnixDateToHumanStringSSms: ic.formatUnixDateToHumanStringSSms,
        formatUnixDateToHumanStringHHMM: oc.formatUnixDateToHumanStringHHMM,
        formatUnixDateToHumanStringMMMDD: ac.formatUnixDateToHumanStringMMMDD,
        formatUnixDateToHumanStringMMM: sc.formatUnixDateToHumanStringMMM,
        formatUnixDateToHumanStringDD: nc.formatUnixDateToHumanStringDD,
        formatUnixDateToHumanStringYYYY: lc.formatUnixDateToHumanStringYYYY,
        logDoubleVector: dc.logDoubleVector,
        getFontString: hc.getFontString,
        DEFAULT_FONT_FAMILY: uc.DEFAULT_FONT_FAMILY,
        getFontFamily: cc.getFontFamily,
        geometryHelpers: pc.geometryHelpers,
        generateGuid: gc.generateGuid,
        base64Id: yc.base64Id,
        hasAllProperties: fc.hasAllProperties,
        hashUtils: vc.hashUtils,
        HEIGHT_SERIES_MAX_TEXTURE_SIZE: mc.HEIGHT_SERIES_MAX_TEXTURE_SIZE,
        validateColorStops: Sc.validateColorStops,
        htmlToElement: Pc.htmlToElement,
        stringOccurrences: Cc.stringOccurrences,
        createImageAsync: bc.createImageAsync,
        createImagesArrayAsync: xc.createImagesArrayAsync,
        isRealNumber: Ac.isRealNumber,
        Logger: Tc.Logger,
        getNoisySinewave: Ec.getNoisySinewave,
        fillNoisySinewave: Rc.fillNoisySinewave,
        logToBase: Dc.logToBase,
        memoize: wc.memoize,
        ObjectRegistry: Mc.ObjectRegistry,
        MemoryUsageHelper: Lc.MemoryUsageHelper,
        formatNumber2Digits: Oc.formatNumber2Digits,
        numericHashCode: Ic.numericHashCode,
        formatNumber: kc.formatNumber,
        toSuperScript: _c.toSuperScript,
        toScientific: Vc.toScientific,
        toEngineering: Nc.toEngineering,
        checkIsNaN: Bc.checkIsNaN,
        parseColorToHexStringArgb: Fc.parseColorToHexStringArgb,
        parseColorToHexStringAbgr: Hc.parseColorToHexStringAbgr,
        parseColorToUIntArgb: Yc.parseColorToUIntArgb,
        parseColorToUIntAbgr: zc.parseColorToUIntAbgr,
        toHex: jc.toHex,
        parseColorToTArgb: Xc.parseColorToTArgb,
        parseArgbToHtmlColor: Gc.parseArgbToHtmlColor,
        parseTArgbToHtmlColor: Wc.parseTArgbToHtmlColor,
        EPerformanceMarkType: Uc.EPerformanceMarkType,
        EPerformanceDebugLevel: $c.EPerformanceDebugLevel,
        PerformanceDebugHelper: Zc.PerformanceDebugHelper,
        runAfterFramePaint: qc.runAfterFramePaint,
        calcDistanceFromLine: Kc.calcDistanceFromLine,
        calcCrossProduct: Jc.calcCrossProduct,
        calcDistance: Qc.calcDistance,
        testIsInBounds: ep.testIsInBounds,
        calcAnnotationBordersForAxisMarker:
          tp.calcAnnotationBordersForAxisMarker,
        testIsInXBounds: rp.testIsInXBounds,
        testIsInInterval: ip.testIsInInterval,
        calcDotProduct: op.calcDotProduct,
        calcDistanceFromLineSegment: ap.calcDistanceFromLineSegment,
        testPointInTriangle: sp.testPointInTriangle,
        getRandomInRange: np.getRandomInRange,
        getStocksDataFactory: lp.getStocksDataFactory,
        getNextRandomPriceBarFactory: dp.getNextRandomPriceBarFactory,
        getAttributeFromString: hp.getAttributeFromString,
        wrapNativeText: up.wrapNativeText,
        getNativeTextSize: cp.getNativeTextSize,
        ESize: pp.ESize,
        ECoord: gp.ECoord,
        EShift: yp.EShift,
        translateFromCanvasToSeriesViewRect:
          fp.translateFromCanvasToSeriesViewRect,
        translateFromSeriesViewRectToCanvas:
          vp.translateFromSeriesViewRectToCanvas,
        translateFromCanvasToSeriesViewRectX:
          mp.translateFromCanvasToSeriesViewRectX,
        translateFromCanvasToSeriesViewRectY:
          Sp.translateFromCanvasToSeriesViewRectY,
        translateFromSeriesViewRectToCanvasX:
          Pp.translateFromSeriesViewRectToCanvasX,
        translateFromSeriesViewRectToCanvasY:
          Cp.translateFromSeriesViewRectToCanvasY,
        translateToScaled: bp.translateToScaled,
        translateToNotScaled: xp.translateToNotScaled,
        translateToScaledRect: Ap.translateToScaledRect,
        translateToNotScaledRect: Tp.translateToNotScaledRect,
        translateDataValueRectToAbsolute: Ep.translateDataValueRectToAbsolute,
        updateTsrVector4: Rp.updateTsrVector4,
        fromTsrVector4: Dp.fromTsrVector4,
        watermarkHelpers: wp.watermarkHelpers,
        zeroArray2D: Mp.zeroArray2D,
      };
    (e.default = Lp),
      si.SciChartSurface.useWasmFromCDN(),
      Ol.SciChart3DSurface.useWasmFromCDN();
  })(),
    (self.SciChart = i.default);
})();
