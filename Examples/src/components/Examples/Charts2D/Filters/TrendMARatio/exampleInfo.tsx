import { createExampleInfo } from "../../../exampleInfoUtils";
import { IExampleMetadata } from "../../../IExampleMetadata";

const metaData: IExampleMetadata =
    //// This metadata is computer generated - do not edit!
    {
        exampleId: "Charts2DFiltersTrendMARatio",
        imagePath: "javascript-trend-ma-ratio.jpg",
        description:
            "Demonstrates how use **Linear Trend, Moving Average and Ratio Filters** with filter chaining, using SciChart.js, High Performance JavaScript Charts",
        tips: [],
        frameworks: {
            javascript: {
                subtitle:
                    "Demonstrates how use **Linear Trend, Moving Average and Ratio Filters** with filter chaining, using SciChart.js, High Performance JavaScript Charts",
                title: "Trendline, Moving Average and Ratio Filters",
                pageTitle: "Trendline, Moving Average and Ratio Filters",
                metaDescription: "Chart with Linear Trendline, Moving Average and Ratio Filters with filter chaining",
                markdownContent:
                    "# Trendline, Moving Average and Ratio Filters in Vanilla JavaScript\n\n## Overview\nThis example demonstrates how to integrate SciChart.js with a vanilla JavaScript application to create a high-performance financial chart that applies dynamic data transformations. It showcases advanced technical analysis filters including **Moving Average**, **Linear Trendline** and **Ratio** filters, while also configuring dual y-axes for displaying both the original and transformed data.\n\n## Technical Implementation\nThe chart is initialized asynchronously using SciChart.js’s native asynchronous API, where a WebAssembly context is created by calling [SciChartSurface.create and loading Wasm](https://www.scichart.com/documentation/js/current/SciChartSurface.create%20and%20createSingle.html). Data is generated using a random walk generator and then processed through several filters, including two distinct **Moving Average** filters with different lengths, an **offset and scale filter**, a **Linear Trendline** filter, and finally, a **Ratio** filter that computes the ratio between the original data series and its transformed version. The filter chaining demonstrates how multiple data transformations can be applied step-by-step as described in the [Transforming Data with Filters](https://www.scichart.com/examples/transforming-data-with-filters/) documentation.\n\n## Features and Capabilities\nThe implementation includes several advanced features such as: \n- Dual y-axis configuration to clearly distinguish between original data and ratio values, following best practices outlined in the [Tutorial 08 - Adding Multiple Axis](https://www.scichart.com/documentation/js/current/Tutorial%2008%20-%20Adding%20Multiple%20Axis.html) guide.\n- Interactive chart modifiers like **MouseWheelZoomModifier**, **ZoomPanModifier**, **ZoomExtentsModifier** and a **LegendModifier** that enhance user interactivity. More details on these can be found in the [MouseWheelZoomModifier Documentation](https://www.scichart.com/documentation/js/current/MouseWheelZoomModifier.html).\n- Annotations using the **NativeTextAnnotation** to overlay descriptive text with relative coordinates, adding additional context to the chart.\n\n## Integration and Best Practices\nThe example demonstrates best practices for integrating SciChart.js into a vanilla JavaScript project. Developers can follow the step-by-step asynchronous initialization process as detailed in the [Getting Started with SciChart JS](https://www.scichart.com/getting-started/scichart-javascript/) guide. Furthermore, resource cleanup is handled through a destructor function that properly disposes of chart objects, ensuring efficient memory management as recommended in the [Memory Best Practices | JavaScript Chart Documentation](https://www.scichart.com/documentation/js/current/MemoryBestPractices.html). This implementation not only highlights the usage of dynamic filter chaining and dual-axis configuration, but also shows how to optimize performance when working with WebAssembly-powered charts.\n",
            },
            react: {
                subtitle:
                    "Demonstrates how use **Linear Trend, Moving Average and Ratio Filters** with filter chaining, using SciChart.js, High Performance JavaScript Charts",
                title: "Trendline, Moving Average and Ratio Filters",
                pageTitle: "Trendline, Moving Average and Ratio Filters",
                metaDescription: "Chart with Linear Trendline, Moving Average and Ratio Filters with filter chaining",
                markdownContent:
                    "# Trendline, Moving Average and Ratio Filters in React\n\n## Overview\nThis example demonstrates how to apply advanced technical analysis filters such as **Moving Average**, **Linear Trendline** and **Ratio** filters in a SciChart.js chart using a React integration. The implementation shows how to generate dynamic data, apply multiple data filters sequentially, and render the transformed data on a dual y-axis chart with interactive annotations and chart modifiers.\n\n## Technical Implementation\nThe chart is implemented using the [SciChartReact](https://www.scichart.com/documentation/js/current/TutorialReusableReactComponent.html) component which accepts an asynchronous initChart callback. This callback creates a SciChartSurface with dual y-axes, one for the original data and another for the ratio calculations. The example generates a random walk data series and then applies several filters: two **Moving Average** filters with different lengths, a **Linear Trendline** filter, and a **Ratio** filter that computes the ratio of the original data to a scaled and offset version. Each filter is applied in sequence, demonstrating effective filter chaining as described in the [Trend MA Ratio Demo](https://demo.scichart.com/react/trend-ma-ratio) and [Transforming Data with Filters](https://www.scichart.com/examples/transforming-data-with-filters/) guides.\n\n## Features and Capabilities\nThis example highlights several advanced features including:\n- Dual y-axis configuration to display both original and transformed data\n- Interactive modifiers such as MouseWheelZoomModifier, ZoomPanModifier, ZoomExtentsModifier, and a LegendModifier to enhance user interactivity, aligning with best practices outlined in the [Adding Zooming, Panning Behavior](https://www.scichart.com/documentation/js/current/Tutorial%2003%20-%20Adding%20Zooming,%20Panning%20Behavior.html) tutorial.\n- Use of [NativeTextAnnotation](https://www.scichart.com/documentation/js/current/NativeTextAnnotation.html) for overlaying descriptive text with relative coordinate modes\n- Advanced filter chaining techniques for data transformation.\n\n## Integration and Best Practices\nBy leveraging the [SciChartReact](https://www.scichart.com/documentation/js/current/TutorialReusableReactComponent.html) component, the integration into a React application is seamless. The asynchronous initialization ensures that the WebAssembly context is properly setup, optimizing performance as discussed in [Memory Best Practices](https://www.scichart.com/documentation/js/current/MemoryBestPractices.html) and relevant performance optimization strategies on WebGL-based charts. This approach not only simplifies the integration process but also allows developers to focus on customizing the chart behavior using advanced data filtering techniques without dealing with low-level performance issues.\n\nDevelopers looking to further enhance the chart’s capabilities can refer to the discussion on interactive modifiers, dual axis configuration, and advanced filter chaining for additional context and examples. The example serves as a robust foundation for building high-performance financial or technical analysis charts in a React environment.",
            },
            angular: {
                subtitle:
                    "Demonstrates how use **Linear Trend, Moving Average and Ratio Filters** with filter chaining, using SciChart.js, High Performance JavaScript Charts",
                title: "Trendline, Moving Average and Ratio Filters",
                pageTitle: "Trendline, Moving Average and Ratio Filters",
                metaDescription: "Chart with Linear Trendline, Moving Average and Ratio Filters with filter chaining",
                markdownContent:
                    "# Trendline, Moving Average and Ratio Filters in Angular\n\n## Overview\nThis example demonstrates how to integrate SciChart.js within an Angular application using standalone components to render high performance charts. The implementation applies advanced data transformation techniques such as **Moving Average**, **Linear Trendline** and **Ratio Filters** to a dynamically generated data series. The chart is configured with dual y-axes, enabling the display of both original and transformed data.\n\n## Technical Implementation\nThe chart is initialized asynchronously using an Angular standalone component, leveraging input binding to pass the custom chart initialization callback. The code sets up two y-axes (one on the left for original data and one on the right for ratio calculations) and uses several SciChart.js filters to process the data. Specifically, the example uses two moving average filters with different lengths, a linear trendline filter, a scale and offset filter, and a ratio filter that computes the ratio between the original data and an offset version. For further details on Angular integration and asynchronous initialization, refer to the [Getting Started with SciChart JS](https://www.scichart.com/getting-started/scichart-javascript/) guide and the [scichart-angular - Yarn](https://www.npmjs.com/package/scichart-angular) documentation.\n\n## Features and Capabilities\nThe implementation showcases several advanced features including: real-time filter chaining that enables dynamic transforms; dual-axis configuration for clear visualization of original versus transformed data; and interactive chart modifiers such as zooming and panning. These interactive features are implemented with modifiers like ZoomPanModifier, MouseWheelZoomModifier, and a LegendModifier, enhancing the chart’s responsiveness and user experience. More details on dual-axis setups can be found in the [Tutorial 08 - Adding Multiple Axis](https://www.scichart.com/documentation/js/current/Tutorial%2008%20-%20Adding%20Multiple%20Axis.html) documentation.\n\n## Integration and Best Practices\nBy utilizing the ScichartAngularComponent, developers can adhere to Angular best practices such as asynchronous component initialization and proper resource management. The example demonstrates effective performance optimization by initializing the WebAssembly context only once and disposing of chart resources when necessary. Developers are encouraged to review the [Memory Best Practices | JavaScript Chart Documentation - SciChart](https://www.scichart.com/documentation/js/current/MemoryBestPractices.html) for techniques to optimize WebAssembly usage, alongside Angular performance tips from various community resources. In addition, the incorporation of interactive elements and dynamic annotations follows best practices in chart configuration and interactivity, ensuring a robust and maintainable implementation.",
            },
        },
        documentationLinks: [
            {
                href: "https://www.scichart.com/documentation/js/current/What%20is%20the%20Filters%20API.html",
                title: "This specific page in the JavaScript Filters API documentation will help you to get started",
                linkTitle: "JavaScript Filters Api Documentation",
            },
        ],
        path: "trend-ma-ratio",
        metaKeywords: "trend, line, moving, average, ratio, transform, chart, javascript, webgl, canvas",
        onWebsite: true,
        filepath: "Charts2D/Filters/TrendMARatio",
        thumbnailImage: "javascript-trend-ma-ratio.jpg",
        sandboxConfig: {},
        markdownContent: null,
        pageLayout: "default",
        extraDependencies: {},
    };
//// End of computer generated metadata

export const trendMARatioExampleInfo = createExampleInfo(metaData);
