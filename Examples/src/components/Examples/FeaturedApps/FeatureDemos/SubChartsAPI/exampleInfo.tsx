import { createExampleInfo } from "../../../exampleInfoUtils";
import { IExampleMetadata } from "../../../IExampleMetadata";

const metaData: IExampleMetadata =
    //// This metadata is computer generated - do not edit!
    {
        exampleId: "FeaturedAppsFeatureDemosSubChartsAPI",
        imagePath: "javascript-subcharts-grid.jpg",
        description:
            "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript.",
        tips: [],
        frameworks: {
            javascript: {
                subtitle:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript.",
                title: "JavaScript 64-Chart Dashboard Performance Demo",
                pageTitle: "JavaScript 64-Chart Dashboard Performance Demo",
                metaDescription:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript",
                markdownContent:
                    "# Sub Charts API Example - Vanilla JavaScript\n\n## Overview\nThis example demonstrates a comprehensive use of the SciChart.js sub-charts API implemented using vanilla JavaScript. It creates a grid of 64 sub-charts arranged in an 8x8 layout where each sub-chart displays one or more renderable series (such as Line, Column, Band, Scatter, and Candlestick). The purpose of the example is to illustrate techniques for managing complex multi-chart dashboards with real-time data streaming while maintaining high performance.\n\n## Technical Implementation\nThe implementation starts with creating a main chart using the SciChartSurface API. Each sub-chart is added to the main surface via the addSubChart method and is positioned using relative coordinates calculated by a helper function. You can learn more about this technique in the [SubCharts Positioning documentation](https://www.scichart.com/documentation/js/current/SubChartPositioning.html). Each sub-chart is configured with its own invisible NumericAxis (customized using advanced options available in the [Numeric Axis documentation](https://www.scichart.com/documentation/js/current/NumericAxis.html)) and different renderable series are added according to the series type. Data for each chart is pre-populated and updated in real time using functions such as prePopulateData and appendData. Real-time data streaming is implemented using iterative updates scheduled with setTimeout, a strategy detailed in the [Realtime Updates tutorial](https://www.scichart.com/documentation/js/current/Tutorial%2004%20-%20Adding%20Realtime%20Updates.html). Performance is monitored by subscribing to the render events of a sub-chart, providing insights into average render times and maximum frames per second as described in the [Performance Tips & Tricks documentation](https://www.scichart.com/documentation/js/current/Performance%20Tips.html).\n\n## Features and Capabilities\n**Real-time Updates:** The example handles streaming large datasets into multiple data series simultaneously by efficiently appending new data and removing old data when necessary, thus managing FIFO capacity effectively.\n\n**Theme Customization:** The look and feel of the charts are customized by overriding theme methods (such as getStrokeColor and getFillColor) provided by SciChart.js. Refer to the [SciChartJSDarkTheme documentation](https://www.scichart.com/documentation/js/current/typedoc/classes/scichartjsdarktheme.html) for more details on theme configuration.\n\n**Stacked and Multiple Series Integration:** The implementation demonstrates how to integrate different renderable series types within a single sub-chart, including the use of stacked collections like StackedColumnCollection and StackedMountainCollection. This illustrates how multiple series can be synchronized and rendered together.\n\n**Sub-chart Layout:** The use of helper functions to calculate sub-chart positions ensures that each sub-chart is placed correctly within the overall grid, enabling complex dashboard layouts. Each sub-chart maintains its own axis configuration while still being part of a unified main chart.\n\n## Integration and Best Practices\nThis example follows best practices for high-performance real-time charting applications. By leveraging techniques such as efficient data series management, real-time updates, and performance monitoring, developers can build scalable dashboards. The example’s approach to managing multiple sub-charts in a grid structure serves as a blueprint for creating complex, multi-view dashboards. For additional customization options such as advanced filtering, refer to the [Data Series Realtime Updates documentation](https://www.scichart.com/documentation/js/current/DataSeries_RealtimeUpdates.html) and the [Custom Filters documentation](https://www.scichart.com/documentation/js/current/Creating%20a%20Custom%20Filter.html).\n\nOverall, this example provides a solid foundation for developing sophisticated real-time charting solutions using vanilla JavaScript with SciChart.js, showcasing effective performance optimization and modular chart configuration.",
            },
            react: {
                subtitle:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript.",
                title: "React 64-Chart Dashboard Performance Demo",
                pageTitle: "React 64-Chart Dashboard Performance Demo",
                metaDescription:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript",
                markdownContent:
                    "# Sub Charts API - React\n\n## Overview\nThis example demonstrates how to integrate SciChart.js into a React application by constructing an 8x8 grid of 64 sub-charts that update in real-time. By leveraging functional components and React hooks such as useRef and useState, the example provides a robust framework for building high-performance chart dashboards.\n\n## Technical Implementation\nThe implementation establishes a main SciChartSurface and then dynamically creates multiple sub-surfaces using the SciChart SubCharts API. Each sub-chart is configured via JSON-based options that determine properties like axes, layout positions, and chart padding. React is used to manage the lifecycle of these charts via the SciChartReact component, ensuring proper initialization and cleanup. For more detailed guidance on integrating SciChart.js into React, developers can consult [Creating a SciChart React Component from the Ground Up](https://www.scichart.com/documentation/js/current/TutorialReusableReactComponent.html).\n\n## Features and Capabilities\nKey features include real-time data updates, dynamic sub-chart composition, and interactive modifiers. The charts are updated in real-time using high-frequency data streams, a technique detailed in [Adding Realtime Updates | JavaScript Chart Documentation - SciChart](https://www.scichart.com/documentation/js/current/Tutorial%2004%20-%20Adding%20Realtime%20Updates.html). Advanced interactive functionalities such as zooming and panning are provided by modifiers like MouseWheelZoomModifier and ZoomPanModifier, enhancing user engagement and data exploration.\n\n## Integration and Best Practices\nThe example adheres to best practices for React integration by employing functional components, state management, and efficient cleanup of event subscriptions. Performance optimization is achieved by minimizing unnecessary re-renders and managing WebGL resources effectively, a strategy that aligns with insights from [React Charts with SciChart.js: Introducing “SciChart React”](https://www.scichart.com/blog/react-charts-with-scichart-js/). Additionally, the implementation demonstrates best practices in event handling and cleanup, ensuring stable performance even with high-frequency updates, as discussed in [ReactJS Sweep Line: Optimizing SciChartJS Performance, Reusing WasmContext for Multiple Charts](https://stackoverflow.com/questions/77781766/reactjs-sweep-line-optimizing-scichartjs-performance-reusing-wasmcontext-for-m).\n\nOverall, the Sub Charts API example in React provides a practical blueprint for building complex, interactive chart dashboards that efficiently handle real-time data streams while maintaining high rendering performance.",
            },
            angular: {
                subtitle:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript.",
                title: "Angular 64-Chart Dashboard Performance Demo",
                pageTitle: "Angular 64-Chart Dashboard Performance Demo",
                metaDescription:
                    "Using the SubCharts API as part of SciChart.js, this demo showcases an 8x8 grid of 64 charts updating in realtime in JavaScript",
                markdownContent:
                    "# Sub Charts API - Angular\n\n## Overview\nThe Sub Charts API example for Angular demonstrates how to integrate high-performance SciChart.js sub-charts within an Angular application. This example constructs an 8x8 grid of 64 charts that update in real time, providing an interactive dashboard capable of handling large datasets and intensive data streams.\n\n## Technical Implementation\nThe implementation uses JSON-based configuration settings to dynamically create and manage multiple sub-surfaces with unique axes and renderable series. Each sub-chart is configured with properties such as axis visibility, padding, and viewport borders, set up using SciChart.js API methods. Angular’s dependency injection and lifecycle hooks ensure proper initialization and cleanup of these components. For further details on initial setup and configuration, refer to [Getting Started with SciChart JS](https://www.scichart.com/getting-started/scichart-javascript/). Additionally, performance optimizations are achieved by leveraging WebGL rendering techniques and controlled data streaming, as explained in [Performance Optimisation of JavaScript Applications & Charts](https://www.scichart.com/blog/performance-optimisation-of-javascript-applications-charts/).\n\n## Features and Capabilities\nKey features of this example include **real-time data updates**, dynamic component configuration via JSON, and advanced interactive modifiers such as zooming and panning across charts. The example demonstrates how sub-charts can be efficiently updated with new data using Angular event binding and reactive programming techniques. Developers can explore best practices for real-time chart updates in the [Adding Realtime Updates | JavaScript Chart Documentation](https://www.scichart.com/documentation/js/current/Tutorial%2004%20-%20Adding%20Realtime%20Updates.html) guide.\n\n## Integration and Best Practices\nThe example adheres to modular component design principles in Angular, promoting reusability and efficient resource management. Angular’s dependency injection enables seamless integration of external libraries like SciChart.js, while lifecycle hooks facilitate optimal initialization and teardown of charts to avoid memory leaks. For a deeper understanding of Angular change detection strategies, see [Deep dive into the OnPush change detection strategy in Angular](https://medium.com/angular-in-depth/deep-dive-into-the-onpush-change-detection-strategy-in-angular-fab5e4da1d69). Furthermore, the synchronization of axes and interactive behaviors across sub-charts is managed elegantly through shared configurations and can be studied further in [How to Link JavaScript Charts and Synchronise zooming, panning ...](https://www.scichart.com/blog/how-to-link-javascript-charts-and-synchronise-zooming-panning-crosshairs/).",
            },
        },
        documentationLinks: [
            {
                href: "https://www.scichart.com/documentation/js/current/WhatIsTheSubChartsAPI.html",
                title: "This specifics page in the JavaScript SubCharts API documentation will help you to get started",
                linkTitle: "Scichart.js SubCharts API Documentation",
            },
        ],
        path: "multiple-chart-dashboard-performance-demo",
        metaKeywords: "javascript, multichart, dashboard, performance, grid, realtime, webgl, canvas",
        onWebsite: false,
        filepath: "FeaturedApps/FeatureDemos/SubChartsAPI",
        thumbnailImage: "javascript-subcharts-grid.jpg",
        sandboxConfig: {},
        markdownContent: null,
        pageLayout: "default",
        extraDependencies: {},
    };
//// End of computer generated metadata

export const subchartsGridExampleInfo = createExampleInfo(metaData);
